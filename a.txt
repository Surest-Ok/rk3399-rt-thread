
rtthread.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000048000000 <_start>:
.section ".text.entrypoint","ax"
.globl _start
_start:
    mrs     x0, CurrentEL           /* CurrentEL Register. bit 2, 3. Others reserved */
    48000000:	d5384240 	mrs	x0, currentel
    and     x0, x0, #12             /* Clear reserved bits */
    48000004:	927e0400 	and	x0, x0, #0xc

    /* Running at EL3? */
    cmp     x0, #12                 /* EL3 value is 0b1100 */
    48000008:	f100301f 	cmp	x0, #0xc
    bne     cpu_not_in_el3
    4800000c:	540001a1 	b.ne	48000040 <cpu_not_in_el3>  // b.any

    /* Should never be executed, just for completeness. (EL3) */
    mov     x0, #(1 << 0)           /* EL0 and EL1 are in Non-Secure state */
    48000010:	d2800020 	mov	x0, #0x1                   	// #1
    orr     x0, x0, #(1 << 4)       /* RES1 */
    48000014:	b27c0000 	orr	x0, x0, #0x10
    orr     x0, x0, #(1 << 5)       /* RES1 */
    48000018:	b27b0000 	orr	x0, x0, #0x20
    orr     x0, x0, #(1 << 7)       /* SMC instructions are undefined at EL1 and above */
    4800001c:	b2790000 	orr	x0, x0, #0x80
    orr     x0, x0, #(1 << 8)       /* HVC instructions are enabled at EL1 and above */
    48000020:	b2780000 	orr	x0, x0, #0x100
    orr     x0, x0, #(1 << 10)      /* The next lower level is AArch64 */
    48000024:	b2760000 	orr	x0, x0, #0x400
    msr     scr_el3, x2
    48000028:	d51e1102 	msr	scr_el3, x2

    mov     x2, #0x3c9
    4800002c:	d2807922 	mov	x2, #0x3c9                 	// #969
    msr     spsr_el3, x2            /* 0b1111001001 */
    48000030:	d51e4002 	msr	spsr_el3, x2
    adr     x2, cpu_not_in_el3
    48000034:	10000062 	adr	x2, 48000040 <cpu_not_in_el3>
    msr     elr_el3, x2
    48000038:	d51e4022 	msr	elr_el3, x2
    eret                            /* Exception Return: from EL3, continue from cpu_not_in_el3 */
    4800003c:	d69f03e0 	eret

0000000048000040 <cpu_not_in_el3>:

cpu_not_in_el3:                     /* Running at EL2 or EL1 */
    cmp     x0, #4                  /* EL1 = 0100  */
    48000040:	f100101f 	cmp	x0, #0x4
    beq     cpu_in_el1              /* Halt this core if running in El1 */
    48000044:	540007c0 	b.eq	4800013c <cpu_in_el1>  // b.none

0000000048000048 <cpu_in_el2>:

cpu_in_el2:

    bl      __asm_flush_dcache_all
    48000048:	94000fb6 	bl	48003f20 <__asm_flush_dcache_all>
    bl      __asm_invalidate_icache_all
    4800004c:	94000fc6 	bl	48003f64 <__asm_invalidate_icache_all>

    mrs     x0, hcr_el2
    48000050:	d53c1100 	mrs	x0, hcr_el2
    orr     x0, x0, #(1 << 31)          /* Enable AArch64 in EL1 */ 
    48000054:	b2610000 	orr	x0, x0, #0x80000000
    orr     x0, x0, #(1 << 41) 
    48000058:	b2570000 	orr	x0, x0, #0x20000000000
    orr     x0, x0, #(1 << 40) 
    4800005c:	b2580000 	orr	x0, x0, #0x10000000000
    bic     x0, x0, #(1 << 27)   
    48000060:	9264f800 	and	x0, x0, #0xfffffffff7ffffff
    bic     x0, x0, #(1 << 3)   
    48000064:	927cf800 	and	x0, x0, #0xfffffffffffffff7
    bic     x0, x0, #(1 << 4)   
    48000068:	927bf800 	and	x0, x0, #0xffffffffffffffef
    bic     x0, x0, #(1 << 5)  
    4800006c:	927af800 	and	x0, x0, #0xffffffffffffffdf
  
    orr     x0, x0, #(1 << 1)  
    48000070:	b27f0000 	orr	x0, x0, #0x2
    bic     x0, x0, #(1 << 42)      
    48000074:	9255f800 	and	x0, x0, #0xfffffbffffffffff
    msr     hcr_el2, x0
    48000078:	d51c1100 	msr	hcr_el2, x0

    /* Enable CNTP for EL1 */
    mrs     x0, cnthctl_el2         /* Counter-timer Hypervisor Control register */
    4800007c:	d53ce100 	mrs	x0, cnthctl_el2
    orr     x0, x0, #3
    48000080:	b2400400 	orr	x0, x0, #0x3
    msr     cnthctl_el2, x0
    48000084:	d51ce100 	msr	cnthctl_el2, x0
    msr     cntvoff_el2, xzr
    48000088:	d51ce07f 	msr	cntvoff_el2, xzr

    mrs     x0, midr_el1
    4800008c:	d5380000 	mrs	x0, midr_el1
    mrs     x2, mpidr_el1
    48000090:	d53800a2 	mrs	x2, mpidr_el1
    msr vpidr_el2, x0
    48000094:	d51c0000 	msr	vpidr_el2, x0
    msr vmpidr_el2, x2
    48000098:	d51c00a2 	msr	vmpidr_el2, x2

  	mov	x0, #0x0800			        // Set/clear RES{1,0} bits
    4800009c:	d2810000 	mov	x0, #0x800                 	// #2048
    movk x0, #0x30d0, lsl #16	    // Clear EE and E0E on LE systems
    480000a0:	f2a61a00 	movk	x0, #0x30d0, lsl #16
	msr	sctlr_el1, x0  
    480000a4:	d5181000 	msr	sctlr_el1, x0

    // Disable EL2 coprocessor traps.
	mov x9, #0x33ff
    480000a8:	d2867fe9 	mov	x9, #0x33ff                	// #13311
	msr cptr_el2, x9
    480000ac:	d51c1149 	msr	cptr_el2, x9
    msr hstr_el2, xzr
    480000b0:	d51c117f 	msr	hstr_el2, xzr

	// Disable stage 2 translations.
	msr vttbr_el2, xzr
    480000b4:	d51c211f 	msr	vttbr_el2, xzr

    /* Hypervisor stub */
	adrp	x0, system_vectors
    480000b8:	b0000000 	adrp	x0, 48001000 <system_vectors>
	msr	vbar_el2, x0
    480000bc:	d51cc000 	msr	vbar_el2, x0

    mrs     x2, sctlr_el2
    480000c0:	d53c1002 	mrs	x2, sctlr_el2
    orr     x2, x2, #(1 << 12)
    480000c4:	b2740042 	orr	x2, x2, #0x1000
    bic     x2, x2, #(3 << 3)       /* Disable SP Alignment check */
    480000c8:	927bf442 	and	x2, x2, #0xffffffffffffffe7
    bic     x2, x2, #(1 << 1)       /* Disable Alignment check */
    480000cc:	927ef842 	and	x2, x2, #0xfffffffffffffffd
    bic	    x2, x2, #(1 << 25)
    480000d0:	9266f842 	and	x2, x2, #0xfffffffffdffffff
    msr     sctlr_el2, x2
    480000d4:	d51c1002 	msr	sctlr_el2, x2
  
    /* Avoid trap from SIMD or float point instruction */
    mov     x1, #(3 << 20)         /* Don't trap any SIMD/FP instructions in both EL0 and EL1 */
    480000d8:	d2a00601 	mov	x1, #0x300000              	// #3145728
    msr     cpacr_el1, x1
    480000dc:	d5181041 	msr	cpacr_el1, x1

    mrs     x1, sctlr_el1
    480000e0:	d5381001 	mrs	x1, sctlr_el1
    orr     x1, x1, #(1 << 12)      /* Enable Instruction */
    480000e4:	b2740021 	orr	x1, x1, #0x1000
    bic     x1, x1, #(3 << 3)       /* Disable SP Alignment check */
    480000e8:	927bf421 	and	x1, x1, #0xffffffffffffffe7
    bic     x1, x1, #(1 << 1)       /* Disable Alignment check */
    480000ec:	927ef821 	and	x1, x1, #0xfffffffffffffffd
    msr     sctlr_el1, x1
    480000f0:	d5181001 	msr	sctlr_el1, x1

    /* Change execution level to EL1 */
    mov     x2, #0x3c5
    480000f4:	d28078a2 	mov	x2, #0x3c5                 	// #965
    msr     spsr_el2, x2            /* 0b1111000100 */
    480000f8:	d51c4002 	msr	spsr_el2, x2
    adr     x2, cpu_in_el1
    480000fc:	10000202 	adr	x2, 4800013c <cpu_in_el1>
    msr     elr_el2, x2
    48000100:	d51c4022 	msr	elr_el2, x2
    isb
    48000104:	d5033fdf 	isb

    ldr x1, = _start
    48000108:	58000641 	ldr	x1, 480001d0 <secondary_cpu_start+0x8>
    /* Read cpu id */
    mrs     x0, mpidr_el1
    4800010c:	d53800a0 	mrs	x0, mpidr_el1
    and     x0, x0, #3
    48000110:	92400400 	and	x0, x0, #0x3
    mov     x2, x0
    48000114:	aa0003e2 	mov	x2, x0
0:
    cmp     x0 , #0
    48000118:	f100001f 	cmp	x0, #0x0
    b.eq    1f
    4800011c:	54000080 	b.eq	4800012c <cpu_in_el2+0xe4>  // b.none
    sub     x1 , x1 , #0x100000
    48000120:	d1440021 	sub	x1, x1, #0x100, lsl #12
    sub     x0 , x0 , #1
    48000124:	d1000400 	sub	x0, x0, #0x1
    b.ne    0b
    48000128:	54ffff81 	b.ne	48000118 <cpu_in_el2+0xd0>  // b.any

1:
    bic     x1 , x1 , #0xf
    4800012c:	927cec21 	and	x1, x1, #0xfffffffffffffff0
    msr     spsel, #1                                                                
    48000130:	d50041bf 	msr	spsel, #0x1
    msr     sp_el1, x1
    48000134:	d51c4101 	msr	sp_el1, x1
    eret
    48000138:	d69f03e0 	eret

000000004800013c <cpu_in_el1>:

cpu_in_el1:

    cmp     x2, #0
    4800013c:	f100005f 	cmp	x2, #0x0
    b.ne    secondary_cpu_start
    48000140:	54000441 	b.ne	480001c8 <secondary_cpu_start>  // b.any

    ldr     x1,  =__bss_start
    48000144:	580004a1 	ldr	x1, 480001d8 <secondary_cpu_start+0x10>
    ldr     w2, =__bss_size
    48000148:	18000422 	ldr	w2, 480001cc <secondary_cpu_start+0x4>

000000004800014c <clean_bss_loop>:

clean_bss_loop:
    cbz     w2, jump_to_entry
    4800014c:	34000082 	cbz	w2, 4800015c <jump_to_entry>
    str     xzr, [x1], #8
    48000150:	f800843f 	str	xzr, [x1], #8
    sub     w2, w2, #1
    48000154:	51000442 	sub	w2, w2, #0x1
    cbnz    w2, clean_bss_loop
    48000158:	35ffffa2 	cbnz	w2, 4800014c <clean_bss_loop>

000000004800015c <jump_to_entry>:

jump_to_entry:

    b       rtthread_startup
    4800015c:	1400153f 	b	48005658 <rtthread_startup>
    b       cpu_idle                /* For failsafe, halt this core too */
    48000160:	14000001 	b	48000164 <cpu_idle>

0000000048000164 <cpu_idle>:

.globl cpu_idle
cpu_idle:
    wfe
    48000164:	d503205f 	wfe

0000000048000168 <diy_led_on>:
.globl diy_led_on

diy_led_on:
    mov x28,lr
    48000168:	aa1e03fc 	mov	x28, x30
	mov	x0, #0xff720000           
    4800016c:	d2bfee40 	mov	x0, #0xff720000            	// #4285661184
	mov	x1, #0xff720000           
    48000170:	d2bfee41 	mov	x1, #0xff720000            	// #4285661184
	ldr	w1, [x1,#4]
    48000174:	b9400421 	ldr	w1, [x1, #4]
	orr	w1, w1, #0x2000
    48000178:	32130021 	orr	w1, w1, #0x2000
	str	w1, [x0,#4]
    4800017c:	b9000401 	str	w1, [x0, #4]
	mov	x0, #0xff720000           
    48000180:	d2bfee40 	mov	x0, #0xff720000            	// #4285661184
	mov	x1, #0xff720000           
    48000184:	d2bfee41 	mov	x1, #0xff720000            	// #4285661184
	ldr	w1, [x1]
    48000188:	b9400021 	ldr	w1, [x1]
	orr	w1, w1, #0x2000
    4800018c:	32130021 	orr	w1, w1, #0x2000
	str	w1, [x0]
    48000190:	b9000001 	str	w1, [x0]
	ret x28
    48000194:	d65f0380 	ret	x28

0000000048000198 <work_led_on>:

.globl	work_led_on
work_led_on:
    mov x28,lr
    48000198:	aa1e03fc 	mov	x28, x30
	mov	x0, #0xff780000           
    4800019c:	d2bfef00 	mov	x0, #0xff780000            	// #4286054400
	mov	x1, #0xff780000           
    480001a0:	d2bfef01 	mov	x1, #0xff780000            	// #4286054400
	ldr w1, [x1,#4]
    480001a4:	b9400421 	ldr	w1, [x1, #4]
	orr	w1, w1, #0x8000000
    480001a8:	32050021 	orr	w1, w1, #0x8000000
	str	w1, [x0,#4]
    480001ac:	b9000401 	str	w1, [x0, #4]
	mov	x0, #0xff780000           
    480001b0:	d2bfef00 	mov	x0, #0xff780000            	// #4286054400
	mov	x1, #0xff780000           
    480001b4:	d2bfef01 	mov	x1, #0xff780000            	// #4286054400
	ldr	w1, [x1]
    480001b8:	b9400021 	ldr	w1, [x1]
	orr	w1, w1, #0x8000000
    480001bc:	32050021 	orr	w1, w1, #0x8000000
	str	w1, [x0]
    480001c0:	b9000001 	str	w1, [x0]
	ret x28
    480001c4:	d65f0380 	ret	x28

00000000480001c8 <secondary_cpu_start>:

.global secondary_cpu_start
secondary_cpu_start:
    b .
    480001c8:	14000000 	b	480001c8 <secondary_cpu_start>
    480001cc:	00002f27 	.word	0x00002f27
    480001d0:	48000000 	.word	0x48000000
    480001d4:	00000000 	.word	0x00000000
    480001d8:	48022000 	.word	0x48022000
    480001dc:	00000000 	.word	0x00000000

00000000480001e0 <main>:
#include <rtthread.h>
#include <rtdevice.h>
#include <board.h>

int main(int argc, char** argv)
{
    480001e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480001e4:	910003fd 	mov	x29, sp
    480001e8:	b9001fe0 	str	w0, [sp, #28]
    480001ec:	f9000be1 	str	x1, [sp, #16]
    rt_kprintf("Hi, this is RT-Thread!!\n");
    480001f0:	b00000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480001f4:	91340000 	add	x0, x0, #0xd00
    480001f8:	94003ece 	bl	4800fd30 <rt_kprintf>
    return 0;
    480001fc:	52800000 	mov	w0, #0x0                   	// #0
}
    48000200:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48000204:	d65f03c0 	ret

0000000048000208 <mmu_memset>:
void __asm_flush_dcache_range(unsigned long long start, unsigned long long end);
void __asm_invalidate_dcache_all(void);
void __asm_invalidate_icache_all(void);

void mmu_memset(char *dst, char v,  size_t len)
{
    48000208:	d10083ff 	sub	sp, sp, #0x20
    4800020c:	f9000fe0 	str	x0, [sp, #24]
    48000210:	39005fe1 	strb	w1, [sp, #23]
    48000214:	f90007e2 	str	x2, [sp, #8]
    while (len--)
    48000218:	14000006 	b	48000230 <mmu_memset+0x28>
    {
        *dst++ = v;
    4800021c:	f9400fe0 	ldr	x0, [sp, #24]
    48000220:	91000401 	add	x1, x0, #0x1
    48000224:	f9000fe1 	str	x1, [sp, #24]
    48000228:	39405fe1 	ldrb	w1, [sp, #23]
    4800022c:	39000001 	strb	w1, [x0]
    while (len--)
    48000230:	f94007e0 	ldr	x0, [sp, #8]
    48000234:	d1000401 	sub	x1, x0, #0x1
    48000238:	f90007e1 	str	x1, [sp, #8]
    4800023c:	f100001f 	cmp	x0, #0x0
    48000240:	54fffee1 	b.ne	4800021c <mmu_memset+0x14>  // b.any
    }
}
    48000244:	d503201f 	nop
    48000248:	d503201f 	nop
    4800024c:	910083ff 	add	sp, sp, #0x20
    48000250:	d65f03c0 	ret

0000000048000254 <get_free_page>:

static unsigned long __page_off = 0;
static unsigned long get_free_page(void)
{
    __page_off += 512;
    48000254:	d00001a0 	adrp	x0, 48036000 <__page_off>
    48000258:	91000000 	add	x0, x0, #0x0
    4800025c:	f9400000 	ldr	x0, [x0]
    48000260:	91080001 	add	x1, x0, #0x200
    48000264:	d00001a0 	adrp	x0, 48036000 <__page_off>
    48000268:	91000000 	add	x0, x0, #0x0
    4800026c:	f9000001 	str	x1, [x0]
    return (unsigned long)(main_tbl + __page_off);
    48000270:	d00001a0 	adrp	x0, 48036000 <__page_off>
    48000274:	91000000 	add	x0, x0, #0x0
    48000278:	f9400000 	ldr	x0, [x0]
    4800027c:	d37df001 	lsl	x1, x0, #3
    48000280:	d0000100 	adrp	x0, 48022000 <main_tbl>
    48000284:	91000000 	add	x0, x0, #0x0
    48000288:	8b000020 	add	x0, x1, x0
}
    4800028c:	d65f03c0 	ret

0000000048000290 <get_sctlr>:


static inline unsigned int get_sctlr(void)
{
    48000290:	d10043ff 	sub	sp, sp, #0x10
    unsigned int val;
    asm volatile("mrs %0, sctlr_el1" : "=r" (val) : : "cc");
    48000294:	d5381000 	mrs	x0, sctlr_el1
    48000298:	b9000fe0 	str	w0, [sp, #12]
    return val;
    4800029c:	b9400fe0 	ldr	w0, [sp, #12]
}
    480002a0:	910043ff 	add	sp, sp, #0x10
    480002a4:	d65f03c0 	ret

00000000480002a8 <set_sctlr>:

static inline void set_sctlr(unsigned int val)
{
    480002a8:	d10043ff 	sub	sp, sp, #0x10
    480002ac:	b9000fe0 	str	w0, [sp, #12]
    asm volatile("msr sctlr_el1, %0" : : "r" (val) : "cc");
    480002b0:	b9400fe0 	ldr	w0, [sp, #12]
    480002b4:	d5181000 	msr	sctlr_el1, x0
    asm volatile("isb");
    480002b8:	d5033fdf 	isb
}
    480002bc:	d503201f 	nop
    480002c0:	910043ff 	add	sp, sp, #0x10
    480002c4:	d65f03c0 	ret

00000000480002c8 <mmu_init>:

void mmu_init(void)
{
    480002c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480002cc:	910003fd 	mov	x29, sp
    unsigned long val64;
    unsigned long val32;

    val64 = 0x007f6eUL;
    480002d0:	d28fedc0 	mov	x0, #0x7f6e                	// #32622
    480002d4:	f9000fe0 	str	x0, [sp, #24]
    __asm__ volatile("msr MAIR_EL1, %0\n dsb sy\n"::"r"(val64));
    480002d8:	f9400fe0 	ldr	x0, [sp, #24]
    480002dc:	d518a200 	msr	mair_el1, x0
    480002e0:	d5033f9f 	dsb	sy
    __asm__ volatile("mrs %0, MAIR_EL1\n dsb sy\n":"=r"(val64));
    480002e4:	d538a200 	mrs	x0, mair_el1
    480002e8:	d5033f9f 	dsb	sy
    480002ec:	f9000fe0 	str	x0, [sp, #24]

    //TCR_EL1
    val32 = (16UL << 0)//48bit
    480002f0:	d285e200 	mov	x0, #0x2f10                	// #12048
    480002f4:	f2b01000 	movk	x0, #0x8080, lsl #16
    480002f8:	f2c00020 	movk	x0, #0x1, lsl #32
    480002fc:	f9000be0 	str	x0, [sp, #16]
        | (0x1UL << 32)
        | (0x0UL << 35)
        | (0x0UL << 36)
        | (0x0UL << 37)
        | (0x0UL << 38);
    __asm__ volatile("msr TCR_EL1, %0\n"::"r"(val32));
    48000300:	f9400be0 	ldr	x0, [sp, #16]
    48000304:	d5182040 	msr	tcr_el1, x0
    __asm__ volatile("mrs %0, TCR_EL1\n":"=r"(val32));
    48000308:	d5382040 	mrs	x0, tcr_el1
    4800030c:	f9000be0 	str	x0, [sp, #16]

    __asm__ volatile("msr TTBR0_EL1, %0\n dsb sy\n"::"r"(main_tbl));
    48000310:	d0000100 	adrp	x0, 48022000 <main_tbl>
    48000314:	91000000 	add	x0, x0, #0x0
    48000318:	d5182000 	msr	ttbr0_el1, x0
    4800031c:	d5033f9f 	dsb	sy
    __asm__ volatile("mrs %0, TTBR0_EL1\n dsb sy\n":"=r"(val64));
    48000320:	d5382000 	mrs	x0, ttbr0_el1
    48000324:	d5033f9f 	dsb	sy
    48000328:	f9000fe0 	str	x0, [sp, #24]

    mmu_memset((char *)main_tbl, 0, 4096);
    4800032c:	d2820002 	mov	x2, #0x1000                	// #4096
    48000330:	52800001 	mov	w1, #0x0                   	// #0
    48000334:	d0000100 	adrp	x0, 48022000 <main_tbl>
    48000338:	91000000 	add	x0, x0, #0x0
    4800033c:	97ffffb3 	bl	48000208 <mmu_memset>
}
    48000340:	d503201f 	nop
    48000344:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48000348:	d65f03c0 	ret

000000004800034c <mmu_enable>:

void mmu_enable(void)
{
    4800034c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48000350:	910003fd 	mov	x29, sp
    unsigned long val64;
    unsigned long val32;

    __asm__ volatile("mrs %0, SCTLR_EL1\n":"=r"(val64));
    48000354:	d5381000 	mrs	x0, sctlr_el1
    48000358:	f9000fe0 	str	x0, [sp, #24]
    val64 &= ~0x1000; //disable I
    4800035c:	f9400fe0 	ldr	x0, [sp, #24]
    48000360:	9273f800 	and	x0, x0, #0xffffffffffffefff
    48000364:	f9000fe0 	str	x0, [sp, #24]
    __asm__ volatile("dmb sy\n msr SCTLR_EL1, %0\n isb sy\n"::"r"(val64));
    48000368:	f9400fe0 	ldr	x0, [sp, #24]
    4800036c:	d5033fbf 	dmb	sy
    48000370:	d5181000 	msr	sctlr_el1, x0
    48000374:	d5033fdf 	isb

    __asm__ volatile("IC IALLUIS\n dsb sy\n isb sy\n");
    48000378:	d508711f 	ic	ialluis
    4800037c:	d5033f9f 	dsb	sy
    48000380:	d5033fdf 	isb
    __asm__ volatile("tlbi vmalle1\n dsb sy\n isb sy\n");
    48000384:	d508871f 	tlbi	vmalle1
    48000388:	d5033f9f 	dsb	sy
    4800038c:	d5033fdf 	isb

    //SCTLR_EL1, turn on mmu
    __asm__ volatile("mrs %0, SCTLR_EL1\n":"=r"(val32));
    48000390:	d5381000 	mrs	x0, sctlr_el1
    48000394:	f9000be0 	str	x0, [sp, #16]
    val32 |= 0x1005; //enable mmu, I C M
    48000398:	f9400be1 	ldr	x1, [sp, #16]
    4800039c:	d28200a0 	mov	x0, #0x1005                	// #4101
    480003a0:	aa000020 	orr	x0, x1, x0
    480003a4:	f9000be0 	str	x0, [sp, #16]
    __asm__ volatile("dmb sy\n msr SCTLR_EL1, %0\nisb sy\n"::"r"(val32));
    480003a8:	f9400be0 	ldr	x0, [sp, #16]
    480003ac:	d5033fbf 	dmb	sy
    480003b0:	d5181000 	msr	sctlr_el1, x0
    480003b4:	d5033fdf 	isb
    rt_hw_icache_enable();
    480003b8:	940001c2 	bl	48000ac0 <rt_hw_icache_enable>
    rt_hw_dcache_enable();
    480003bc:	9400016f 	bl	48000978 <rt_hw_dcache_enable>

}
    480003c0:	d503201f 	nop
    480003c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480003c8:	d65f03c0 	ret

00000000480003cc <map_single_page_2M>:

static int map_single_page_2M(unsigned long* lv0_tbl, unsigned long va, unsigned long pa, unsigned long attr)
{
    480003cc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    480003d0:	910003fd 	mov	x29, sp
    480003d4:	f90017e0 	str	x0, [sp, #40]
    480003d8:	f90013e1 	str	x1, [sp, #32]
    480003dc:	f9000fe2 	str	x2, [sp, #24]
    480003e0:	f9000be3 	str	x3, [sp, #16]
    int level;
    unsigned long* cur_lv_tbl = lv0_tbl;
    480003e4:	f94017e0 	ldr	x0, [sp, #40]
    480003e8:	f9002be0 	str	x0, [sp, #80]
    unsigned long page;
    unsigned long off;
    int level_shift = 39;
    480003ec:	528004e0 	mov	w0, #0x27                  	// #39
    480003f0:	b9004fe0 	str	w0, [sp, #76]

    if (va & (0x200000UL - 1))
    480003f4:	f94013e0 	ldr	x0, [sp, #32]
    480003f8:	92405000 	and	x0, x0, #0x1fffff
    480003fc:	f100001f 	cmp	x0, #0x0
    48000400:	54000060 	b.eq	4800040c <map_single_page_2M+0x40>  // b.none
    {
        return MMU_MAP_ERROR_VANOTALIGN;
    48000404:	12800000 	mov	w0, #0xffffffff            	// #-1
    48000408:	14000059 	b	4800056c <map_single_page_2M+0x1a0>
    }
    if (pa & (0x200000UL - 1))
    4800040c:	f9400fe0 	ldr	x0, [sp, #24]
    48000410:	92405000 	and	x0, x0, #0x1fffff
    48000414:	f100001f 	cmp	x0, #0x0
    48000418:	54000060 	b.eq	48000424 <map_single_page_2M+0x58>  // b.none
    {
        return MMU_MAP_ERROR_PANOTALIGN;
    4800041c:	12800020 	mov	w0, #0xfffffffe            	// #-2
    48000420:	14000053 	b	4800056c <map_single_page_2M+0x1a0>
    }
    for (level = 0; level < 2; level++)
    48000424:	b9005fff 	str	wzr, [sp, #92]
    48000428:	14000037 	b	48000504 <map_single_page_2M+0x138>
    {
        off = (va >> level_shift);
    4800042c:	b9404fe0 	ldr	w0, [sp, #76]
    48000430:	f94013e1 	ldr	x1, [sp, #32]
    48000434:	9ac02420 	lsr	x0, x1, x0
    48000438:	f90023e0 	str	x0, [sp, #64]
        off &= MMU_LEVEL_MASK;
    4800043c:	f94023e0 	ldr	x0, [sp, #64]
    48000440:	92402000 	and	x0, x0, #0x1ff
    48000444:	f90023e0 	str	x0, [sp, #64]
        if ((cur_lv_tbl[off] & 1) == 0)
    48000448:	f94023e0 	ldr	x0, [sp, #64]
    4800044c:	d37df000 	lsl	x0, x0, #3
    48000450:	f9402be1 	ldr	x1, [sp, #80]
    48000454:	8b000020 	add	x0, x1, x0
    48000458:	f9400000 	ldr	x0, [x0]
    4800045c:	92400000 	and	x0, x0, #0x1
    48000460:	f100001f 	cmp	x0, #0x0
    48000464:	54000261 	b.ne	480004b0 <map_single_page_2M+0xe4>  // b.any
        {
            page = get_free_page();
    48000468:	97ffff7b 	bl	48000254 <get_free_page>
    4800046c:	f9001fe0 	str	x0, [sp, #56]
            if (!page)
    48000470:	f9401fe0 	ldr	x0, [sp, #56]
    48000474:	f100001f 	cmp	x0, #0x0
    48000478:	54000061 	b.ne	48000484 <map_single_page_2M+0xb8>  // b.any
            {
                return MMU_MAP_ERROR_NOPAGE;
    4800047c:	12800040 	mov	w0, #0xfffffffd            	// #-3
    48000480:	1400003b 	b	4800056c <map_single_page_2M+0x1a0>
            }
            mmu_memset((char *)page, 0, 4096);
    48000484:	f9401fe0 	ldr	x0, [sp, #56]
    48000488:	d2820002 	mov	x2, #0x1000                	// #4096
    4800048c:	52800001 	mov	w1, #0x0                   	// #0
    48000490:	97ffff5e 	bl	48000208 <mmu_memset>
            cur_lv_tbl[off] = page | 0x3UL;
    48000494:	f94023e0 	ldr	x0, [sp, #64]
    48000498:	d37df000 	lsl	x0, x0, #3
    4800049c:	f9402be1 	ldr	x1, [sp, #80]
    480004a0:	8b000020 	add	x0, x1, x0
    480004a4:	f9401fe1 	ldr	x1, [sp, #56]
    480004a8:	b2400421 	orr	x1, x1, #0x3
    480004ac:	f9000001 	str	x1, [x0]
        }
        page = cur_lv_tbl[off];
    480004b0:	f94023e0 	ldr	x0, [sp, #64]
    480004b4:	d37df000 	lsl	x0, x0, #3
    480004b8:	f9402be1 	ldr	x1, [sp, #80]
    480004bc:	8b000020 	add	x0, x1, x0
    480004c0:	f9400000 	ldr	x0, [x0]
    480004c4:	f9001fe0 	str	x0, [sp, #56]
        if (!(page & 0x2))
    480004c8:	f9401fe0 	ldr	x0, [sp, #56]
    480004cc:	927f0000 	and	x0, x0, #0x2
    480004d0:	f100001f 	cmp	x0, #0x0
    480004d4:	54000061 	b.ne	480004e0 <map_single_page_2M+0x114>  // b.any
        {
            //is block! error!
            return MMU_MAP_ERROR_CONFLICT;
    480004d8:	12800060 	mov	w0, #0xfffffffc            	// #-4
    480004dc:	14000024 	b	4800056c <map_single_page_2M+0x1a0>
        }
        cur_lv_tbl = (unsigned long*)(page & 0x0000fffffffff000UL);
    480004e0:	f9401fe0 	ldr	x0, [sp, #56]
    480004e4:	92748c00 	and	x0, x0, #0xfffffffff000
    480004e8:	f9002be0 	str	x0, [sp, #80]
        level_shift -= 9;
    480004ec:	b9404fe0 	ldr	w0, [sp, #76]
    480004f0:	51002400 	sub	w0, w0, #0x9
    480004f4:	b9004fe0 	str	w0, [sp, #76]
    for (level = 0; level < 2; level++)
    480004f8:	b9405fe0 	ldr	w0, [sp, #92]
    480004fc:	11000400 	add	w0, w0, #0x1
    48000500:	b9005fe0 	str	w0, [sp, #92]
    48000504:	b9405fe0 	ldr	w0, [sp, #92]
    48000508:	7100041f 	cmp	w0, #0x1
    4800050c:	54fff90d 	b.le	4800042c <map_single_page_2M+0x60>
    }
    attr &= 0xfff0000000000ffcUL;
    48000510:	f9400be1 	ldr	x1, [sp, #16]
    48000514:	d281ff80 	mov	x0, #0xffc                 	// #4092
    48000518:	f2fffe00 	movk	x0, #0xfff0, lsl #48
    4800051c:	8a000020 	and	x0, x1, x0
    48000520:	f9000be0 	str	x0, [sp, #16]
    pa |= (attr | 0x1UL); //block
    48000524:	f9400be1 	ldr	x1, [sp, #16]
    48000528:	f9400fe0 	ldr	x0, [sp, #24]
    4800052c:	aa000020 	orr	x0, x1, x0
    48000530:	b2400000 	orr	x0, x0, #0x1
    48000534:	f9000fe0 	str	x0, [sp, #24]
    off = (va >> 21);
    48000538:	f94013e0 	ldr	x0, [sp, #32]
    4800053c:	d355fc00 	lsr	x0, x0, #21
    48000540:	f90023e0 	str	x0, [sp, #64]
    off &= MMU_LEVEL_MASK;
    48000544:	f94023e0 	ldr	x0, [sp, #64]
    48000548:	92402000 	and	x0, x0, #0x1ff
    4800054c:	f90023e0 	str	x0, [sp, #64]
    cur_lv_tbl[off] = pa;
    48000550:	f94023e0 	ldr	x0, [sp, #64]
    48000554:	d37df000 	lsl	x0, x0, #3
    48000558:	f9402be1 	ldr	x1, [sp, #80]
    4800055c:	8b000020 	add	x0, x1, x0
    48000560:	f9400fe1 	ldr	x1, [sp, #24]
    48000564:	f9000001 	str	x1, [x0]
    return 0;
    48000568:	52800000 	mov	w0, #0x0                   	// #0
}
    4800056c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    48000570:	d65f03c0 	ret

0000000048000574 <armv8_map_2M>:

int armv8_map_2M(unsigned long va, unsigned long pa, int count, unsigned long attr)
{
    48000574:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48000578:	910003fd 	mov	x29, sp
    4800057c:	f90017e0 	str	x0, [sp, #40]
    48000580:	f90013e1 	str	x1, [sp, #32]
    48000584:	b9001fe2 	str	w2, [sp, #28]
    48000588:	f9000be3 	str	x3, [sp, #16]
    int i;
    int ret;

    if (va & (0x200000 - 1))
    4800058c:	f94017e0 	ldr	x0, [sp, #40]
    48000590:	92405000 	and	x0, x0, #0x1fffff
    48000594:	f100001f 	cmp	x0, #0x0
    48000598:	54000060 	b.eq	480005a4 <armv8_map_2M+0x30>  // b.none
    {
        return -1;
    4800059c:	12800000 	mov	w0, #0xffffffff            	// #-1
    480005a0:	14000023 	b	4800062c <armv8_map_2M+0xb8>
    }
    if (pa & (0x200000 - 1))
    480005a4:	f94013e0 	ldr	x0, [sp, #32]
    480005a8:	92405000 	and	x0, x0, #0x1fffff
    480005ac:	f100001f 	cmp	x0, #0x0
    480005b0:	54000060 	b.eq	480005bc <armv8_map_2M+0x48>  // b.none
    {
        return -1;
    480005b4:	12800000 	mov	w0, #0xffffffff            	// #-1
    480005b8:	1400001d 	b	4800062c <armv8_map_2M+0xb8>
    }
    for (i = 0; i < count; i++)
    480005bc:	b9003fff 	str	wzr, [sp, #60]
    480005c0:	14000016 	b	48000618 <armv8_map_2M+0xa4>
    {
        ret = map_single_page_2M((unsigned long *)main_tbl, va, pa, attr);
    480005c4:	f9400be3 	ldr	x3, [sp, #16]
    480005c8:	f94013e2 	ldr	x2, [sp, #32]
    480005cc:	f94017e1 	ldr	x1, [sp, #40]
    480005d0:	d0000100 	adrp	x0, 48022000 <main_tbl>
    480005d4:	91000000 	add	x0, x0, #0x0
    480005d8:	97ffff7d 	bl	480003cc <map_single_page_2M>
    480005dc:	b9003be0 	str	w0, [sp, #56]
        va += 0x200000;
    480005e0:	f94017e0 	ldr	x0, [sp, #40]
    480005e4:	91480000 	add	x0, x0, #0x200, lsl #12
    480005e8:	f90017e0 	str	x0, [sp, #40]
        pa += 0x200000;
    480005ec:	f94013e0 	ldr	x0, [sp, #32]
    480005f0:	91480000 	add	x0, x0, #0x200, lsl #12
    480005f4:	f90013e0 	str	x0, [sp, #32]
        if (ret != 0)
    480005f8:	b9403be0 	ldr	w0, [sp, #56]
    480005fc:	7100001f 	cmp	w0, #0x0
    48000600:	54000060 	b.eq	4800060c <armv8_map_2M+0x98>  // b.none
        {
            return ret;
    48000604:	b9403be0 	ldr	w0, [sp, #56]
    48000608:	14000009 	b	4800062c <armv8_map_2M+0xb8>
    for (i = 0; i < count; i++)
    4800060c:	b9403fe0 	ldr	w0, [sp, #60]
    48000610:	11000400 	add	w0, w0, #0x1
    48000614:	b9003fe0 	str	w0, [sp, #60]
    48000618:	b9403fe1 	ldr	w1, [sp, #60]
    4800061c:	b9401fe0 	ldr	w0, [sp, #28]
    48000620:	6b00003f 	cmp	w1, w0
    48000624:	54fffd0b 	b.lt	480005c4 <armv8_map_2M+0x50>  // b.tstop
        }
    }
    return 0;
    48000628:	52800000 	mov	w0, #0x0                   	// #0
}
    4800062c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48000630:	d65f03c0 	ret

0000000048000634 <set_table>:

static void set_table(uint64_t *pt, uint64_t *table_addr)
{
    48000634:	d10083ff 	sub	sp, sp, #0x20
    48000638:	f90007e0 	str	x0, [sp, #8]
    4800063c:	f90003e1 	str	x1, [sp]
    uint64_t val;
    val = (0x3UL | (uint64_t)table_addr);
    48000640:	f94003e0 	ldr	x0, [sp]
    48000644:	b2400400 	orr	x0, x0, #0x3
    48000648:	f9000fe0 	str	x0, [sp, #24]
    *pt = val;
    4800064c:	f94007e0 	ldr	x0, [sp, #8]
    48000650:	f9400fe1 	ldr	x1, [sp, #24]
    48000654:	f9000001 	str	x1, [x0]
}
    48000658:	d503201f 	nop
    4800065c:	910083ff 	add	sp, sp, #0x20
    48000660:	d65f03c0 	ret

0000000048000664 <mmu_memset2>:

void mmu_memset2(unsigned char *dst, char v,  int len)
{
    48000664:	d10043ff 	sub	sp, sp, #0x10
    48000668:	f90007e0 	str	x0, [sp, #8]
    4800066c:	39001fe1 	strb	w1, [sp, #7]
    48000670:	b90003e2 	str	w2, [sp]
    while (len--)
    48000674:	14000006 	b	4800068c <mmu_memset2+0x28>
    {
        *dst++ = v;
    48000678:	f94007e0 	ldr	x0, [sp, #8]
    4800067c:	91000401 	add	x1, x0, #0x1
    48000680:	f90007e1 	str	x1, [sp, #8]
    48000684:	39401fe1 	ldrb	w1, [sp, #7]
    48000688:	39000001 	strb	w1, [x0]
    while (len--)
    4800068c:	b94003e0 	ldr	w0, [sp]
    48000690:	51000401 	sub	w1, w0, #0x1
    48000694:	b90003e1 	str	w1, [sp]
    48000698:	7100001f 	cmp	w0, #0x0
    4800069c:	54fffee1 	b.ne	48000678 <mmu_memset2+0x14>  // b.any
    }
}
    480006a0:	d503201f 	nop
    480006a4:	d503201f 	nop
    480006a8:	910043ff 	add	sp, sp, #0x10
    480006ac:	d65f03c0 	ret

00000000480006b0 <create_table>:

static uint64_t *create_table(void)
{
    480006b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480006b4:	910003fd 	mov	x29, sp
    uint64_t *new_table = (uint64_t *)((unsigned char *)&main_tbl[0] + free_idx * 4096); //+ free_idx * GRANULE_SIZE;
    480006b8:	b0000100 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480006bc:	91150000 	add	x0, x0, #0x540
    480006c0:	b9400000 	ldr	w0, [x0]
    480006c4:	53144c00 	lsl	w0, w0, #12
    480006c8:	93407c01 	sxtw	x1, w0
    480006cc:	d0000100 	adrp	x0, 48022000 <main_tbl>
    480006d0:	91000000 	add	x0, x0, #0x0
    480006d4:	8b000020 	add	x0, x1, x0
    480006d8:	f9000fe0 	str	x0, [sp, #24]
    /* Mark all entries as invalid */
    mmu_memset2((unsigned char *)new_table, 0, 4096);
    480006dc:	52820002 	mov	w2, #0x1000                	// #4096
    480006e0:	52800001 	mov	w1, #0x0                   	// #0
    480006e4:	f9400fe0 	ldr	x0, [sp, #24]
    480006e8:	97ffffdf 	bl	48000664 <mmu_memset2>
    free_idx++;
    480006ec:	b0000100 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480006f0:	91150000 	add	x0, x0, #0x540
    480006f4:	b9400000 	ldr	w0, [x0]
    480006f8:	11000401 	add	w1, w0, #0x1
    480006fc:	b0000100 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48000700:	91150000 	add	x0, x0, #0x540
    48000704:	b9000001 	str	w1, [x0]
    return new_table;
    48000708:	f9400fe0 	ldr	x0, [sp, #24]
}
    4800070c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48000710:	d65f03c0 	ret

0000000048000714 <pte_type>:

static int pte_type(uint64_t *pte)
{
    48000714:	d10043ff 	sub	sp, sp, #0x10
    48000718:	f90007e0 	str	x0, [sp, #8]
    return *pte & PMD_TYPE_MASK;
    4800071c:	f94007e0 	ldr	x0, [sp, #8]
    48000720:	f9400000 	ldr	x0, [x0]
    48000724:	12000400 	and	w0, w0, #0x3
}
    48000728:	910043ff 	add	sp, sp, #0x10
    4800072c:	d65f03c0 	ret

0000000048000730 <level2shift>:

static int level2shift(int level)
{
    48000730:	d10043ff 	sub	sp, sp, #0x10
    48000734:	b9000fe0 	str	w0, [sp, #12]
    /* Page is 12 bits wide, every level translates 9 bits */
    return (12 + 9 * (3 - level));
    48000738:	52800061 	mov	w1, #0x3                   	// #3
    4800073c:	b9400fe0 	ldr	w0, [sp, #12]
    48000740:	4b000021 	sub	w1, w1, w0
    48000744:	2a0103e0 	mov	w0, w1
    48000748:	531d7000 	lsl	w0, w0, #3
    4800074c:	0b010000 	add	w0, w0, w1
    48000750:	11003000 	add	w0, w0, #0xc
}
    48000754:	910043ff 	add	sp, sp, #0x10
    48000758:	d65f03c0 	ret

000000004800075c <get_level_table>:

static uint64_t *get_level_table(uint64_t *pte)
{
    4800075c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48000760:	910003fd 	mov	x29, sp
    48000764:	f9000fe0 	str	x0, [sp, #24]
    uint64_t *table = (uint64_t *)(*pte & XLAT_ADDR_MASK);
    48000768:	f9400fe0 	ldr	x0, [sp, #24]
    4800076c:	f9400000 	ldr	x0, [x0]
    48000770:	92746800 	and	x0, x0, #0x7ffffff000
    48000774:	f90017e0 	str	x0, [sp, #40]

    if (pte_type(pte) != PMD_TYPE_TABLE)
    48000778:	f9400fe0 	ldr	x0, [sp, #24]
    4800077c:	97ffffe6 	bl	48000714 <pte_type>
    48000780:	71000c1f 	cmp	w0, #0x3
    48000784:	540000c0 	b.eq	4800079c <get_level_table+0x40>  // b.none
    {
        table = create_table();
    48000788:	97ffffca 	bl	480006b0 <create_table>
    4800078c:	f90017e0 	str	x0, [sp, #40]
        set_table(pte, table);
    48000790:	f94017e1 	ldr	x1, [sp, #40]
    48000794:	f9400fe0 	ldr	x0, [sp, #24]
    48000798:	97ffffa7 	bl	48000634 <set_table>
    }
    return table;
    4800079c:	f94017e0 	ldr	x0, [sp, #40]
}
    480007a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480007a4:	d65f03c0 	ret

00000000480007a8 <map_region>:

static void map_region(uint64_t virt, uint64_t phys, uint64_t size, uint64_t attr)
{
    480007a8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    480007ac:	910003fd 	mov	x29, sp
    480007b0:	f90017e0 	str	x0, [sp, #40]
    480007b4:	f90013e1 	str	x1, [sp, #32]
    480007b8:	f9000fe2 	str	x2, [sp, #24]
    480007bc:	f9000be3 	str	x3, [sp, #16]
    uint64_t block_size = 0;
    480007c0:	f9002bff 	str	xzr, [sp, #80]
    uint64_t block_shift = 0;
    480007c4:	f90027ff 	str	xzr, [sp, #72]
    uint64_t *pte;
    uint64_t idx = 0;
    480007c8:	f90023ff 	str	xzr, [sp, #64]
    uint64_t addr = 0;
    480007cc:	f90037ff 	str	xzr, [sp, #104]
    uint64_t *table = 0;
    480007d0:	f90033ff 	str	xzr, [sp, #96]
    int level = 0;
    480007d4:	b9005fff 	str	wzr, [sp, #92]

    addr = virt;
    480007d8:	f94017e0 	ldr	x0, [sp, #40]
    480007dc:	f90037e0 	str	x0, [sp, #104]
    while (size)
    480007e0:	14000051 	b	48000924 <map_region+0x17c>
    {
        table = &main_tbl[0];
    480007e4:	d0000100 	adrp	x0, 48022000 <main_tbl>
    480007e8:	91000000 	add	x0, x0, #0x0
    480007ec:	f90033e0 	str	x0, [sp, #96]
        for (level = 0; level < 4; level++)
    480007f0:	b9005fff 	str	wzr, [sp, #92]
    480007f4:	14000049 	b	48000918 <map_region+0x170>
        {
            block_shift = level2shift(level);
    480007f8:	b9405fe0 	ldr	w0, [sp, #92]
    480007fc:	97ffffcd 	bl	48000730 <level2shift>
    48000800:	93407c00 	sxtw	x0, w0
    48000804:	f90027e0 	str	x0, [sp, #72]
            idx = addr >> block_shift;
    48000808:	f94027e0 	ldr	x0, [sp, #72]
    4800080c:	2a0003e1 	mov	w1, w0
    48000810:	f94037e0 	ldr	x0, [sp, #104]
    48000814:	9ac12400 	lsr	x0, x0, x1
    48000818:	f90023e0 	str	x0, [sp, #64]
            idx = idx%512;
    4800081c:	f94023e0 	ldr	x0, [sp, #64]
    48000820:	92402000 	and	x0, x0, #0x1ff
    48000824:	f90023e0 	str	x0, [sp, #64]
            block_size = (uint64_t)(1L << block_shift);
    48000828:	f94027e0 	ldr	x0, [sp, #72]
    4800082c:	2a0003e1 	mov	w1, w0
    48000830:	d2800020 	mov	x0, #0x1                   	// #1
    48000834:	9ac12000 	lsl	x0, x0, x1
    48000838:	f9002be0 	str	x0, [sp, #80]
            pte = table + idx;
    4800083c:	f94023e0 	ldr	x0, [sp, #64]
    48000840:	d37df000 	lsl	x0, x0, #3
    48000844:	f94033e1 	ldr	x1, [sp, #96]
    48000848:	8b000020 	add	x0, x1, x0
    4800084c:	f9001fe0 	str	x0, [sp, #56]

            if (size >= block_size && IS_ALIGNED(addr, block_size))
    48000850:	f9400fe1 	ldr	x1, [sp, #24]
    48000854:	f9402be0 	ldr	x0, [sp, #80]
    48000858:	eb00003f 	cmp	x1, x0
    4800085c:	54000523 	b.cc	48000900 <map_region+0x158>  // b.lo, b.ul, b.last
    48000860:	f9402be0 	ldr	x0, [sp, #80]
    48000864:	d1000401 	sub	x1, x0, #0x1
    48000868:	f94037e0 	ldr	x0, [sp, #104]
    4800086c:	8a000020 	and	x0, x1, x0
    48000870:	f100001f 	cmp	x0, #0x0
    48000874:	54000461 	b.ne	48000900 <map_region+0x158>  // b.any
            {
                attr &= 0xfff0000000000ffcUL;
    48000878:	f9400be1 	ldr	x1, [sp, #16]
    4800087c:	d281ff80 	mov	x0, #0xffc                 	// #4092
    48000880:	f2fffe00 	movk	x0, #0xfff0, lsl #48
    48000884:	8a000020 	and	x0, x1, x0
    48000888:	f9000be0 	str	x0, [sp, #16]
                if(level != 3)
    4800088c:	b9405fe0 	ldr	w0, [sp, #92]
    48000890:	71000c1f 	cmp	w0, #0x3
    48000894:	54000100 	b.eq	480008b4 <map_region+0x10c>  // b.none
                {
                    *pte = phys | (attr | 0x1UL);
    48000898:	f9400be1 	ldr	x1, [sp, #16]
    4800089c:	f94013e0 	ldr	x0, [sp, #32]
    480008a0:	aa000020 	orr	x0, x1, x0
    480008a4:	b2400001 	orr	x1, x0, #0x1
    480008a8:	f9401fe0 	ldr	x0, [sp, #56]
    480008ac:	f9000001 	str	x1, [x0]
    480008b0:	14000007 	b	480008cc <map_region+0x124>
                }
                else
                {
                    *pte = phys | (attr | 0x3UL);
    480008b4:	f9400be1 	ldr	x1, [sp, #16]
    480008b8:	f94013e0 	ldr	x0, [sp, #32]
    480008bc:	aa000020 	orr	x0, x1, x0
    480008c0:	b2400401 	orr	x1, x0, #0x3
    480008c4:	f9401fe0 	ldr	x0, [sp, #56]
    480008c8:	f9000001 	str	x1, [x0]
                }
                addr += block_size;
    480008cc:	f94037e1 	ldr	x1, [sp, #104]
    480008d0:	f9402be0 	ldr	x0, [sp, #80]
    480008d4:	8b000020 	add	x0, x1, x0
    480008d8:	f90037e0 	str	x0, [sp, #104]
                phys += block_size;
    480008dc:	f94013e1 	ldr	x1, [sp, #32]
    480008e0:	f9402be0 	ldr	x0, [sp, #80]
    480008e4:	8b000020 	add	x0, x1, x0
    480008e8:	f90013e0 	str	x0, [sp, #32]
                size -= block_size;
    480008ec:	f9400fe1 	ldr	x1, [sp, #24]
    480008f0:	f9402be0 	ldr	x0, [sp, #80]
    480008f4:	cb000020 	sub	x0, x1, x0
    480008f8:	f9000fe0 	str	x0, [sp, #24]
                break;
    480008fc:	1400000a 	b	48000924 <map_region+0x17c>
            }
            table = get_level_table(pte);
    48000900:	f9401fe0 	ldr	x0, [sp, #56]
    48000904:	97ffff96 	bl	4800075c <get_level_table>
    48000908:	f90033e0 	str	x0, [sp, #96]
        for (level = 0; level < 4; level++)
    4800090c:	b9405fe0 	ldr	w0, [sp, #92]
    48000910:	11000400 	add	w0, w0, #0x1
    48000914:	b9005fe0 	str	w0, [sp, #92]
    48000918:	b9405fe0 	ldr	w0, [sp, #92]
    4800091c:	71000c1f 	cmp	w0, #0x3
    48000920:	54fff6cd 	b.le	480007f8 <map_region+0x50>
    while (size)
    48000924:	f9400fe0 	ldr	x0, [sp, #24]
    48000928:	f100001f 	cmp	x0, #0x0
    4800092c:	54fff5c1 	b.ne	480007e4 <map_region+0x3c>  // b.any
        }
    }
}
    48000930:	d503201f 	nop
    48000934:	d503201f 	nop
    48000938:	a8c77bfd 	ldp	x29, x30, [sp], #112
    4800093c:	d65f03c0 	ret

0000000048000940 <armv8_map>:

void armv8_map(unsigned long va, unsigned long pa, unsigned long size, unsigned long attr)
{
    48000940:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48000944:	910003fd 	mov	x29, sp
    48000948:	f90017e0 	str	x0, [sp, #40]
    4800094c:	f90013e1 	str	x1, [sp, #32]
    48000950:	f9000fe2 	str	x2, [sp, #24]
    48000954:	f9000be3 	str	x3, [sp, #16]
    map_region(va, pa, size, attr);
    48000958:	f9400be3 	ldr	x3, [sp, #16]
    4800095c:	f9400fe2 	ldr	x2, [sp, #24]
    48000960:	f94013e1 	ldr	x1, [sp, #32]
    48000964:	f94017e0 	ldr	x0, [sp, #40]
    48000968:	97ffff90 	bl	480007a8 <map_region>
}
    4800096c:	d503201f 	nop
    48000970:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48000974:	d65f03c0 	ret

0000000048000978 <rt_hw_dcache_enable>:

void rt_hw_dcache_enable(void)
{
    48000978:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4800097c:	910003fd 	mov	x29, sp
    if (!(get_sctlr() & CR_M))
    48000980:	97fffe44 	bl	48000290 <get_sctlr>
    48000984:	12000000 	and	w0, w0, #0x1
    48000988:	7100001f 	cmp	w0, #0x0
    4800098c:	540000a1 	b.ne	480009a0 <rt_hw_dcache_enable+0x28>  // b.any
    {
        rt_kprintf("please init mmu!\n");
    48000990:	b00000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48000994:	91348000 	add	x0, x0, #0xd20
    48000998:	94003ce6 	bl	4800fd30 <rt_kprintf>
    }
    else
    {
        set_sctlr(get_sctlr() | CR_C);
    }
}
    4800099c:	14000004 	b	480009ac <rt_hw_dcache_enable+0x34>
        set_sctlr(get_sctlr() | CR_C);
    480009a0:	97fffe3c 	bl	48000290 <get_sctlr>
    480009a4:	321e0000 	orr	w0, w0, #0x4
    480009a8:	97fffe40 	bl	480002a8 <set_sctlr>
}
    480009ac:	d503201f 	nop
    480009b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    480009b4:	d65f03c0 	ret

00000000480009b8 <rt_hw_dcache_flush_all>:

void rt_hw_dcache_flush_all(void)
{
    480009b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480009bc:	910003fd 	mov	x29, sp
    int ret;

    __asm_flush_dcache_all();
    480009c0:	94000d58 	bl	48003f20 <__asm_flush_dcache_all>
    ret = __asm_flush_l3_cache();
    480009c4:	94000d6b 	bl	48003f70 <__asm_flush_l3_cache>
    480009c8:	b9001fe0 	str	w0, [sp, #28]
    if (ret)
    480009cc:	b9401fe0 	ldr	w0, [sp, #28]
    480009d0:	7100001f 	cmp	w0, #0x0
    480009d4:	540000c0 	b.eq	480009ec <rt_hw_dcache_flush_all+0x34>  // b.none
    {
        rt_kprintf("flushing dcache returns 0x%x\n", ret);
    480009d8:	b9401fe1 	ldr	w1, [sp, #28]
    480009dc:	b00000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480009e0:	9134e000 	add	x0, x0, #0xd38
    480009e4:	94003cd3 	bl	4800fd30 <rt_kprintf>
    }
    else
    {
        rt_kprintf("flushing dcache successfully.\n");
    }
}
    480009e8:	14000004 	b	480009f8 <rt_hw_dcache_flush_all+0x40>
        rt_kprintf("flushing dcache successfully.\n");
    480009ec:	b00000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480009f0:	91356000 	add	x0, x0, #0xd58
    480009f4:	94003ccf 	bl	4800fd30 <rt_kprintf>
}
    480009f8:	d503201f 	nop
    480009fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48000a00:	d65f03c0 	ret

0000000048000a04 <rt_hw_dcache_flush_range>:

void rt_hw_dcache_flush_range(unsigned long start_addr, unsigned long size)
{
    48000a04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48000a08:	910003fd 	mov	x29, sp
    48000a0c:	f9000fe0 	str	x0, [sp, #24]
    48000a10:	f9000be1 	str	x1, [sp, #16]
    __asm_flush_dcache_range(start_addr, start_addr + size);
    48000a14:	f9400fe1 	ldr	x1, [sp, #24]
    48000a18:	f9400be0 	ldr	x0, [sp, #16]
    48000a1c:	8b000020 	add	x0, x1, x0
    48000a20:	aa0003e1 	mov	x1, x0
    48000a24:	f9400fe0 	ldr	x0, [sp, #24]
    48000a28:	94000d42 	bl	48003f30 <__asm_flush_dcache_range>
}
    48000a2c:	d503201f 	nop
    48000a30:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48000a34:	d65f03c0 	ret

0000000048000a38 <rt_hw_dcache_invalidate_range>:
void rt_hw_dcache_invalidate_range(unsigned long start_addr,unsigned long size)
{
    48000a38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48000a3c:	910003fd 	mov	x29, sp
    48000a40:	f9000fe0 	str	x0, [sp, #24]
    48000a44:	f9000be1 	str	x1, [sp, #16]
    __asm_flush_dcache_range(start_addr, start_addr + size);
    48000a48:	f9400fe1 	ldr	x1, [sp, #24]
    48000a4c:	f9400be0 	ldr	x0, [sp, #16]
    48000a50:	8b000020 	add	x0, x1, x0
    48000a54:	aa0003e1 	mov	x1, x0
    48000a58:	f9400fe0 	ldr	x0, [sp, #24]
    48000a5c:	94000d35 	bl	48003f30 <__asm_flush_dcache_range>
}
    48000a60:	d503201f 	nop
    48000a64:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48000a68:	d65f03c0 	ret

0000000048000a6c <rt_hw_dcache_invalidate_all>:

void rt_hw_dcache_invalidate_all(void)
{
    48000a6c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48000a70:	910003fd 	mov	x29, sp
    __asm_invalidate_dcache_all();
    48000a74:	94000d2d 	bl	48003f28 <__asm_invalidate_dcache_all>
}
    48000a78:	d503201f 	nop
    48000a7c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48000a80:	d65f03c0 	ret

0000000048000a84 <rt_hw_dcache_disable>:

void rt_hw_dcache_disable(void)
{
    48000a84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48000a88:	910003fd 	mov	x29, sp
    /* if cache isn't enabled no need to disable */
    if(!(get_sctlr() & CR_C))
    48000a8c:	97fffe01 	bl	48000290 <get_sctlr>
    48000a90:	121e0000 	and	w0, w0, #0x4
    48000a94:	7100001f 	cmp	w0, #0x0
    48000a98:	540000a1 	b.ne	48000aac <rt_hw_dcache_disable+0x28>  // b.any
    {
        rt_kprintf("need enable cache!\n");
    48000a9c:	b00000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48000aa0:	9135e000 	add	x0, x0, #0xd78
    48000aa4:	94003ca3 	bl	4800fd30 <rt_kprintf>
        return;
    48000aa8:	14000004 	b	48000ab8 <rt_hw_dcache_disable+0x34>
    }
    set_sctlr(get_sctlr() & ~CR_C);
    48000aac:	97fffdf9 	bl	48000290 <get_sctlr>
    48000ab0:	121d7800 	and	w0, w0, #0xfffffffb
    48000ab4:	97fffdfd 	bl	480002a8 <set_sctlr>
}
    48000ab8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48000abc:	d65f03c0 	ret

0000000048000ac0 <rt_hw_icache_enable>:

//icache
void rt_hw_icache_enable(void)
{
    48000ac0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48000ac4:	910003fd 	mov	x29, sp
    __asm_invalidate_icache_all();
    48000ac8:	94000d27 	bl	48003f64 <__asm_invalidate_icache_all>
    set_sctlr(get_sctlr() | CR_I);
    48000acc:	97fffdf1 	bl	48000290 <get_sctlr>
    48000ad0:	32140000 	orr	w0, w0, #0x1000
    48000ad4:	97fffdf5 	bl	480002a8 <set_sctlr>
}
    48000ad8:	d503201f 	nop
    48000adc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48000ae0:	d65f03c0 	ret

0000000048000ae4 <rt_hw_icache_invalidate_all>:

void rt_hw_icache_invalidate_all(void)
{
    48000ae4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48000ae8:	910003fd 	mov	x29, sp
    __asm_invalidate_icache_all();
    48000aec:	94000d1e 	bl	48003f64 <__asm_invalidate_icache_all>
}
    48000af0:	d503201f 	nop
    48000af4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48000af8:	d65f03c0 	ret

0000000048000afc <rt_hw_icache_disable>:

void rt_hw_icache_disable(void)
{
    48000afc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48000b00:	910003fd 	mov	x29, sp
    set_sctlr(get_sctlr() & ~CR_I);
    48000b04:	97fffde3 	bl	48000290 <get_sctlr>
    48000b08:	12137800 	and	w0, w0, #0xffffefff
    48000b0c:	97fffde7 	bl	480002a8 <set_sctlr>
}
    48000b10:	d503201f 	nop
    48000b14:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48000b18:	d65f03c0 	ret
	...

0000000048001000 <system_vectors>:
.align 11
    .set    VBAR, system_vectors
    .org    VBAR
    // Exception from CurrentEL (EL1) with SP_EL0 (SPSEL=1)
    .org (VBAR + 0x00 + 0)
            MOV X0, #0x47
    48001000:	d28008e0 	mov	x0, #0x47                  	// #71
    BL debug
    48001004:	94000ffc 	bl	48004ff4 <debug>
    B vector_error      // 			Synchronous
    48001008:	14000ebe 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x80 + 0)
    B vector_irq        //          IRQ/vIRQ
    48001080:	14000e20 	b	48004900 <vector_irq>
	...
    .org (VBAR + 0x100 + 0)
    B vector_fiq        //          FIQ/vFIQ
    48001100:	14000d80 	b	48004700 <vector_fiq>
	...
    .org (VBAR + 0x180 + 0)
            MOV X0, #0x46
    48001180:	d28008c0 	mov	x0, #0x46                  	// #70
    BL debug
    48001184:	94000f9c 	bl	48004ff4 <debug>
        mrs     x0, mpidr_el1
    48001188:	d53800a0 	mrs	x0, mpidr_el1
    and     x0, x0, #3
    4800118c:	92400400 	and	x0, x0, #0x3
    add     x0, x0, #0x41
    48001190:	91010400 	add	x0, x0, #0x41
    BL debug
    48001194:	94000f98 	bl	48004ff4 <debug>
    B vector_error      //          Error/vError
    48001198:	14000e5a 	b	48004b00 <vector_error>
	...

    // Exception from CurrentEL (EL1) with SP_ELn
    .org (VBAR + 0x200 + 0)
            MOV X0, #0x45
    48001200:	d28008a0 	mov	x0, #0x45                  	// #69
    BL debug
    48001204:	94000f7c 	bl	48004ff4 <debug>
    B vector_error      // 			Synchronous
    48001208:	14000e3e 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x280 + 0)
    B vector_irq    	// 			IRQ/vIRQ
    48001280:	14000da0 	b	48004900 <vector_irq>
	...
    .org (VBAR + 0x300 + 0)
    B vector_fiq        //          FIQ/vFIQ
    48001300:	14000d00 	b	48004700 <vector_fiq>
	...
    .org (VBAR + 0x380 + 0)
            MOV X0, #0x48
    48001380:	d2800900 	mov	x0, #0x48                  	// #72
    BL debug
    48001384:	94000f1c 	bl	48004ff4 <debug>
    B vector_error
    48001388:	14000dde 	b	48004b00 <vector_error>
	...

    // Exception from lower EL, aarch64
    .org (VBAR + 0x400 + 0)
    MOV X0, #0x41
    48001400:	d2800820 	mov	x0, #0x41                  	// #65
    BL debug
    48001404:	94000efc 	bl	48004ff4 <debug>
    B vector_error
    48001408:	14000dbe 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x480 + 0)
        MOV X0, #0x42
    48001480:	d2800840 	mov	x0, #0x42                  	// #66
    BL debug
    48001484:	94000edc 	bl	48004ff4 <debug>
    B vector_error
    48001488:	14000d9e 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x500 + 0)
        MOV X0, #0x43
    48001500:	d2800860 	mov	x0, #0x43                  	// #67
    BL debug
    48001504:	94000ebc 	bl	48004ff4 <debug>
    B vector_error
    48001508:	14000d7e 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x580 + 0)
        MOV X0, #0x44
    48001580:	d2800880 	mov	x0, #0x44                  	// #68
    BL debug
    48001584:	94000e9c 	bl	48004ff4 <debug>
    B vector_error
    48001588:	14000d5e 	b	48004b00 <vector_error>
	...

    // Exception from lower EL, aarch32
    .org (VBAR + 0x600 + 0)
    B vector_error
    48001600:	14000d40 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x680 + 0)
    B vector_error
    48001680:	14000d20 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x700 + 0)
    B vector_error
    48001700:	14000d00 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x780 + 0)
    B vector_error
    48001780:	14000ce0 	b	48004b00 <vector_error>
	...
    .org (VBAR + 0x800 + 0)
    B vector_error
    48001800:	14000cc0 	b	48004b00 <vector_error>

0000000048001804 <rt_hw_stack_init>:
 *
 * @return stack address
 */
rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter,
    rt_uint8_t *stack_addr, void *texit)
{
    48001804:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48001808:	910003fd 	mov	x29, sp
    4800180c:	f90017e0 	str	x0, [sp, #40]
    48001810:	f90013e1 	str	x1, [sp, #32]
    48001814:	f9000fe2 	str	x2, [sp, #24]
    48001818:	f9000be3 	str	x3, [sp, #16]
    rt_ubase_t *stk;
    rt_ubase_t current_el;

    stk      = (rt_ubase_t*)stack_addr;
    4800181c:	f9400fe0 	ldr	x0, [sp, #24]
    48001820:	f9001fe0 	str	x0, [sp, #56]

    *(--stk) = ( rt_ubase_t ) 11;           /* X1 */
    48001824:	f9401fe0 	ldr	x0, [sp, #56]
    48001828:	d1002000 	sub	x0, x0, #0x8
    4800182c:	f9001fe0 	str	x0, [sp, #56]
    48001830:	f9401fe0 	ldr	x0, [sp, #56]
    48001834:	d2800161 	mov	x1, #0xb                   	// #11
    48001838:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) parameter;    /* X0 */
    4800183c:	f9401fe0 	ldr	x0, [sp, #56]
    48001840:	d1002000 	sub	x0, x0, #0x8
    48001844:	f9001fe0 	str	x0, [sp, #56]
    48001848:	f94013e1 	ldr	x1, [sp, #32]
    4800184c:	f9401fe0 	ldr	x0, [sp, #56]
    48001850:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 33;           /* X3 */
    48001854:	f9401fe0 	ldr	x0, [sp, #56]
    48001858:	d1002000 	sub	x0, x0, #0x8
    4800185c:	f9001fe0 	str	x0, [sp, #56]
    48001860:	f9401fe0 	ldr	x0, [sp, #56]
    48001864:	d2800421 	mov	x1, #0x21                  	// #33
    48001868:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 22;           /* X2 */
    4800186c:	f9401fe0 	ldr	x0, [sp, #56]
    48001870:	d1002000 	sub	x0, x0, #0x8
    48001874:	f9001fe0 	str	x0, [sp, #56]
    48001878:	f9401fe0 	ldr	x0, [sp, #56]
    4800187c:	d28002c1 	mov	x1, #0x16                  	// #22
    48001880:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 55;           /* X5 */
    48001884:	f9401fe0 	ldr	x0, [sp, #56]
    48001888:	d1002000 	sub	x0, x0, #0x8
    4800188c:	f9001fe0 	str	x0, [sp, #56]
    48001890:	f9401fe0 	ldr	x0, [sp, #56]
    48001894:	d28006e1 	mov	x1, #0x37                  	// #55
    48001898:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 44;           /* X4 */
    4800189c:	f9401fe0 	ldr	x0, [sp, #56]
    480018a0:	d1002000 	sub	x0, x0, #0x8
    480018a4:	f9001fe0 	str	x0, [sp, #56]
    480018a8:	f9401fe0 	ldr	x0, [sp, #56]
    480018ac:	d2800581 	mov	x1, #0x2c                  	// #44
    480018b0:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 77;           /* X7 */
    480018b4:	f9401fe0 	ldr	x0, [sp, #56]
    480018b8:	d1002000 	sub	x0, x0, #0x8
    480018bc:	f9001fe0 	str	x0, [sp, #56]
    480018c0:	f9401fe0 	ldr	x0, [sp, #56]
    480018c4:	d28009a1 	mov	x1, #0x4d                  	// #77
    480018c8:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 66;           /* X6 */
    480018cc:	f9401fe0 	ldr	x0, [sp, #56]
    480018d0:	d1002000 	sub	x0, x0, #0x8
    480018d4:	f9001fe0 	str	x0, [sp, #56]
    480018d8:	f9401fe0 	ldr	x0, [sp, #56]
    480018dc:	d2800841 	mov	x1, #0x42                  	// #66
    480018e0:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 99;           /* X9 */
    480018e4:	f9401fe0 	ldr	x0, [sp, #56]
    480018e8:	d1002000 	sub	x0, x0, #0x8
    480018ec:	f9001fe0 	str	x0, [sp, #56]
    480018f0:	f9401fe0 	ldr	x0, [sp, #56]
    480018f4:	d2800c61 	mov	x1, #0x63                  	// #99
    480018f8:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 88;           /* X8 */
    480018fc:	f9401fe0 	ldr	x0, [sp, #56]
    48001900:	d1002000 	sub	x0, x0, #0x8
    48001904:	f9001fe0 	str	x0, [sp, #56]
    48001908:	f9401fe0 	ldr	x0, [sp, #56]
    4800190c:	d2800b01 	mov	x1, #0x58                  	// #88
    48001910:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 11;           /* X11 */
    48001914:	f9401fe0 	ldr	x0, [sp, #56]
    48001918:	d1002000 	sub	x0, x0, #0x8
    4800191c:	f9001fe0 	str	x0, [sp, #56]
    48001920:	f9401fe0 	ldr	x0, [sp, #56]
    48001924:	d2800161 	mov	x1, #0xb                   	// #11
    48001928:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 10;           /* X10 */
    4800192c:	f9401fe0 	ldr	x0, [sp, #56]
    48001930:	d1002000 	sub	x0, x0, #0x8
    48001934:	f9001fe0 	str	x0, [sp, #56]
    48001938:	f9401fe0 	ldr	x0, [sp, #56]
    4800193c:	d2800141 	mov	x1, #0xa                   	// #10
    48001940:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 13;           /* X13 */
    48001944:	f9401fe0 	ldr	x0, [sp, #56]
    48001948:	d1002000 	sub	x0, x0, #0x8
    4800194c:	f9001fe0 	str	x0, [sp, #56]
    48001950:	f9401fe0 	ldr	x0, [sp, #56]
    48001954:	d28001a1 	mov	x1, #0xd                   	// #13
    48001958:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 12;           /* X12 */
    4800195c:	f9401fe0 	ldr	x0, [sp, #56]
    48001960:	d1002000 	sub	x0, x0, #0x8
    48001964:	f9001fe0 	str	x0, [sp, #56]
    48001968:	f9401fe0 	ldr	x0, [sp, #56]
    4800196c:	d2800181 	mov	x1, #0xc                   	// #12
    48001970:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 15;           /* X15 */
    48001974:	f9401fe0 	ldr	x0, [sp, #56]
    48001978:	d1002000 	sub	x0, x0, #0x8
    4800197c:	f9001fe0 	str	x0, [sp, #56]
    48001980:	f9401fe0 	ldr	x0, [sp, #56]
    48001984:	d28001e1 	mov	x1, #0xf                   	// #15
    48001988:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 14;           /* X14 */
    4800198c:	f9401fe0 	ldr	x0, [sp, #56]
    48001990:	d1002000 	sub	x0, x0, #0x8
    48001994:	f9001fe0 	str	x0, [sp, #56]
    48001998:	f9401fe0 	ldr	x0, [sp, #56]
    4800199c:	d28001c1 	mov	x1, #0xe                   	// #14
    480019a0:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 17;           /* X17 */
    480019a4:	f9401fe0 	ldr	x0, [sp, #56]
    480019a8:	d1002000 	sub	x0, x0, #0x8
    480019ac:	f9001fe0 	str	x0, [sp, #56]
    480019b0:	f9401fe0 	ldr	x0, [sp, #56]
    480019b4:	d2800221 	mov	x1, #0x11                  	// #17
    480019b8:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 16;           /* X16 */
    480019bc:	f9401fe0 	ldr	x0, [sp, #56]
    480019c0:	d1002000 	sub	x0, x0, #0x8
    480019c4:	f9001fe0 	str	x0, [sp, #56]
    480019c8:	f9401fe0 	ldr	x0, [sp, #56]
    480019cc:	d2800201 	mov	x1, #0x10                  	// #16
    480019d0:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 19;           /* X19 */
    480019d4:	f9401fe0 	ldr	x0, [sp, #56]
    480019d8:	d1002000 	sub	x0, x0, #0x8
    480019dc:	f9001fe0 	str	x0, [sp, #56]
    480019e0:	f9401fe0 	ldr	x0, [sp, #56]
    480019e4:	d2800261 	mov	x1, #0x13                  	// #19
    480019e8:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 18;           /* X18 */
    480019ec:	f9401fe0 	ldr	x0, [sp, #56]
    480019f0:	d1002000 	sub	x0, x0, #0x8
    480019f4:	f9001fe0 	str	x0, [sp, #56]
    480019f8:	f9401fe0 	ldr	x0, [sp, #56]
    480019fc:	d2800241 	mov	x1, #0x12                  	// #18
    48001a00:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 21;           /* X21 */
    48001a04:	f9401fe0 	ldr	x0, [sp, #56]
    48001a08:	d1002000 	sub	x0, x0, #0x8
    48001a0c:	f9001fe0 	str	x0, [sp, #56]
    48001a10:	f9401fe0 	ldr	x0, [sp, #56]
    48001a14:	d28002a1 	mov	x1, #0x15                  	// #21
    48001a18:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 20;           /* X20 */
    48001a1c:	f9401fe0 	ldr	x0, [sp, #56]
    48001a20:	d1002000 	sub	x0, x0, #0x8
    48001a24:	f9001fe0 	str	x0, [sp, #56]
    48001a28:	f9401fe0 	ldr	x0, [sp, #56]
    48001a2c:	d2800281 	mov	x1, #0x14                  	// #20
    48001a30:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 23;           /* X23 */
    48001a34:	f9401fe0 	ldr	x0, [sp, #56]
    48001a38:	d1002000 	sub	x0, x0, #0x8
    48001a3c:	f9001fe0 	str	x0, [sp, #56]
    48001a40:	f9401fe0 	ldr	x0, [sp, #56]
    48001a44:	d28002e1 	mov	x1, #0x17                  	// #23
    48001a48:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 22;           /* X22 */
    48001a4c:	f9401fe0 	ldr	x0, [sp, #56]
    48001a50:	d1002000 	sub	x0, x0, #0x8
    48001a54:	f9001fe0 	str	x0, [sp, #56]
    48001a58:	f9401fe0 	ldr	x0, [sp, #56]
    48001a5c:	d28002c1 	mov	x1, #0x16                  	// #22
    48001a60:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 25;           /* X25 */
    48001a64:	f9401fe0 	ldr	x0, [sp, #56]
    48001a68:	d1002000 	sub	x0, x0, #0x8
    48001a6c:	f9001fe0 	str	x0, [sp, #56]
    48001a70:	f9401fe0 	ldr	x0, [sp, #56]
    48001a74:	d2800321 	mov	x1, #0x19                  	// #25
    48001a78:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 24;           /* X24 */
    48001a7c:	f9401fe0 	ldr	x0, [sp, #56]
    48001a80:	d1002000 	sub	x0, x0, #0x8
    48001a84:	f9001fe0 	str	x0, [sp, #56]
    48001a88:	f9401fe0 	ldr	x0, [sp, #56]
    48001a8c:	d2800301 	mov	x1, #0x18                  	// #24
    48001a90:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 27;           /* X27 */
    48001a94:	f9401fe0 	ldr	x0, [sp, #56]
    48001a98:	d1002000 	sub	x0, x0, #0x8
    48001a9c:	f9001fe0 	str	x0, [sp, #56]
    48001aa0:	f9401fe0 	ldr	x0, [sp, #56]
    48001aa4:	d2800361 	mov	x1, #0x1b                  	// #27
    48001aa8:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 26;           /* X26 */
    48001aac:	f9401fe0 	ldr	x0, [sp, #56]
    48001ab0:	d1002000 	sub	x0, x0, #0x8
    48001ab4:	f9001fe0 	str	x0, [sp, #56]
    48001ab8:	f9401fe0 	ldr	x0, [sp, #56]
    48001abc:	d2800341 	mov	x1, #0x1a                  	// #26
    48001ac0:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 29;           /* X29 */
    48001ac4:	f9401fe0 	ldr	x0, [sp, #56]
    48001ac8:	d1002000 	sub	x0, x0, #0x8
    48001acc:	f9001fe0 	str	x0, [sp, #56]
    48001ad0:	f9401fe0 	ldr	x0, [sp, #56]
    48001ad4:	d28003a1 	mov	x1, #0x1d                  	// #29
    48001ad8:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 28;           /* X28 */
    48001adc:	f9401fe0 	ldr	x0, [sp, #56]
    48001ae0:	d1002000 	sub	x0, x0, #0x8
    48001ae4:	f9001fe0 	str	x0, [sp, #56]
    48001ae8:	f9401fe0 	ldr	x0, [sp, #56]
    48001aec:	d2800381 	mov	x1, #0x1c                  	// #28
    48001af0:	f9000001 	str	x1, [x0]
    *(--stk) = ( rt_ubase_t ) 0;            /* XZR - has no effect, used so there are an even number of registers. */
    48001af4:	f9401fe0 	ldr	x0, [sp, #56]
    48001af8:	d1002000 	sub	x0, x0, #0x8
    48001afc:	f9001fe0 	str	x0, [sp, #56]
    48001b00:	f9401fe0 	ldr	x0, [sp, #56]
    48001b04:	f900001f 	str	xzr, [x0]
    *(--stk) = ( rt_ubase_t ) texit;        /* X30 - procedure call link register. */
    48001b08:	f9401fe0 	ldr	x0, [sp, #56]
    48001b0c:	d1002000 	sub	x0, x0, #0x8
    48001b10:	f9001fe0 	str	x0, [sp, #56]
    48001b14:	f9400be1 	ldr	x1, [sp, #16]
    48001b18:	f9401fe0 	ldr	x0, [sp, #56]
    48001b1c:	f9000001 	str	x1, [x0]

    current_el = rt_hw_get_current_el();
    48001b20:	940009f0 	bl	480042e0 <rt_hw_get_current_el>
    48001b24:	f9001be0 	str	x0, [sp, #48]

    if(current_el == 3)
    48001b28:	f9401be0 	ldr	x0, [sp, #48]
    48001b2c:	f1000c1f 	cmp	x0, #0x3
    48001b30:	54000101 	b.ne	48001b50 <rt_hw_stack_init+0x34c>  // b.any
    {
        *(--stk) = INITIAL_SPSR_EL3;
    48001b34:	f9401fe0 	ldr	x0, [sp, #56]
    48001b38:	d1002000 	sub	x0, x0, #0x8
    48001b3c:	f9001fe0 	str	x0, [sp, #56]
    48001b40:	f9401fe0 	ldr	x0, [sp, #56]
    48001b44:	d2800181 	mov	x1, #0xc                   	// #12
    48001b48:	f9000001 	str	x1, [x0]
    48001b4c:	14000011 	b	48001b90 <rt_hw_stack_init+0x38c>
    }
    else if(current_el == 2)
    48001b50:	f9401be0 	ldr	x0, [sp, #48]
    48001b54:	f100081f 	cmp	x0, #0x2
    48001b58:	54000101 	b.ne	48001b78 <rt_hw_stack_init+0x374>  // b.any
    {
        *(--stk) = INITIAL_SPSR_EL2;
    48001b5c:	f9401fe0 	ldr	x0, [sp, #56]
    48001b60:	d1002000 	sub	x0, x0, #0x8
    48001b64:	f9001fe0 	str	x0, [sp, #56]
    48001b68:	f9401fe0 	ldr	x0, [sp, #56]
    48001b6c:	d2800101 	mov	x1, #0x8                   	// #8
    48001b70:	f9000001 	str	x1, [x0]
    48001b74:	14000007 	b	48001b90 <rt_hw_stack_init+0x38c>
    }
    else
    {
        *(--stk) = INITIAL_SPSR_EL1;
    48001b78:	f9401fe0 	ldr	x0, [sp, #56]
    48001b7c:	d1002000 	sub	x0, x0, #0x8
    48001b80:	f9001fe0 	str	x0, [sp, #56]
    48001b84:	f9401fe0 	ldr	x0, [sp, #56]
    48001b88:	d2800081 	mov	x1, #0x4                   	// #4
    48001b8c:	f9000001 	str	x1, [x0]
    }

    *(--stk) = ( rt_ubase_t ) tentry;       /* Exception return address. */
    48001b90:	f9401fe0 	ldr	x0, [sp, #56]
    48001b94:	d1002000 	sub	x0, x0, #0x8
    48001b98:	f9001fe0 	str	x0, [sp, #56]
    48001b9c:	f94017e1 	ldr	x1, [sp, #40]
    48001ba0:	f9401fe0 	ldr	x0, [sp, #56]
    48001ba4:	f9000001 	str	x1, [x0]

    /* return task's current stack address */
    return (rt_uint8_t *)stk;
    48001ba8:	f9401fe0 	ldr	x0, [sp, #56]
}
    48001bac:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48001bb0:	d65f03c0 	ret

0000000048001bb4 <arm_gic_cpumask_to_affval>:
 * @out param target_list:  Target List. The set of PEs for which SGI interrupts will be generated. Each bit corresponds to the
 *                          PE within a cluster with an Affinity 0 value equal to the bit number.
 * @return {rt_uint32_t} 0 is finish , 1 is data valid
 */
RT_WEAK rt_uint32_t arm_gic_cpumask_to_affval(rt_uint32_t *cpu_mask, rt_uint32_t *cluster_id, rt_uint32_t *target_list)
{
    48001bb4:	d10083ff 	sub	sp, sp, #0x20
    48001bb8:	f9000fe0 	str	x0, [sp, #24]
    48001bbc:	f9000be1 	str	x1, [sp, #16]
    48001bc0:	f90007e2 	str	x2, [sp, #8]
    if (*cpu_mask == 0)
    48001bc4:	f9400fe0 	ldr	x0, [sp, #24]
    48001bc8:	b9400000 	ldr	w0, [x0]
    48001bcc:	7100001f 	cmp	w0, #0x0
    48001bd0:	54000061 	b.ne	48001bdc <arm_gic_cpumask_to_affval+0x28>  // b.any
    {
        return 0;
    48001bd4:	52800000 	mov	w0, #0x0                   	// #0
    48001bd8:	1400004d 	b	48001d0c <arm_gic_cpumask_to_affval+0x158>
    }

    *target_list = 0;
    48001bdc:	f94007e0 	ldr	x0, [sp, #8]
    48001be0:	b900001f 	str	wzr, [x0]
    *cluster_id = 0;
    48001be4:	f9400be0 	ldr	x0, [sp, #16]
    48001be8:	b900001f 	str	wzr, [x0]

    if (*cpu_mask & 0x3)
    48001bec:	f9400fe0 	ldr	x0, [sp, #24]
    48001bf0:	b9400000 	ldr	w0, [x0]
    48001bf4:	12000400 	and	w0, w0, #0x3
    48001bf8:	7100001f 	cmp	w0, #0x0
    48001bfc:	54000380 	b.eq	48001c6c <arm_gic_cpumask_to_affval+0xb8>  // b.none
    {
        if ((*cpu_mask & 0x3) == 0x3)
    48001c00:	f9400fe0 	ldr	x0, [sp, #24]
    48001c04:	b9400000 	ldr	w0, [x0]
    48001c08:	12000400 	and	w0, w0, #0x3
    48001c0c:	71000c1f 	cmp	w0, #0x3
    48001c10:	540000a1 	b.ne	48001c24 <arm_gic_cpumask_to_affval+0x70>  // b.any
        {
            *target_list = 3;
    48001c14:	f94007e0 	ldr	x0, [sp, #8]
    48001c18:	52800061 	mov	w1, #0x3                   	// #3
    48001c1c:	b9000001 	str	w1, [x0]
    48001c20:	1400000d 	b	48001c54 <arm_gic_cpumask_to_affval+0xa0>
        }
        else if ((*cpu_mask & 0x1))
    48001c24:	f9400fe0 	ldr	x0, [sp, #24]
    48001c28:	b9400000 	ldr	w0, [x0]
    48001c2c:	12000000 	and	w0, w0, #0x1
    48001c30:	7100001f 	cmp	w0, #0x0
    48001c34:	540000a0 	b.eq	48001c48 <arm_gic_cpumask_to_affval+0x94>  // b.none
        {
            *target_list = 1;
    48001c38:	f94007e0 	ldr	x0, [sp, #8]
    48001c3c:	52800021 	mov	w1, #0x1                   	// #1
    48001c40:	b9000001 	str	w1, [x0]
    48001c44:	14000004 	b	48001c54 <arm_gic_cpumask_to_affval+0xa0>
        }
        else
        {
            *target_list = 2;
    48001c48:	f94007e0 	ldr	x0, [sp, #8]
    48001c4c:	52800041 	mov	w1, #0x2                   	// #2
    48001c50:	b9000001 	str	w1, [x0]
        }
        *cpu_mask &= ~0x3;
    48001c54:	f9400fe0 	ldr	x0, [sp, #24]
    48001c58:	b9400000 	ldr	w0, [x0]
    48001c5c:	121e7401 	and	w1, w0, #0xfffffffc
    48001c60:	f9400fe0 	ldr	x0, [sp, #24]
    48001c64:	b9000001 	str	w1, [x0]
    48001c68:	14000028 	b	48001d08 <arm_gic_cpumask_to_affval+0x154>
    }
    else if (*cpu_mask & 0xc)
    48001c6c:	f9400fe0 	ldr	x0, [sp, #24]
    48001c70:	b9400000 	ldr	w0, [x0]
    48001c74:	121e0400 	and	w0, w0, #0xc
    48001c78:	7100001f 	cmp	w0, #0x0
    48001c7c:	540003e0 	b.eq	48001cf8 <arm_gic_cpumask_to_affval+0x144>  // b.none
    {
        *cluster_id = 0x100;
    48001c80:	f9400be0 	ldr	x0, [sp, #16]
    48001c84:	52802001 	mov	w1, #0x100                 	// #256
    48001c88:	b9000001 	str	w1, [x0]
        if ((*cpu_mask & 0xc) == 0xc)
    48001c8c:	f9400fe0 	ldr	x0, [sp, #24]
    48001c90:	b9400000 	ldr	w0, [x0]
    48001c94:	121e0400 	and	w0, w0, #0xc
    48001c98:	7100301f 	cmp	w0, #0xc
    48001c9c:	540000a1 	b.ne	48001cb0 <arm_gic_cpumask_to_affval+0xfc>  // b.any
        {
            *target_list = 3;
    48001ca0:	f94007e0 	ldr	x0, [sp, #8]
    48001ca4:	52800061 	mov	w1, #0x3                   	// #3
    48001ca8:	b9000001 	str	w1, [x0]
    48001cac:	1400000d 	b	48001ce0 <arm_gic_cpumask_to_affval+0x12c>
        }
        else if ((*cpu_mask & 0x4))
    48001cb0:	f9400fe0 	ldr	x0, [sp, #24]
    48001cb4:	b9400000 	ldr	w0, [x0]
    48001cb8:	121e0000 	and	w0, w0, #0x4
    48001cbc:	7100001f 	cmp	w0, #0x0
    48001cc0:	540000a0 	b.eq	48001cd4 <arm_gic_cpumask_to_affval+0x120>  // b.none
        {
            *target_list = 1;
    48001cc4:	f94007e0 	ldr	x0, [sp, #8]
    48001cc8:	52800021 	mov	w1, #0x1                   	// #1
    48001ccc:	b9000001 	str	w1, [x0]
    48001cd0:	14000004 	b	48001ce0 <arm_gic_cpumask_to_affval+0x12c>
        }
        else
        {
            *target_list = 2;
    48001cd4:	f94007e0 	ldr	x0, [sp, #8]
    48001cd8:	52800041 	mov	w1, #0x2                   	// #2
    48001cdc:	b9000001 	str	w1, [x0]
        }
        *cpu_mask &= ~0xc;
    48001ce0:	f9400fe0 	ldr	x0, [sp, #24]
    48001ce4:	b9400000 	ldr	w0, [x0]
    48001ce8:	121c7401 	and	w1, w0, #0xfffffff3
    48001cec:	f9400fe0 	ldr	x0, [sp, #24]
    48001cf0:	b9000001 	str	w1, [x0]
    48001cf4:	14000005 	b	48001d08 <arm_gic_cpumask_to_affval+0x154>
    }
    else
    {
        *cpu_mask = 0;
    48001cf8:	f9400fe0 	ldr	x0, [sp, #24]
    48001cfc:	b900001f 	str	wzr, [x0]
        return 0;
    48001d00:	52800000 	mov	w0, #0x0                   	// #0
    48001d04:	14000002 	b	48001d0c <arm_gic_cpumask_to_affval+0x158>
    }
    return 0;
    48001d08:	52800000 	mov	w0, #0x0                   	// #0
}
    48001d0c:	910083ff 	add	sp, sp, #0x20
    48001d10:	d65f03c0 	ret

0000000048001d14 <get_main_cpu_affval>:

RT_WEAK rt_uint64_t get_main_cpu_affval(void)
{
    return 0;
    48001d14:	d2800000 	mov	x0, #0x0                   	// #0
}
    48001d18:	d65f03c0 	ret

0000000048001d1c <arm_gic_get_active_irq>:

int arm_gic_get_active_irq(rt_uint32_t index)
{
    48001d1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48001d20:	910003fd 	mov	x29, sp
    48001d24:	b9001fe0 	str	w0, [sp, #28]
    int irq;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48001d28:	b9401fe0 	ldr	w0, [sp, #28]
    48001d2c:	7100001f 	cmp	w0, #0x0
    48001d30:	540000e0 	b.eq	48001d4c <arm_gic_get_active_irq+0x30>  // b.none
    48001d34:	d2800d42 	mov	x2, #0x6a                  	// #106
    48001d38:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001d3c:	913aa001 	add	x1, x0, #0xea8
    48001d40:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001d44:	91364000 	add	x0, x0, #0xd90
    48001d48:	940038c8 	bl	48010068 <rt_assert_handler>

    __get_gicv3_reg(ICC_IAR1_EL1, irq);
    48001d4c:	d538cc00 	mrs	x0, s3_0_c12_c12_0
    48001d50:	b9002fe0 	str	w0, [sp, #44]

    irq = (irq & 0x1FFFFFF) + _gic_table[index].offset;
    48001d54:	b9402fe0 	ldr	w0, [sp, #44]
    48001d58:	12006001 	and	w1, w0, #0x1ffffff
    48001d5c:	b00001a0 	adrp	x0, 48036000 <__page_off>
    48001d60:	91002002 	add	x2, x0, #0x8
    48001d64:	b9401fe3 	ldr	w3, [sp, #28]
    48001d68:	d2800300 	mov	x0, #0x18                  	// #24
    48001d6c:	9b007c60 	mul	x0, x3, x0
    48001d70:	8b000040 	add	x0, x2, x0
    48001d74:	b9400000 	ldr	w0, [x0]
    48001d78:	0b000020 	add	w0, w1, w0
    48001d7c:	b9002fe0 	str	w0, [sp, #44]
    return irq;
    48001d80:	b9402fe0 	ldr	w0, [sp, #44]
}
    48001d84:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48001d88:	d65f03c0 	ret

0000000048001d8c <arm_gic_ack>:

void arm_gic_ack(rt_uint32_t index, int irq)
{
    48001d8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48001d90:	910003fd 	mov	x29, sp
    48001d94:	b9001fe0 	str	w0, [sp, #28]
    48001d98:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48001d9c:	b9401fe0 	ldr	w0, [sp, #28]
    48001da0:	7100001f 	cmp	w0, #0x0
    48001da4:	540000e0 	b.eq	48001dc0 <arm_gic_ack+0x34>  // b.none
    48001da8:	d2800e82 	mov	x2, #0x74                  	// #116
    48001dac:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001db0:	913b0001 	add	x1, x0, #0xec0
    48001db4:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001db8:	91364000 	add	x0, x0, #0xd90
    48001dbc:	940038ab 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(irq >= 0U);

    __asm__ volatile("dsb 0xF" ::
    48001dc0:	d5033f9f 	dsb	sy
                         : "memory");
    __set_gicv3_reg(ICC_EOIR1_EL1, irq);
    48001dc4:	b9401be0 	ldr	w0, [sp, #24]
    48001dc8:	d518cc20 	msr	s3_0_c12_c12_1, x0
}
    48001dcc:	d503201f 	nop
    48001dd0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48001dd4:	d65f03c0 	ret

0000000048001dd8 <arm_gic_mask>:

void arm_gic_mask(rt_uint32_t index, int irq)
{
    48001dd8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48001ddc:	910003fd 	mov	x29, sp
    48001de0:	b9001fe0 	str	w0, [sp, #28]
    48001de4:	b9001be1 	str	w1, [sp, #24]
    rt_uint32_t mask = 1U << (irq % 32U);
    48001de8:	b9401be0 	ldr	w0, [sp, #24]
    48001dec:	12001000 	and	w0, w0, #0x1f
    48001df0:	52800021 	mov	w1, #0x1                   	// #1
    48001df4:	1ac02020 	lsl	w0, w1, w0
    48001df8:	b9002fe0 	str	w0, [sp, #44]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48001dfc:	b9401fe0 	ldr	w0, [sp, #28]
    48001e00:	7100001f 	cmp	w0, #0x0
    48001e04:	540000e0 	b.eq	48001e20 <arm_gic_mask+0x48>  // b.none
    48001e08:	d2801002 	mov	x2, #0x80                  	// #128
    48001e0c:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001e10:	913b4001 	add	x1, x0, #0xed0
    48001e14:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001e18:	91364000 	add	x0, x0, #0xd90
    48001e1c:	94003893 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    48001e20:	b9401be1 	ldr	w1, [sp, #24]
    48001e24:	b00001a0 	adrp	x0, 48036000 <__page_off>
    48001e28:	91002002 	add	x2, x0, #0x8
    48001e2c:	b9401fe3 	ldr	w3, [sp, #28]
    48001e30:	d2800300 	mov	x0, #0x18                  	// #24
    48001e34:	9b007c60 	mul	x0, x3, x0
    48001e38:	8b000040 	add	x0, x2, x0
    48001e3c:	b9400000 	ldr	w0, [x0]
    48001e40:	4b000020 	sub	w0, w1, w0
    48001e44:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    if (irq < 32U)
    48001e48:	b9401be0 	ldr	w0, [sp, #24]
    48001e4c:	71007c1f 	cmp	w0, #0x1f
    48001e50:	54000408 	b.hi	48001ed0 <arm_gic_mask+0xf8>  // b.pmore
    {
        rt_int32_t cpu_id = rt_hw_cpu_id();
    48001e54:	94000b52 	bl	48004b9c <rt_hw_cpu_id>
    48001e58:	b9002be0 	str	w0, [sp, #40]
        RT_ASSERT((cpu_id) < RT_CPUS_NR);
    48001e5c:	b9402be0 	ldr	w0, [sp, #40]
    48001e60:	7100041f 	cmp	w0, #0x1
    48001e64:	540000ed 	b.le	48001e80 <arm_gic_mask+0xa8>
    48001e68:	d2801102 	mov	x2, #0x88                  	// #136
    48001e6c:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001e70:	913b4001 	add	x1, x0, #0xed0
    48001e74:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001e78:	9136a000 	add	x0, x0, #0xda8
    48001e7c:	9400387b 	bl	48010068 <rt_assert_handler>
        GIC_RDISTSGI_ICENABLER0(_gic_table[index].redist_hw_base[cpu_id]) = mask;
    48001e80:	b00001a0 	adrp	x0, 48036000 <__page_off>
    48001e84:	91002002 	add	x2, x0, #0x8
    48001e88:	b9802be3 	ldrsw	x3, [sp, #40]
    48001e8c:	b9401fe1 	ldr	w1, [sp, #28]
    48001e90:	aa0103e0 	mov	x0, x1
    48001e94:	8b000000 	add	x0, x0, x0
    48001e98:	8b010000 	add	x0, x0, x1
    48001e9c:	8b000000 	add	x0, x0, x0
    48001ea0:	8b030000 	add	x0, x0, x3
    48001ea4:	d37ef400 	lsl	x0, x0, #2
    48001ea8:	8b000040 	add	x0, x2, x0
    48001eac:	b9400400 	ldr	w0, [x0, #4]
    48001eb0:	2a0003e1 	mov	w1, w0
    48001eb4:	d2803000 	mov	x0, #0x180                 	// #384
    48001eb8:	f2a00020 	movk	x0, #0x1, lsl #16
    48001ebc:	8b000020 	add	x0, x1, x0
    48001ec0:	aa0003e1 	mov	x1, x0
    48001ec4:	b9402fe0 	ldr	w0, [sp, #44]
    48001ec8:	b9000020 	str	w0, [x1]
    }
    else
    {
        GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
    }
}
    48001ecc:	14000012 	b	48001f14 <arm_gic_mask+0x13c>
        GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
    48001ed0:	b00001a0 	adrp	x0, 48036000 <__page_off>
    48001ed4:	91002001 	add	x1, x0, #0x8
    48001ed8:	b9401fe2 	ldr	w2, [sp, #28]
    48001edc:	d2800300 	mov	x0, #0x18                  	// #24
    48001ee0:	9b007c40 	mul	x0, x2, x0
    48001ee4:	8b000020 	add	x0, x1, x0
    48001ee8:	b9400c00 	ldr	w0, [x0, #12]
    48001eec:	2a0003e1 	mov	w1, w0
    48001ef0:	b9401be0 	ldr	w0, [sp, #24]
    48001ef4:	53057c00 	lsr	w0, w0, #5
    48001ef8:	531e7400 	lsl	w0, w0, #2
    48001efc:	2a0003e0 	mov	w0, w0
    48001f00:	8b000020 	add	x0, x1, x0
    48001f04:	91060000 	add	x0, x0, #0x180
    48001f08:	aa0003e1 	mov	x1, x0
    48001f0c:	b9402fe0 	ldr	w0, [sp, #44]
    48001f10:	b9000020 	str	w0, [x1]
}
    48001f14:	d503201f 	nop
    48001f18:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48001f1c:	d65f03c0 	ret

0000000048001f20 <arm_gic_umask>:

void arm_gic_umask(rt_uint32_t index, int irq)
{
    48001f20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48001f24:	910003fd 	mov	x29, sp
    48001f28:	b9001fe0 	str	w0, [sp, #28]
    48001f2c:	b9001be1 	str	w1, [sp, #24]
    rt_uint32_t mask = 1U << (irq % 32U);
    48001f30:	b9401be0 	ldr	w0, [sp, #24]
    48001f34:	12001000 	and	w0, w0, #0x1f
    48001f38:	52800021 	mov	w1, #0x1                   	// #1
    48001f3c:	1ac02020 	lsl	w0, w1, w0
    48001f40:	b9002fe0 	str	w0, [sp, #44]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48001f44:	b9401fe0 	ldr	w0, [sp, #28]
    48001f48:	7100001f 	cmp	w0, #0x0
    48001f4c:	540000e0 	b.eq	48001f68 <arm_gic_umask+0x48>  // b.none
    48001f50:	d28012a2 	mov	x2, #0x95                  	// #149
    48001f54:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001f58:	913b8001 	add	x1, x0, #0xee0
    48001f5c:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001f60:	91364000 	add	x0, x0, #0xd90
    48001f64:	94003841 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    48001f68:	b9401be1 	ldr	w1, [sp, #24]
    48001f6c:	b00001a0 	adrp	x0, 48036000 <__page_off>
    48001f70:	91002002 	add	x2, x0, #0x8
    48001f74:	b9401fe3 	ldr	w3, [sp, #28]
    48001f78:	d2800300 	mov	x0, #0x18                  	// #24
    48001f7c:	9b007c60 	mul	x0, x3, x0
    48001f80:	8b000040 	add	x0, x2, x0
    48001f84:	b9400000 	ldr	w0, [x0]
    48001f88:	4b000020 	sub	w0, w1, w0
    48001f8c:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    if (irq < 32U)
    48001f90:	b9401be0 	ldr	w0, [sp, #24]
    48001f94:	71007c1f 	cmp	w0, #0x1f
    48001f98:	54000408 	b.hi	48002018 <arm_gic_umask+0xf8>  // b.pmore
    {
        rt_int32_t cpu_id = rt_hw_cpu_id();
    48001f9c:	94000b00 	bl	48004b9c <rt_hw_cpu_id>
    48001fa0:	b9002be0 	str	w0, [sp, #40]
        RT_ASSERT((cpu_id) < RT_CPUS_NR);
    48001fa4:	b9402be0 	ldr	w0, [sp, #40]
    48001fa8:	7100041f 	cmp	w0, #0x1
    48001fac:	540000ed 	b.le	48001fc8 <arm_gic_umask+0xa8>
    48001fb0:	d28013a2 	mov	x2, #0x9d                  	// #157
    48001fb4:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001fb8:	913b8001 	add	x1, x0, #0xee0
    48001fbc:	900000e0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48001fc0:	9136a000 	add	x0, x0, #0xda8
    48001fc4:	94003829 	bl	48010068 <rt_assert_handler>
        GIC_RDISTSGI_ISENABLER0(_gic_table[index].redist_hw_base[cpu_id]) = mask;
    48001fc8:	b00001a0 	adrp	x0, 48036000 <__page_off>
    48001fcc:	91002002 	add	x2, x0, #0x8
    48001fd0:	b9802be3 	ldrsw	x3, [sp, #40]
    48001fd4:	b9401fe1 	ldr	w1, [sp, #28]
    48001fd8:	aa0103e0 	mov	x0, x1
    48001fdc:	8b000000 	add	x0, x0, x0
    48001fe0:	8b010000 	add	x0, x0, x1
    48001fe4:	8b000000 	add	x0, x0, x0
    48001fe8:	8b030000 	add	x0, x0, x3
    48001fec:	d37ef400 	lsl	x0, x0, #2
    48001ff0:	8b000040 	add	x0, x2, x0
    48001ff4:	b9400400 	ldr	w0, [x0, #4]
    48001ff8:	2a0003e1 	mov	w1, w0
    48001ffc:	d2802000 	mov	x0, #0x100                 	// #256
    48002000:	f2a00020 	movk	x0, #0x1, lsl #16
    48002004:	8b000020 	add	x0, x1, x0
    48002008:	aa0003e1 	mov	x1, x0
    4800200c:	b9402fe0 	ldr	w0, [sp, #44]
    48002010:	b9000020 	str	w0, [x1]
    }
    else
    {
        GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
    }
}
    48002014:	14000012 	b	4800205c <arm_gic_umask+0x13c>
        GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
    48002018:	900001a0 	adrp	x0, 48036000 <__page_off>
    4800201c:	91002001 	add	x1, x0, #0x8
    48002020:	b9401fe2 	ldr	w2, [sp, #28]
    48002024:	d2800300 	mov	x0, #0x18                  	// #24
    48002028:	9b007c40 	mul	x0, x2, x0
    4800202c:	8b000020 	add	x0, x1, x0
    48002030:	b9400c00 	ldr	w0, [x0, #12]
    48002034:	2a0003e1 	mov	w1, w0
    48002038:	b9401be0 	ldr	w0, [sp, #24]
    4800203c:	53057c00 	lsr	w0, w0, #5
    48002040:	531e7400 	lsl	w0, w0, #2
    48002044:	2a0003e0 	mov	w0, w0
    48002048:	8b000020 	add	x0, x1, x0
    4800204c:	91040000 	add	x0, x0, #0x100
    48002050:	aa0003e1 	mov	x1, x0
    48002054:	b9402fe0 	ldr	w0, [sp, #44]
    48002058:	b9000020 	str	w0, [x1]
}
    4800205c:	d503201f 	nop
    48002060:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002064:	d65f03c0 	ret

0000000048002068 <arm_gic_get_pending_irq>:

rt_uint32_t arm_gic_get_pending_irq(rt_uint32_t index, int irq)
{
    48002068:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800206c:	910003fd 	mov	x29, sp
    48002070:	b9001fe0 	str	w0, [sp, #28]
    48002074:	b9001be1 	str	w1, [sp, #24]
    rt_uint32_t pend;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002078:	b9401fe0 	ldr	w0, [sp, #28]
    4800207c:	7100001f 	cmp	w0, #0x0
    48002080:	540000e0 	b.eq	4800209c <arm_gic_get_pending_irq+0x34>  // b.none
    48002084:	d2801542 	mov	x2, #0xaa                  	// #170
    48002088:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    4800208c:	913bc001 	add	x1, x0, #0xef0
    48002090:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002094:	91364000 	add	x0, x0, #0xd90
    48002098:	940037f4 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    4800209c:	b9401be1 	ldr	w1, [sp, #24]
    480020a0:	900001a0 	adrp	x0, 48036000 <__page_off>
    480020a4:	91002002 	add	x2, x0, #0x8
    480020a8:	b9401fe3 	ldr	w3, [sp, #28]
    480020ac:	d2800300 	mov	x0, #0x18                  	// #24
    480020b0:	9b007c60 	mul	x0, x3, x0
    480020b4:	8b000040 	add	x0, x2, x0
    480020b8:	b9400000 	ldr	w0, [x0]
    480020bc:	4b000020 	sub	w0, w1, w0
    480020c0:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    if (irq >= 16U)
    480020c4:	b9401be0 	ldr	w0, [sp, #24]
    480020c8:	71003c1f 	cmp	w0, #0xf
    480020cc:	540002c9 	b.ls	48002124 <arm_gic_get_pending_irq+0xbc>  // b.plast
    {
        pend = (GIC_DIST_PENDING_SET(_gic_table[index].dist_hw_base, irq) >> (irq % 32U)) & 0x1UL;
    480020d0:	900001a0 	adrp	x0, 48036000 <__page_off>
    480020d4:	91002001 	add	x1, x0, #0x8
    480020d8:	b9401fe2 	ldr	w2, [sp, #28]
    480020dc:	d2800300 	mov	x0, #0x18                  	// #24
    480020e0:	9b007c40 	mul	x0, x2, x0
    480020e4:	8b000020 	add	x0, x1, x0
    480020e8:	b9400c00 	ldr	w0, [x0, #12]
    480020ec:	2a0003e1 	mov	w1, w0
    480020f0:	b9401be0 	ldr	w0, [sp, #24]
    480020f4:	53057c00 	lsr	w0, w0, #5
    480020f8:	531e7400 	lsl	w0, w0, #2
    480020fc:	2a0003e0 	mov	w0, w0
    48002100:	8b000020 	add	x0, x1, x0
    48002104:	91080000 	add	x0, x0, #0x200
    48002108:	b9400001 	ldr	w1, [x0]
    4800210c:	b9401be0 	ldr	w0, [sp, #24]
    48002110:	12001000 	and	w0, w0, #0x1f
    48002114:	1ac02420 	lsr	w0, w1, w0
    48002118:	12000000 	and	w0, w0, #0x1
    4800211c:	b9002fe0 	str	w0, [sp, #44]
    48002120:	1400001c 	b	48002190 <arm_gic_get_pending_irq+0x128>
    }
    else
    {
        /* INTID 0-15 Software Generated Interrupt */
        pend = (GIC_DIST_SPENDSGI(_gic_table[index].dist_hw_base, irq) >> ((irq % 4U) * 8U)) & 0xFFUL;
    48002124:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002128:	91002001 	add	x1, x0, #0x8
    4800212c:	b9401fe2 	ldr	w2, [sp, #28]
    48002130:	d2800300 	mov	x0, #0x18                  	// #24
    48002134:	9b007c40 	mul	x0, x2, x0
    48002138:	8b000020 	add	x0, x1, x0
    4800213c:	b9400c00 	ldr	w0, [x0, #12]
    48002140:	2a0003e1 	mov	w1, w0
    48002144:	b9401be0 	ldr	w0, [sp, #24]
    48002148:	2a0003e0 	mov	w0, w0
    4800214c:	927e7400 	and	x0, x0, #0xfffffffc
    48002150:	8b000020 	add	x0, x1, x0
    48002154:	913c8000 	add	x0, x0, #0xf20
    48002158:	b9400001 	ldr	w1, [x0]
    4800215c:	b9401be0 	ldr	w0, [sp, #24]
    48002160:	12000400 	and	w0, w0, #0x3
    48002164:	531d7000 	lsl	w0, w0, #3
    48002168:	1ac02420 	lsr	w0, w1, w0
    4800216c:	12001c00 	and	w0, w0, #0xff
    48002170:	b9002fe0 	str	w0, [sp, #44]
        /* No CPU identification offered */
        if (pend != 0U)
    48002174:	b9402fe0 	ldr	w0, [sp, #44]
    48002178:	7100001f 	cmp	w0, #0x0
    4800217c:	54000080 	b.eq	4800218c <arm_gic_get_pending_irq+0x124>  // b.none
        {
            pend = 1U;
    48002180:	52800020 	mov	w0, #0x1                   	// #1
    48002184:	b9002fe0 	str	w0, [sp, #44]
    48002188:	14000002 	b	48002190 <arm_gic_get_pending_irq+0x128>
        }
        else
        {
            pend = 0U;
    4800218c:	b9002fff 	str	wzr, [sp, #44]
        }
    }

    return (pend);
    48002190:	b9402fe0 	ldr	w0, [sp, #44]
}
    48002194:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002198:	d65f03c0 	ret

000000004800219c <arm_gic_set_pending_irq>:

void arm_gic_set_pending_irq(rt_uint32_t index, int irq)
{
    4800219c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480021a0:	910003fd 	mov	x29, sp
    480021a4:	b9001fe0 	str	w0, [sp, #28]
    480021a8:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    480021ac:	b9401fe0 	ldr	w0, [sp, #28]
    480021b0:	7100001f 	cmp	w0, #0x0
    480021b4:	540000e0 	b.eq	480021d0 <arm_gic_set_pending_irq+0x34>  // b.none
    480021b8:	d28018e2 	mov	x2, #0xc7                  	// #199
    480021bc:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480021c0:	913c2001 	add	x1, x0, #0xf08
    480021c4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480021c8:	91364000 	add	x0, x0, #0xd90
    480021cc:	940037a7 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    480021d0:	b9401be1 	ldr	w1, [sp, #24]
    480021d4:	900001a0 	adrp	x0, 48036000 <__page_off>
    480021d8:	91002002 	add	x2, x0, #0x8
    480021dc:	b9401fe3 	ldr	w3, [sp, #28]
    480021e0:	d2800300 	mov	x0, #0x18                  	// #24
    480021e4:	9b007c60 	mul	x0, x3, x0
    480021e8:	8b000040 	add	x0, x2, x0
    480021ec:	b9400000 	ldr	w0, [x0]
    480021f0:	4b000020 	sub	w0, w1, w0
    480021f4:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    if (irq >= 16U)
    480021f8:	b9401be0 	ldr	w0, [sp, #24]
    480021fc:	71003c1f 	cmp	w0, #0xf
    48002200:	540002c9 	b.ls	48002258 <arm_gic_set_pending_irq+0xbc>  // b.plast
    {
        GIC_DIST_PENDING_SET(_gic_table[index].dist_hw_base, irq) = 1U << (irq % 32U);
    48002204:	b9401be0 	ldr	w0, [sp, #24]
    48002208:	12001000 	and	w0, w0, #0x1f
    4800220c:	900001a1 	adrp	x1, 48036000 <__page_off>
    48002210:	91002022 	add	x2, x1, #0x8
    48002214:	b9401fe3 	ldr	w3, [sp, #28]
    48002218:	d2800301 	mov	x1, #0x18                  	// #24
    4800221c:	9b017c61 	mul	x1, x3, x1
    48002220:	8b010041 	add	x1, x2, x1
    48002224:	b9400c21 	ldr	w1, [x1, #12]
    48002228:	2a0103e2 	mov	w2, w1
    4800222c:	b9401be1 	ldr	w1, [sp, #24]
    48002230:	53057c21 	lsr	w1, w1, #5
    48002234:	531e7421 	lsl	w1, w1, #2
    48002238:	2a0103e1 	mov	w1, w1
    4800223c:	8b010041 	add	x1, x2, x1
    48002240:	91080021 	add	x1, x1, #0x200
    48002244:	aa0103e2 	mov	x2, x1
    48002248:	52800021 	mov	w1, #0x1                   	// #1
    4800224c:	1ac02020 	lsl	w0, w1, w0
    48002250:	b9000040 	str	w0, [x2]
    {
        /* INTID 0-15 Software Generated Interrupt */
        /* Forward the interrupt to the CPU interface that requested it */
        GIC_DIST_SOFTINT(_gic_table[index].dist_hw_base) = (irq | 0x02000000U);
    }
}
    48002254:	1400000d 	b	48002288 <arm_gic_set_pending_irq+0xec>
        GIC_DIST_SOFTINT(_gic_table[index].dist_hw_base) = (irq | 0x02000000U);
    48002258:	b9401be0 	ldr	w0, [sp, #24]
    4800225c:	900001a1 	adrp	x1, 48036000 <__page_off>
    48002260:	91002022 	add	x2, x1, #0x8
    48002264:	b9401fe3 	ldr	w3, [sp, #28]
    48002268:	d2800301 	mov	x1, #0x18                  	// #24
    4800226c:	9b017c61 	mul	x1, x3, x1
    48002270:	8b010041 	add	x1, x2, x1
    48002274:	b9400c21 	ldr	w1, [x1, #12]
    48002278:	2a0103e1 	mov	w1, w1
    4800227c:	913c0021 	add	x1, x1, #0xf00
    48002280:	32070000 	orr	w0, w0, #0x2000000
    48002284:	b9000020 	str	w0, [x1]
}
    48002288:	d503201f 	nop
    4800228c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48002290:	d65f03c0 	ret

0000000048002294 <arm_gic_clear_pending_irq>:

void arm_gic_clear_pending_irq(rt_uint32_t index, int irq)
{
    48002294:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002298:	910003fd 	mov	x29, sp
    4800229c:	b9001fe0 	str	w0, [sp, #28]
    480022a0:	b9001be1 	str	w1, [sp, #24]
    rt_uint32_t mask;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    480022a4:	b9401fe0 	ldr	w0, [sp, #28]
    480022a8:	7100001f 	cmp	w0, #0x0
    480022ac:	540000e0 	b.eq	480022c8 <arm_gic_clear_pending_irq+0x34>  // b.none
    480022b0:	d2801b82 	mov	x2, #0xdc                  	// #220
    480022b4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480022b8:	913c8001 	add	x1, x0, #0xf20
    480022bc:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480022c0:	91364000 	add	x0, x0, #0xd90
    480022c4:	94003769 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    480022c8:	b9401be1 	ldr	w1, [sp, #24]
    480022cc:	900001a0 	adrp	x0, 48036000 <__page_off>
    480022d0:	91002002 	add	x2, x0, #0x8
    480022d4:	b9401fe3 	ldr	w3, [sp, #28]
    480022d8:	d2800300 	mov	x0, #0x18                  	// #24
    480022dc:	9b007c60 	mul	x0, x3, x0
    480022e0:	8b000040 	add	x0, x2, x0
    480022e4:	b9400000 	ldr	w0, [x0]
    480022e8:	4b000020 	sub	w0, w1, w0
    480022ec:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    if (irq >= 16U)
    480022f0:	b9401be0 	ldr	w0, [sp, #24]
    480022f4:	71003c1f 	cmp	w0, #0xf
    480022f8:	54000309 	b.ls	48002358 <arm_gic_clear_pending_irq+0xc4>  // b.plast
    {
        mask = 1U << (irq % 32U);
    480022fc:	b9401be0 	ldr	w0, [sp, #24]
    48002300:	12001000 	and	w0, w0, #0x1f
    48002304:	52800021 	mov	w1, #0x1                   	// #1
    48002308:	1ac02020 	lsl	w0, w1, w0
    4800230c:	b9002fe0 	str	w0, [sp, #44]
        GIC_DIST_PENDING_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
    48002310:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002314:	91002001 	add	x1, x0, #0x8
    48002318:	b9401fe2 	ldr	w2, [sp, #28]
    4800231c:	d2800300 	mov	x0, #0x18                  	// #24
    48002320:	9b007c40 	mul	x0, x2, x0
    48002324:	8b000020 	add	x0, x1, x0
    48002328:	b9400c00 	ldr	w0, [x0, #12]
    4800232c:	2a0003e1 	mov	w1, w0
    48002330:	b9401be0 	ldr	w0, [sp, #24]
    48002334:	53057c00 	lsr	w0, w0, #5
    48002338:	531e7400 	lsl	w0, w0, #2
    4800233c:	2a0003e0 	mov	w0, w0
    48002340:	8b000020 	add	x0, x1, x0
    48002344:	910a0000 	add	x0, x0, #0x280
    48002348:	aa0003e1 	mov	x1, x0
    4800234c:	b9402fe0 	ldr	w0, [sp, #44]
    48002350:	b9000020 	str	w0, [x1]
    else
    {
        mask = 1U << ((irq % 4U) * 8U);
        GIC_DIST_CPENDSGI(_gic_table[index].dist_hw_base, irq) = mask;
    }
}
    48002354:	14000017 	b	480023b0 <arm_gic_clear_pending_irq+0x11c>
        mask = 1U << ((irq % 4U) * 8U);
    48002358:	b9401be0 	ldr	w0, [sp, #24]
    4800235c:	12000400 	and	w0, w0, #0x3
    48002360:	531d7000 	lsl	w0, w0, #3
    48002364:	52800021 	mov	w1, #0x1                   	// #1
    48002368:	1ac02020 	lsl	w0, w1, w0
    4800236c:	b9002fe0 	str	w0, [sp, #44]
        GIC_DIST_CPENDSGI(_gic_table[index].dist_hw_base, irq) = mask;
    48002370:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002374:	91002001 	add	x1, x0, #0x8
    48002378:	b9401fe2 	ldr	w2, [sp, #28]
    4800237c:	d2800300 	mov	x0, #0x18                  	// #24
    48002380:	9b007c40 	mul	x0, x2, x0
    48002384:	8b000020 	add	x0, x1, x0
    48002388:	b9400c00 	ldr	w0, [x0, #12]
    4800238c:	2a0003e1 	mov	w1, w0
    48002390:	b9401be0 	ldr	w0, [sp, #24]
    48002394:	2a0003e0 	mov	w0, w0
    48002398:	927e7400 	and	x0, x0, #0xfffffffc
    4800239c:	8b000020 	add	x0, x1, x0
    480023a0:	913c4000 	add	x0, x0, #0xf10
    480023a4:	aa0003e1 	mov	x1, x0
    480023a8:	b9402fe0 	ldr	w0, [sp, #44]
    480023ac:	b9000020 	str	w0, [x1]
}
    480023b0:	d503201f 	nop
    480023b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480023b8:	d65f03c0 	ret

00000000480023bc <arm_gic_set_configuration>:

void arm_gic_set_configuration(rt_uint32_t index, int irq, rt_uint32_t config)
{
    480023bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480023c0:	910003fd 	mov	x29, sp
    480023c4:	b9001fe0 	str	w0, [sp, #28]
    480023c8:	b9001be1 	str	w1, [sp, #24]
    480023cc:	b90017e2 	str	w2, [sp, #20]
    rt_uint32_t icfgr;
    rt_uint32_t shift;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    480023d0:	b9401fe0 	ldr	w0, [sp, #28]
    480023d4:	7100001f 	cmp	w0, #0x0
    480023d8:	540000e0 	b.eq	480023f4 <arm_gic_set_configuration+0x38>  // b.none
    480023dc:	d2801e42 	mov	x2, #0xf2                  	// #242
    480023e0:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480023e4:	913d0001 	add	x1, x0, #0xf40
    480023e8:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480023ec:	91364000 	add	x0, x0, #0xd90
    480023f0:	9400371e 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    480023f4:	b9401be1 	ldr	w1, [sp, #24]
    480023f8:	900001a0 	adrp	x0, 48036000 <__page_off>
    480023fc:	91002002 	add	x2, x0, #0x8
    48002400:	b9401fe3 	ldr	w3, [sp, #28]
    48002404:	d2800300 	mov	x0, #0x18                  	// #24
    48002408:	9b007c60 	mul	x0, x3, x0
    4800240c:	8b000040 	add	x0, x2, x0
    48002410:	b9400000 	ldr	w0, [x0]
    48002414:	4b000020 	sub	w0, w1, w0
    48002418:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    icfgr = GIC_DIST_CONFIG(_gic_table[index].dist_hw_base, irq);
    4800241c:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002420:	91002001 	add	x1, x0, #0x8
    48002424:	b9401fe2 	ldr	w2, [sp, #28]
    48002428:	d2800300 	mov	x0, #0x18                  	// #24
    4800242c:	9b007c40 	mul	x0, x2, x0
    48002430:	8b000020 	add	x0, x1, x0
    48002434:	b9400c00 	ldr	w0, [x0, #12]
    48002438:	2a0003e1 	mov	w1, w0
    4800243c:	b9401be0 	ldr	w0, [sp, #24]
    48002440:	53047c00 	lsr	w0, w0, #4
    48002444:	531e7400 	lsl	w0, w0, #2
    48002448:	2a0003e0 	mov	w0, w0
    4800244c:	8b000020 	add	x0, x1, x0
    48002450:	91300000 	add	x0, x0, #0xc00
    48002454:	b9400000 	ldr	w0, [x0]
    48002458:	b9002fe0 	str	w0, [sp, #44]
    shift = (irq % 16U) << 1U;
    4800245c:	b9401be0 	ldr	w0, [sp, #24]
    48002460:	0b000000 	add	w0, w0, w0
    48002464:	121f0c00 	and	w0, w0, #0x1e
    48002468:	b9002be0 	str	w0, [sp, #40]

    icfgr &= (~(3U << shift));
    4800246c:	b9402be0 	ldr	w0, [sp, #40]
    48002470:	52800061 	mov	w1, #0x3                   	// #3
    48002474:	1ac02020 	lsl	w0, w1, w0
    48002478:	2a2003e0 	mvn	w0, w0
    4800247c:	b9402fe1 	ldr	w1, [sp, #44]
    48002480:	0a000020 	and	w0, w1, w0
    48002484:	b9002fe0 	str	w0, [sp, #44]
    icfgr |= (config << shift);
    48002488:	b9402be0 	ldr	w0, [sp, #40]
    4800248c:	b94017e1 	ldr	w1, [sp, #20]
    48002490:	1ac02020 	lsl	w0, w1, w0
    48002494:	b9402fe1 	ldr	w1, [sp, #44]
    48002498:	2a000020 	orr	w0, w1, w0
    4800249c:	b9002fe0 	str	w0, [sp, #44]

    GIC_DIST_CONFIG(_gic_table[index].dist_hw_base, irq) = icfgr;
    480024a0:	900001a0 	adrp	x0, 48036000 <__page_off>
    480024a4:	91002001 	add	x1, x0, #0x8
    480024a8:	b9401fe2 	ldr	w2, [sp, #28]
    480024ac:	d2800300 	mov	x0, #0x18                  	// #24
    480024b0:	9b007c40 	mul	x0, x2, x0
    480024b4:	8b000020 	add	x0, x1, x0
    480024b8:	b9400c00 	ldr	w0, [x0, #12]
    480024bc:	2a0003e1 	mov	w1, w0
    480024c0:	b9401be0 	ldr	w0, [sp, #24]
    480024c4:	53047c00 	lsr	w0, w0, #4
    480024c8:	531e7400 	lsl	w0, w0, #2
    480024cc:	2a0003e0 	mov	w0, w0
    480024d0:	8b000020 	add	x0, x1, x0
    480024d4:	91300000 	add	x0, x0, #0xc00
    480024d8:	aa0003e1 	mov	x1, x0
    480024dc:	b9402fe0 	ldr	w0, [sp, #44]
    480024e0:	b9000020 	str	w0, [x1]
}
    480024e4:	d503201f 	nop
    480024e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480024ec:	d65f03c0 	ret

00000000480024f0 <arm_gic_get_configuration>:

rt_uint32_t arm_gic_get_configuration(rt_uint32_t index, int irq)
{
    480024f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480024f4:	910003fd 	mov	x29, sp
    480024f8:	b9001fe0 	str	w0, [sp, #28]
    480024fc:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002500:	b9401fe0 	ldr	w0, [sp, #28]
    48002504:	7100001f 	cmp	w0, #0x0
    48002508:	540000e0 	b.eq	48002524 <arm_gic_get_configuration+0x34>  // b.none
    4800250c:	d2802042 	mov	x2, #0x102                 	// #258
    48002510:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002514:	913d8001 	add	x1, x0, #0xf60
    48002518:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    4800251c:	91364000 	add	x0, x0, #0xd90
    48002520:	940036d2 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    48002524:	b9401be1 	ldr	w1, [sp, #24]
    48002528:	900001a0 	adrp	x0, 48036000 <__page_off>
    4800252c:	91002002 	add	x2, x0, #0x8
    48002530:	b9401fe3 	ldr	w3, [sp, #28]
    48002534:	d2800300 	mov	x0, #0x18                  	// #24
    48002538:	9b007c60 	mul	x0, x3, x0
    4800253c:	8b000040 	add	x0, x2, x0
    48002540:	b9400000 	ldr	w0, [x0]
    48002544:	4b000020 	sub	w0, w1, w0
    48002548:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    return (GIC_DIST_CONFIG(_gic_table[index].dist_hw_base, irq) >> ((irq % 16U) >> 1U));
    4800254c:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002550:	91002001 	add	x1, x0, #0x8
    48002554:	b9401fe2 	ldr	w2, [sp, #28]
    48002558:	d2800300 	mov	x0, #0x18                  	// #24
    4800255c:	9b007c40 	mul	x0, x2, x0
    48002560:	8b000020 	add	x0, x1, x0
    48002564:	b9400c00 	ldr	w0, [x0, #12]
    48002568:	2a0003e1 	mov	w1, w0
    4800256c:	b9401be0 	ldr	w0, [sp, #24]
    48002570:	53047c00 	lsr	w0, w0, #4
    48002574:	531e7400 	lsl	w0, w0, #2
    48002578:	2a0003e0 	mov	w0, w0
    4800257c:	8b000020 	add	x0, x1, x0
    48002580:	91300000 	add	x0, x0, #0xc00
    48002584:	b9400001 	ldr	w1, [x0]
    48002588:	b9401be0 	ldr	w0, [sp, #24]
    4800258c:	53017c00 	lsr	w0, w0, #1
    48002590:	12000800 	and	w0, w0, #0x7
    48002594:	1ac02420 	lsr	w0, w1, w0
}
    48002598:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800259c:	d65f03c0 	ret

00000000480025a0 <arm_gic_clear_active>:

void arm_gic_clear_active(rt_uint32_t index, int irq)
{
    480025a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480025a4:	910003fd 	mov	x29, sp
    480025a8:	b9001fe0 	str	w0, [sp, #28]
    480025ac:	b9001be1 	str	w1, [sp, #24]
    rt_uint32_t mask = 1U << (irq % 32U);
    480025b0:	b9401be0 	ldr	w0, [sp, #24]
    480025b4:	12001000 	and	w0, w0, #0x1f
    480025b8:	52800021 	mov	w1, #0x1                   	// #1
    480025bc:	1ac02020 	lsl	w0, w1, w0
    480025c0:	b9002fe0 	str	w0, [sp, #44]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    480025c4:	b9401fe0 	ldr	w0, [sp, #28]
    480025c8:	7100001f 	cmp	w0, #0x0
    480025cc:	540000e0 	b.eq	480025e8 <arm_gic_clear_active+0x48>  // b.none
    480025d0:	d28021c2 	mov	x2, #0x10e                 	// #270
    480025d4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480025d8:	913e0001 	add	x1, x0, #0xf80
    480025dc:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480025e0:	91364000 	add	x0, x0, #0xd90
    480025e4:	940036a1 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    480025e8:	b9401be1 	ldr	w1, [sp, #24]
    480025ec:	900001a0 	adrp	x0, 48036000 <__page_off>
    480025f0:	91002002 	add	x2, x0, #0x8
    480025f4:	b9401fe3 	ldr	w3, [sp, #28]
    480025f8:	d2800300 	mov	x0, #0x18                  	// #24
    480025fc:	9b007c60 	mul	x0, x3, x0
    48002600:	8b000040 	add	x0, x2, x0
    48002604:	b9400000 	ldr	w0, [x0]
    48002608:	4b000020 	sub	w0, w1, w0
    4800260c:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    GIC_DIST_ACTIVE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
    48002610:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002614:	91002001 	add	x1, x0, #0x8
    48002618:	b9401fe2 	ldr	w2, [sp, #28]
    4800261c:	d2800300 	mov	x0, #0x18                  	// #24
    48002620:	9b007c40 	mul	x0, x2, x0
    48002624:	8b000020 	add	x0, x1, x0
    48002628:	b9400c00 	ldr	w0, [x0, #12]
    4800262c:	2a0003e1 	mov	w1, w0
    48002630:	b9401be0 	ldr	w0, [sp, #24]
    48002634:	53057c00 	lsr	w0, w0, #5
    48002638:	531e7400 	lsl	w0, w0, #2
    4800263c:	2a0003e0 	mov	w0, w0
    48002640:	8b000020 	add	x0, x1, x0
    48002644:	910e0000 	add	x0, x0, #0x380
    48002648:	aa0003e1 	mov	x1, x0
    4800264c:	b9402fe0 	ldr	w0, [sp, #44]
    48002650:	b9000020 	str	w0, [x1]
}
    48002654:	d503201f 	nop
    48002658:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800265c:	d65f03c0 	ret

0000000048002660 <arm_gic_set_cpu>:

/* Set up the cpu mask for the specific interrupt */
void arm_gic_set_cpu(rt_uint32_t index, int irq, unsigned int cpumask)
{
    48002660:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002664:	910003fd 	mov	x29, sp
    48002668:	b9001fe0 	str	w0, [sp, #28]
    4800266c:	b9001be1 	str	w1, [sp, #24]
    48002670:	b90017e2 	str	w2, [sp, #20]
    rt_uint32_t old_tgt;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002674:	b9401fe0 	ldr	w0, [sp, #28]
    48002678:	7100001f 	cmp	w0, #0x0
    4800267c:	540000e0 	b.eq	48002698 <arm_gic_set_cpu+0x38>  // b.none
    48002680:	d2802362 	mov	x2, #0x11b                 	// #283
    48002684:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002688:	913e6001 	add	x1, x0, #0xf98
    4800268c:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002690:	91364000 	add	x0, x0, #0xd90
    48002694:	94003675 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    48002698:	b9401be1 	ldr	w1, [sp, #24]
    4800269c:	900001a0 	adrp	x0, 48036000 <__page_off>
    480026a0:	91002002 	add	x2, x0, #0x8
    480026a4:	b9401fe3 	ldr	w3, [sp, #28]
    480026a8:	d2800300 	mov	x0, #0x18                  	// #24
    480026ac:	9b007c60 	mul	x0, x3, x0
    480026b0:	8b000040 	add	x0, x2, x0
    480026b4:	b9400000 	ldr	w0, [x0]
    480026b8:	4b000020 	sub	w0, w1, w0
    480026bc:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    old_tgt = GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq);
    480026c0:	900001a0 	adrp	x0, 48036000 <__page_off>
    480026c4:	91002001 	add	x1, x0, #0x8
    480026c8:	b9401fe2 	ldr	w2, [sp, #28]
    480026cc:	d2800300 	mov	x0, #0x18                  	// #24
    480026d0:	9b007c40 	mul	x0, x2, x0
    480026d4:	8b000020 	add	x0, x1, x0
    480026d8:	b9400c00 	ldr	w0, [x0, #12]
    480026dc:	2a0003e1 	mov	w1, w0
    480026e0:	b9401be0 	ldr	w0, [sp, #24]
    480026e4:	2a0003e0 	mov	w0, w0
    480026e8:	927e7400 	and	x0, x0, #0xfffffffc
    480026ec:	8b000020 	add	x0, x1, x0
    480026f0:	91200000 	add	x0, x0, #0x800
    480026f4:	b9400000 	ldr	w0, [x0]
    480026f8:	b9002fe0 	str	w0, [sp, #44]

    old_tgt &= ~(0x0FFUL << ((irq % 4U) * 8U));
    480026fc:	b9401be0 	ldr	w0, [sp, #24]
    48002700:	12000400 	and	w0, w0, #0x3
    48002704:	531d7000 	lsl	w0, w0, #3
    48002708:	d2801fe1 	mov	x1, #0xff                  	// #255
    4800270c:	9ac02020 	lsl	x0, x1, x0
    48002710:	2a2003e0 	mvn	w0, w0
    48002714:	b9402fe1 	ldr	w1, [sp, #44]
    48002718:	0a000020 	and	w0, w1, w0
    4800271c:	b9002fe0 	str	w0, [sp, #44]
    old_tgt |= cpumask << ((irq % 4U) * 8U);
    48002720:	b9401be0 	ldr	w0, [sp, #24]
    48002724:	12000400 	and	w0, w0, #0x3
    48002728:	531d7000 	lsl	w0, w0, #3
    4800272c:	b94017e1 	ldr	w1, [sp, #20]
    48002730:	1ac02020 	lsl	w0, w1, w0
    48002734:	b9402fe1 	ldr	w1, [sp, #44]
    48002738:	2a000020 	orr	w0, w1, w0
    4800273c:	b9002fe0 	str	w0, [sp, #44]

    GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq) = old_tgt;
    48002740:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002744:	91002001 	add	x1, x0, #0x8
    48002748:	b9401fe2 	ldr	w2, [sp, #28]
    4800274c:	d2800300 	mov	x0, #0x18                  	// #24
    48002750:	9b007c40 	mul	x0, x2, x0
    48002754:	8b000020 	add	x0, x1, x0
    48002758:	b9400c00 	ldr	w0, [x0, #12]
    4800275c:	2a0003e1 	mov	w1, w0
    48002760:	b9401be0 	ldr	w0, [sp, #24]
    48002764:	2a0003e0 	mov	w0, w0
    48002768:	927e7400 	and	x0, x0, #0xfffffffc
    4800276c:	8b000020 	add	x0, x1, x0
    48002770:	91200000 	add	x0, x0, #0x800
    48002774:	aa0003e1 	mov	x1, x0
    48002778:	b9402fe0 	ldr	w0, [sp, #44]
    4800277c:	b9000020 	str	w0, [x1]
}
    48002780:	d503201f 	nop
    48002784:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002788:	d65f03c0 	ret

000000004800278c <arm_gic_get_target_cpu>:

rt_uint32_t arm_gic_get_target_cpu(rt_uint32_t index, int irq)
{
    4800278c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48002790:	910003fd 	mov	x29, sp
    48002794:	b9001fe0 	str	w0, [sp, #28]
    48002798:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    4800279c:	b9401fe0 	ldr	w0, [sp, #28]
    480027a0:	7100001f 	cmp	w0, #0x0
    480027a4:	540000e0 	b.eq	480027c0 <arm_gic_get_target_cpu+0x34>  // b.none
    480027a8:	d2802542 	mov	x2, #0x12a                 	// #298
    480027ac:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480027b0:	913ea001 	add	x1, x0, #0xfa8
    480027b4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480027b8:	91364000 	add	x0, x0, #0xd90
    480027bc:	9400362b 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    480027c0:	b9401be1 	ldr	w1, [sp, #24]
    480027c4:	900001a0 	adrp	x0, 48036000 <__page_off>
    480027c8:	91002002 	add	x2, x0, #0x8
    480027cc:	b9401fe3 	ldr	w3, [sp, #28]
    480027d0:	d2800300 	mov	x0, #0x18                  	// #24
    480027d4:	9b007c60 	mul	x0, x3, x0
    480027d8:	8b000040 	add	x0, x2, x0
    480027dc:	b9400000 	ldr	w0, [x0]
    480027e0:	4b000020 	sub	w0, w1, w0
    480027e4:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    return (GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq) >> ((irq % 4U) * 8U)) & 0xFFUL;
    480027e8:	900001a0 	adrp	x0, 48036000 <__page_off>
    480027ec:	91002001 	add	x1, x0, #0x8
    480027f0:	b9401fe2 	ldr	w2, [sp, #28]
    480027f4:	d2800300 	mov	x0, #0x18                  	// #24
    480027f8:	9b007c40 	mul	x0, x2, x0
    480027fc:	8b000020 	add	x0, x1, x0
    48002800:	b9400c00 	ldr	w0, [x0, #12]
    48002804:	2a0003e1 	mov	w1, w0
    48002808:	b9401be0 	ldr	w0, [sp, #24]
    4800280c:	2a0003e0 	mov	w0, w0
    48002810:	927e7400 	and	x0, x0, #0xfffffffc
    48002814:	8b000020 	add	x0, x1, x0
    48002818:	91200000 	add	x0, x0, #0x800
    4800281c:	b9400001 	ldr	w1, [x0]
    48002820:	b9401be0 	ldr	w0, [sp, #24]
    48002824:	12000400 	and	w0, w0, #0x3
    48002828:	531d7000 	lsl	w0, w0, #3
    4800282c:	1ac02420 	lsr	w0, w1, w0
    48002830:	12001c00 	and	w0, w0, #0xff
}
    48002834:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48002838:	d65f03c0 	ret

000000004800283c <arm_gic_set_priority>:

void arm_gic_set_priority(rt_uint32_t index, int irq, rt_uint32_t priority)
{
    4800283c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002840:	910003fd 	mov	x29, sp
    48002844:	b9001fe0 	str	w0, [sp, #28]
    48002848:	b9001be1 	str	w1, [sp, #24]
    4800284c:	b90017e2 	str	w2, [sp, #20]
    rt_uint32_t mask;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002850:	b9401fe0 	ldr	w0, [sp, #28]
    48002854:	7100001f 	cmp	w0, #0x0
    48002858:	540000e0 	b.eq	48002874 <arm_gic_set_priority+0x38>  // b.none
    4800285c:	d28026c2 	mov	x2, #0x136                 	// #310
    48002860:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002864:	913f0001 	add	x1, x0, #0xfc0
    48002868:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    4800286c:	91364000 	add	x0, x0, #0xd90
    48002870:	940035fe 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    48002874:	b9401be1 	ldr	w1, [sp, #24]
    48002878:	900001a0 	adrp	x0, 48036000 <__page_off>
    4800287c:	91002002 	add	x2, x0, #0x8
    48002880:	b9401fe3 	ldr	w3, [sp, #28]
    48002884:	d2800300 	mov	x0, #0x18                  	// #24
    48002888:	9b007c60 	mul	x0, x3, x0
    4800288c:	8b000040 	add	x0, x2, x0
    48002890:	b9400000 	ldr	w0, [x0]
    48002894:	4b000020 	sub	w0, w1, w0
    48002898:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    if (irq < 32U)
    4800289c:	b9401be0 	ldr	w0, [sp, #24]
    480028a0:	71007c1f 	cmp	w0, #0x1f
    480028a4:	540009a8 	b.hi	480029d8 <arm_gic_set_priority+0x19c>  // b.pmore
    {
        rt_int32_t cpu_id = rt_hw_cpu_id();
    480028a8:	940008bd 	bl	48004b9c <rt_hw_cpu_id>
    480028ac:	b9002be0 	str	w0, [sp, #40]
        RT_ASSERT((cpu_id) < RT_CPUS_NR);
    480028b0:	b9402be0 	ldr	w0, [sp, #40]
    480028b4:	7100041f 	cmp	w0, #0x1
    480028b8:	540000ed 	b.le	480028d4 <arm_gic_set_priority+0x98>
    480028bc:	d28027c2 	mov	x2, #0x13e                 	// #318
    480028c0:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480028c4:	913f0001 	add	x1, x0, #0xfc0
    480028c8:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480028cc:	9136a000 	add	x0, x0, #0xda8
    480028d0:	940035e6 	bl	48010068 <rt_assert_handler>

        mask = GIC_RDISTSGI_IPRIORITYR(_gic_table[index].redist_hw_base[cpu_id], irq);
    480028d4:	900001a0 	adrp	x0, 48036000 <__page_off>
    480028d8:	91002002 	add	x2, x0, #0x8
    480028dc:	b9802be3 	ldrsw	x3, [sp, #40]
    480028e0:	b9401fe1 	ldr	w1, [sp, #28]
    480028e4:	aa0103e0 	mov	x0, x1
    480028e8:	8b000000 	add	x0, x0, x0
    480028ec:	8b010000 	add	x0, x0, x1
    480028f0:	8b000000 	add	x0, x0, x0
    480028f4:	8b030000 	add	x0, x0, x3
    480028f8:	d37ef400 	lsl	x0, x0, #2
    480028fc:	8b000040 	add	x0, x2, x0
    48002900:	b9400400 	ldr	w0, [x0, #4]
    48002904:	2a0003e1 	mov	w1, w0
    48002908:	b9401be0 	ldr	w0, [sp, #24]
    4800290c:	2a0003e0 	mov	w0, w0
    48002910:	927e7400 	and	x0, x0, #0xfffffffc
    48002914:	8b000021 	add	x1, x1, x0
    48002918:	d2808000 	mov	x0, #0x400                 	// #1024
    4800291c:	f2a00020 	movk	x0, #0x1, lsl #16
    48002920:	8b000020 	add	x0, x1, x0
    48002924:	b9400000 	ldr	w0, [x0]
    48002928:	b9002fe0 	str	w0, [sp, #44]
        mask &= ~(0xFFUL << ((irq % 4U) * 8U));
    4800292c:	b9401be0 	ldr	w0, [sp, #24]
    48002930:	12000400 	and	w0, w0, #0x3
    48002934:	531d7000 	lsl	w0, w0, #3
    48002938:	d2801fe1 	mov	x1, #0xff                  	// #255
    4800293c:	9ac02020 	lsl	x0, x1, x0
    48002940:	2a2003e0 	mvn	w0, w0
    48002944:	b9402fe1 	ldr	w1, [sp, #44]
    48002948:	0a000020 	and	w0, w1, w0
    4800294c:	b9002fe0 	str	w0, [sp, #44]
        mask |= ((priority & 0xFFUL) << ((irq % 4U) * 8U));
    48002950:	b94017e0 	ldr	w0, [sp, #20]
    48002954:	92401c01 	and	x1, x0, #0xff
    48002958:	b9401be0 	ldr	w0, [sp, #24]
    4800295c:	12000400 	and	w0, w0, #0x3
    48002960:	531d7000 	lsl	w0, w0, #3
    48002964:	9ac02020 	lsl	x0, x1, x0
    48002968:	2a0003e1 	mov	w1, w0
    4800296c:	b9402fe0 	ldr	w0, [sp, #44]
    48002970:	2a010000 	orr	w0, w0, w1
    48002974:	b9002fe0 	str	w0, [sp, #44]
        GIC_RDISTSGI_IPRIORITYR(_gic_table[index].redist_hw_base[cpu_id], irq) = mask;
    48002978:	900001a0 	adrp	x0, 48036000 <__page_off>
    4800297c:	91002002 	add	x2, x0, #0x8
    48002980:	b9802be3 	ldrsw	x3, [sp, #40]
    48002984:	b9401fe1 	ldr	w1, [sp, #28]
    48002988:	aa0103e0 	mov	x0, x1
    4800298c:	8b000000 	add	x0, x0, x0
    48002990:	8b010000 	add	x0, x0, x1
    48002994:	8b000000 	add	x0, x0, x0
    48002998:	8b030000 	add	x0, x0, x3
    4800299c:	d37ef400 	lsl	x0, x0, #2
    480029a0:	8b000040 	add	x0, x2, x0
    480029a4:	b9400400 	ldr	w0, [x0, #4]
    480029a8:	2a0003e1 	mov	w1, w0
    480029ac:	b9401be0 	ldr	w0, [sp, #24]
    480029b0:	2a0003e0 	mov	w0, w0
    480029b4:	927e7400 	and	x0, x0, #0xfffffffc
    480029b8:	8b000021 	add	x1, x1, x0
    480029bc:	d2808000 	mov	x0, #0x400                 	// #1024
    480029c0:	f2a00020 	movk	x0, #0x1, lsl #16
    480029c4:	8b000020 	add	x0, x1, x0
    480029c8:	aa0003e1 	mov	x1, x0
    480029cc:	b9402fe0 	ldr	w0, [sp, #44]
    480029d0:	b9000020 	str	w0, [x1]
        mask = GIC_DIST_PRI(_gic_table[index].dist_hw_base, irq);
        mask &= ~(0xFFUL << ((irq % 4U) * 8U));
        mask |= ((priority & 0xFFUL) << ((irq % 4U) * 8U));
        GIC_DIST_PRI(_gic_table[index].dist_hw_base, irq) = mask;
    }
}
    480029d4:	14000033 	b	48002aa0 <arm_gic_set_priority+0x264>
        mask = GIC_DIST_PRI(_gic_table[index].dist_hw_base, irq);
    480029d8:	900001a0 	adrp	x0, 48036000 <__page_off>
    480029dc:	91002001 	add	x1, x0, #0x8
    480029e0:	b9401fe2 	ldr	w2, [sp, #28]
    480029e4:	d2800300 	mov	x0, #0x18                  	// #24
    480029e8:	9b007c40 	mul	x0, x2, x0
    480029ec:	8b000020 	add	x0, x1, x0
    480029f0:	b9400c00 	ldr	w0, [x0, #12]
    480029f4:	2a0003e1 	mov	w1, w0
    480029f8:	b9401be0 	ldr	w0, [sp, #24]
    480029fc:	2a0003e0 	mov	w0, w0
    48002a00:	927e7400 	and	x0, x0, #0xfffffffc
    48002a04:	8b000020 	add	x0, x1, x0
    48002a08:	91100000 	add	x0, x0, #0x400
    48002a0c:	b9400000 	ldr	w0, [x0]
    48002a10:	b9002fe0 	str	w0, [sp, #44]
        mask &= ~(0xFFUL << ((irq % 4U) * 8U));
    48002a14:	b9401be0 	ldr	w0, [sp, #24]
    48002a18:	12000400 	and	w0, w0, #0x3
    48002a1c:	531d7000 	lsl	w0, w0, #3
    48002a20:	d2801fe1 	mov	x1, #0xff                  	// #255
    48002a24:	9ac02020 	lsl	x0, x1, x0
    48002a28:	2a2003e0 	mvn	w0, w0
    48002a2c:	b9402fe1 	ldr	w1, [sp, #44]
    48002a30:	0a000020 	and	w0, w1, w0
    48002a34:	b9002fe0 	str	w0, [sp, #44]
        mask |= ((priority & 0xFFUL) << ((irq % 4U) * 8U));
    48002a38:	b94017e0 	ldr	w0, [sp, #20]
    48002a3c:	92401c01 	and	x1, x0, #0xff
    48002a40:	b9401be0 	ldr	w0, [sp, #24]
    48002a44:	12000400 	and	w0, w0, #0x3
    48002a48:	531d7000 	lsl	w0, w0, #3
    48002a4c:	9ac02020 	lsl	x0, x1, x0
    48002a50:	2a0003e1 	mov	w1, w0
    48002a54:	b9402fe0 	ldr	w0, [sp, #44]
    48002a58:	2a010000 	orr	w0, w0, w1
    48002a5c:	b9002fe0 	str	w0, [sp, #44]
        GIC_DIST_PRI(_gic_table[index].dist_hw_base, irq) = mask;
    48002a60:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002a64:	91002001 	add	x1, x0, #0x8
    48002a68:	b9401fe2 	ldr	w2, [sp, #28]
    48002a6c:	d2800300 	mov	x0, #0x18                  	// #24
    48002a70:	9b007c40 	mul	x0, x2, x0
    48002a74:	8b000020 	add	x0, x1, x0
    48002a78:	b9400c00 	ldr	w0, [x0, #12]
    48002a7c:	2a0003e1 	mov	w1, w0
    48002a80:	b9401be0 	ldr	w0, [sp, #24]
    48002a84:	2a0003e0 	mov	w0, w0
    48002a88:	927e7400 	and	x0, x0, #0xfffffffc
    48002a8c:	8b000020 	add	x0, x1, x0
    48002a90:	91100000 	add	x0, x0, #0x400
    48002a94:	aa0003e1 	mov	x1, x0
    48002a98:	b9402fe0 	ldr	w0, [sp, #44]
    48002a9c:	b9000020 	str	w0, [x1]
}
    48002aa0:	d503201f 	nop
    48002aa4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002aa8:	d65f03c0 	ret

0000000048002aac <arm_gic_get_priority>:

rt_uint32_t arm_gic_get_priority(rt_uint32_t index, int irq)
{
    48002aac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002ab0:	910003fd 	mov	x29, sp
    48002ab4:	b9001fe0 	str	w0, [sp, #28]
    48002ab8:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002abc:	b9401fe0 	ldr	w0, [sp, #28]
    48002ac0:	7100001f 	cmp	w0, #0x0
    48002ac4:	540000e0 	b.eq	48002ae0 <arm_gic_get_priority+0x34>  // b.none
    48002ac8:	d2802a02 	mov	x2, #0x150                 	// #336
    48002acc:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002ad0:	913f6001 	add	x1, x0, #0xfd8
    48002ad4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002ad8:	91364000 	add	x0, x0, #0xd90
    48002adc:	94003563 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    48002ae0:	b9401be1 	ldr	w1, [sp, #24]
    48002ae4:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002ae8:	91002002 	add	x2, x0, #0x8
    48002aec:	b9401fe3 	ldr	w3, [sp, #28]
    48002af0:	d2800300 	mov	x0, #0x18                  	// #24
    48002af4:	9b007c60 	mul	x0, x3, x0
    48002af8:	8b000040 	add	x0, x2, x0
    48002afc:	b9400000 	ldr	w0, [x0]
    48002b00:	4b000020 	sub	w0, w1, w0
    48002b04:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    if (irq < 32U)
    48002b08:	b9401be0 	ldr	w0, [sp, #24]
    48002b0c:	71007c1f 	cmp	w0, #0x1f
    48002b10:	540004e8 	b.hi	48002bac <arm_gic_get_priority+0x100>  // b.pmore
    {
        rt_int32_t cpu_id = rt_hw_cpu_id();
    48002b14:	94000822 	bl	48004b9c <rt_hw_cpu_id>
    48002b18:	b9002fe0 	str	w0, [sp, #44]

        RT_ASSERT((cpu_id) < RT_CPUS_NR);
    48002b1c:	b9402fe0 	ldr	w0, [sp, #44]
    48002b20:	7100041f 	cmp	w0, #0x1
    48002b24:	540000ed 	b.le	48002b40 <arm_gic_get_priority+0x94>
    48002b28:	d2802b22 	mov	x2, #0x159                 	// #345
    48002b2c:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002b30:	913f6001 	add	x1, x0, #0xfd8
    48002b34:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002b38:	9136a000 	add	x0, x0, #0xda8
    48002b3c:	9400354b 	bl	48010068 <rt_assert_handler>
        return (GIC_RDISTSGI_IPRIORITYR(_gic_table[index].redist_hw_base[cpu_id], irq) >> ((irq % 4U) * 8U)) & 0xFFUL;
    48002b40:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002b44:	91002002 	add	x2, x0, #0x8
    48002b48:	b9802fe3 	ldrsw	x3, [sp, #44]
    48002b4c:	b9401fe1 	ldr	w1, [sp, #28]
    48002b50:	aa0103e0 	mov	x0, x1
    48002b54:	8b000000 	add	x0, x0, x0
    48002b58:	8b010000 	add	x0, x0, x1
    48002b5c:	8b000000 	add	x0, x0, x0
    48002b60:	8b030000 	add	x0, x0, x3
    48002b64:	d37ef400 	lsl	x0, x0, #2
    48002b68:	8b000040 	add	x0, x2, x0
    48002b6c:	b9400400 	ldr	w0, [x0, #4]
    48002b70:	2a0003e1 	mov	w1, w0
    48002b74:	b9401be0 	ldr	w0, [sp, #24]
    48002b78:	2a0003e0 	mov	w0, w0
    48002b7c:	927e7400 	and	x0, x0, #0xfffffffc
    48002b80:	8b000021 	add	x1, x1, x0
    48002b84:	d2808000 	mov	x0, #0x400                 	// #1024
    48002b88:	f2a00020 	movk	x0, #0x1, lsl #16
    48002b8c:	8b000020 	add	x0, x1, x0
    48002b90:	b9400001 	ldr	w1, [x0]
    48002b94:	b9401be0 	ldr	w0, [sp, #24]
    48002b98:	12000400 	and	w0, w0, #0x3
    48002b9c:	531d7000 	lsl	w0, w0, #3
    48002ba0:	1ac02420 	lsr	w0, w1, w0
    48002ba4:	12001c00 	and	w0, w0, #0xff
    48002ba8:	14000014 	b	48002bf8 <arm_gic_get_priority+0x14c>
    }
    else
    {
        return (GIC_DIST_PRI(_gic_table[index].dist_hw_base, irq) >> ((irq % 4U) * 8U)) & 0xFFUL;
    48002bac:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002bb0:	91002001 	add	x1, x0, #0x8
    48002bb4:	b9401fe2 	ldr	w2, [sp, #28]
    48002bb8:	d2800300 	mov	x0, #0x18                  	// #24
    48002bbc:	9b007c40 	mul	x0, x2, x0
    48002bc0:	8b000020 	add	x0, x1, x0
    48002bc4:	b9400c00 	ldr	w0, [x0, #12]
    48002bc8:	2a0003e1 	mov	w1, w0
    48002bcc:	b9401be0 	ldr	w0, [sp, #24]
    48002bd0:	2a0003e0 	mov	w0, w0
    48002bd4:	927e7400 	and	x0, x0, #0xfffffffc
    48002bd8:	8b000020 	add	x0, x1, x0
    48002bdc:	91100000 	add	x0, x0, #0x400
    48002be0:	b9400001 	ldr	w1, [x0]
    48002be4:	b9401be0 	ldr	w0, [sp, #24]
    48002be8:	12000400 	and	w0, w0, #0x3
    48002bec:	531d7000 	lsl	w0, w0, #3
    48002bf0:	1ac02420 	lsr	w0, w1, w0
    48002bf4:	12001c00 	and	w0, w0, #0xff
    }
}
    48002bf8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002bfc:	d65f03c0 	ret

0000000048002c00 <arm_gic_set_system_register_enable_mask>:

void arm_gic_set_system_register_enable_mask(rt_uint32_t index, rt_uint32_t value)
{
    48002c00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48002c04:	910003fd 	mov	x29, sp
    48002c08:	b9001fe0 	str	w0, [sp, #28]
    48002c0c:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002c10:	b9401fe0 	ldr	w0, [sp, #28]
    48002c14:	7100001f 	cmp	w0, #0x0
    48002c18:	540000e0 	b.eq	48002c34 <arm_gic_set_system_register_enable_mask+0x34>  // b.none
    48002c1c:	d2802c82 	mov	x2, #0x164                 	// #356
    48002c20:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002c24:	913fc001 	add	x1, x0, #0xff0
    48002c28:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002c2c:	91364000 	add	x0, x0, #0xd90
    48002c30:	9400350e 	bl	48010068 <rt_assert_handler>

    value &= 0xFFUL;
    48002c34:	b9401be0 	ldr	w0, [sp, #24]
    48002c38:	12001c00 	and	w0, w0, #0xff
    48002c3c:	b9001be0 	str	w0, [sp, #24]
    /* set priority mask */
    __set_gicv3_reg(ICC_SRE_EL1, value);
    48002c40:	b9401be0 	ldr	w0, [sp, #24]
    48002c44:	d518cca0 	msr	s3_0_c12_c12_5, x0
    __asm__ volatile ("isb 0xF"::
    48002c48:	d5033fdf 	isb
                        :"memory");
}
    48002c4c:	d503201f 	nop
    48002c50:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48002c54:	d65f03c0 	ret

0000000048002c58 <arm_gic_get_system_register_enable_mask>:

rt_uint32_t arm_gic_get_system_register_enable_mask(rt_uint32_t index)
{
    48002c58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002c5c:	910003fd 	mov	x29, sp
    48002c60:	b9001fe0 	str	w0, [sp, #28]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002c64:	b9401fe0 	ldr	w0, [sp, #28]
    48002c68:	7100001f 	cmp	w0, #0x0
    48002c6c:	540000e0 	b.eq	48002c88 <arm_gic_get_system_register_enable_mask+0x30>  // b.none
    48002c70:	d2802de2 	mov	x2, #0x16f                 	// #367
    48002c74:	900000e0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48002c78:	91006001 	add	x1, x0, #0x18
    48002c7c:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002c80:	91364000 	add	x0, x0, #0xd90
    48002c84:	940034f9 	bl	48010068 <rt_assert_handler>
    rt_uint32_t value;

    __get_gicv3_reg(ICC_SRE_EL1, value);
    48002c88:	d538cca0 	mrs	x0, s3_0_c12_c12_5
    48002c8c:	b9002fe0 	str	w0, [sp, #44]
    return value;
    48002c90:	b9402fe0 	ldr	w0, [sp, #44]
}
    48002c94:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002c98:	d65f03c0 	ret

0000000048002c9c <arm_gic_set_interface_prior_mask>:

void arm_gic_set_interface_prior_mask(rt_uint32_t index, rt_uint32_t priority)
{
    48002c9c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48002ca0:	910003fd 	mov	x29, sp
    48002ca4:	b9001fe0 	str	w0, [sp, #28]
    48002ca8:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002cac:	b9401fe0 	ldr	w0, [sp, #28]
    48002cb0:	7100001f 	cmp	w0, #0x0
    48002cb4:	540000e0 	b.eq	48002cd0 <arm_gic_set_interface_prior_mask+0x34>  // b.none
    48002cb8:	d2802f02 	mov	x2, #0x178                 	// #376
    48002cbc:	900000e0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48002cc0:	91010001 	add	x1, x0, #0x40
    48002cc4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002cc8:	91364000 	add	x0, x0, #0xd90
    48002ccc:	940034e7 	bl	48010068 <rt_assert_handler>

    priority &= 0xFFUL;
    48002cd0:	b9401be0 	ldr	w0, [sp, #24]
    48002cd4:	12001c00 	and	w0, w0, #0xff
    48002cd8:	b9001be0 	str	w0, [sp, #24]
    /* set priority mask */
    __set_gicv3_reg(ICC_PMR_EL1, priority);
    48002cdc:	b9401be0 	ldr	w0, [sp, #24]
    48002ce0:	d5184600 	msr	s3_0_c4_c6_0, x0
}
    48002ce4:	d503201f 	nop
    48002ce8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48002cec:	d65f03c0 	ret

0000000048002cf0 <arm_gic_get_interface_prior_mask>:

rt_uint32_t arm_gic_get_interface_prior_mask(rt_uint32_t index)
{
    48002cf0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002cf4:	910003fd 	mov	x29, sp
    48002cf8:	b9001fe0 	str	w0, [sp, #28]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002cfc:	b9401fe0 	ldr	w0, [sp, #28]
    48002d00:	7100001f 	cmp	w0, #0x0
    48002d04:	540000e0 	b.eq	48002d20 <arm_gic_get_interface_prior_mask+0x30>  // b.none
    48002d08:	d2803022 	mov	x2, #0x181                 	// #385
    48002d0c:	900000e0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48002d10:	9101a001 	add	x1, x0, #0x68
    48002d14:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002d18:	91364000 	add	x0, x0, #0xd90
    48002d1c:	940034d3 	bl	48010068 <rt_assert_handler>
    rt_uint32_t priority;

    __get_gicv3_reg(ICC_PMR_EL1, priority);
    48002d20:	d5384600 	mrs	x0, s3_0_c4_c6_0
    48002d24:	b9002fe0 	str	w0, [sp, #44]
    return priority;
    48002d28:	b9402fe0 	ldr	w0, [sp, #44]
}
    48002d2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002d30:	d65f03c0 	ret

0000000048002d34 <arm_gic_set_binary_point>:

void arm_gic_set_binary_point(rt_uint32_t index, rt_uint32_t binary_point)
{
    48002d34:	d10043ff 	sub	sp, sp, #0x10
    48002d38:	b9000fe0 	str	w0, [sp, #12]
    48002d3c:	b9000be1 	str	w1, [sp, #8]
    index = index;
    binary_point &= 0x7U;
    48002d40:	b9400be0 	ldr	w0, [sp, #8]
    48002d44:	12000800 	and	w0, w0, #0x7
    48002d48:	b9000be0 	str	w0, [sp, #8]

    __set_gicv3_reg(ICC_BPR1_EL1, binary_point);
    48002d4c:	b9400be0 	ldr	w0, [sp, #8]
    48002d50:	d518cc60 	msr	s3_0_c12_c12_3, x0
}
    48002d54:	d503201f 	nop
    48002d58:	910043ff 	add	sp, sp, #0x10
    48002d5c:	d65f03c0 	ret

0000000048002d60 <arm_gic_get_binary_point>:

rt_uint32_t arm_gic_get_binary_point(rt_uint32_t index)
{
    48002d60:	d10083ff 	sub	sp, sp, #0x20
    48002d64:	b9000fe0 	str	w0, [sp, #12]
    rt_uint32_t binary_point;

    index = index;
    __get_gicv3_reg(ICC_BPR1_EL1, binary_point);
    48002d68:	d538cc60 	mrs	x0, s3_0_c12_c12_3
    48002d6c:	b9001fe0 	str	w0, [sp, #28]
    return binary_point;
    48002d70:	b9401fe0 	ldr	w0, [sp, #28]
}
    48002d74:	910083ff 	add	sp, sp, #0x20
    48002d78:	d65f03c0 	ret

0000000048002d7c <arm_gic_get_irq_status>:

rt_uint32_t arm_gic_get_irq_status(rt_uint32_t index, int irq)
{
    48002d7c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002d80:	910003fd 	mov	x29, sp
    48002d84:	b9001fe0 	str	w0, [sp, #28]
    48002d88:	b9001be1 	str	w1, [sp, #24]
    rt_uint32_t pending;
    rt_uint32_t active;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002d8c:	b9401fe0 	ldr	w0, [sp, #28]
    48002d90:	7100001f 	cmp	w0, #0x0
    48002d94:	540000e0 	b.eq	48002db0 <arm_gic_get_irq_status+0x34>  // b.none
    48002d98:	d28033c2 	mov	x2, #0x19e                 	// #414
    48002d9c:	900000e0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48002da0:	91024001 	add	x1, x0, #0x90
    48002da4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002da8:	91364000 	add	x0, x0, #0xd90
    48002dac:	940034af 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    48002db0:	b9401be1 	ldr	w1, [sp, #24]
    48002db4:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002db8:	91002002 	add	x2, x0, #0x8
    48002dbc:	b9401fe3 	ldr	w3, [sp, #28]
    48002dc0:	d2800300 	mov	x0, #0x18                  	// #24
    48002dc4:	9b007c60 	mul	x0, x3, x0
    48002dc8:	8b000040 	add	x0, x2, x0
    48002dcc:	b9400000 	ldr	w0, [x0]
    48002dd0:	4b000020 	sub	w0, w1, w0
    48002dd4:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    active = (GIC_DIST_ACTIVE_SET(_gic_table[index].dist_hw_base, irq) >> (irq % 32U)) & 0x1UL;
    48002dd8:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002ddc:	91002001 	add	x1, x0, #0x8
    48002de0:	b9401fe2 	ldr	w2, [sp, #28]
    48002de4:	d2800300 	mov	x0, #0x18                  	// #24
    48002de8:	9b007c40 	mul	x0, x2, x0
    48002dec:	8b000020 	add	x0, x1, x0
    48002df0:	b9400c00 	ldr	w0, [x0, #12]
    48002df4:	2a0003e1 	mov	w1, w0
    48002df8:	b9401be0 	ldr	w0, [sp, #24]
    48002dfc:	53057c00 	lsr	w0, w0, #5
    48002e00:	531e7400 	lsl	w0, w0, #2
    48002e04:	2a0003e0 	mov	w0, w0
    48002e08:	8b000020 	add	x0, x1, x0
    48002e0c:	910c0000 	add	x0, x0, #0x300
    48002e10:	b9400001 	ldr	w1, [x0]
    48002e14:	b9401be0 	ldr	w0, [sp, #24]
    48002e18:	12001000 	and	w0, w0, #0x1f
    48002e1c:	1ac02420 	lsr	w0, w1, w0
    48002e20:	12000000 	and	w0, w0, #0x1
    48002e24:	b9002fe0 	str	w0, [sp, #44]
    pending = (GIC_DIST_PENDING_SET(_gic_table[index].dist_hw_base, irq) >> (irq % 32U)) & 0x1UL;
    48002e28:	900001a0 	adrp	x0, 48036000 <__page_off>
    48002e2c:	91002001 	add	x1, x0, #0x8
    48002e30:	b9401fe2 	ldr	w2, [sp, #28]
    48002e34:	d2800300 	mov	x0, #0x18                  	// #24
    48002e38:	9b007c40 	mul	x0, x2, x0
    48002e3c:	8b000020 	add	x0, x1, x0
    48002e40:	b9400c00 	ldr	w0, [x0, #12]
    48002e44:	2a0003e1 	mov	w1, w0
    48002e48:	b9401be0 	ldr	w0, [sp, #24]
    48002e4c:	53057c00 	lsr	w0, w0, #5
    48002e50:	531e7400 	lsl	w0, w0, #2
    48002e54:	2a0003e0 	mov	w0, w0
    48002e58:	8b000020 	add	x0, x1, x0
    48002e5c:	91080000 	add	x0, x0, #0x200
    48002e60:	b9400001 	ldr	w1, [x0]
    48002e64:	b9401be0 	ldr	w0, [sp, #24]
    48002e68:	12001000 	and	w0, w0, #0x1f
    48002e6c:	1ac02420 	lsr	w0, w1, w0
    48002e70:	12000000 	and	w0, w0, #0x1
    48002e74:	b9002be0 	str	w0, [sp, #40]

    return ((active << 1U) | pending);
    48002e78:	b9402fe0 	ldr	w0, [sp, #44]
    48002e7c:	0b000000 	add	w0, w0, w0
    48002e80:	2a0003e1 	mov	w1, w0
    48002e84:	b9402be0 	ldr	w0, [sp, #40]
    48002e88:	2a000020 	orr	w0, w1, w0
}
    48002e8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002e90:	d65f03c0 	ret

0000000048002e94 <arm_gic_send_affinity_sgi>:

void arm_gic_send_affinity_sgi(rt_uint32_t index, int irq, rt_uint32_t cpu_mask, rt_uint32_t routing_mode)
{
    48002e94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002e98:	910003fd 	mov	x29, sp
    48002e9c:	b9001fe0 	str	w0, [sp, #28]
    48002ea0:	b9001be1 	str	w1, [sp, #24]
    48002ea4:	b90017e2 	str	w2, [sp, #20]
    48002ea8:	b90013e3 	str	w3, [sp, #16]
    rt_uint64_t sgi_val;

    if (routing_mode)
    48002eac:	b94013e0 	ldr	w0, [sp, #16]
    48002eb0:	7100001f 	cmp	w0, #0x0
    48002eb4:	54000540 	b.eq	48002f5c <arm_gic_send_affinity_sgi+0xc8>  // b.none
    {
        sgi_val = (1ULL << 40) | ((irq & 0x0FULL) << 24); //Interrupts routed to all PEs in the system, excluding "self".
    48002eb8:	b9401be0 	ldr	w0, [sp, #24]
    48002ebc:	2a0003e0 	mov	w0, w0
    48002ec0:	d3689c00 	lsl	x0, x0, #24
    48002ec4:	92680c00 	and	x0, x0, #0xf000000
    48002ec8:	b2580000 	orr	x0, x0, #0x10000000000
    48002ecc:	f90017e0 	str	x0, [sp, #40]
        /*  Write the ICC_SGI1R registers */
        __asm__ volatile("dsb 0xF" ::
    48002ed0:	d5033f9f 	dsb	sy
                            : "memory");
        __set_gicv3_reg(ICC_SGI1R_EL1, sgi_val);
    48002ed4:	f94017e0 	ldr	x0, [sp, #40]
    48002ed8:	d518cba0 	msr	s3_0_c12_c11_5, x0
        __asm__ volatile("isb 0xF" ::
    48002edc:	d5033fdf 	isb
            __set_gicv3_reg(ICC_SGI1R_EL1, sgi_val);
            __asm__ volatile("isb 0xF" ::
                                : "memory");
        }
    }
}
    48002ee0:	14000025 	b	48002f74 <arm_gic_send_affinity_sgi+0xe0>
            sgi_val = ((irq & 0x0FULL) << 24 |
    48002ee4:	b9401be0 	ldr	w0, [sp, #24]
    48002ee8:	2a0003e0 	mov	w0, w0
    48002eec:	d3689c00 	lsl	x0, x0, #24
    48002ef0:	92680c01 	and	x1, x0, #0xf000000
    48002ef4:	b94023e0 	ldr	w0, [sp, #32]
    48002ef8:	2a0003e0 	mov	w0, w0
    48002efc:	aa000021 	orr	x1, x1, x0
                       ((cluster_id >> 8) & 0xFFULL) << GIC_RSGI_AFF1_OFFSET |
    48002f00:	b94027e0 	ldr	w0, [sp, #36]
    48002f04:	53087c00 	lsr	w0, w0, #8
    48002f08:	2a0003e0 	mov	w0, w0
    48002f0c:	d370bc00 	lsl	x0, x0, #16
    48002f10:	92701c00 	and	x0, x0, #0xff0000
                       target_list |
    48002f14:	aa000021 	orr	x1, x1, x0
                       ((cluster_id >> 16) & 0xFFULL) << GIC_RSGI_AFF2_OFFSET |
    48002f18:	b94027e0 	ldr	w0, [sp, #36]
    48002f1c:	53107c00 	lsr	w0, w0, #16
    48002f20:	2a0003e0 	mov	w0, w0
    48002f24:	d3607c00 	lsl	x0, x0, #32
    48002f28:	92601c00 	and	x0, x0, #0xff00000000
                       ((cluster_id >> 8) & 0xFFULL) << GIC_RSGI_AFF1_OFFSET |
    48002f2c:	aa000021 	orr	x1, x1, x0
                       ((cluster_id >> 24) & 0xFFull) << GIC_RSGI_AFF3_OFFSET);
    48002f30:	b94027e0 	ldr	w0, [sp, #36]
    48002f34:	53187c00 	lsr	w0, w0, #24
    48002f38:	2a0003e0 	mov	w0, w0
    48002f3c:	d3503c00 	lsl	x0, x0, #48
    48002f40:	92501c00 	and	x0, x0, #0xff000000000000
            sgi_val = ((irq & 0x0FULL) << 24 |
    48002f44:	aa000020 	orr	x0, x1, x0
    48002f48:	f90017e0 	str	x0, [sp, #40]
            __asm__ volatile("dsb 0xF" ::
    48002f4c:	d5033f9f 	dsb	sy
            __set_gicv3_reg(ICC_SGI1R_EL1, sgi_val);
    48002f50:	f94017e0 	ldr	x0, [sp, #40]
    48002f54:	d518cba0 	msr	s3_0_c12_c11_5, x0
            __asm__ volatile("isb 0xF" ::
    48002f58:	d5033fdf 	isb
        while (arm_gic_cpumask_to_affval(&cpu_mask, &cluster_id, &target_list))
    48002f5c:	910083e2 	add	x2, sp, #0x20
    48002f60:	910093e1 	add	x1, sp, #0x24
    48002f64:	910053e0 	add	x0, sp, #0x14
    48002f68:	97fffb13 	bl	48001bb4 <arm_gic_cpumask_to_affval>
    48002f6c:	7100001f 	cmp	w0, #0x0
    48002f70:	54fffba1 	b.ne	48002ee4 <arm_gic_send_affinity_sgi+0x50>  // b.any
}
    48002f74:	d503201f 	nop
    48002f78:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002f7c:	d65f03c0 	ret

0000000048002f80 <arm_gic_get_high_pending_irq>:

rt_uint32_t arm_gic_get_high_pending_irq(rt_uint32_t index)
{
    48002f80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48002f84:	910003fd 	mov	x29, sp
    48002f88:	b9001fe0 	str	w0, [sp, #28]
    rt_uint32_t irq;
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002f8c:	b9401fe0 	ldr	w0, [sp, #28]
    48002f90:	7100001f 	cmp	w0, #0x0
    48002f94:	540000e0 	b.eq	48002fb0 <arm_gic_get_high_pending_irq+0x30>  // b.none
    48002f98:	d28039c2 	mov	x2, #0x1ce                 	// #462
    48002f9c:	900000e0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48002fa0:	9102a001 	add	x1, x0, #0xa8
    48002fa4:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002fa8:	91364000 	add	x0, x0, #0xd90
    48002fac:	9400342f 	bl	48010068 <rt_assert_handler>

    index = index;
    __get_gicv3_reg(ICC_HPPIR1_EL1, irq);
    48002fb0:	d538cc40 	mrs	x0, s3_0_c12_c12_2
    48002fb4:	b9002fe0 	str	w0, [sp, #44]
    return irq;
    48002fb8:	b9402fe0 	ldr	w0, [sp, #44]
}
    48002fbc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48002fc0:	d65f03c0 	ret

0000000048002fc4 <arm_gic_get_interface_id>:

rt_uint32_t arm_gic_get_interface_id(rt_uint32_t index)
{
    48002fc4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48002fc8:	910003fd 	mov	x29, sp
    48002fcc:	b9001fe0 	str	w0, [sp, #28]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48002fd0:	b9401fe0 	ldr	w0, [sp, #28]
    48002fd4:	7100001f 	cmp	w0, #0x0
    48002fd8:	540000e0 	b.eq	48002ff4 <arm_gic_get_interface_id+0x30>  // b.none
    48002fdc:	d2803ae2 	mov	x2, #0x1d7                 	// #471
    48002fe0:	900000e0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48002fe4:	91032001 	add	x1, x0, #0xc8
    48002fe8:	f00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48002fec:	91364000 	add	x0, x0, #0xd90
    48002ff0:	9400341e 	bl	48010068 <rt_assert_handler>

    return GIC_CPU_IIDR(_gic_table[index].cpu_hw_base);
    48002ff4:	b9401fe1 	ldr	w1, [sp, #28]
    48002ff8:	d2800300 	mov	x0, #0x18                  	// #24
    48002ffc:	9b007c20 	mul	x0, x1, x0
    48003000:	91004001 	add	x1, x0, #0x10
    48003004:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003008:	91002000 	add	x0, x0, #0x8
    4800300c:	8b000020 	add	x0, x1, x0
    48003010:	9103f000 	add	x0, x0, #0xfc
    48003014:	b9400000 	ldr	w0, [x0]
}
    48003018:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800301c:	d65f03c0 	ret

0000000048003020 <arm_gic_set_group>:

void arm_gic_set_group(rt_uint32_t index, int irq, rt_uint32_t group)
{
    48003020:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48003024:	910003fd 	mov	x29, sp
    48003028:	b9001fe0 	str	w0, [sp, #28]
    4800302c:	b9001be1 	str	w1, [sp, #24]
    48003030:	b90017e2 	str	w2, [sp, #20]
    rt_uint32_t igroupr;
    rt_uint32_t shift;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48003034:	b9401fe0 	ldr	w0, [sp, #28]
    48003038:	7100001f 	cmp	w0, #0x0
    4800303c:	540000e0 	b.eq	48003058 <arm_gic_set_group+0x38>  // b.none
    48003040:	d2803c22 	mov	x2, #0x1e1                 	// #481
    48003044:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48003048:	9103a001 	add	x1, x0, #0xe8
    4800304c:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003050:	91364000 	add	x0, x0, #0xd90
    48003054:	94003405 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(group <= 1U);
    48003058:	b94017e0 	ldr	w0, [sp, #20]
    4800305c:	7100041f 	cmp	w0, #0x1
    48003060:	540000e9 	b.ls	4800307c <arm_gic_set_group+0x5c>  // b.plast
    48003064:	d2803c42 	mov	x2, #0x1e2                 	// #482
    48003068:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800306c:	9103a001 	add	x1, x0, #0xe8
    48003070:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003074:	91370000 	add	x0, x0, #0xdc0
    48003078:	940033fc 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    4800307c:	b9401be1 	ldr	w1, [sp, #24]
    48003080:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003084:	91002002 	add	x2, x0, #0x8
    48003088:	b9401fe3 	ldr	w3, [sp, #28]
    4800308c:	d2800300 	mov	x0, #0x18                  	// #24
    48003090:	9b007c60 	mul	x0, x3, x0
    48003094:	8b000040 	add	x0, x2, x0
    48003098:	b9400000 	ldr	w0, [x0]
    4800309c:	4b000020 	sub	w0, w1, w0
    480030a0:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    igroupr = GIC_DIST_IGROUP(_gic_table[index].dist_hw_base, irq);
    480030a4:	f0000180 	adrp	x0, 48036000 <__page_off>
    480030a8:	91002001 	add	x1, x0, #0x8
    480030ac:	b9401fe2 	ldr	w2, [sp, #28]
    480030b0:	d2800300 	mov	x0, #0x18                  	// #24
    480030b4:	9b007c40 	mul	x0, x2, x0
    480030b8:	8b000020 	add	x0, x1, x0
    480030bc:	b9400c00 	ldr	w0, [x0, #12]
    480030c0:	2a0003e1 	mov	w1, w0
    480030c4:	b9401be0 	ldr	w0, [sp, #24]
    480030c8:	53057c00 	lsr	w0, w0, #5
    480030cc:	531e7400 	lsl	w0, w0, #2
    480030d0:	2a0003e0 	mov	w0, w0
    480030d4:	8b000020 	add	x0, x1, x0
    480030d8:	91020000 	add	x0, x0, #0x80
    480030dc:	b9400000 	ldr	w0, [x0]
    480030e0:	b9002fe0 	str	w0, [sp, #44]
    shift = (irq % 32U);
    480030e4:	b9401be0 	ldr	w0, [sp, #24]
    480030e8:	12001000 	and	w0, w0, #0x1f
    480030ec:	b9002be0 	str	w0, [sp, #40]
    igroupr &= (~(1U << shift));
    480030f0:	b9402be0 	ldr	w0, [sp, #40]
    480030f4:	52800021 	mov	w1, #0x1                   	// #1
    480030f8:	1ac02020 	lsl	w0, w1, w0
    480030fc:	2a2003e0 	mvn	w0, w0
    48003100:	b9402fe1 	ldr	w1, [sp, #44]
    48003104:	0a000020 	and	w0, w1, w0
    48003108:	b9002fe0 	str	w0, [sp, #44]
    igroupr |= ((group & 0x1U) << shift);
    4800310c:	b94017e0 	ldr	w0, [sp, #20]
    48003110:	12000001 	and	w1, w0, #0x1
    48003114:	b9402be0 	ldr	w0, [sp, #40]
    48003118:	1ac02020 	lsl	w0, w1, w0
    4800311c:	b9402fe1 	ldr	w1, [sp, #44]
    48003120:	2a000020 	orr	w0, w1, w0
    48003124:	b9002fe0 	str	w0, [sp, #44]

    GIC_DIST_IGROUP(_gic_table[index].dist_hw_base, irq) = igroupr;
    48003128:	f0000180 	adrp	x0, 48036000 <__page_off>
    4800312c:	91002001 	add	x1, x0, #0x8
    48003130:	b9401fe2 	ldr	w2, [sp, #28]
    48003134:	d2800300 	mov	x0, #0x18                  	// #24
    48003138:	9b007c40 	mul	x0, x2, x0
    4800313c:	8b000020 	add	x0, x1, x0
    48003140:	b9400c00 	ldr	w0, [x0, #12]
    48003144:	2a0003e1 	mov	w1, w0
    48003148:	b9401be0 	ldr	w0, [sp, #24]
    4800314c:	53057c00 	lsr	w0, w0, #5
    48003150:	531e7400 	lsl	w0, w0, #2
    48003154:	2a0003e0 	mov	w0, w0
    48003158:	8b000020 	add	x0, x1, x0
    4800315c:	91020000 	add	x0, x0, #0x80
    48003160:	aa0003e1 	mov	x1, x0
    48003164:	b9402fe0 	ldr	w0, [sp, #44]
    48003168:	b9000020 	str	w0, [x1]
}
    4800316c:	d503201f 	nop
    48003170:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48003174:	d65f03c0 	ret

0000000048003178 <arm_gic_get_group>:

rt_uint32_t arm_gic_get_group(rt_uint32_t index, int irq)
{
    48003178:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800317c:	910003fd 	mov	x29, sp
    48003180:	b9001fe0 	str	w0, [sp, #28]
    48003184:	b9001be1 	str	w1, [sp, #24]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48003188:	b9401fe0 	ldr	w0, [sp, #28]
    4800318c:	7100001f 	cmp	w0, #0x0
    48003190:	540000e0 	b.eq	480031ac <arm_gic_get_group+0x34>  // b.none
    48003194:	d2803e22 	mov	x2, #0x1f1                 	// #497
    48003198:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800319c:	91040001 	add	x1, x0, #0x100
    480031a0:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480031a4:	91364000 	add	x0, x0, #0xd90
    480031a8:	940033b0 	bl	48010068 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
    480031ac:	b9401be1 	ldr	w1, [sp, #24]
    480031b0:	f0000180 	adrp	x0, 48036000 <__page_off>
    480031b4:	91002002 	add	x2, x0, #0x8
    480031b8:	b9401fe3 	ldr	w3, [sp, #28]
    480031bc:	d2800300 	mov	x0, #0x18                  	// #24
    480031c0:	9b007c60 	mul	x0, x3, x0
    480031c4:	8b000040 	add	x0, x2, x0
    480031c8:	b9400000 	ldr	w0, [x0]
    480031cc:	4b000020 	sub	w0, w1, w0
    480031d0:	b9001be0 	str	w0, [sp, #24]
    RT_ASSERT(irq >= 0U);

    return (GIC_DIST_IGROUP(_gic_table[index].dist_hw_base, irq) >> (irq % 32U)) & 0x1UL;
    480031d4:	f0000180 	adrp	x0, 48036000 <__page_off>
    480031d8:	91002001 	add	x1, x0, #0x8
    480031dc:	b9401fe2 	ldr	w2, [sp, #28]
    480031e0:	d2800300 	mov	x0, #0x18                  	// #24
    480031e4:	9b007c40 	mul	x0, x2, x0
    480031e8:	8b000020 	add	x0, x1, x0
    480031ec:	b9400c00 	ldr	w0, [x0, #12]
    480031f0:	2a0003e1 	mov	w1, w0
    480031f4:	b9401be0 	ldr	w0, [sp, #24]
    480031f8:	53057c00 	lsr	w0, w0, #5
    480031fc:	531e7400 	lsl	w0, w0, #2
    48003200:	2a0003e0 	mov	w0, w0
    48003204:	8b000020 	add	x0, x1, x0
    48003208:	91020000 	add	x0, x0, #0x80
    4800320c:	b9400001 	ldr	w1, [x0]
    48003210:	b9401be0 	ldr	w0, [sp, #24]
    48003214:	12001000 	and	w0, w0, #0x1f
    48003218:	1ac02420 	lsr	w0, w1, w0
    4800321c:	12000000 	and	w0, w0, #0x1
}
    48003220:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48003224:	d65f03c0 	ret

0000000048003228 <arm_gicv3_wait_rwp>:

static int arm_gicv3_wait_rwp(rt_uint32_t index, rt_uint32_t irq)
{
    48003228:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800322c:	910003fd 	mov	x29, sp
    48003230:	b9001fe0 	str	w0, [sp, #28]
    48003234:	b9001be1 	str	w1, [sp, #24]
    rt_uint32_t rwp_bit;
    rt_uint32_t base;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48003238:	b9401fe0 	ldr	w0, [sp, #28]
    4800323c:	7100001f 	cmp	w0, #0x0
    48003240:	540000e0 	b.eq	4800325c <arm_gicv3_wait_rwp+0x34>  // b.none
    48003244:	d2803fc2 	mov	x2, #0x1fe                 	// #510
    48003248:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800324c:	91046001 	add	x1, x0, #0x118
    48003250:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003254:	91364000 	add	x0, x0, #0xd90
    48003258:	94003384 	bl	48010068 <rt_assert_handler>

    if (irq < 32u)
    4800325c:	b9401be0 	ldr	w0, [sp, #24]
    48003260:	71007c1f 	cmp	w0, #0x1f
    48003264:	54000388 	b.hi	480032d4 <arm_gicv3_wait_rwp+0xac>  // b.pmore
    {
        rt_int32_t cpu_id = rt_hw_cpu_id();
    48003268:	9400064d 	bl	48004b9c <rt_hw_cpu_id>
    4800326c:	b90027e0 	str	w0, [sp, #36]

        RT_ASSERT((cpu_id) < RT_CPUS_NR);
    48003270:	b94027e0 	ldr	w0, [sp, #36]
    48003274:	7100041f 	cmp	w0, #0x1
    48003278:	540000ed 	b.le	48003294 <arm_gicv3_wait_rwp+0x6c>
    4800327c:	d2804082 	mov	x2, #0x204                 	// #516
    48003280:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48003284:	91046001 	add	x1, x0, #0x118
    48003288:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    4800328c:	9136a000 	add	x0, x0, #0xda8
    48003290:	94003376 	bl	48010068 <rt_assert_handler>
        base = _gic_table[index].redist_hw_base[cpu_id];
    48003294:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003298:	91002002 	add	x2, x0, #0x8
    4800329c:	b98027e3 	ldrsw	x3, [sp, #36]
    480032a0:	b9401fe1 	ldr	w1, [sp, #28]
    480032a4:	aa0103e0 	mov	x0, x1
    480032a8:	8b000000 	add	x0, x0, x0
    480032ac:	8b010000 	add	x0, x0, x1
    480032b0:	8b000000 	add	x0, x0, x0
    480032b4:	8b030000 	add	x0, x0, x3
    480032b8:	d37ef400 	lsl	x0, x0, #2
    480032bc:	8b000040 	add	x0, x2, x0
    480032c0:	b9400400 	ldr	w0, [x0, #4]
    480032c4:	b9002be0 	str	w0, [sp, #40]
        rwp_bit = GICR_CTLR_RWP;
    480032c8:	52800100 	mov	w0, #0x8                   	// #8
    480032cc:	b9002fe0 	str	w0, [sp, #44]
    480032d0:	1400000b 	b	480032fc <arm_gicv3_wait_rwp+0xd4>
    }
    else
    {
        base = _gic_table[index].dist_hw_base;
    480032d4:	f0000180 	adrp	x0, 48036000 <__page_off>
    480032d8:	91002001 	add	x1, x0, #0x8
    480032dc:	b9401fe2 	ldr	w2, [sp, #28]
    480032e0:	d2800300 	mov	x0, #0x18                  	// #24
    480032e4:	9b007c40 	mul	x0, x2, x0
    480032e8:	8b000020 	add	x0, x1, x0
    480032ec:	b9400c00 	ldr	w0, [x0, #12]
    480032f0:	b9002be0 	str	w0, [sp, #40]
        rwp_bit = GICD_CTLR_RWP;
    480032f4:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
    480032f8:	b9002fe0 	str	w0, [sp, #44]
    }

    while (__REG32(base) & rwp_bit)
    480032fc:	d503201f 	nop
    48003300:	b9402be0 	ldr	w0, [sp, #40]
    48003304:	b9400001 	ldr	w1, [x0]
    48003308:	b9402fe0 	ldr	w0, [sp, #44]
    4800330c:	0a000020 	and	w0, w1, w0
    48003310:	7100001f 	cmp	w0, #0x0
    48003314:	54ffff61 	b.ne	48003300 <arm_gicv3_wait_rwp+0xd8>  // b.any
    {
        ;
    }

    return 0;
    48003318:	52800000 	mov	w0, #0x0                   	// #0
}
    4800331c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48003320:	d65f03c0 	ret

0000000048003324 <arm_gic_dist_init>:

int arm_gic_dist_init(rt_uint32_t index, rt_uint32_t dist_base, int irq_start)
{
    48003324:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48003328:	910003fd 	mov	x29, sp
    4800332c:	b9001fe0 	str	w0, [sp, #28]
    48003330:	b9001be1 	str	w1, [sp, #24]
    48003334:	b90017e2 	str	w2, [sp, #20]
    rt_uint64_t cpu0_affval;
    unsigned int gic_type, i;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48003338:	b9401fe0 	ldr	w0, [sp, #28]
    4800333c:	7100001f 	cmp	w0, #0x0
    48003340:	540000e0 	b.eq	4800335c <arm_gic_dist_init+0x38>  // b.none
    48003344:	d2804362 	mov	x2, #0x21b                 	// #539
    48003348:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800334c:	9104c001 	add	x1, x0, #0x130
    48003350:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003354:	91364000 	add	x0, x0, #0xd90
    48003358:	94003344 	bl	48010068 <rt_assert_handler>

    _gic_table[index].dist_hw_base = dist_base;
    4800335c:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003360:	91002001 	add	x1, x0, #0x8
    48003364:	b9401fe2 	ldr	w2, [sp, #28]
    48003368:	d2800300 	mov	x0, #0x18                  	// #24
    4800336c:	9b007c40 	mul	x0, x2, x0
    48003370:	8b000020 	add	x0, x1, x0
    48003374:	b9401be1 	ldr	w1, [sp, #24]
    48003378:	b9000c01 	str	w1, [x0, #12]
    _gic_table[index].offset = irq_start;
    4800337c:	b94017e1 	ldr	w1, [sp, #20]
    48003380:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003384:	91002002 	add	x2, x0, #0x8
    48003388:	b9401fe3 	ldr	w3, [sp, #28]
    4800338c:	d2800300 	mov	x0, #0x18                  	// #24
    48003390:	9b007c60 	mul	x0, x3, x0
    48003394:	8b000040 	add	x0, x2, x0
    48003398:	b9000001 	str	w1, [x0]

    /* Find out how many interrupts are supported. */
    gic_type = GIC_DIST_TYPE(dist_base);
    4800339c:	b9401be0 	ldr	w0, [sp, #24]
    480033a0:	91001000 	add	x0, x0, #0x4
    480033a4:	b9400000 	ldr	w0, [x0]
    480033a8:	b9002be0 	str	w0, [sp, #40]
    _gic_max_irq = ((gic_type & 0x1fU) + 1U) * 32U;
    480033ac:	b9402be0 	ldr	w0, [sp, #40]
    480033b0:	12001000 	and	w0, w0, #0x1f
    480033b4:	11000400 	add	w0, w0, #0x1
    480033b8:	531b6801 	lsl	w1, w0, #5
    480033bc:	f0000180 	adrp	x0, 48036000 <__page_off>
    480033c0:	91008000 	add	x0, x0, #0x20
    480033c4:	b9000001 	str	w1, [x0]
    /*
     * The GIC only supports up to 1020 interrupt sources.
     * Limit this to either the architected maximum, or the
     * platform maximum.
     */
    if (_gic_max_irq > 1020U)
    480033c8:	f0000180 	adrp	x0, 48036000 <__page_off>
    480033cc:	91008000 	add	x0, x0, #0x20
    480033d0:	b9400000 	ldr	w0, [x0]
    480033d4:	710ff01f 	cmp	w0, #0x3fc
    480033d8:	540000a9 	b.ls	480033ec <arm_gic_dist_init+0xc8>  // b.plast
        _gic_max_irq = 1020U;
    480033dc:	f0000180 	adrp	x0, 48036000 <__page_off>
    480033e0:	91008000 	add	x0, x0, #0x20
    480033e4:	52807f81 	mov	w1, #0x3fc                 	// #1020
    480033e8:	b9000001 	str	w1, [x0]
    if (_gic_max_irq > ARM_GIC_NR_IRQS) /* the platform maximum interrupts */
    480033ec:	f0000180 	adrp	x0, 48036000 <__page_off>
    480033f0:	91008000 	add	x0, x0, #0x20
    480033f4:	b9400000 	ldr	w0, [x0]
    480033f8:	7104001f 	cmp	w0, #0x100
    480033fc:	540000a9 	b.ls	48003410 <arm_gic_dist_init+0xec>  // b.plast
        _gic_max_irq = ARM_GIC_NR_IRQS;
    48003400:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003404:	91008000 	add	x0, x0, #0x20
    48003408:	52802001 	mov	w1, #0x100                 	// #256
    4800340c:	b9000001 	str	w1, [x0]

    GIC_DIST_CTRL(dist_base) = 0x0U;
    48003410:	b9401be0 	ldr	w0, [sp, #24]
    48003414:	b900001f 	str	wzr, [x0]
    /* Wait for register write pending */
    arm_gicv3_wait_rwp(0, 32);
    48003418:	52800401 	mov	w1, #0x20                  	// #32
    4800341c:	52800000 	mov	w0, #0x0                   	// #0
    48003420:	97ffff82 	bl	48003228 <arm_gicv3_wait_rwp>

    /* Set all global interrupts to be level triggered, active low. */
    for (i = 32U; i < _gic_max_irq; i += 16U)
    48003424:	52800400 	mov	w0, #0x20                  	// #32
    48003428:	b9002fe0 	str	w0, [sp, #44]
    4800342c:	1400000c 	b	4800345c <arm_gic_dist_init+0x138>
        GIC_DIST_CONFIG(dist_base, i) = 0x0U;
    48003430:	b9401be1 	ldr	w1, [sp, #24]
    48003434:	b9402fe0 	ldr	w0, [sp, #44]
    48003438:	53047c00 	lsr	w0, w0, #4
    4800343c:	531e7400 	lsl	w0, w0, #2
    48003440:	2a0003e0 	mov	w0, w0
    48003444:	8b000020 	add	x0, x1, x0
    48003448:	91300000 	add	x0, x0, #0xc00
    4800344c:	b900001f 	str	wzr, [x0]
    for (i = 32U; i < _gic_max_irq; i += 16U)
    48003450:	b9402fe0 	ldr	w0, [sp, #44]
    48003454:	11004000 	add	w0, w0, #0x10
    48003458:	b9002fe0 	str	w0, [sp, #44]
    4800345c:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003460:	91008000 	add	x0, x0, #0x20
    48003464:	b9400000 	ldr	w0, [x0]
    48003468:	b9402fe1 	ldr	w1, [sp, #44]
    4800346c:	6b00003f 	cmp	w1, w0
    48003470:	54fffe03 	b.cc	48003430 <arm_gic_dist_init+0x10c>  // b.lo, b.ul, b.last

    arm_gicv3_wait_rwp(0, 32);
    48003474:	52800401 	mov	w1, #0x20                  	// #32
    48003478:	52800000 	mov	w0, #0x0                   	// #0
    4800347c:	97ffff6b 	bl	48003228 <arm_gicv3_wait_rwp>

    cpu0_affval = get_main_cpu_affval();
    48003480:	97fffa25 	bl	48001d14 <get_main_cpu_affval>
    48003484:	f90013e0 	str	x0, [sp, #32]
    /* Set all global interrupts to this CPU only. */
    for (i = 32U; i < _gic_max_irq; i++)
    48003488:	52800400 	mov	w0, #0x20                  	// #32
    4800348c:	b9002fe0 	str	w0, [sp, #44]
    48003490:	14000017 	b	480034ec <arm_gic_dist_init+0x1c8>
    {
        GIC_DIST_IROUTER_LOW(dist_base, i) = cpu0_affval;
    48003494:	b9401be1 	ldr	w1, [sp, #24]
    48003498:	b9402fe0 	ldr	w0, [sp, #44]
    4800349c:	531d7000 	lsl	w0, w0, #3
    480034a0:	2a0003e0 	mov	w0, w0
    480034a4:	8b000020 	add	x0, x1, x0
    480034a8:	91401800 	add	x0, x0, #0x6, lsl #12
    480034ac:	f94013e1 	ldr	x1, [sp, #32]
    480034b0:	b9000001 	str	w1, [x0]
        GIC_DIST_IROUTER_HIGH(dist_base, i) = cpu0_affval >> 32;
    480034b4:	f94013e0 	ldr	x0, [sp, #32]
    480034b8:	d360fc02 	lsr	x2, x0, #32
    480034bc:	b9401be1 	ldr	w1, [sp, #24]
    480034c0:	b9402fe0 	ldr	w0, [sp, #44]
    480034c4:	531d7000 	lsl	w0, w0, #3
    480034c8:	2a0003e0 	mov	w0, w0
    480034cc:	8b000021 	add	x1, x1, x0
    480034d0:	d28c0080 	mov	x0, #0x6004                	// #24580
    480034d4:	8b000020 	add	x0, x1, x0
    480034d8:	2a0203e1 	mov	w1, w2
    480034dc:	b9000001 	str	w1, [x0]
    for (i = 32U; i < _gic_max_irq; i++)
    480034e0:	b9402fe0 	ldr	w0, [sp, #44]
    480034e4:	11000400 	add	w0, w0, #0x1
    480034e8:	b9002fe0 	str	w0, [sp, #44]
    480034ec:	f0000180 	adrp	x0, 48036000 <__page_off>
    480034f0:	91008000 	add	x0, x0, #0x20
    480034f4:	b9400000 	ldr	w0, [x0]
    480034f8:	b9402fe1 	ldr	w1, [sp, #44]
    480034fc:	6b00003f 	cmp	w1, w0
    48003500:	54fffca3 	b.cc	48003494 <arm_gic_dist_init+0x170>  // b.lo, b.ul, b.last
    }

    arm_gicv3_wait_rwp(0, 32);
    48003504:	52800401 	mov	w1, #0x20                  	// #32
    48003508:	52800000 	mov	w0, #0x0                   	// #0
    4800350c:	97ffff47 	bl	48003228 <arm_gicv3_wait_rwp>

    /* Set priority on spi interrupts. */
    for (i = 32U; i < _gic_max_irq; i += 4U)
    48003510:	52800400 	mov	w0, #0x20                  	// #32
    48003514:	b9002fe0 	str	w0, [sp, #44]
    48003518:	1400000d 	b	4800354c <arm_gic_dist_init+0x228>
        GIC_DIST_PRI(dist_base, i) = 0xa0a0a0a0U;
    4800351c:	b9401be1 	ldr	w1, [sp, #24]
    48003520:	b9402fe0 	ldr	w0, [sp, #44]
    48003524:	927e7400 	and	x0, x0, #0xfffffffc
    48003528:	8b000020 	add	x0, x1, x0
    4800352c:	91100000 	add	x0, x0, #0x400
    48003530:	aa0003e1 	mov	x1, x0
    48003534:	52941400 	mov	w0, #0xa0a0                	// #41120
    48003538:	72b41400 	movk	w0, #0xa0a0, lsl #16
    4800353c:	b9000020 	str	w0, [x1]
    for (i = 32U; i < _gic_max_irq; i += 4U)
    48003540:	b9402fe0 	ldr	w0, [sp, #44]
    48003544:	11001000 	add	w0, w0, #0x4
    48003548:	b9002fe0 	str	w0, [sp, #44]
    4800354c:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003550:	91008000 	add	x0, x0, #0x20
    48003554:	b9400000 	ldr	w0, [x0]
    48003558:	b9402fe1 	ldr	w1, [sp, #44]
    4800355c:	6b00003f 	cmp	w1, w0
    48003560:	54fffde3 	b.cc	4800351c <arm_gic_dist_init+0x1f8>  // b.lo, b.ul, b.last

    arm_gicv3_wait_rwp(0, 32);
    48003564:	52800401 	mov	w1, #0x20                  	// #32
    48003568:	52800000 	mov	w0, #0x0                   	// #0
    4800356c:	97ffff2f 	bl	48003228 <arm_gicv3_wait_rwp>
    /* Disable all interrupts. */
    for (i = 0U; i < _gic_max_irq; i += 32U)
    48003570:	b9002fff 	str	wzr, [sp, #44]
    48003574:	14000018 	b	480035d4 <arm_gic_dist_init+0x2b0>
    {
        GIC_DIST_PENDING_CLEAR(dist_base, i) = 0xffffffffU;
    48003578:	b9401be1 	ldr	w1, [sp, #24]
    4800357c:	b9402fe0 	ldr	w0, [sp, #44]
    48003580:	53057c00 	lsr	w0, w0, #5
    48003584:	531e7400 	lsl	w0, w0, #2
    48003588:	2a0003e0 	mov	w0, w0
    4800358c:	8b000020 	add	x0, x1, x0
    48003590:	910a0000 	add	x0, x0, #0x280
    48003594:	aa0003e1 	mov	x1, x0
    48003598:	12800000 	mov	w0, #0xffffffff            	// #-1
    4800359c:	b9000020 	str	w0, [x1]
        GIC_DIST_ENABLE_CLEAR(dist_base, i) = 0xffffffffU;
    480035a0:	b9401be1 	ldr	w1, [sp, #24]
    480035a4:	b9402fe0 	ldr	w0, [sp, #44]
    480035a8:	53057c00 	lsr	w0, w0, #5
    480035ac:	531e7400 	lsl	w0, w0, #2
    480035b0:	2a0003e0 	mov	w0, w0
    480035b4:	8b000020 	add	x0, x1, x0
    480035b8:	91060000 	add	x0, x0, #0x180
    480035bc:	aa0003e1 	mov	x1, x0
    480035c0:	12800000 	mov	w0, #0xffffffff            	// #-1
    480035c4:	b9000020 	str	w0, [x1]
    for (i = 0U; i < _gic_max_irq; i += 32U)
    480035c8:	b9402fe0 	ldr	w0, [sp, #44]
    480035cc:	11008000 	add	w0, w0, #0x20
    480035d0:	b9002fe0 	str	w0, [sp, #44]
    480035d4:	f0000180 	adrp	x0, 48036000 <__page_off>
    480035d8:	91008000 	add	x0, x0, #0x20
    480035dc:	b9400000 	ldr	w0, [x0]
    480035e0:	b9402fe1 	ldr	w1, [sp, #44]
    480035e4:	6b00003f 	cmp	w1, w0
    480035e8:	54fffc83 	b.cc	48003578 <arm_gic_dist_init+0x254>  // b.lo, b.ul, b.last
    }

    arm_gicv3_wait_rwp(0, 32);
    480035ec:	52800401 	mov	w1, #0x20                  	// #32
    480035f0:	52800000 	mov	w0, #0x0                   	// #0
    480035f4:	97ffff0d 	bl	48003228 <arm_gicv3_wait_rwp>
    /* All interrupts defaults to IGROUP1(IRQ). */
    for (i = 0U; i < _gic_max_irq; i += 32U)
    480035f8:	b9002fff 	str	wzr, [sp, #44]
    480035fc:	1400000e 	b	48003634 <arm_gic_dist_init+0x310>
        GIC_DIST_IGROUP(dist_base, i) = 0xffffffffU;
    48003600:	b9401be1 	ldr	w1, [sp, #24]
    48003604:	b9402fe0 	ldr	w0, [sp, #44]
    48003608:	53057c00 	lsr	w0, w0, #5
    4800360c:	531e7400 	lsl	w0, w0, #2
    48003610:	2a0003e0 	mov	w0, w0
    48003614:	8b000020 	add	x0, x1, x0
    48003618:	91020000 	add	x0, x0, #0x80
    4800361c:	aa0003e1 	mov	x1, x0
    48003620:	12800000 	mov	w0, #0xffffffff            	// #-1
    48003624:	b9000020 	str	w0, [x1]
    for (i = 0U; i < _gic_max_irq; i += 32U)
    48003628:	b9402fe0 	ldr	w0, [sp, #44]
    4800362c:	11008000 	add	w0, w0, #0x20
    48003630:	b9002fe0 	str	w0, [sp, #44]
    48003634:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003638:	91008000 	add	x0, x0, #0x20
    4800363c:	b9400000 	ldr	w0, [x0]
    48003640:	b9402fe1 	ldr	w1, [sp, #44]
    48003644:	6b00003f 	cmp	w1, w0
    48003648:	54fffdc3 	b.cc	48003600 <arm_gic_dist_init+0x2dc>  // b.lo, b.ul, b.last

    arm_gicv3_wait_rwp(0, 32);
    4800364c:	52800401 	mov	w1, #0x20                  	// #32
    48003650:	52800000 	mov	w0, #0x0                   	// #0
    48003654:	97fffef5 	bl	48003228 <arm_gicv3_wait_rwp>
            Enables GICD_CTLR contains separate enable bits for Group 0, Secure Group 1 and Non-secure Group 1:
            GICD_CTLR.EnableGrp1S enables distribution of Secure Group 1 interrupts.
            GICD_CTLR.EnableGrp1NS enables distribution of Non-secure Group 1 interrupts.
            GICD_CTLR.EnableGrp0 enables distribution of Group 0 interrupts.
      */
    GIC_DIST_CTRL(dist_base) = GICD_CTLR_ARE_NS | GICD_CTLR_ENGRP1NS;
    48003658:	b9401be0 	ldr	w0, [sp, #24]
    4800365c:	aa0003e1 	mov	x1, x0
    48003660:	52800440 	mov	w0, #0x22                  	// #34
    48003664:	b9000020 	str	w0, [x1]

    return 0;
    48003668:	52800000 	mov	w0, #0x0                   	// #0
}
    4800366c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48003670:	d65f03c0 	ret

0000000048003674 <arm_gic_redist_address_set>:

int arm_gic_redist_address_set(rt_uint32_t index, rt_uint32_t redist_addr, rt_uint32_t cpu_id)
{
    48003674:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48003678:	910003fd 	mov	x29, sp
    4800367c:	b9001fe0 	str	w0, [sp, #28]
    48003680:	b9001be1 	str	w1, [sp, #24]
    48003684:	b90017e2 	str	w2, [sp, #20]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48003688:	b9401fe0 	ldr	w0, [sp, #28]
    4800368c:	7100001f 	cmp	w0, #0x0
    48003690:	540000e0 	b.eq	480036ac <arm_gic_redist_address_set+0x38>  // b.none
    48003694:	d2804cc2 	mov	x2, #0x266                 	// #614
    48003698:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800369c:	91052001 	add	x1, x0, #0x148
    480036a0:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480036a4:	91364000 	add	x0, x0, #0xd90
    480036a8:	94003270 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((cpu_id) < RT_CPUS_NR);
    480036ac:	b94017e0 	ldr	w0, [sp, #20]
    480036b0:	7100041f 	cmp	w0, #0x1
    480036b4:	540000e9 	b.ls	480036d0 <arm_gic_redist_address_set+0x5c>  // b.plast
    480036b8:	d2804ce2 	mov	x2, #0x267                 	// #615
    480036bc:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480036c0:	91052001 	add	x1, x0, #0x148
    480036c4:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480036c8:	9136a000 	add	x0, x0, #0xda8
    480036cc:	94003267 	bl	48010068 <rt_assert_handler>
    _gic_table[index].redist_hw_base[cpu_id] = redist_addr;
    480036d0:	f0000180 	adrp	x0, 48036000 <__page_off>
    480036d4:	91002002 	add	x2, x0, #0x8
    480036d8:	b94017e3 	ldr	w3, [sp, #20]
    480036dc:	b9401fe1 	ldr	w1, [sp, #28]
    480036e0:	aa0103e0 	mov	x0, x1
    480036e4:	8b000000 	add	x0, x0, x0
    480036e8:	8b010000 	add	x0, x0, x1
    480036ec:	8b000000 	add	x0, x0, x0
    480036f0:	8b030000 	add	x0, x0, x3
    480036f4:	d37ef400 	lsl	x0, x0, #2
    480036f8:	8b000040 	add	x0, x2, x0
    480036fc:	b9401be1 	ldr	w1, [sp, #24]
    48003700:	b9000401 	str	w1, [x0, #4]

    return 0;
    48003704:	52800000 	mov	w0, #0x0                   	// #0
}
    48003708:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800370c:	d65f03c0 	ret

0000000048003710 <arm_gic_cpu_interface_address_set>:

int arm_gic_cpu_interface_address_set(rt_uint32_t index, rt_uint32_t interface_addr, rt_uint32_t cpu_id)
{
    48003710:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48003714:	910003fd 	mov	x29, sp
    48003718:	b9001fe0 	str	w0, [sp, #28]
    4800371c:	b9001be1 	str	w1, [sp, #24]
    48003720:	b90017e2 	str	w2, [sp, #20]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48003724:	b9401fe0 	ldr	w0, [sp, #28]
    48003728:	7100001f 	cmp	w0, #0x0
    4800372c:	540000e0 	b.eq	48003748 <arm_gic_cpu_interface_address_set+0x38>  // b.none
    48003730:	d2804de2 	mov	x2, #0x26f                 	// #623
    48003734:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48003738:	9105a001 	add	x1, x0, #0x168
    4800373c:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003740:	91364000 	add	x0, x0, #0xd90
    48003744:	94003249 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((cpu_id) < RT_CPUS_NR);
    48003748:	b94017e0 	ldr	w0, [sp, #20]
    4800374c:	7100041f 	cmp	w0, #0x1
    48003750:	540000e9 	b.ls	4800376c <arm_gic_cpu_interface_address_set+0x5c>  // b.plast
    48003754:	d2804e02 	mov	x2, #0x270                 	// #624
    48003758:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800375c:	9105a001 	add	x1, x0, #0x168
    48003760:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003764:	9136a000 	add	x0, x0, #0xda8
    48003768:	94003240 	bl	48010068 <rt_assert_handler>
    _gic_table[index].cpu_hw_base[cpu_id] = interface_addr;
    4800376c:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003770:	91002002 	add	x2, x0, #0x8
    48003774:	b94017e3 	ldr	w3, [sp, #20]
    48003778:	b9401fe1 	ldr	w1, [sp, #28]
    4800377c:	aa0103e0 	mov	x0, x1
    48003780:	8b000000 	add	x0, x0, x0
    48003784:	8b010000 	add	x0, x0, x1
    48003788:	8b000000 	add	x0, x0, x0
    4800378c:	8b030000 	add	x0, x0, x3
    48003790:	91001000 	add	x0, x0, #0x4
    48003794:	b9401be1 	ldr	w1, [sp, #24]
    48003798:	b8207841 	str	w1, [x2, x0, lsl #2]

    return 0;
    4800379c:	52800000 	mov	w0, #0x0                   	// #0
}
    480037a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480037a4:	d65f03c0 	ret

00000000480037a8 <arm_gic_redist_init>:

int arm_gic_redist_init(rt_uint32_t index)
{
    480037a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480037ac:	910003fd 	mov	x29, sp
    480037b0:	b9001fe0 	str	w0, [sp, #28]
    unsigned int i;
    rt_uint32_t base;
    rt_int32_t cpu_id = rt_hw_cpu_id();
    480037b4:	940004fa 	bl	48004b9c <rt_hw_cpu_id>
    480037b8:	b9002be0 	str	w0, [sp, #40]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
    480037bc:	b9401fe0 	ldr	w0, [sp, #28]
    480037c0:	7100001f 	cmp	w0, #0x0
    480037c4:	540000e0 	b.eq	480037e0 <arm_gic_redist_init+0x38>  // b.none
    480037c8:	d2804f82 	mov	x2, #0x27c                 	// #636
    480037cc:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480037d0:	91064001 	add	x1, x0, #0x190
    480037d4:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480037d8:	91364000 	add	x0, x0, #0xd90
    480037dc:	94003223 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((cpu_id) < RT_CPUS_NR);
    480037e0:	b9402be0 	ldr	w0, [sp, #40]
    480037e4:	7100041f 	cmp	w0, #0x1
    480037e8:	540000ed 	b.le	48003804 <arm_gic_redist_init+0x5c>
    480037ec:	d2804fa2 	mov	x2, #0x27d                 	// #637
    480037f0:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480037f4:	91064001 	add	x1, x0, #0x190
    480037f8:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    480037fc:	9136a000 	add	x0, x0, #0xda8
    48003800:	9400321a 	bl	48010068 <rt_assert_handler>

    base = _gic_table[index].redist_hw_base[cpu_id];
    48003804:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003808:	91002002 	add	x2, x0, #0x8
    4800380c:	b9802be3 	ldrsw	x3, [sp, #40]
    48003810:	b9401fe1 	ldr	w1, [sp, #28]
    48003814:	aa0103e0 	mov	x0, x1
    48003818:	8b000000 	add	x0, x0, x0
    4800381c:	8b010000 	add	x0, x0, x1
    48003820:	8b000000 	add	x0, x0, x0
    48003824:	8b030000 	add	x0, x0, x3
    48003828:	d37ef400 	lsl	x0, x0, #2
    4800382c:	8b000040 	add	x0, x2, x0
    48003830:	b9400400 	ldr	w0, [x0, #4]
    48003834:	b90027e0 	str	w0, [sp, #36]
    /* redistributor enable */
    GIC_RDIST_WAKER(base) &= ~(1U << 1);
    48003838:	b94027e0 	ldr	w0, [sp, #36]
    4800383c:	91005000 	add	x0, x0, #0x14
    48003840:	b9400000 	ldr	w0, [x0]
    48003844:	b94027e1 	ldr	w1, [sp, #36]
    48003848:	91005021 	add	x1, x1, #0x14
    4800384c:	121e7800 	and	w0, w0, #0xfffffffd
    48003850:	b9000020 	str	w0, [x1]
    while (GIC_RDIST_WAKER(base) & (1 << 2))
    48003854:	d503201f 	nop
    48003858:	b94027e0 	ldr	w0, [sp, #36]
    4800385c:	91005000 	add	x0, x0, #0x14
    48003860:	b9400000 	ldr	w0, [x0]
    48003864:	121e0000 	and	w0, w0, #0x4
    48003868:	7100001f 	cmp	w0, #0x0
    4800386c:	54ffff61 	b.ne	48003858 <arm_gic_redist_init+0xb0>  // b.any
    {
        ;
    }

    /* Disable all sgi and ppi interrupt */
    GIC_RDISTSGI_ICENABLER0(base) = 0xFFFFFFFF;
    48003870:	b94027e1 	ldr	w1, [sp, #36]
    48003874:	d2803000 	mov	x0, #0x180                 	// #384
    48003878:	f2a00020 	movk	x0, #0x1, lsl #16
    4800387c:	8b000020 	add	x0, x1, x0
    48003880:	aa0003e1 	mov	x1, x0
    48003884:	12800000 	mov	w0, #0xffffffff            	// #-1
    48003888:	b9000020 	str	w0, [x1]
    arm_gicv3_wait_rwp(0, 0);
    4800388c:	52800001 	mov	w1, #0x0                   	// #0
    48003890:	52800000 	mov	w0, #0x0                   	// #0
    48003894:	97fffe65 	bl	48003228 <arm_gicv3_wait_rwp>

    /* Clear all inetrrupt pending */
    GIC_RDISTSGI_ICPENDR0(base) = 0xFFFFFFFF;
    48003898:	b94027e1 	ldr	w1, [sp, #36]
    4800389c:	d2805000 	mov	x0, #0x280                 	// #640
    480038a0:	f2a00020 	movk	x0, #0x1, lsl #16
    480038a4:	8b000020 	add	x0, x1, x0
    480038a8:	aa0003e1 	mov	x1, x0
    480038ac:	12800000 	mov	w0, #0xffffffff            	// #-1
    480038b0:	b9000020 	str	w0, [x1]

    /* the corresponding interrupt is Group 1 or Non-secure Group 1. */
    GIC_RDISTSGI_IGROUPR0(base, 0) = 0xFFFFFFFF;
    480038b4:	b94027e1 	ldr	w1, [sp, #36]
    480038b8:	d2801000 	mov	x0, #0x80                  	// #128
    480038bc:	f2a00020 	movk	x0, #0x1, lsl #16
    480038c0:	8b000020 	add	x0, x1, x0
    480038c4:	aa0003e1 	mov	x1, x0
    480038c8:	12800000 	mov	w0, #0xffffffff            	// #-1
    480038cc:	b9000020 	str	w0, [x1]
    GIC_RDISTSGI_IGRPMODR0(base, 0) = 0xFFFFFFFF;
    480038d0:	b94027e1 	ldr	w1, [sp, #36]
    480038d4:	d281a000 	mov	x0, #0xd00                 	// #3328
    480038d8:	f2a00020 	movk	x0, #0x1, lsl #16
    480038dc:	8b000020 	add	x0, x1, x0
    480038e0:	aa0003e1 	mov	x1, x0
    480038e4:	12800000 	mov	w0, #0xffffffff            	// #-1
    480038e8:	b9000020 	str	w0, [x1]

    /* Configure default priorities for SGI 0:15 and PPI 16:31. */
    for (i = 0; i < 32; i += 4)
    480038ec:	b9002fff 	str	wzr, [sp, #44]
    480038f0:	1400000f 	b	4800392c <arm_gic_redist_init+0x184>
    {
        GIC_RDISTSGI_IPRIORITYR(base, i) = 0xa0a0a0a0U;
    480038f4:	b94027e1 	ldr	w1, [sp, #36]
    480038f8:	b9402fe0 	ldr	w0, [sp, #44]
    480038fc:	927e7400 	and	x0, x0, #0xfffffffc
    48003900:	8b000021 	add	x1, x1, x0
    48003904:	d2808000 	mov	x0, #0x400                 	// #1024
    48003908:	f2a00020 	movk	x0, #0x1, lsl #16
    4800390c:	8b000020 	add	x0, x1, x0
    48003910:	aa0003e1 	mov	x1, x0
    48003914:	52941400 	mov	w0, #0xa0a0                	// #41120
    48003918:	72b41400 	movk	w0, #0xa0a0, lsl #16
    4800391c:	b9000020 	str	w0, [x1]
    for (i = 0; i < 32; i += 4)
    48003920:	b9402fe0 	ldr	w0, [sp, #44]
    48003924:	11001000 	add	w0, w0, #0x4
    48003928:	b9002fe0 	str	w0, [sp, #44]
    4800392c:	b9402fe0 	ldr	w0, [sp, #44]
    48003930:	71007c1f 	cmp	w0, #0x1f
    48003934:	54fffe09 	b.ls	480038f4 <arm_gic_redist_init+0x14c>  // b.plast
    }

    /* Trigger level for PPI interrupts*/
    GIC_RDISTSGI_ICFGR1(base) = 0x0U; // PPI is level-sensitive.
    48003938:	b94027e1 	ldr	w1, [sp, #36]
    4800393c:	d2818080 	mov	x0, #0xc04                 	// #3076
    48003940:	f2a00020 	movk	x0, #0x1, lsl #16
    48003944:	8b000020 	add	x0, x1, x0
    48003948:	b900001f 	str	wzr, [x0]
    return 0;
    4800394c:	52800000 	mov	w0, #0x0                   	// #0
}
    48003950:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48003954:	d65f03c0 	ret

0000000048003958 <arm_gic_cpu_init>:

int arm_gic_cpu_init(rt_uint32_t index)
{
    48003958:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800395c:	910003fd 	mov	x29, sp
    48003960:	b9001fe0 	str	w0, [sp, #28]
    rt_uint32_t value;
    RT_ASSERT(index < ARM_GIC_MAX_NR);
    48003964:	b9401fe0 	ldr	w0, [sp, #28]
    48003968:	7100001f 	cmp	w0, #0x0
    4800396c:	540000e0 	b.eq	48003988 <arm_gic_cpu_init+0x30>  // b.none
    48003970:	d2805402 	mov	x2, #0x2a0                 	// #672
    48003974:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48003978:	9106a001 	add	x1, x0, #0x1a8
    4800397c:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003980:	91364000 	add	x0, x0, #0xd90
    48003984:	940031b9 	bl	48010068 <rt_assert_handler>

    value = arm_gic_get_system_register_enable_mask(index);
    48003988:	b9401fe0 	ldr	w0, [sp, #28]
    4800398c:	97fffcb3 	bl	48002c58 <arm_gic_get_system_register_enable_mask>
    48003990:	b9002fe0 	str	w0, [sp, #44]
    value |= (1U << 0);
    48003994:	b9402fe0 	ldr	w0, [sp, #44]
    48003998:	32000000 	orr	w0, w0, #0x1
    4800399c:	b9002fe0 	str	w0, [sp, #44]
    arm_gic_set_system_register_enable_mask(index, value);
    480039a0:	b9402fe1 	ldr	w1, [sp, #44]
    480039a4:	b9401fe0 	ldr	w0, [sp, #28]
    480039a8:	97fffc96 	bl	48002c00 <arm_gic_set_system_register_enable_mask>
    __set_gicv3_reg(ICC_CTLR_EL1, 0);
    480039ac:	52800000 	mov	w0, #0x0                   	// #0
    480039b0:	d518cc80 	msr	s3_0_c12_c12_4, x0

    arm_gic_set_interface_prior_mask(index, 0xFFU);
    480039b4:	52801fe1 	mov	w1, #0xff                  	// #255
    480039b8:	b9401fe0 	ldr	w0, [sp, #28]
    480039bc:	97fffcb8 	bl	48002c9c <arm_gic_set_interface_prior_mask>

    /* Enable group1 interrupt */
    value = 0x1U;
    480039c0:	52800020 	mov	w0, #0x1                   	// #1
    480039c4:	b9002fe0 	str	w0, [sp, #44]
    __set_gicv3_reg(ICC_IGRPEN1_EL1, value);
    480039c8:	b9402fe0 	ldr	w0, [sp, #44]
    480039cc:	d518cce0 	msr	s3_0_c12_c12_7, x0

    arm_gic_set_binary_point(0, 0);
    480039d0:	52800001 	mov	w1, #0x0                   	// #0
    480039d4:	52800000 	mov	w0, #0x0                   	// #0
    480039d8:	97fffcd7 	bl	48002d34 <arm_gic_set_binary_point>

    /* ICC_BPR0_EL1 determines the preemption group for both
       Group 0 and Group 1 interrupts.
       */
    value = 0x1U;
    480039dc:	52800020 	mov	w0, #0x1                   	// #1
    480039e0:	b9002fe0 	str	w0, [sp, #44]
    __set_gicv3_reg(ICC_CTLR_EL1, value);
    480039e4:	b9402fe0 	ldr	w0, [sp, #44]
    480039e8:	d518cc80 	msr	s3_0_c12_c12_4, x0

    return 0;
    480039ec:	52800000 	mov	w0, #0x0                   	// #0
}
    480039f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480039f4:	d65f03c0 	ret

00000000480039f8 <arm_gic_dump_type>:
    arm_gic_cpu_init(0);
}
#endif

void arm_gic_dump_type(rt_uint32_t index)
{
    480039f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480039fc:	910003fd 	mov	x29, sp
    48003a00:	b9001fe0 	str	w0, [sp, #28]
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
    48003a04:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003a08:	91002001 	add	x1, x0, #0x8
    48003a0c:	b9401fe2 	ldr	w2, [sp, #28]
    48003a10:	d2800300 	mov	x0, #0x18                  	// #24
    48003a14:	9b007c40 	mul	x0, x2, x0
    48003a18:	8b000020 	add	x0, x1, x0
    48003a1c:	b9400c00 	ldr	w0, [x0, #12]
    48003a20:	2a0003e0 	mov	w0, w0
    48003a24:	91001000 	add	x0, x0, #0x4
    48003a28:	b9400000 	ldr	w0, [x0]
    48003a2c:	b9002fe0 	str	w0, [sp, #44]
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4U) & 0xfUL,
    48003a30:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003a34:	91002001 	add	x1, x0, #0x8
    48003a38:	b9401fe2 	ldr	w2, [sp, #28]
    48003a3c:	d2800300 	mov	x0, #0x18                  	// #24
    48003a40:	9b007c40 	mul	x0, x2, x0
    48003a44:	8b000020 	add	x0, x1, x0
    48003a48:	b9400c00 	ldr	w0, [x0, #12]
    48003a4c:	2a0003e0 	mov	w0, w0
    48003a50:	913fa000 	add	x0, x0, #0xfe8
    48003a54:	b9400000 	ldr	w0, [x0]
    48003a58:	53047c00 	lsr	w0, w0, #4
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
    48003a5c:	2a0003e0 	mov	w0, w0
    48003a60:	92400c06 	and	x6, x0, #0xf
    48003a64:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003a68:	91002001 	add	x1, x0, #0x8
    48003a6c:	b9401fe2 	ldr	w2, [sp, #28]
    48003a70:	d2800300 	mov	x0, #0x18                  	// #24
    48003a74:	9b007c40 	mul	x0, x2, x0
    48003a78:	8b000020 	add	x0, x1, x0
    48003a7c:	b9400c01 	ldr	w1, [x0, #12]
    48003a80:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003a84:	91008000 	add	x0, x0, #0x20
    48003a88:	b9400002 	ldr	w2, [x0]
               _gic_table[index].dist_hw_base,
               _gic_max_irq,
               gic_type & (1U << 10U) ? "has" : "no",
    48003a8c:	b9402fe0 	ldr	w0, [sp, #44]
    48003a90:	12160000 	and	w0, w0, #0x400
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
    48003a94:	7100001f 	cmp	w0, #0x0
    48003a98:	54000080 	b.eq	48003aa8 <arm_gic_dump_type+0xb0>  // b.none
    48003a9c:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003aa0:	91374000 	add	x0, x0, #0xdd0
    48003aa4:	14000003 	b	48003ab0 <arm_gic_dump_type+0xb8>
    48003aa8:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003aac:	91376000 	add	x0, x0, #0xdd8
    48003ab0:	b9402fe5 	ldr	w5, [sp, #44]
    48003ab4:	aa0003e4 	mov	x4, x0
    48003ab8:	2a0203e3 	mov	w3, w2
    48003abc:	2a0103e2 	mov	w2, w1
    48003ac0:	aa0603e1 	mov	x1, x6
    48003ac4:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003ac8:	91378000 	add	x0, x0, #0xde0
    48003acc:	94003099 	bl	4800fd30 <rt_kprintf>
               gic_type);
}
    48003ad0:	d503201f 	nop
    48003ad4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48003ad8:	d65f03c0 	ret

0000000048003adc <arm_gic_dump>:

void arm_gic_dump(rt_uint32_t index)
{
    48003adc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48003ae0:	910003fd 	mov	x29, sp
    48003ae4:	b9001fe0 	str	w0, [sp, #28]
    unsigned int i, k;

    k = arm_gic_get_high_pending_irq(0);
    48003ae8:	52800000 	mov	w0, #0x0                   	// #0
    48003aec:	97fffd25 	bl	48002f80 <arm_gic_get_high_pending_irq>
    48003af0:	b9002be0 	str	w0, [sp, #40]
    rt_kprintf("--- high pending priority: %d(%08x)\n", k, k);
    48003af4:	b9402be2 	ldr	w2, [sp, #40]
    48003af8:	b9402be1 	ldr	w1, [sp, #40]
    48003afc:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003b00:	91388000 	add	x0, x0, #0xe20
    48003b04:	9400308b 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("--- hw mask ---\n");
    48003b08:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003b0c:	91392000 	add	x0, x0, #0xe48
    48003b10:	94003088 	bl	4800fd30 <rt_kprintf>
    for (i = 0U; i < _gic_max_irq / 32U; i++)
    48003b14:	b9002fff 	str	wzr, [sp, #44]
    48003b18:	14000017 	b	48003b74 <arm_gic_dump+0x98>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base,
    48003b1c:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003b20:	91002001 	add	x1, x0, #0x8
    48003b24:	b9401fe2 	ldr	w2, [sp, #28]
    48003b28:	d2800300 	mov	x0, #0x18                  	// #24
    48003b2c:	9b007c40 	mul	x0, x2, x0
    48003b30:	8b000020 	add	x0, x1, x0
    48003b34:	b9400c00 	ldr	w0, [x0, #12]
    48003b38:	2a0003e1 	mov	w1, w0
    48003b3c:	b9402fe0 	ldr	w0, [sp, #44]
    48003b40:	12006800 	and	w0, w0, #0x7ffffff
    48003b44:	531e7400 	lsl	w0, w0, #2
    48003b48:	2a0003e0 	mov	w0, w0
    48003b4c:	8b000020 	add	x0, x1, x0
    48003b50:	91040000 	add	x0, x0, #0x100
        rt_kprintf("0x%08x, ",
    48003b54:	b9400000 	ldr	w0, [x0]
    48003b58:	2a0003e1 	mov	w1, w0
    48003b5c:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003b60:	91398000 	add	x0, x0, #0xe60
    48003b64:	94003073 	bl	4800fd30 <rt_kprintf>
    for (i = 0U; i < _gic_max_irq / 32U; i++)
    48003b68:	b9402fe0 	ldr	w0, [sp, #44]
    48003b6c:	11000400 	add	w0, w0, #0x1
    48003b70:	b9002fe0 	str	w0, [sp, #44]
    48003b74:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003b78:	91008000 	add	x0, x0, #0x20
    48003b7c:	b9400000 	ldr	w0, [x0]
    48003b80:	53057c00 	lsr	w0, w0, #5
    48003b84:	b9402fe1 	ldr	w1, [sp, #44]
    48003b88:	6b00003f 	cmp	w1, w0
    48003b8c:	54fffc83 	b.cc	48003b1c <arm_gic_dump+0x40>  // b.lo, b.ul, b.last
                                       i * 32U));
    }
    rt_kprintf("\n--- hw pending ---\n");
    48003b90:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003b94:	9139c000 	add	x0, x0, #0xe70
    48003b98:	94003066 	bl	4800fd30 <rt_kprintf>
    for (i = 0U; i < _gic_max_irq / 32U; i++)
    48003b9c:	b9002fff 	str	wzr, [sp, #44]
    48003ba0:	14000017 	b	48003bfc <arm_gic_dump+0x120>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_PENDING_SET(_gic_table[index].dist_hw_base,
    48003ba4:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003ba8:	91002001 	add	x1, x0, #0x8
    48003bac:	b9401fe2 	ldr	w2, [sp, #28]
    48003bb0:	d2800300 	mov	x0, #0x18                  	// #24
    48003bb4:	9b007c40 	mul	x0, x2, x0
    48003bb8:	8b000020 	add	x0, x1, x0
    48003bbc:	b9400c00 	ldr	w0, [x0, #12]
    48003bc0:	2a0003e1 	mov	w1, w0
    48003bc4:	b9402fe0 	ldr	w0, [sp, #44]
    48003bc8:	12006800 	and	w0, w0, #0x7ffffff
    48003bcc:	531e7400 	lsl	w0, w0, #2
    48003bd0:	2a0003e0 	mov	w0, w0
    48003bd4:	8b000020 	add	x0, x1, x0
    48003bd8:	91080000 	add	x0, x0, #0x200
        rt_kprintf("0x%08x, ",
    48003bdc:	b9400000 	ldr	w0, [x0]
    48003be0:	2a0003e1 	mov	w1, w0
    48003be4:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003be8:	91398000 	add	x0, x0, #0xe60
    48003bec:	94003051 	bl	4800fd30 <rt_kprintf>
    for (i = 0U; i < _gic_max_irq / 32U; i++)
    48003bf0:	b9402fe0 	ldr	w0, [sp, #44]
    48003bf4:	11000400 	add	w0, w0, #0x1
    48003bf8:	b9002fe0 	str	w0, [sp, #44]
    48003bfc:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003c00:	91008000 	add	x0, x0, #0x20
    48003c04:	b9400000 	ldr	w0, [x0]
    48003c08:	53057c00 	lsr	w0, w0, #5
    48003c0c:	b9402fe1 	ldr	w1, [sp, #44]
    48003c10:	6b00003f 	cmp	w1, w0
    48003c14:	54fffc83 	b.cc	48003ba4 <arm_gic_dump+0xc8>  // b.lo, b.ul, b.last
                                        i * 32U));
    }
    rt_kprintf("\n--- hw active ---\n");
    48003c18:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003c1c:	913a2000 	add	x0, x0, #0xe88
    48003c20:	94003044 	bl	4800fd30 <rt_kprintf>
    for (i = 0U; i < _gic_max_irq / 32U; i++)
    48003c24:	b9002fff 	str	wzr, [sp, #44]
    48003c28:	14000017 	b	48003c84 <arm_gic_dump+0x1a8>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_ACTIVE_SET(_gic_table[index].dist_hw_base,
    48003c2c:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003c30:	91002001 	add	x1, x0, #0x8
    48003c34:	b9401fe2 	ldr	w2, [sp, #28]
    48003c38:	d2800300 	mov	x0, #0x18                  	// #24
    48003c3c:	9b007c40 	mul	x0, x2, x0
    48003c40:	8b000020 	add	x0, x1, x0
    48003c44:	b9400c00 	ldr	w0, [x0, #12]
    48003c48:	2a0003e1 	mov	w1, w0
    48003c4c:	b9402fe0 	ldr	w0, [sp, #44]
    48003c50:	12006800 	and	w0, w0, #0x7ffffff
    48003c54:	531e7400 	lsl	w0, w0, #2
    48003c58:	2a0003e0 	mov	w0, w0
    48003c5c:	8b000020 	add	x0, x1, x0
    48003c60:	910c0000 	add	x0, x0, #0x300
        rt_kprintf("0x%08x, ",
    48003c64:	b9400000 	ldr	w0, [x0]
    48003c68:	2a0003e1 	mov	w1, w0
    48003c6c:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003c70:	91398000 	add	x0, x0, #0xe60
    48003c74:	9400302f 	bl	4800fd30 <rt_kprintf>
    for (i = 0U; i < _gic_max_irq / 32U; i++)
    48003c78:	b9402fe0 	ldr	w0, [sp, #44]
    48003c7c:	11000400 	add	w0, w0, #0x1
    48003c80:	b9002fe0 	str	w0, [sp, #44]
    48003c84:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003c88:	91008000 	add	x0, x0, #0x20
    48003c8c:	b9400000 	ldr	w0, [x0]
    48003c90:	53057c00 	lsr	w0, w0, #5
    48003c94:	b9402fe1 	ldr	w1, [sp, #44]
    48003c98:	6b00003f 	cmp	w1, w0
    48003c9c:	54fffc83 	b.cc	48003c2c <arm_gic_dump+0x150>  // b.lo, b.ul, b.last
                                       i * 32U));
    }
    rt_kprintf("\n");
    48003ca0:	d00000c0 	adrp	x0, 4801d000 <_strtol_l.part.0+0x70>
    48003ca4:	913a8000 	add	x0, x0, #0xea0
    48003ca8:	94003022 	bl	4800fd30 <rt_kprintf>
}
    48003cac:	d503201f 	nop
    48003cb0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48003cb4:	d65f03c0 	ret

0000000048003cb8 <gic_dump>:

long gic_dump(void)
{
    48003cb8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48003cbc:	910003fd 	mov	x29, sp
    arm_gic_dump_type(0);
    48003cc0:	52800000 	mov	w0, #0x0                   	// #0
    48003cc4:	97ffff4d 	bl	480039f8 <arm_gic_dump_type>
    arm_gic_dump(0);
    48003cc8:	52800000 	mov	w0, #0x0                   	// #0
    48003ccc:	97ffff84 	bl	48003adc <arm_gic_dump>

    return 0;
    48003cd0:	d2800000 	mov	x0, #0x0                   	// #0
}
    48003cd4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48003cd8:	d65f03c0 	ret

0000000048003cdc <platform_get_gic_dist_base>:
    return GIC_500_REDISTRIBUTOR_PPTR;
}

rt_inline rt_uint32_t platform_get_gic_dist_base(void)
{
    return GIC_500_DISTRIBUTOR_PPTR;
    48003cdc:	52bfdc00 	mov	w0, #0xfee00000            	// #-18874368
}
    48003ce0:	d65f03c0 	ret

0000000048003ce4 <rt_hw_vector_init>:
rt_ubase_t rt_interrupt_from_thread;
rt_ubase_t rt_interrupt_to_thread;
rt_ubase_t rt_thread_switch_interrupt_flag;

void rt_hw_vector_init(void)
{
    48003ce4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48003ce8:	910003fd 	mov	x29, sp
    rt_hw_set_current_vbar((rt_ubase_t)&system_vectors);  // cpu_gcc.S
    48003cec:	d0ffffe0 	adrp	x0, 48001000 <system_vectors>
    48003cf0:	91000000 	add	x0, x0, #0x0
    48003cf4:	9400018b 	bl	48004320 <rt_hw_set_current_vbar>

}
    48003cf8:	d503201f 	nop
    48003cfc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48003d00:	d65f03c0 	ret

0000000048003d04 <rt_hw_interrupt_init>:

/**
 * This function will initialize hardware interrupt
 */
void rt_hw_interrupt_init(void)
{
    48003d04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48003d08:	910003fd 	mov	x29, sp
    rt_uint32_t gic_dist_base   = 0;
    48003d0c:	b9001fff 	str	wzr, [sp, #28]
    /* initialize ARM GIC */
    gic_dist_base =    platform_get_gic_dist_base();
    48003d10:	97fffff3 	bl	48003cdc <platform_get_gic_dist_base>
    48003d14:	b9001fe0 	str	w0, [sp, #28]

    arm_gic_dist_init(0, gic_dist_base, 0);
    48003d18:	52800002 	mov	w2, #0x0                   	// #0
    48003d1c:	b9401fe1 	ldr	w1, [sp, #28]
    48003d20:	52800000 	mov	w0, #0x0                   	// #0
    48003d24:	97fffd80 	bl	48003324 <arm_gic_dist_init>
    arm_gic_cpu_init(0);
    48003d28:	52800000 	mov	w0, #0x0                   	// #0
    48003d2c:	97ffff0b 	bl	48003958 <arm_gic_cpu_init>
    arm_gic_redist_init(0);
    48003d30:	52800000 	mov	w0, #0x0                   	// #0
    48003d34:	97fffe9d 	bl	480037a8 <arm_gic_redist_init>
}
    48003d38:	d503201f 	nop
    48003d3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48003d40:	d65f03c0 	ret

0000000048003d44 <rt_hw_interrupt_install>:
 * @param new_handler the interrupt service routine to be installed
 * @param old_handler the old interrupt service routine
 */
rt_isr_handler_t rt_hw_interrupt_install(int vector, rt_isr_handler_t handler,
        void *param, const char *name)
{
    48003d44:	d100c3ff 	sub	sp, sp, #0x30
    48003d48:	b9001fe0 	str	w0, [sp, #28]
    48003d4c:	f9000be1 	str	x1, [sp, #16]
    48003d50:	f90007e2 	str	x2, [sp, #8]
    48003d54:	f90003e3 	str	x3, [sp]
    rt_isr_handler_t old_handler = RT_NULL;
    48003d58:	f90017ff 	str	xzr, [sp, #40]

    if (vector < MAX_HANDLERS)
    48003d5c:	b9401fe0 	ldr	w0, [sp, #28]
    48003d60:	7107fc1f 	cmp	w0, #0x1ff
    48003d64:	5400032c 	b.gt	48003dc8 <rt_hw_interrupt_install+0x84>
    {
        old_handler = isr_table[vector].handler;
    48003d68:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003d6c:	9100a001 	add	x1, x0, #0x28
    48003d70:	b9801fe0 	ldrsw	x0, [sp, #28]
    48003d74:	d37cec00 	lsl	x0, x0, #4
    48003d78:	8b000020 	add	x0, x1, x0
    48003d7c:	f9400000 	ldr	x0, [x0]
    48003d80:	f90017e0 	str	x0, [sp, #40]

        if (handler != RT_NULL)
    48003d84:	f9400be0 	ldr	x0, [sp, #16]
    48003d88:	f100001f 	cmp	x0, #0x0
    48003d8c:	540001e0 	b.eq	48003dc8 <rt_hw_interrupt_install+0x84>  // b.none
        {
#ifdef RT_USING_INTERRUPT_INFO
            rt_strncpy(isr_table[vector].name, name, RT_NAME_MAX);
#endif /* RT_USING_INTERRUPT_INFO */
            isr_table[vector].handler = handler;
    48003d90:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003d94:	9100a001 	add	x1, x0, #0x28
    48003d98:	b9801fe0 	ldrsw	x0, [sp, #28]
    48003d9c:	d37cec00 	lsl	x0, x0, #4
    48003da0:	8b000020 	add	x0, x1, x0
    48003da4:	f9400be1 	ldr	x1, [sp, #16]
    48003da8:	f9000001 	str	x1, [x0]
            isr_table[vector].param = param;
    48003dac:	f0000180 	adrp	x0, 48036000 <__page_off>
    48003db0:	9100a001 	add	x1, x0, #0x28
    48003db4:	b9801fe0 	ldrsw	x0, [sp, #28]
    48003db8:	d37cec00 	lsl	x0, x0, #4
    48003dbc:	8b000020 	add	x0, x1, x0
    48003dc0:	f94007e1 	ldr	x1, [sp, #8]
    48003dc4:	f9000401 	str	x1, [x0, #8]
        }
    }

    return old_handler;
    48003dc8:	f94017e0 	ldr	x0, [sp, #40]
}
    48003dcc:	9100c3ff 	add	sp, sp, #0x30
    48003dd0:	d65f03c0 	ret

0000000048003dd4 <rt_hw_interrupt_mask>:
/**
 * This function will mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_mask(int vector)
{
    48003dd4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48003dd8:	910003fd 	mov	x29, sp
    48003ddc:	b9001fe0 	str	w0, [sp, #28]
    arm_gic_mask(0, vector);
    48003de0:	b9401fe1 	ldr	w1, [sp, #28]
    48003de4:	52800000 	mov	w0, #0x0                   	// #0
    48003de8:	97fff7fc 	bl	48001dd8 <arm_gic_mask>
}
    48003dec:	d503201f 	nop
    48003df0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48003df4:	d65f03c0 	ret

0000000048003df8 <rt_hw_interrupt_umask>:
/**
 * This function will un-mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_umask(int vector)
{
    48003df8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48003dfc:	910003fd 	mov	x29, sp
    48003e00:	b9001fe0 	str	w0, [sp, #28]
    arm_gic_umask(0, vector);
    48003e04:	b9401fe1 	ldr	w1, [sp, #28]
    48003e08:	52800000 	mov	w0, #0x0                   	// #0
    48003e0c:	97fff845 	bl	48001f20 <arm_gic_umask>
}
    48003e10:	d503201f 	nop
    48003e14:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48003e18:	d65f03c0 	ret

0000000048003e1c <rt_hw_interrupt_get_irq>:
/**
 * This function returns the active interrupt number.
 * @param none
 */
int rt_hw_interrupt_get_irq(void)
{
    48003e1c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48003e20:	910003fd 	mov	x29, sp
    return (arm_gic_get_active_irq(0) & GIC_ACK_INTID_MASK);
    48003e24:	52800000 	mov	w0, #0x0                   	// #0
    48003e28:	97fff7bd 	bl	48001d1c <arm_gic_get_active_irq>
    48003e2c:	12002400 	and	w0, w0, #0x3ff
}
    48003e30:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48003e34:	d65f03c0 	ret

0000000048003e38 <rt_hw_interrupt_ack>:
/**
 * This function acknowledges the interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_ack(int vector)
{
    48003e38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48003e3c:	910003fd 	mov	x29, sp
    48003e40:	b9001fe0 	str	w0, [sp, #28]
    arm_gic_ack(0, vector);
    48003e44:	b9401fe1 	ldr	w1, [sp, #28]
    48003e48:	52800000 	mov	w0, #0x0                   	// #0
    48003e4c:	97fff7d0 	bl	48001d8c <arm_gic_ack>
}
    48003e50:	d503201f 	nop
    48003e54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48003e58:	d65f03c0 	ret

0000000048003e5c <__asm_dcache_level>:
 * x1: 0 clean & invalidate, 1 invalidate only
 * x2~x9: clobbered
 */
.globl __asm_dcache_level
__asm_dcache_level:
    lsl    x12, x0, #1
    48003e5c:	d37ff80c 	lsl	x12, x0, #1
    msr    csselr_el1, x12        /* select cache level */
    48003e60:	d51a000c 	msr	csselr_el1, x12
    isb                /* sync change of cssidr_el1 */
    48003e64:	d5033fdf 	isb
    mrs    x6, ccsidr_el1        /* read the new cssidr_el1 */
    48003e68:	d5390006 	mrs	x6, ccsidr_el1
    and    x2, x6, #7        /* x2 <- log2(cache line size)-4 */
    48003e6c:	924008c2 	and	x2, x6, #0x7
    add    x2, x2, #4        /* x2 <- log2(cache line size) */
    48003e70:	91001042 	add	x2, x2, #0x4
    mov    x3, #0x3ff
    48003e74:	d2807fe3 	mov	x3, #0x3ff                 	// #1023
    and    x3, x3, x6, lsr #3    /* x3 <- max number of #ways */
    48003e78:	8a460c63 	and	x3, x3, x6, lsr #3
    clz    w5, w3            /* bit position of #ways */
    48003e7c:	5ac01065 	clz	w5, w3
    mov    x4, #0x7fff
    48003e80:	d28fffe4 	mov	x4, #0x7fff                	// #32767
    and    x4, x4, x6, lsr #13    /* x4 <- max number of #sets */
    48003e84:	8a463484 	and	x4, x4, x6, lsr #13

0000000048003e88 <loop_set>:
    /* x3 <- number of cache ways - 1 */
    /* x4 <- number of cache sets - 1 */
    /* x5 <- bit position of #ways */

loop_set:
    mov    x6, x3            /* x6 <- working copy of #ways */
    48003e88:	aa0303e6 	mov	x6, x3

0000000048003e8c <loop_way>:
loop_way:
    lsl    x7, x6, x5
    48003e8c:	9ac520c7 	lsl	x7, x6, x5
    orr    x9, x12, x7        /* map way and level to cisw value */
    48003e90:	aa070189 	orr	x9, x12, x7
    lsl    x7, x4, x2
    48003e94:	9ac22087 	lsl	x7, x4, x2
    orr    x9, x9, x7        /* map set number to cisw value */
    48003e98:	aa070129 	orr	x9, x9, x7
    tbz    w1, #0, 1f
    48003e9c:	36000061 	tbz	w1, #0, 48003ea8 <loop_way+0x1c>
    dc    isw, x9
    48003ea0:	d5087649 	dc	isw, x9
    b    2f
    48003ea4:	14000002 	b	48003eac <loop_way+0x20>
1:    dc    cisw, x9        /* clean & invalidate by set/way */
    48003ea8:	d5087e49 	dc	cisw, x9
2:    subs    x6, x6, #1        /* decrement the way */
    48003eac:	f10004c6 	subs	x6, x6, #0x1
    b.ge    loop_way
    48003eb0:	54fffeea 	b.ge	48003e8c <loop_way>  // b.tcont
    subs    x4, x4, #1        /* decrement the set */
    48003eb4:	f1000484 	subs	x4, x4, #0x1
    b.ge    loop_set
    48003eb8:	54fffe8a 	b.ge	48003e88 <loop_set>  // b.tcont

    ret
    48003ebc:	d65f03c0 	ret

0000000048003ec0 <__asm_dcache_all>:
 *
 * flush or invalidate all data cache by SET/WAY.
 */
.globl __asm_dcache_all
__asm_dcache_all:
    mov    x1, x0
    48003ec0:	aa0003e1 	mov	x1, x0
    dsb    sy
    48003ec4:	d5033f9f 	dsb	sy
    mrs    x10, clidr_el1        /* read clidr_el1 */
    48003ec8:	d539002a 	mrs	x10, clidr_el1
    lsr    x11, x10, #24
    48003ecc:	d358fd4b 	lsr	x11, x10, #24
    and    x11, x11, #0x7        /* x11 <- loc */
    48003ed0:	9240096b 	and	x11, x11, #0x7
    cbz    x11, finished        /* if loc is 0, exit */
    48003ed4:	b400024b 	cbz	x11, 48003f1c <finished>
    mov    x15, lr
    48003ed8:	aa1e03ef 	mov	x15, x30
    mov    x0, #0            /* start flush at cache level 0 */
    48003edc:	d2800000 	mov	x0, #0x0                   	// #0

0000000048003ee0 <loop_level>:
    /* x10 <- clidr_el1 */
    /* x11 <- loc */
    /* x15 <- return address */

loop_level:
    lsl    x12, x0, #1
    48003ee0:	d37ff80c 	lsl	x12, x0, #1
    add    x12, x12, x0        /* x0 <- tripled cache level */
    48003ee4:	8b00018c 	add	x12, x12, x0
    lsr    x12, x10, x12
    48003ee8:	9acc254c 	lsr	x12, x10, x12
    and    x12, x12, #7        /* x12 <- cache type */
    48003eec:	9240098c 	and	x12, x12, #0x7
    cmp    x12, #2
    48003ef0:	f100099f 	cmp	x12, #0x2
    b.lt    skip            /* skip if no cache or icache */
    48003ef4:	5400004b 	b.lt	48003efc <skip>  // b.tstop
    bl    __asm_dcache_level    /* x1 = 0 flush, 1 invalidate */
    48003ef8:	97ffffd9 	bl	48003e5c <__asm_dcache_level>

0000000048003efc <skip>:
skip:
    add    x0, x0, #1        /* increment cache level */
    48003efc:	91000400 	add	x0, x0, #0x1
    cmp    x11, x0
    48003f00:	eb00017f 	cmp	x11, x0
    b.gt    loop_level
    48003f04:	54fffeec 	b.gt	48003ee0 <loop_level>

    mov    x0, #0
    48003f08:	d2800000 	mov	x0, #0x0                   	// #0
    msr    csselr_el1, x0        /* restore csselr_el1 */
    48003f0c:	d51a0000 	msr	csselr_el1, x0
    dsb    sy
    48003f10:	d5033f9f 	dsb	sy
    isb
    48003f14:	d5033fdf 	isb
    mov    lr, x15
    48003f18:	aa0f03fe 	mov	x30, x15

0000000048003f1c <finished>:

finished:
    ret
    48003f1c:	d65f03c0 	ret

0000000048003f20 <__asm_flush_dcache_all>:

.globl __asm_flush_dcache_all
__asm_flush_dcache_all:
    mov    x0, #0
    48003f20:	d2800000 	mov	x0, #0x0                   	// #0
    b    __asm_dcache_all
    48003f24:	17ffffe7 	b	48003ec0 <__asm_dcache_all>

0000000048003f28 <__asm_invalidate_dcache_all>:

.globl __asm_invalidate_dcache_all
__asm_invalidate_dcache_all:
    mov    x0, #0x1
    48003f28:	d2800020 	mov	x0, #0x1                   	// #1
    b    __asm_dcache_all
    48003f2c:	17ffffe5 	b	48003ec0 <__asm_dcache_all>

0000000048003f30 <__asm_flush_dcache_range>:
 * x0: start address
 * x1: end address
 */
.globl __asm_flush_dcache_range
__asm_flush_dcache_range:
    mrs    x3, ctr_el0
    48003f30:	d53b0023 	mrs	x3, ctr_el0
    lsr    x3, x3, #16
    48003f34:	d350fc63 	lsr	x3, x3, #16
    and    x3, x3, #0xf
    48003f38:	92400c63 	and	x3, x3, #0xf
    mov    x2, #4
    48003f3c:	d2800082 	mov	x2, #0x4                   	// #4
    lsl    x2, x2, x3        /* cache line size */
    48003f40:	9ac32042 	lsl	x2, x2, x3

    /* x2 <- minimal cache line size in cache system */
    sub    x3, x2, #1
    48003f44:	d1000443 	sub	x3, x2, #0x1
    bic    x0, x0, x3
    48003f48:	8a230000 	bic	x0, x0, x3
1:    dc    civac, x0    /* clean & invalidate data or unified cache */
    48003f4c:	d50b7e20 	dc	civac, x0
    add    x0, x0, x2
    48003f50:	8b020000 	add	x0, x0, x2
    cmp    x0, x1
    48003f54:	eb01001f 	cmp	x0, x1
    b.lo    1b
    48003f58:	54ffffa3 	b.cc	48003f4c <__asm_flush_dcache_range+0x1c>  // b.lo, b.ul, b.last
    dsb    sy
    48003f5c:	d5033f9f 	dsb	sy
    ret
    48003f60:	d65f03c0 	ret

0000000048003f64 <__asm_invalidate_icache_all>:
 *
 * invalidate all tlb entries.
 */
.globl __asm_invalidate_icache_all
__asm_invalidate_icache_all:
    ic    ialluis
    48003f64:	d508711f 	ic	ialluis
    isb    sy
    48003f68:	d5033fdf 	isb
    ret
    48003f6c:	d65f03c0 	ret

0000000048003f70 <__asm_flush_l3_cache>:

.globl __asm_flush_l3_cache
__asm_flush_l3_cache:
    mov    x0, #0            /* return status as success */
    48003f70:	d2800000 	mov	x0, #0x0                   	// #0
    48003f74:	d65f03c0 	ret

0000000048003f78 <arm_smccc_smc>:
 * The SMC instruction is used to generate a synchronous exception that is
 * handled by Secure Monitor code running in EL3.
 */
.globl arm_smccc_smc
arm_smccc_smc:
    48003f78:	d4000003 	smc	#0x0
    48003f7c:	f94003e8 	ldr	x8, [sp]
    48003f80:	a9000500 	stp	x0, x1, [x8]
    48003f84:	a9010d02 	stp	x2, x3, [x8, #16]
    48003f88:	a9021504 	stp	x4, x5, [x8, #32]
    48003f8c:	a9031d06 	stp	x6, x7, [x8, #48]
    48003f90:	d65f03c0 	ret

0000000048003f94 <rt_hw_show_register>:
 * this function will show registers of CPU
 *
 * @param regs the registers point
 */
void rt_hw_show_register(struct rt_hw_exp_stack *regs)
{
    48003f94:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48003f98:	910003fd 	mov	x29, sp
    48003f9c:	f9000fe0 	str	x0, [sp, #24]
    rt_kprintf("Execption:\n");
    48003fa0:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48003fa4:	91070000 	add	x0, x0, #0x1c0
    48003fa8:	94002f62 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X00:0x%16.16p X01:0x%16.16p X02:0x%16.16p X03:0x%16.16p\n", (void *)regs->x0, (void *)regs->x1, (void *)regs->x2, (void *)regs->x3);
    48003fac:	f9400fe0 	ldr	x0, [sp, #24]
    48003fb0:	f9408000 	ldr	x0, [x0, #256]
    48003fb4:	aa0003e1 	mov	x1, x0
    48003fb8:	f9400fe0 	ldr	x0, [sp, #24]
    48003fbc:	f9408400 	ldr	x0, [x0, #264]
    48003fc0:	aa0003e2 	mov	x2, x0
    48003fc4:	f9400fe0 	ldr	x0, [sp, #24]
    48003fc8:	f9407800 	ldr	x0, [x0, #240]
    48003fcc:	aa0003e3 	mov	x3, x0
    48003fd0:	f9400fe0 	ldr	x0, [sp, #24]
    48003fd4:	f9407c00 	ldr	x0, [x0, #248]
    48003fd8:	aa0003e4 	mov	x4, x0
    48003fdc:	f00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48003fe0:	91074000 	add	x0, x0, #0x1d0
    48003fe4:	94002f53 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X04:0x%16.16p X05:0x%16.16p X06:0x%16.16p X07:0x%16.16p\n", (void *)regs->x4, (void *)regs->x5, (void *)regs->x6, (void *)regs->x7);
    48003fe8:	f9400fe0 	ldr	x0, [sp, #24]
    48003fec:	f9407000 	ldr	x0, [x0, #224]
    48003ff0:	aa0003e1 	mov	x1, x0
    48003ff4:	f9400fe0 	ldr	x0, [sp, #24]
    48003ff8:	f9407400 	ldr	x0, [x0, #232]
    48003ffc:	aa0003e2 	mov	x2, x0
    48004000:	f9400fe0 	ldr	x0, [sp, #24]
    48004004:	f9406800 	ldr	x0, [x0, #208]
    48004008:	aa0003e3 	mov	x3, x0
    4800400c:	f9400fe0 	ldr	x0, [sp, #24]
    48004010:	f9406c00 	ldr	x0, [x0, #216]
    48004014:	aa0003e4 	mov	x4, x0
    48004018:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800401c:	91084000 	add	x0, x0, #0x210
    48004020:	94002f44 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X08:0x%16.16p X09:0x%16.16p X10:0x%16.16p X11:0x%16.16p\n", (void *)regs->x8, (void *)regs->x9, (void *)regs->x10, (void *)regs->x11);
    48004024:	f9400fe0 	ldr	x0, [sp, #24]
    48004028:	f9406000 	ldr	x0, [x0, #192]
    4800402c:	aa0003e1 	mov	x1, x0
    48004030:	f9400fe0 	ldr	x0, [sp, #24]
    48004034:	f9406400 	ldr	x0, [x0, #200]
    48004038:	aa0003e2 	mov	x2, x0
    4800403c:	f9400fe0 	ldr	x0, [sp, #24]
    48004040:	f9405800 	ldr	x0, [x0, #176]
    48004044:	aa0003e3 	mov	x3, x0
    48004048:	f9400fe0 	ldr	x0, [sp, #24]
    4800404c:	f9405c00 	ldr	x0, [x0, #184]
    48004050:	aa0003e4 	mov	x4, x0
    48004054:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004058:	91094000 	add	x0, x0, #0x250
    4800405c:	94002f35 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X12:0x%16.16p X13:0x%16.16p X14:0x%16.16p X15:0x%16.16p\n", (void *)regs->x12, (void *)regs->x13, (void *)regs->x14, (void *)regs->x15);
    48004060:	f9400fe0 	ldr	x0, [sp, #24]
    48004064:	f9405000 	ldr	x0, [x0, #160]
    48004068:	aa0003e1 	mov	x1, x0
    4800406c:	f9400fe0 	ldr	x0, [sp, #24]
    48004070:	f9405400 	ldr	x0, [x0, #168]
    48004074:	aa0003e2 	mov	x2, x0
    48004078:	f9400fe0 	ldr	x0, [sp, #24]
    4800407c:	f9404800 	ldr	x0, [x0, #144]
    48004080:	aa0003e3 	mov	x3, x0
    48004084:	f9400fe0 	ldr	x0, [sp, #24]
    48004088:	f9404c00 	ldr	x0, [x0, #152]
    4800408c:	aa0003e4 	mov	x4, x0
    48004090:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004094:	910a4000 	add	x0, x0, #0x290
    48004098:	94002f26 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X16:0x%16.16p X17:0x%16.16p X18:0x%16.16p X19:0x%16.16p\n", (void *)regs->x16, (void *)regs->x17, (void *)regs->x18, (void *)regs->x19);
    4800409c:	f9400fe0 	ldr	x0, [sp, #24]
    480040a0:	f9404000 	ldr	x0, [x0, #128]
    480040a4:	aa0003e1 	mov	x1, x0
    480040a8:	f9400fe0 	ldr	x0, [sp, #24]
    480040ac:	f9404400 	ldr	x0, [x0, #136]
    480040b0:	aa0003e2 	mov	x2, x0
    480040b4:	f9400fe0 	ldr	x0, [sp, #24]
    480040b8:	f9403800 	ldr	x0, [x0, #112]
    480040bc:	aa0003e3 	mov	x3, x0
    480040c0:	f9400fe0 	ldr	x0, [sp, #24]
    480040c4:	f9403c00 	ldr	x0, [x0, #120]
    480040c8:	aa0003e4 	mov	x4, x0
    480040cc:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480040d0:	910b4000 	add	x0, x0, #0x2d0
    480040d4:	94002f17 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X20:0x%16.16p X21:0x%16.16p X22:0x%16.16p X23:0x%16.16p\n", (void *)regs->x20, (void *)regs->x21, (void *)regs->x22, (void *)regs->x23);
    480040d8:	f9400fe0 	ldr	x0, [sp, #24]
    480040dc:	f9403000 	ldr	x0, [x0, #96]
    480040e0:	aa0003e1 	mov	x1, x0
    480040e4:	f9400fe0 	ldr	x0, [sp, #24]
    480040e8:	f9403400 	ldr	x0, [x0, #104]
    480040ec:	aa0003e2 	mov	x2, x0
    480040f0:	f9400fe0 	ldr	x0, [sp, #24]
    480040f4:	f9402800 	ldr	x0, [x0, #80]
    480040f8:	aa0003e3 	mov	x3, x0
    480040fc:	f9400fe0 	ldr	x0, [sp, #24]
    48004100:	f9402c00 	ldr	x0, [x0, #88]
    48004104:	aa0003e4 	mov	x4, x0
    48004108:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800410c:	910c4000 	add	x0, x0, #0x310
    48004110:	94002f08 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X24:0x%16.16p X25:0x%16.16p X26:0x%16.16p X27:0x%16.16p\n", (void *)regs->x24, (void *)regs->x25, (void *)regs->x26, (void *)regs->x27);
    48004114:	f9400fe0 	ldr	x0, [sp, #24]
    48004118:	f9402000 	ldr	x0, [x0, #64]
    4800411c:	aa0003e1 	mov	x1, x0
    48004120:	f9400fe0 	ldr	x0, [sp, #24]
    48004124:	f9402400 	ldr	x0, [x0, #72]
    48004128:	aa0003e2 	mov	x2, x0
    4800412c:	f9400fe0 	ldr	x0, [sp, #24]
    48004130:	f9401800 	ldr	x0, [x0, #48]
    48004134:	aa0003e3 	mov	x3, x0
    48004138:	f9400fe0 	ldr	x0, [sp, #24]
    4800413c:	f9401c00 	ldr	x0, [x0, #56]
    48004140:	aa0003e4 	mov	x4, x0
    48004144:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004148:	910d4000 	add	x0, x0, #0x350
    4800414c:	94002ef9 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("X28:0x%16.16p X29:0x%16.16p X30:0x%16.16p\n", (void *)regs->x28, (void *)regs->x29, (void *)regs->x30);
    48004150:	f9400fe0 	ldr	x0, [sp, #24]
    48004154:	f9401000 	ldr	x0, [x0, #32]
    48004158:	aa0003e1 	mov	x1, x0
    4800415c:	f9400fe0 	ldr	x0, [sp, #24]
    48004160:	f9401400 	ldr	x0, [x0, #40]
    48004164:	aa0003e2 	mov	x2, x0
    48004168:	f9400fe0 	ldr	x0, [sp, #24]
    4800416c:	f9400800 	ldr	x0, [x0, #16]
    48004170:	aa0003e3 	mov	x3, x0
    48004174:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004178:	910e4000 	add	x0, x0, #0x390
    4800417c:	94002eed 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("SPSR  :0x%16.16p\n", (void *)regs->spsr);
    48004180:	f9400fe0 	ldr	x0, [sp, #24]
    48004184:	f9400400 	ldr	x0, [x0, #8]
    48004188:	aa0003e1 	mov	x1, x0
    4800418c:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004190:	910f0000 	add	x0, x0, #0x3c0
    48004194:	94002ee7 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("EPC   :0x%16.16p\n", (void *)regs->pc);
    48004198:	f9400fe0 	ldr	x0, [sp, #24]
    4800419c:	f9400000 	ldr	x0, [x0]
    480041a0:	aa0003e1 	mov	x1, x0
    480041a4:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480041a8:	910f6000 	add	x0, x0, #0x3d8
    480041ac:	94002ee1 	bl	4800fd30 <rt_kprintf>
}
    480041b0:	d503201f 	nop
    480041b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480041b8:	d65f03c0 	ret

00000000480041bc <rt_hw_trap_error>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_error(struct rt_hw_exp_stack *regs)
{
    480041bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480041c0:	910003fd 	mov	x29, sp
    480041c4:	f9000fe0 	str	x0, [sp, #24]
    rt_kprintf("error exception:\n");
    480041c8:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480041cc:	910fc000 	add	x0, x0, #0x3f0
    480041d0:	94002ed8 	bl	4800fd30 <rt_kprintf>
    rt_hw_show_register(regs);
    480041d4:	f9400fe0 	ldr	x0, [sp, #24]
    480041d8:	97ffff6f 	bl	48003f94 <rt_hw_show_register>

    rt_hw_cpu_shutdown();
    480041dc:	94000279 	bl	48004bc0 <rt_hw_cpu_shutdown>
}
    480041e0:	d503201f 	nop
    480041e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480041e8:	d65f03c0 	ret

00000000480041ec <rt_hw_trap_irq>:

void rt_hw_trap_irq(void)
{
    480041ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480041f0:	910003fd 	mov	x29, sp
    void *param;
    int ir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    ir = rt_hw_interrupt_get_irq();
    480041f4:	97ffff0a 	bl	48003e1c <rt_hw_interrupt_get_irq>
    480041f8:	b9002fe0 	str	w0, [sp, #44]

    if (ir == 1023)
    480041fc:	b9402fe0 	ldr	w0, [sp, #44]
    48004200:	710ffc1f 	cmp	w0, #0x3ff
    48004204:	54000320 	b.eq	48004268 <rt_hw_trap_irq+0x7c>  // b.none
        /* Spurious interrupt */
        return;
    }

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
    48004208:	d0000180 	adrp	x0, 48036000 <__page_off>
    4800420c:	9100a001 	add	x1, x0, #0x28
    48004210:	b9802fe0 	ldrsw	x0, [sp, #44]
    48004214:	d37cec00 	lsl	x0, x0, #4
    48004218:	8b000020 	add	x0, x1, x0
    4800421c:	f9400000 	ldr	x0, [x0]
    48004220:	f90013e0 	str	x0, [sp, #32]
#ifdef RT_USING_INTERRUPT_INFO
    isr_table[ir].counter++;
#endif
    if (isr_func)
    48004224:	f94013e0 	ldr	x0, [sp, #32]
    48004228:	f100001f 	cmp	x0, #0x0
    4800422c:	54000180 	b.eq	4800425c <rt_hw_trap_irq+0x70>  // b.none
    {
        /* Interrupt for myself. */
        param = isr_table[ir].param;
    48004230:	d0000180 	adrp	x0, 48036000 <__page_off>
    48004234:	9100a001 	add	x1, x0, #0x28
    48004238:	b9802fe0 	ldrsw	x0, [sp, #44]
    4800423c:	d37cec00 	lsl	x0, x0, #4
    48004240:	8b000020 	add	x0, x1, x0
    48004244:	f9400400 	ldr	x0, [x0, #8]
    48004248:	f9000fe0 	str	x0, [sp, #24]
        /* turn to interrupt service routine */
        isr_func(ir, param);
    4800424c:	f94013e2 	ldr	x2, [sp, #32]
    48004250:	f9400fe1 	ldr	x1, [sp, #24]
    48004254:	b9402fe0 	ldr	w0, [sp, #44]
    48004258:	d63f0040 	blr	x2
    }

    /* end of interrupt */
    rt_hw_interrupt_ack(ir);
    4800425c:	b9402fe0 	ldr	w0, [sp, #44]
    48004260:	97fffef6 	bl	48003e38 <rt_hw_interrupt_ack>
    48004264:	14000002 	b	4800426c <rt_hw_trap_irq+0x80>
        return;
    48004268:	d503201f 	nop
#endif
}
    4800426c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48004270:	d65f03c0 	ret

0000000048004274 <rt_hw_trap_fiq>:

void rt_hw_trap_fiq(void)
{
    48004274:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48004278:	910003fd 	mov	x29, sp
    void *param;
    int ir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    ir = rt_hw_interrupt_get_irq();
    4800427c:	97fffee8 	bl	48003e1c <rt_hw_interrupt_get_irq>
    48004280:	b9002fe0 	str	w0, [sp, #44]

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
    48004284:	d0000180 	adrp	x0, 48036000 <__page_off>
    48004288:	9100a001 	add	x1, x0, #0x28
    4800428c:	b9802fe0 	ldrsw	x0, [sp, #44]
    48004290:	d37cec00 	lsl	x0, x0, #4
    48004294:	8b000020 	add	x0, x1, x0
    48004298:	f9400000 	ldr	x0, [x0]
    4800429c:	f90013e0 	str	x0, [sp, #32]
    param = isr_table[ir].param;
    480042a0:	d0000180 	adrp	x0, 48036000 <__page_off>
    480042a4:	9100a001 	add	x1, x0, #0x28
    480042a8:	b9802fe0 	ldrsw	x0, [sp, #44]
    480042ac:	d37cec00 	lsl	x0, x0, #4
    480042b0:	8b000020 	add	x0, x1, x0
    480042b4:	f9400400 	ldr	x0, [x0, #8]
    480042b8:	f9000fe0 	str	x0, [sp, #24]

    /* turn to interrupt service routine */
    isr_func(ir, param);
    480042bc:	f94013e2 	ldr	x2, [sp, #32]
    480042c0:	f9400fe1 	ldr	x1, [sp, #24]
    480042c4:	b9402fe0 	ldr	w0, [sp, #44]
    480042c8:	d63f0040 	blr	x2

    /* end of interrupt */
    rt_hw_interrupt_ack(ir);
    480042cc:	b9402fe0 	ldr	w0, [sp, #44]
    480042d0:	97fffeda 	bl	48003e38 <rt_hw_interrupt_ack>
}
    480042d4:	d503201f 	nop
    480042d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480042dc:	d65f03c0 	ret

00000000480042e0 <rt_hw_get_current_el>:
 */
 
.text
.globl rt_hw_get_current_el
rt_hw_get_current_el:
	MRS		X0, CurrentEL
    480042e0:	d5384240 	mrs	x0, currentel
	CMP		X0, 0xc
    480042e4:	f100301f 	cmp	x0, #0xc
	B.EQ	3f
    480042e8:	540000e0 	b.eq	48004304 <rt_hw_get_current_el+0x24>  // b.none
	CMP		X0, 0x8
    480042ec:	f100201f 	cmp	x0, #0x8
	B.EQ	2f
    480042f0:	540000e0 	b.eq	4800430c <rt_hw_get_current_el+0x2c>  // b.none
	CMP		X0, 0x4
    480042f4:	f100101f 	cmp	x0, #0x4
	B.EQ	1f
    480042f8:	540000e0 	b.eq	48004314 <rt_hw_get_current_el+0x34>  // b.none
	
	LDR		X0, =0
    480042fc:	58000560 	ldr	x0, 480043a8 <rt_hw_set_elx_env+0x4c>
	B		0f
    48004300:	14000007 	b	4800431c <rt_hw_get_current_el+0x3c>
3:
	LDR		X0, =3
    48004304:	58000560 	ldr	x0, 480043b0 <rt_hw_set_elx_env+0x54>
	B		0f
    48004308:	14000005 	b	4800431c <rt_hw_get_current_el+0x3c>
2:
	LDR		X0, =2
    4800430c:	58000560 	ldr	x0, 480043b8 <rt_hw_set_elx_env+0x5c>
	B		0f
    48004310:	14000003 	b	4800431c <rt_hw_get_current_el+0x3c>
1:
	LDR		X0, =1
    48004314:	58000560 	ldr	x0, 480043c0 <rt_hw_set_elx_env+0x64>
	B		0f
    48004318:	14000001 	b	4800431c <rt_hw_get_current_el+0x3c>
0:
	RET
    4800431c:	d65f03c0 	ret

0000000048004320 <rt_hw_set_current_vbar>:


.globl rt_hw_set_current_vbar
rt_hw_set_current_vbar:
	MRS		X1, CurrentEL
    48004320:	d5384241 	mrs	x1, currentel
	CMP		X1, 0xc
    48004324:	f100303f 	cmp	x1, #0xc
	B.EQ	3f
    48004328:	540000c0 	b.eq	48004340 <rt_hw_set_current_vbar+0x20>  // b.none
	CMP		X1, 0x8
    4800432c:	f100203f 	cmp	x1, #0x8
	B.EQ	2f
    48004330:	540000c0 	b.eq	48004348 <rt_hw_set_current_vbar+0x28>  // b.none
	CMP		X1, 0x4
    48004334:	f100103f 	cmp	x1, #0x4
	B.EQ	1f
    48004338:	540000c0 	b.eq	48004350 <rt_hw_set_current_vbar+0x30>  // b.none
	B		0f
    4800433c:	14000007 	b	48004358 <rt_hw_set_current_vbar+0x38>
3:
	MSR		VBAR_EL3,X0
    48004340:	d51ec000 	msr	vbar_el3, x0
	B		0f
    48004344:	14000005 	b	48004358 <rt_hw_set_current_vbar+0x38>
2:
	MSR		VBAR_EL2,X0
    48004348:	d51cc000 	msr	vbar_el2, x0
	B		0f
    4800434c:	14000003 	b	48004358 <rt_hw_set_current_vbar+0x38>
1:
	MSR		VBAR_EL1,X0
    48004350:	d518c000 	msr	vbar_el1, x0
	B		0f
    48004354:	14000001 	b	48004358 <rt_hw_set_current_vbar+0x38>
0:
	RET
    48004358:	d65f03c0 	ret

000000004800435c <rt_hw_set_elx_env>:

    
.globl rt_hw_set_elx_env
rt_hw_set_elx_env:
	MRS		X1, CurrentEL
    4800435c:	d5384241 	mrs	x1, currentel
	CMP		X1, 0xc
    48004360:	f100303f 	cmp	x1, #0xc
	B.EQ	3f
    48004364:	540000c0 	b.eq	4800437c <rt_hw_set_elx_env+0x20>  // b.none
	CMP		X1, 0x8
    48004368:	f100203f 	cmp	x1, #0x8
	B.EQ	2f
    4800436c:	54000100 	b.eq	4800438c <rt_hw_set_elx_env+0x30>  // b.none
	CMP		X1, 0x4
    48004370:	f100103f 	cmp	x1, #0x4
	B.EQ	1f
    48004374:	54000140 	b.eq	4800439c <rt_hw_set_elx_env+0x40>  // b.none
	B		0f
    48004378:	1400000a 	b	480043a0 <rt_hw_set_elx_env+0x44>
3:
	MRS		X0, SCR_EL3
    4800437c:	d53e1100 	mrs	x0, scr_el3
	ORR		X0, X0, #0xF			/* SCR_EL3.NS|IRQ|FIQ|EA */
    48004380:	b2400c00 	orr	x0, x0, #0xf
	MSR		SCR_EL3, X0
    48004384:	d51e1100 	msr	scr_el3, x0
	B		0f
    48004388:	14000006 	b	480043a0 <rt_hw_set_elx_env+0x44>
2:
	MRS	X0, HCR_EL2
    4800438c:	d53c1100 	mrs	x0, hcr_el2
	ORR	X0, X0, #0x38
    48004390:	b27d0800 	orr	x0, x0, #0x38
	MSR	HCR_EL2, X0
    48004394:	d51c1100 	msr	hcr_el2, x0
	B		0f
    48004398:	14000002 	b	480043a0 <rt_hw_set_elx_env+0x44>
1:
	B		0f
    4800439c:	14000001 	b	480043a0 <rt_hw_set_elx_env+0x44>
0:
	RET
    480043a0:	d65f03c0 	ret
	...
    480043b0:	00000003 	.word	0x00000003
    480043b4:	00000000 	.word	0x00000000
    480043b8:	00000002 	.word	0x00000002
    480043bc:	00000000 	.word	0x00000000
    480043c0:	00000001 	.word	0x00000001
	...

0000000048004400 <rt_hw_gtimer_enable>:
  /*
 *enable gtimer
 */
.globl rt_hw_gtimer_enable
rt_hw_gtimer_enable:
	MOV X0,#1
    48004400:	d2800020 	mov	x0, #0x1                   	// #1
	MSR CNTP_CTL_EL0,X0
    48004404:	d51be220 	msr	cntp_ctl_el0, x0
	RET
    48004408:	d65f03c0 	ret

000000004800440c <rt_hw_set_gtimer_val>:
/*
 *set gtimer CNTP_CVAL_EL0 value
 */
.globl rt_hw_set_gtimer_val
rt_hw_set_gtimer_val:
	MSR CNTP_TVAL_EL0,X0
    4800440c:	d51be200 	msr	cntp_tval_el0, x0
	RET
    48004410:	d65f03c0 	ret

0000000048004414 <rt_hw_get_gtimer_val>:
/*
 *get gtimer CNTP_TVAL_EL0 value
 */
.globl rt_hw_get_gtimer_val
rt_hw_get_gtimer_val:
	MRS X0,CNTP_TVAL_EL0
    48004414:	d53be200 	mrs	x0, cntp_tval_el0
	RET
    48004418:	d65f03c0 	ret

000000004800441c <rt_hw_get_cntpct_val>:


.globl rt_hw_get_cntpct_val
rt_hw_get_cntpct_val:
	MRS X0, CNTPCT_EL0
    4800441c:	d53be020 	mrs	x0, cntpct_el0
	RET
    48004420:	d65f03c0 	ret

0000000048004424 <rt_hw_get_gtimer_frq>:
/*
 *get gtimer frq value
 */
.globl rt_hw_get_gtimer_frq
rt_hw_get_gtimer_frq:
	MRS X0,CNTFRQ_EL0
    48004424:	d53be000 	mrs	x0, cntfrq_el0
	RET
    48004428:	d65f03c0 	ret

000000004800442c <rt_hw_interrupt_disable>:
/*
 * rt_base_t rt_hw_interrupt_disable();
 */
.globl rt_hw_interrupt_disable
rt_hw_interrupt_disable:
    MRS      X0, DAIF
    4800442c:	d53b4220 	mrs	x0, daif
    MSR      DAIFSet, #3
    48004430:	d50343df 	msr	daifset, #0x3
    DSB      SY
    48004434:	d5033f9f 	dsb	sy
    RET
    48004438:	d65f03c0 	ret

000000004800443c <rt_hw_interrupt_enable>:
/*
 * void rt_hw_interrupt_enable(rt_base_t level);
 */
.globl rt_hw_interrupt_enable
rt_hw_interrupt_enable:
    DSB     SY
    4800443c:	d5033f9f 	dsb	sy
    MOV     X1, #0xC0
    48004440:	d2801801 	mov	x1, #0xc0                  	// #192
    ANDS    X0, X0, X1
    48004444:	ea010000 	ands	x0, x0, x1
    B.NE    rt_hw_interrupt_enable_exit
    48004448:	54000041 	b.ne	48004450 <rt_hw_interrupt_enable_exit>  // b.any
    MSR     DAIFClr, #3
    4800444c:	d50343ff 	msr	daifclr, #0x3

0000000048004450 <rt_hw_interrupt_enable_exit>:
rt_hw_interrupt_enable_exit:
    RET
    48004450:	d65f03c0 	ret

0000000048004454 <rt_hw_context_switch_to>:
 * void rt_hw_context_switch_to(rt_ubase_t to);
 * r0 --> to
 */
.globl rt_hw_context_switch_to
rt_hw_context_switch_to:
    LDR		X0, [X0]
    48004454:	f9400000 	ldr	x0, [x0]
    RESTORE_CONTEXT
    48004458:	d50040bf 	msr	spsel, #0x0
    4800445c:	9100001f 	mov	sp, x0
    48004460:	a8c10fe2 	ldp	x2, x3, [sp], #16
    48004464:	d5384240 	mrs	x0, currentel
    48004468:	f100301f 	cmp	x0, #0xc
    4800446c:	540000c0 	b.eq	48004484 <rt_hw_context_switch_to+0x30>  // b.none
    48004470:	f100201f 	cmp	x0, #0x8
    48004474:	540000e0 	b.eq	48004490 <rt_hw_context_switch_to+0x3c>  // b.none
    48004478:	f100101f 	cmp	x0, #0x4
    4800447c:	54000100 	b.eq	4800449c <rt_hw_context_switch_to+0x48>  // b.none
    48004480:	14000000 	b	48004480 <rt_hw_context_switch_to+0x2c>
    48004484:	d51e4003 	msr	spsr_el3, x3
    48004488:	d51e4022 	msr	elr_el3, x2
    4800448c:	14000007 	b	480044a8 <rt_hw_context_switch_to+0x54>
    48004490:	d51c4003 	msr	spsr_el2, x3
    48004494:	d51c4022 	msr	elr_el2, x2
    48004498:	14000004 	b	480044a8 <rt_hw_context_switch_to+0x54>
    4800449c:	d5184003 	msr	spsr_el1, x3
    480044a0:	d5184022 	msr	elr_el1, x2
    480044a4:	14000001 	b	480044a8 <rt_hw_context_switch_to+0x54>
    480044a8:	a8c17ffe 	ldp	x30, xzr, [sp], #16
    480044ac:	a8c177fc 	ldp	x28, x29, [sp], #16
    480044b0:	a8c16ffa 	ldp	x26, x27, [sp], #16
    480044b4:	a8c167f8 	ldp	x24, x25, [sp], #16
    480044b8:	a8c15ff6 	ldp	x22, x23, [sp], #16
    480044bc:	a8c157f4 	ldp	x20, x21, [sp], #16
    480044c0:	a8c14ff2 	ldp	x18, x19, [sp], #16
    480044c4:	a8c147f0 	ldp	x16, x17, [sp], #16
    480044c8:	a8c13fee 	ldp	x14, x15, [sp], #16
    480044cc:	a8c137ec 	ldp	x12, x13, [sp], #16
    480044d0:	a8c12fea 	ldp	x10, x11, [sp], #16
    480044d4:	a8c127e8 	ldp	x8, x9, [sp], #16
    480044d8:	a8c11fe6 	ldp	x6, x7, [sp], #16
    480044dc:	a8c117e4 	ldp	x4, x5, [sp], #16
    480044e0:	a8c10fe2 	ldp	x2, x3, [sp], #16
    480044e4:	a8c107e0 	ldp	x0, x1, [sp], #16
    480044e8:	d50041bf 	msr	spsel, #0x1
    480044ec:	d69f03e0 	eret

00000000480044f0 <rt_hw_context_switch>:
 * r1 --> to
 */
.globl rt_hw_context_switch
rt_hw_context_switch:

    MOV		X8,X0
    480044f0:	aa0003e8 	mov	x8, x0
    MOV		X9,X1
    480044f4:	aa0103e9 	mov	x9, x1

    SAVE_CONTEXT_T
    480044f8:	d50040bf 	msr	spsel, #0x0
    480044fc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
    48004500:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    48004504:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
    48004508:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
    4800450c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
    48004510:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
    48004514:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
    48004518:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
    4800451c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
    48004520:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
    48004524:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
    48004528:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
    4800452c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
    48004530:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
    48004534:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
    48004538:	a9bf7ffe 	stp	x30, xzr, [sp, #-16]!
    4800453c:	d5384240 	mrs	x0, currentel
    48004540:	f100301f 	cmp	x0, #0xc
    48004544:	540000c0 	b.eq	4800455c <rt_hw_context_switch+0x6c>  // b.none
    48004548:	f100201f 	cmp	x0, #0x8
    4800454c:	540000e0 	b.eq	48004568 <rt_hw_context_switch+0x78>  // b.none
    48004550:	f100101f 	cmp	x0, #0x4
    48004554:	54000100 	b.eq	48004574 <rt_hw_context_switch+0x84>  // b.none
    48004558:	14000000 	b	48004558 <rt_hw_context_switch+0x68>
    4800455c:	d53e4003 	mrs	x3, spsr_el3
    48004560:	aa1e03e2 	mov	x2, x30
    48004564:	14000007 	b	48004580 <rt_hw_context_switch+0x90>
    48004568:	d53c4003 	mrs	x3, spsr_el2
    4800456c:	aa1e03e2 	mov	x2, x30
    48004570:	14000004 	b	48004580 <rt_hw_context_switch+0x90>
    48004574:	d5384003 	mrs	x3, spsr_el1
    48004578:	aa1e03e2 	mov	x2, x30
    4800457c:	14000001 	b	48004580 <rt_hw_context_switch+0x90>
    48004580:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    48004584:	910003e0 	mov	x0, sp
    48004588:	d50041bf 	msr	spsel, #0x1
    
    STR		X0, [X8]            // store sp in preempted tasks TCB
    4800458c:	f9000100 	str	x0, [x8]
    LDR		X0, [X9]            // get new task stack pointer
    48004590:	f9400120 	ldr	x0, [x9]
    
    RESTORE_CONTEXT
    48004594:	d50040bf 	msr	spsel, #0x0
    48004598:	9100001f 	mov	sp, x0
    4800459c:	a8c10fe2 	ldp	x2, x3, [sp], #16
    480045a0:	d5384240 	mrs	x0, currentel
    480045a4:	f100301f 	cmp	x0, #0xc
    480045a8:	540000c0 	b.eq	480045c0 <rt_hw_context_switch+0xd0>  // b.none
    480045ac:	f100201f 	cmp	x0, #0x8
    480045b0:	540000e0 	b.eq	480045cc <rt_hw_context_switch+0xdc>  // b.none
    480045b4:	f100101f 	cmp	x0, #0x4
    480045b8:	54000100 	b.eq	480045d8 <rt_hw_context_switch+0xe8>  // b.none
    480045bc:	14000000 	b	480045bc <rt_hw_context_switch+0xcc>
    480045c0:	d51e4003 	msr	spsr_el3, x3
    480045c4:	d51e4022 	msr	elr_el3, x2
    480045c8:	14000007 	b	480045e4 <rt_hw_context_switch+0xf4>
    480045cc:	d51c4003 	msr	spsr_el2, x3
    480045d0:	d51c4022 	msr	elr_el2, x2
    480045d4:	14000004 	b	480045e4 <rt_hw_context_switch+0xf4>
    480045d8:	d5184003 	msr	spsr_el1, x3
    480045dc:	d5184022 	msr	elr_el1, x2
    480045e0:	14000001 	b	480045e4 <rt_hw_context_switch+0xf4>
    480045e4:	a8c17ffe 	ldp	x30, xzr, [sp], #16
    480045e8:	a8c177fc 	ldp	x28, x29, [sp], #16
    480045ec:	a8c16ffa 	ldp	x26, x27, [sp], #16
    480045f0:	a8c167f8 	ldp	x24, x25, [sp], #16
    480045f4:	a8c15ff6 	ldp	x22, x23, [sp], #16
    480045f8:	a8c157f4 	ldp	x20, x21, [sp], #16
    480045fc:	a8c14ff2 	ldp	x18, x19, [sp], #16
    48004600:	a8c147f0 	ldp	x16, x17, [sp], #16
    48004604:	a8c13fee 	ldp	x14, x15, [sp], #16
    48004608:	a8c137ec 	ldp	x12, x13, [sp], #16
    4800460c:	a8c12fea 	ldp	x10, x11, [sp], #16
    48004610:	a8c127e8 	ldp	x8, x9, [sp], #16
    48004614:	a8c11fe6 	ldp	x6, x7, [sp], #16
    48004618:	a8c117e4 	ldp	x4, x5, [sp], #16
    4800461c:	a8c10fe2 	ldp	x2, x3, [sp], #16
    48004620:	a8c107e0 	ldp	x0, x1, [sp], #16
    48004624:	d50041bf 	msr	spsel, #0x1
    48004628:	d69f03e0 	eret

000000004800462c <rt_hw_context_switch_interrupt>:
.globl rt_thread_switch_interrupt_flag
.globl rt_interrupt_from_thread
.globl rt_interrupt_to_thread
.globl rt_hw_context_switch_interrupt
rt_hw_context_switch_interrupt:
    ADR 	X2, rt_thread_switch_interrupt_flag
    4800462c:	1019d062 	adr	x2, 48038038 <rt_thread_switch_interrupt_flag>
    LDR 	X3, [X2]
    48004630:	f9400043 	ldr	x3, [x2]
    CMP 	X3, #1
    48004634:	f100047f 	cmp	x3, #0x1
    B.EQ 	_reswitch
    48004638:	540000a0 	b.eq	4800464c <_reswitch>  // b.none
    ADR 	X4, rt_interrupt_from_thread   // set rt_interrupt_from_thread
    4800463c:	1019cf64 	adr	x4, 48038028 <rt_interrupt_from_thread>
    MOV 	X3, #1              // set rt_thread_switch_interrupt_flag to 1
    48004640:	d2800023 	mov	x3, #0x1                   	// #1
    STR 	X0, [X4]
    48004644:	f9000080 	str	x0, [x4]
    STR 	X3, [X2]
    48004648:	f9000043 	str	x3, [x2]

000000004800464c <_reswitch>:
_reswitch:
    ADR 	X2, rt_interrupt_to_thread     // set rt_interrupt_to_thread
    4800464c:	1019cf22 	adr	x2, 48038030 <rt_interrupt_to_thread>
    STR 	X1, [X2]
    48004650:	f9000041 	str	x1, [x2]
    RET
    48004654:	d65f03c0 	ret
    48004658:	d503201f 	nop
    4800465c:	d503201f 	nop
    48004660:	d503201f 	nop
    48004664:	d503201f 	nop
    48004668:	d503201f 	nop
    4800466c:	d503201f 	nop
    48004670:	d503201f 	nop
    48004674:	d503201f 	nop
    48004678:	d503201f 	nop
    4800467c:	d503201f 	nop
    48004680:	d503201f 	nop
    48004684:	d503201f 	nop
    48004688:	d503201f 	nop
    4800468c:	d503201f 	nop
    48004690:	d503201f 	nop
    48004694:	d503201f 	nop
    48004698:	d503201f 	nop
    4800469c:	d503201f 	nop
    480046a0:	d503201f 	nop
    480046a4:	d503201f 	nop
    480046a8:	d503201f 	nop
    480046ac:	d503201f 	nop
    480046b0:	d503201f 	nop
    480046b4:	d503201f 	nop
    480046b8:	d503201f 	nop
    480046bc:	d503201f 	nop
    480046c0:	d503201f 	nop
    480046c4:	d503201f 	nop
    480046c8:	d503201f 	nop
    480046cc:	d503201f 	nop
    480046d0:	d503201f 	nop
    480046d4:	d503201f 	nop
    480046d8:	d503201f 	nop
    480046dc:	d503201f 	nop
    480046e0:	d503201f 	nop
    480046e4:	d503201f 	nop
    480046e8:	d503201f 	nop
    480046ec:	d503201f 	nop
    480046f0:	d503201f 	nop
    480046f4:	d503201f 	nop
    480046f8:	d503201f 	nop
    480046fc:	d503201f 	nop

0000000048004700 <vector_fiq>:
// -- Exception handlers ----------------------------------

    .align  8
.globl vector_fiq
vector_fiq:
    SAVE_CONTEXT
    48004700:	d50040bf 	msr	spsel, #0x0
    48004704:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
    48004708:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    4800470c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
    48004710:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
    48004714:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
    48004718:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
    4800471c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
    48004720:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
    48004724:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
    48004728:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
    4800472c:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
    48004730:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
    48004734:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
    48004738:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
    4800473c:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
    48004740:	a9bf7ffe 	stp	x30, xzr, [sp, #-16]!
    48004744:	d5384240 	mrs	x0, currentel
    48004748:	f100301f 	cmp	x0, #0xc
    4800474c:	540000c0 	b.eq	48004764 <vector_fiq+0x64>  // b.none
    48004750:	f100201f 	cmp	x0, #0x8
    48004754:	540000e0 	b.eq	48004770 <vector_fiq+0x70>  // b.none
    48004758:	f100101f 	cmp	x0, #0x4
    4800475c:	54000100 	b.eq	4800477c <vector_fiq+0x7c>  // b.none
    48004760:	14000000 	b	48004760 <vector_fiq+0x60>
    48004764:	d53e4003 	mrs	x3, spsr_el3
    48004768:	d53e4022 	mrs	x2, elr_el3
    4800476c:	14000007 	b	48004788 <vector_fiq+0x88>
    48004770:	d53c4003 	mrs	x3, spsr_el2
    48004774:	d53c4022 	mrs	x2, elr_el2
    48004778:	14000004 	b	48004788 <vector_fiq+0x88>
    4800477c:	d5384003 	mrs	x3, spsr_el1
    48004780:	d5384022 	mrs	x2, elr_el1
    48004784:	14000001 	b	48004788 <vector_fiq+0x88>
    48004788:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    4800478c:	910003e0 	mov	x0, sp
    48004790:	d50041bf 	msr	spsel, #0x1
    STP 	X0, X1, [SP, #-0x10]!
    48004794:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
    BL      rt_hw_trap_fiq
    48004798:	97fffeb7 	bl	48004274 <rt_hw_trap_fiq>
    LDP 	X0, X1, [SP], #0x10
    4800479c:	a8c107e0 	ldp	x0, x1, [sp], #16
    RESTORE_CONTEXT
    480047a0:	d50040bf 	msr	spsel, #0x0
    480047a4:	9100001f 	mov	sp, x0
    480047a8:	a8c10fe2 	ldp	x2, x3, [sp], #16
    480047ac:	d5384240 	mrs	x0, currentel
    480047b0:	f100301f 	cmp	x0, #0xc
    480047b4:	540000c0 	b.eq	480047cc <vector_fiq+0xcc>  // b.none
    480047b8:	f100201f 	cmp	x0, #0x8
    480047bc:	540000e0 	b.eq	480047d8 <vector_fiq+0xd8>  // b.none
    480047c0:	f100101f 	cmp	x0, #0x4
    480047c4:	54000100 	b.eq	480047e4 <vector_fiq+0xe4>  // b.none
    480047c8:	14000000 	b	480047c8 <vector_fiq+0xc8>
    480047cc:	d51e4003 	msr	spsr_el3, x3
    480047d0:	d51e4022 	msr	elr_el3, x2
    480047d4:	14000007 	b	480047f0 <vector_fiq+0xf0>
    480047d8:	d51c4003 	msr	spsr_el2, x3
    480047dc:	d51c4022 	msr	elr_el2, x2
    480047e0:	14000004 	b	480047f0 <vector_fiq+0xf0>
    480047e4:	d5184003 	msr	spsr_el1, x3
    480047e8:	d5184022 	msr	elr_el1, x2
    480047ec:	14000001 	b	480047f0 <vector_fiq+0xf0>
    480047f0:	a8c17ffe 	ldp	x30, xzr, [sp], #16
    480047f4:	a8c177fc 	ldp	x28, x29, [sp], #16
    480047f8:	a8c16ffa 	ldp	x26, x27, [sp], #16
    480047fc:	a8c167f8 	ldp	x24, x25, [sp], #16
    48004800:	a8c15ff6 	ldp	x22, x23, [sp], #16
    48004804:	a8c157f4 	ldp	x20, x21, [sp], #16
    48004808:	a8c14ff2 	ldp	x18, x19, [sp], #16
    4800480c:	a8c147f0 	ldp	x16, x17, [sp], #16
    48004810:	a8c13fee 	ldp	x14, x15, [sp], #16
    48004814:	a8c137ec 	ldp	x12, x13, [sp], #16
    48004818:	a8c12fea 	ldp	x10, x11, [sp], #16
    4800481c:	a8c127e8 	ldp	x8, x9, [sp], #16
    48004820:	a8c11fe6 	ldp	x6, x7, [sp], #16
    48004824:	a8c117e4 	ldp	x4, x5, [sp], #16
    48004828:	a8c10fe2 	ldp	x2, x3, [sp], #16
    4800482c:	a8c107e0 	ldp	x0, x1, [sp], #16
    48004830:	d50041bf 	msr	spsel, #0x1
    48004834:	d69f03e0 	eret
    48004838:	d503201f 	nop
    4800483c:	d503201f 	nop
    48004840:	d503201f 	nop
    48004844:	d503201f 	nop
    48004848:	d503201f 	nop
    4800484c:	d503201f 	nop
    48004850:	d503201f 	nop
    48004854:	d503201f 	nop
    48004858:	d503201f 	nop
    4800485c:	d503201f 	nop
    48004860:	d503201f 	nop
    48004864:	d503201f 	nop
    48004868:	d503201f 	nop
    4800486c:	d503201f 	nop
    48004870:	d503201f 	nop
    48004874:	d503201f 	nop
    48004878:	d503201f 	nop
    4800487c:	d503201f 	nop
    48004880:	d503201f 	nop
    48004884:	d503201f 	nop
    48004888:	d503201f 	nop
    4800488c:	d503201f 	nop
    48004890:	d503201f 	nop
    48004894:	d503201f 	nop
    48004898:	d503201f 	nop
    4800489c:	d503201f 	nop
    480048a0:	d503201f 	nop
    480048a4:	d503201f 	nop
    480048a8:	d503201f 	nop
    480048ac:	d503201f 	nop
    480048b0:	d503201f 	nop
    480048b4:	d503201f 	nop
    480048b8:	d503201f 	nop
    480048bc:	d503201f 	nop
    480048c0:	d503201f 	nop
    480048c4:	d503201f 	nop
    480048c8:	d503201f 	nop
    480048cc:	d503201f 	nop
    480048d0:	d503201f 	nop
    480048d4:	d503201f 	nop
    480048d8:	d503201f 	nop
    480048dc:	d503201f 	nop
    480048e0:	d503201f 	nop
    480048e4:	d503201f 	nop
    480048e8:	d503201f 	nop
    480048ec:	d503201f 	nop
    480048f0:	d503201f 	nop
    480048f4:	d503201f 	nop
    480048f8:	d503201f 	nop
    480048fc:	d503201f 	nop

0000000048004900 <vector_irq>:
// -------------------------------------------------------------------

    .align  8
.globl vector_irq
vector_irq:
    SAVE_CONTEXT
    48004900:	d50040bf 	msr	spsel, #0x0
    48004904:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
    48004908:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    4800490c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
    48004910:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
    48004914:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
    48004918:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
    4800491c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
    48004920:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
    48004924:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
    48004928:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
    4800492c:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
    48004930:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
    48004934:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
    48004938:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
    4800493c:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
    48004940:	a9bf7ffe 	stp	x30, xzr, [sp, #-16]!
    48004944:	d5384240 	mrs	x0, currentel
    48004948:	f100301f 	cmp	x0, #0xc
    4800494c:	540000c0 	b.eq	48004964 <vector_irq+0x64>  // b.none
    48004950:	f100201f 	cmp	x0, #0x8
    48004954:	540000e0 	b.eq	48004970 <vector_irq+0x70>  // b.none
    48004958:	f100101f 	cmp	x0, #0x4
    4800495c:	54000100 	b.eq	4800497c <vector_irq+0x7c>  // b.none
    48004960:	14000000 	b	48004960 <vector_irq+0x60>
    48004964:	d53e4003 	mrs	x3, spsr_el3
    48004968:	d53e4022 	mrs	x2, elr_el3
    4800496c:	14000007 	b	48004988 <vector_irq+0x88>
    48004970:	d53c4003 	mrs	x3, spsr_el2
    48004974:	d53c4022 	mrs	x2, elr_el2
    48004978:	14000004 	b	48004988 <vector_irq+0x88>
    4800497c:	d5384003 	mrs	x3, spsr_el1
    48004980:	d5384022 	mrs	x2, elr_el1
    48004984:	14000001 	b	48004988 <vector_irq+0x88>
    48004988:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    4800498c:	910003e0 	mov	x0, sp
    48004990:	d50041bf 	msr	spsel, #0x1
    STP 	X0, X1, [SP, #-0x10]!
    48004994:	a9bf07e0 	stp	x0, x1, [sp, #-16]!

    BL      rt_interrupt_enter
    48004998:	94001328 	bl	48009638 <rt_interrupt_enter>
    BL      rt_hw_trap_irq
    4800499c:	97fffe14 	bl	480041ec <rt_hw_trap_irq>
    BL      rt_interrupt_leave
    480049a0:	94001341 	bl	480096a4 <rt_interrupt_leave>
    
    LDP 	X0, X1, [SP], #0x10
    480049a4:	a8c107e0 	ldp	x0, x1, [sp], #16

    // if rt_thread_switch_interrupt_flag set, jump to
    // rt_hw_context_switch_interrupt_do and don't return
    ADR 	X1, rt_thread_switch_interrupt_flag
    480049a8:	1019b481 	adr	x1, 48038038 <rt_thread_switch_interrupt_flag>
    LDR     X2, [X1]
    480049ac:	f9400022 	ldr	x2, [x1]
    CMP     X2, #1
    480049b0:	f100045f 	cmp	x2, #0x1
    B.NE     vector_irq_exit
    480049b4:	54000121 	b.ne	480049d8 <vector_irq_exit>  // b.any

    MOV     X2,  #0         // clear flag
    480049b8:	d2800002 	mov	x2, #0x0                   	// #0
    STR     X2,  [X1]
    480049bc:	f9000022 	str	x2, [x1]

    ADR     X3,  rt_interrupt_from_thread
    480049c0:	1019b343 	adr	x3, 48038028 <rt_interrupt_from_thread>
    LDR     X4,  [X3]
    480049c4:	f9400064 	ldr	x4, [x3]
    STR     x0,  [X4]       // store sp in preempted tasks's TCB
    480049c8:	f9000080 	str	x0, [x4]

    ADR     x3,  rt_interrupt_to_thread
    480049cc:	1019b323 	adr	x3, 48038030 <rt_interrupt_to_thread>
    LDR     X4,  [X3]
    480049d0:	f9400064 	ldr	x4, [x3]
    LDR     x0,  [X4]       // get new task's stack pointer
    480049d4:	f9400080 	ldr	x0, [x4]

00000000480049d8 <vector_irq_exit>:
    
vector_irq_exit:	
    RESTORE_CONTEXT
    480049d8:	d50040bf 	msr	spsel, #0x0
    480049dc:	9100001f 	mov	sp, x0
    480049e0:	a8c10fe2 	ldp	x2, x3, [sp], #16
    480049e4:	d5384240 	mrs	x0, currentel
    480049e8:	f100301f 	cmp	x0, #0xc
    480049ec:	540000c0 	b.eq	48004a04 <vector_irq_exit+0x2c>  // b.none
    480049f0:	f100201f 	cmp	x0, #0x8
    480049f4:	540000e0 	b.eq	48004a10 <vector_irq_exit+0x38>  // b.none
    480049f8:	f100101f 	cmp	x0, #0x4
    480049fc:	54000100 	b.eq	48004a1c <vector_irq_exit+0x44>  // b.none
    48004a00:	14000000 	b	48004a00 <vector_irq_exit+0x28>
    48004a04:	d51e4003 	msr	spsr_el3, x3
    48004a08:	d51e4022 	msr	elr_el3, x2
    48004a0c:	14000007 	b	48004a28 <vector_irq_exit+0x50>
    48004a10:	d51c4003 	msr	spsr_el2, x3
    48004a14:	d51c4022 	msr	elr_el2, x2
    48004a18:	14000004 	b	48004a28 <vector_irq_exit+0x50>
    48004a1c:	d5184003 	msr	spsr_el1, x3
    48004a20:	d5184022 	msr	elr_el1, x2
    48004a24:	14000001 	b	48004a28 <vector_irq_exit+0x50>
    48004a28:	a8c17ffe 	ldp	x30, xzr, [sp], #16
    48004a2c:	a8c177fc 	ldp	x28, x29, [sp], #16
    48004a30:	a8c16ffa 	ldp	x26, x27, [sp], #16
    48004a34:	a8c167f8 	ldp	x24, x25, [sp], #16
    48004a38:	a8c15ff6 	ldp	x22, x23, [sp], #16
    48004a3c:	a8c157f4 	ldp	x20, x21, [sp], #16
    48004a40:	a8c14ff2 	ldp	x18, x19, [sp], #16
    48004a44:	a8c147f0 	ldp	x16, x17, [sp], #16
    48004a48:	a8c13fee 	ldp	x14, x15, [sp], #16
    48004a4c:	a8c137ec 	ldp	x12, x13, [sp], #16
    48004a50:	a8c12fea 	ldp	x10, x11, [sp], #16
    48004a54:	a8c127e8 	ldp	x8, x9, [sp], #16
    48004a58:	a8c11fe6 	ldp	x6, x7, [sp], #16
    48004a5c:	a8c117e4 	ldp	x4, x5, [sp], #16
    48004a60:	a8c10fe2 	ldp	x2, x3, [sp], #16
    48004a64:	a8c107e0 	ldp	x0, x1, [sp], #16
    48004a68:	d50041bf 	msr	spsel, #0x1
    48004a6c:	d69f03e0 	eret
    48004a70:	d503201f 	nop
    48004a74:	d503201f 	nop
    48004a78:	d503201f 	nop
    48004a7c:	d503201f 	nop
    48004a80:	d503201f 	nop
    48004a84:	d503201f 	nop
    48004a88:	d503201f 	nop
    48004a8c:	d503201f 	nop
    48004a90:	d503201f 	nop
    48004a94:	d503201f 	nop
    48004a98:	d503201f 	nop
    48004a9c:	d503201f 	nop
    48004aa0:	d503201f 	nop
    48004aa4:	d503201f 	nop
    48004aa8:	d503201f 	nop
    48004aac:	d503201f 	nop
    48004ab0:	d503201f 	nop
    48004ab4:	d503201f 	nop
    48004ab8:	d503201f 	nop
    48004abc:	d503201f 	nop
    48004ac0:	d503201f 	nop
    48004ac4:	d503201f 	nop
    48004ac8:	d503201f 	nop
    48004acc:	d503201f 	nop
    48004ad0:	d503201f 	nop
    48004ad4:	d503201f 	nop
    48004ad8:	d503201f 	nop
    48004adc:	d503201f 	nop
    48004ae0:	d503201f 	nop
    48004ae4:	d503201f 	nop
    48004ae8:	d503201f 	nop
    48004aec:	d503201f 	nop
    48004af0:	d503201f 	nop
    48004af4:	d503201f 	nop
    48004af8:	d503201f 	nop
    48004afc:	d503201f 	nop

0000000048004b00 <vector_error>:
// -------------------------------------------------

    .align  8
    .globl  vector_error
vector_error:
    SAVE_CONTEXT
    48004b00:	d50040bf 	msr	spsel, #0x0
    48004b04:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
    48004b08:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    48004b0c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
    48004b10:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
    48004b14:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
    48004b18:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
    48004b1c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
    48004b20:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
    48004b24:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
    48004b28:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
    48004b2c:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
    48004b30:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
    48004b34:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
    48004b38:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
    48004b3c:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
    48004b40:	a9bf7ffe 	stp	x30, xzr, [sp, #-16]!
    48004b44:	d5384240 	mrs	x0, currentel
    48004b48:	f100301f 	cmp	x0, #0xc
    48004b4c:	540000c0 	b.eq	48004b64 <vector_error+0x64>  // b.none
    48004b50:	f100201f 	cmp	x0, #0x8
    48004b54:	540000e0 	b.eq	48004b70 <vector_error+0x70>  // b.none
    48004b58:	f100101f 	cmp	x0, #0x4
    48004b5c:	54000100 	b.eq	48004b7c <vector_error+0x7c>  // b.none
    48004b60:	14000000 	b	48004b60 <vector_error+0x60>
    48004b64:	d53e4003 	mrs	x3, spsr_el3
    48004b68:	d53e4022 	mrs	x2, elr_el3
    48004b6c:	14000007 	b	48004b88 <vector_error+0x88>
    48004b70:	d53c4003 	mrs	x3, spsr_el2
    48004b74:	d53c4022 	mrs	x2, elr_el2
    48004b78:	14000004 	b	48004b88 <vector_error+0x88>
    48004b7c:	d5384003 	mrs	x3, spsr_el1
    48004b80:	d5384022 	mrs	x2, elr_el1
    48004b84:	14000001 	b	48004b88 <vector_error+0x88>
    48004b88:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
    48004b8c:	910003e0 	mov	x0, sp
    48004b90:	d50041bf 	msr	spsel, #0x1
    BL      rt_hw_trap_error
    48004b94:	97fffd8a 	bl	480041bc <rt_hw_trap_error>
    B       .
    48004b98:	14000000 	b	48004b98 <vector_error+0x98>

0000000048004b9c <rt_hw_cpu_id>:
#include <rtthread.h>
#include <board.h>
#include "cp15.h"

int rt_hw_cpu_id(void)
{
    48004b9c:	d10043ff 	sub	sp, sp, #0x10
    int cpu_id;
    rt_base_t value;

    __asm__ volatile (
    48004ba0:	d53800a0 	mrs	x0, mpidr_el1
    48004ba4:	f90007e0 	str	x0, [sp, #8]
            "mrs %0, mpidr_el1"
            :"=r"(value)
            );
    cpu_id = value & 0xf;
    48004ba8:	f94007e0 	ldr	x0, [sp, #8]
    48004bac:	12000c00 	and	w0, w0, #0xf
    48004bb0:	b90007e0 	str	w0, [sp, #4]
    return cpu_id;
    48004bb4:	b94007e0 	ldr	w0, [sp, #4]
};
    48004bb8:	910043ff 	add	sp, sp, #0x10
    48004bbc:	d65f03c0 	ret

0000000048004bc0 <rt_hw_cpu_shutdown>:
 */
/*@{*/

/** shutdown CPU */
RT_WEAK void rt_hw_cpu_shutdown()
{
    48004bc0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48004bc4:	910003fd 	mov	x29, sp
    rt_uint32_t level;
    rt_kprintf("shutdown...\n");
    48004bc8:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004bcc:	91102000 	add	x0, x0, #0x408
    48004bd0:	94002c58 	bl	4800fd30 <rt_kprintf>

    level = rt_hw_interrupt_disable();
    48004bd4:	97fffe16 	bl	4800442c <rt_hw_interrupt_disable>
    48004bd8:	b9001fe0 	str	w0, [sp, #28]
    while (level)
    48004bdc:	14000007 	b	48004bf8 <rt_hw_cpu_shutdown+0x38>
    {
        RT_ASSERT(0);
    48004be0:	d2800ae2 	mov	x2, #0x57                  	// #87
    48004be4:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004be8:	91108001 	add	x1, x0, #0x420
    48004bec:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004bf0:	91106000 	add	x0, x0, #0x418
    48004bf4:	94002d1d 	bl	48010068 <rt_assert_handler>
    while (level)
    48004bf8:	b9401fe0 	ldr	w0, [sp, #28]
    48004bfc:	7100001f 	cmp	w0, #0x0
    48004c00:	54ffff01 	b.ne	48004be0 <rt_hw_cpu_shutdown+0x20>  // b.any
    }
}
    48004c04:	d503201f 	nop
    48004c08:	d503201f 	nop
    48004c0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48004c10:	d65f03c0 	ret

0000000048004c14 <uart_configure>:
    rt_ubase_t  hw_base;
    rt_uint32_t irqno;
};

static rt_err_t uart_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
{
    48004c14:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48004c18:	910003fd 	mov	x29, sp
    48004c1c:	f9000fe0 	str	x0, [sp, #24]
    48004c20:	f9000be1 	str	x1, [sp, #16]
    volatile unsigned long rate;
    unsigned long baudrate = 1500000;
    48004c24:	d29c6c00 	mov	x0, #0xe360                	// #58208
    48004c28:	f2a002c0 	movk	x0, #0x16, lsl #16
    48004c2c:	f9001fe0 	str	x0, [sp, #56]

    rt_ubase_t base;
    struct hw_uart_device *uart;

    RT_ASSERT(serial != RT_NULL);
    48004c30:	f9400fe0 	ldr	x0, [sp, #24]
    48004c34:	f100001f 	cmp	x0, #0x0
    48004c38:	540000e1 	b.ne	48004c54 <uart_configure+0x40>  // b.any
    48004c3c:	d28003e2 	mov	x2, #0x1f                  	// #31
    48004c40:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004c44:	91120001 	add	x1, x0, #0x480
    48004c48:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004c4c:	9110e000 	add	x0, x0, #0x438
    48004c50:	94002d06 	bl	48010068 <rt_assert_handler>
    uart = (struct hw_uart_device *)serial->parent.user_data;
    48004c54:	f9400fe0 	ldr	x0, [sp, #24]
    48004c58:	f9404800 	ldr	x0, [x0, #144]
    48004c5c:	f9001be0 	str	x0, [sp, #48]
    
    base = uart->hw_base;
    48004c60:	f9401be0 	ldr	x0, [sp, #48]
    48004c64:	f9400000 	ldr	x0, [x0]
    48004c68:	f90017e0 	str	x0, [sp, #40]
    
    switch (base)
    48004c6c:	f94017e1 	ldr	x1, [sp, #40]
    48004c70:	d2bfe340 	mov	x0, #0xff1a0000            	// #4279894016
    48004c74:	eb00003f 	cmp	x1, x0
    48004c78:	54000ae1 	b.ne	48004dd4 <uart_configure+0x1c0>  // b.any
    {
    case RK_UART2_BASE:
        RK_GRF_GPIO4B_IOMUX = (3 << 18) | (3 << 16) | (2 << 2) | (2 << 0);
    48004c7c:	d29c0480 	mov	x0, #0xe024                	// #57380
    48004c80:	f2bfeee0 	movk	x0, #0xff77, lsl #16
    48004c84:	52800141 	mov	w1, #0xa                   	// #10
    48004c88:	72a001e1 	movk	w1, #0xf, lsl #16
    48004c8c:	b9000001 	str	w1, [x0]
    break;
    48004c90:	d503201f 	nop
    default:
        return (RT_EINVAL);
    }
   
    /* UART reset, rx fifo & tx fifo reset */
    RK_UART_SRR(base) = (0x01 << 1) | (0x01 << 1) | (0x01 << 2);
    48004c94:	f94017e0 	ldr	x0, [sp, #40]
    48004c98:	91022000 	add	x0, x0, #0x88
    48004c9c:	aa0003e1 	mov	x1, x0
    48004ca0:	528000c0 	mov	w0, #0x6                   	// #6
    48004ca4:	b9000020 	str	w0, [x1]

    RK_UART_LCR(base) |= (0x01 << 7);            // enable access LCR
    48004ca8:	f94017e0 	ldr	x0, [sp, #40]
    48004cac:	91003000 	add	x0, x0, #0xc
    48004cb0:	b9400000 	ldr	w0, [x0]
    48004cb4:	f94017e1 	ldr	x1, [sp, #40]
    48004cb8:	91003021 	add	x1, x1, #0xc
    48004cbc:	32190000 	orr	w0, w0, #0x80
    48004cc0:	b9000020 	str	w0, [x1]

    /* uart rate is div for 24M input clock */
    rate = RK_UART_CLK / 16 / baudrate;
    48004cc4:	d29c6c01 	mov	x1, #0xe360                	// #58208
    48004cc8:	f2a002c1 	movk	x1, #0x16, lsl #16
    48004ccc:	f9401fe0 	ldr	x0, [sp, #56]
    48004cd0:	9ac00820 	udiv	x0, x1, x0
    48004cd4:	f90013e0 	str	x0, [sp, #32]

    RK_UART_DLL(base) = (rate & 0xff);
    48004cd8:	f94013e0 	ldr	x0, [sp, #32]
    48004cdc:	2a0003e1 	mov	w1, w0
    48004ce0:	f94017e0 	ldr	x0, [sp, #40]
    48004ce4:	12001c21 	and	w1, w1, #0xff
    48004ce8:	b9000001 	str	w1, [x0]
    RK_UART_DLH(base) = ((rate >> 8) & 0xff);
    48004cec:	f94013e0 	ldr	x0, [sp, #32]
    48004cf0:	d348fc00 	lsr	x0, x0, #8
    48004cf4:	2a0003e2 	mov	w2, w0
    48004cf8:	f94017e0 	ldr	x0, [sp, #40]
    48004cfc:	91001000 	add	x0, x0, #0x4
    48004d00:	aa0003e1 	mov	x1, x0
    48004d04:	12001c40 	and	w0, w2, #0xff
    48004d08:	b9000020 	str	w0, [x1]

    RK_UART_LCR(base) &= ~(0x03 << 0);
    48004d0c:	f94017e0 	ldr	x0, [sp, #40]
    48004d10:	91003000 	add	x0, x0, #0xc
    48004d14:	b9400000 	ldr	w0, [x0]
    48004d18:	f94017e1 	ldr	x1, [sp, #40]
    48004d1c:	91003021 	add	x1, x1, #0xc
    48004d20:	121e7400 	and	w0, w0, #0xfffffffc
    48004d24:	b9000020 	str	w0, [x1]
    RK_UART_LCR(base) |=  (0x03 << 0);           //8bits
    48004d28:	f94017e0 	ldr	x0, [sp, #40]
    48004d2c:	91003000 	add	x0, x0, #0xc
    48004d30:	b9400000 	ldr	w0, [x0]
    48004d34:	f94017e1 	ldr	x1, [sp, #40]
    48004d38:	91003021 	add	x1, x1, #0xc
    48004d3c:	32000400 	orr	w0, w0, #0x3
    48004d40:	b9000020 	str	w0, [x1]

    RK_UART_LCR(base) &= ~(0x01 << 3);           //parity disabled
    48004d44:	f94017e0 	ldr	x0, [sp, #40]
    48004d48:	91003000 	add	x0, x0, #0xc
    48004d4c:	b9400000 	ldr	w0, [x0]
    48004d50:	f94017e1 	ldr	x1, [sp, #40]
    48004d54:	91003021 	add	x1, x1, #0xc
    48004d58:	121c7800 	and	w0, w0, #0xfffffff7
    48004d5c:	b9000020 	str	w0, [x1]

    RK_UART_LCR(base) &= ~(0x01 << 2);           //1 stop bit
    48004d60:	f94017e0 	ldr	x0, [sp, #40]
    48004d64:	91003000 	add	x0, x0, #0xc
    48004d68:	b9400000 	ldr	w0, [x0]
    48004d6c:	f94017e1 	ldr	x1, [sp, #40]
    48004d70:	91003021 	add	x1, x1, #0xc
    48004d74:	121d7800 	and	w0, w0, #0xfffffffb
    48004d78:	b9000020 	str	w0, [x1]

    RK_UART_FCR(base) = (0x2 << 6) | (0X1 << 0);
    48004d7c:	f94017e0 	ldr	x0, [sp, #40]
    48004d80:	91002000 	add	x0, x0, #0x8
    48004d84:	aa0003e1 	mov	x1, x0
    48004d88:	52801020 	mov	w0, #0x81                  	// #129
    48004d8c:	b9000020 	str	w0, [x1]

    RK_UART_LCR(base) &= ~(0x01 << 7);          // disable access LCR
    48004d90:	f94017e0 	ldr	x0, [sp, #40]
    48004d94:	91003000 	add	x0, x0, #0xc
    48004d98:	b9400000 	ldr	w0, [x0]
    48004d9c:	f94017e1 	ldr	x1, [sp, #40]
    48004da0:	91003021 	add	x1, x1, #0xc
    48004da4:	12187800 	and	w0, w0, #0xffffff7f
    48004da8:	b9000020 	str	w0, [x1]

    RK_UART_MCR(base) = 0x00;
    48004dac:	f94017e0 	ldr	x0, [sp, #40]
    48004db0:	91004000 	add	x0, x0, #0x10
    48004db4:	b900001f 	str	wzr, [x0]

    RK_UART_IER(base) = 0x01;                   // rx interrupt enable
    48004db8:	f94017e0 	ldr	x0, [sp, #40]
    48004dbc:	91001000 	add	x0, x0, #0x4
    48004dc0:	aa0003e1 	mov	x1, x0
    48004dc4:	52800020 	mov	w0, #0x1                   	// #1
    48004dc8:	b9000020 	str	w0, [x1]

    return RT_EOK;
    48004dcc:	d2800000 	mov	x0, #0x0                   	// #0
    48004dd0:	14000002 	b	48004dd8 <uart_configure+0x1c4>
        return (RT_EINVAL);
    48004dd4:	d2800140 	mov	x0, #0xa                   	// #10
}
    48004dd8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48004ddc:	d65f03c0 	ret

0000000048004de0 <uart_control>:

static rt_err_t uart_control(struct rt_serial_device *serial, int cmd, void *arg)
{
    48004de0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48004de4:	910003fd 	mov	x29, sp
    48004de8:	f90017e0 	str	x0, [sp, #40]
    48004dec:	b90027e1 	str	w1, [sp, #36]
    48004df0:	f9000fe2 	str	x2, [sp, #24]
    struct hw_uart_device *uart;

    RT_ASSERT(serial != RT_NULL);
    48004df4:	f94017e0 	ldr	x0, [sp, #40]
    48004df8:	f100001f 	cmp	x0, #0x0
    48004dfc:	540000e1 	b.ne	48004e18 <uart_control+0x38>  // b.any
    48004e00:	d28009c2 	mov	x2, #0x4e                  	// #78
    48004e04:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004e08:	91124001 	add	x1, x0, #0x490
    48004e0c:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004e10:	9110e000 	add	x0, x0, #0x438
    48004e14:	94002c95 	bl	48010068 <rt_assert_handler>
    uart = (struct hw_uart_device *)serial->parent.user_data;
    48004e18:	f94017e0 	ldr	x0, [sp, #40]
    48004e1c:	f9404800 	ldr	x0, [x0, #144]
    48004e20:	f9001fe0 	str	x0, [sp, #56]

    switch (cmd)
    48004e24:	b94027e0 	ldr	w0, [sp, #36]
    48004e28:	7100401f 	cmp	w0, #0x10
    48004e2c:	54000100 	b.eq	48004e4c <uart_control+0x6c>  // b.none
    48004e30:	b94027e0 	ldr	w0, [sp, #36]
    48004e34:	7100441f 	cmp	w0, #0x11
    48004e38:	54000121 	b.ne	48004e5c <uart_control+0x7c>  // b.any
    {
        case RT_DEVICE_CTRL_CLR_INT:
            /* disable rx irq */
            rt_hw_interrupt_mask(uart->irqno);
    48004e3c:	f9401fe0 	ldr	x0, [sp, #56]
    48004e40:	b9400800 	ldr	w0, [x0, #8]
    48004e44:	97fffbe4 	bl	48003dd4 <rt_hw_interrupt_mask>
            break;
    48004e48:	14000005 	b	48004e5c <uart_control+0x7c>

        case RT_DEVICE_CTRL_SET_INT:
            /* enable rx irq */
            rt_hw_interrupt_umask(uart->irqno);
    48004e4c:	f9401fe0 	ldr	x0, [sp, #56]
    48004e50:	b9400800 	ldr	w0, [x0, #8]
    48004e54:	97fffbe9 	bl	48003df8 <rt_hw_interrupt_umask>
            break;
    48004e58:	d503201f 	nop
    }

    return RT_EOK;
    48004e5c:	d2800000 	mov	x0, #0x0                   	// #0
}
    48004e60:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48004e64:	d65f03c0 	ret

0000000048004e68 <uart_putc>:

static int uart_putc(struct rt_serial_device *serial, char c)
{
    48004e68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48004e6c:	910003fd 	mov	x29, sp
    48004e70:	f9000fe0 	str	x0, [sp, #24]
    48004e74:	39005fe1 	strb	w1, [sp, #23]
    rt_ubase_t base;
    struct hw_uart_device *uart;

    RT_ASSERT(serial != RT_NULL);
    48004e78:	f9400fe0 	ldr	x0, [sp, #24]
    48004e7c:	f100001f 	cmp	x0, #0x0
    48004e80:	540000e1 	b.ne	48004e9c <uart_putc+0x34>  // b.any
    48004e84:	d2800cc2 	mov	x2, #0x66                  	// #102
    48004e88:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004e8c:	91128001 	add	x1, x0, #0x4a0
    48004e90:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004e94:	9110e000 	add	x0, x0, #0x438
    48004e98:	94002c74 	bl	48010068 <rt_assert_handler>
    uart = (struct hw_uart_device *)serial->parent.user_data;
    48004e9c:	f9400fe0 	ldr	x0, [sp, #24]
    48004ea0:	f9404800 	ldr	x0, [x0, #144]
    48004ea4:	f90017e0 	str	x0, [sp, #40]
    base = uart->hw_base;
    48004ea8:	f94017e0 	ldr	x0, [sp, #40]
    48004eac:	f9400000 	ldr	x0, [x0]
    48004eb0:	f90013e0 	str	x0, [sp, #32]

    while((RK_UART_USR(base) & (0x01 << 1)) == 0);
    48004eb4:	d503201f 	nop
    48004eb8:	f94013e0 	ldr	x0, [sp, #32]
    48004ebc:	9101f000 	add	x0, x0, #0x7c
    48004ec0:	b9400000 	ldr	w0, [x0]
    48004ec4:	121f0000 	and	w0, w0, #0x2
    48004ec8:	7100001f 	cmp	w0, #0x0
    48004ecc:	54ffff60 	b.eq	48004eb8 <uart_putc+0x50>  // b.none

    RK_UART_THR(base) = c;
    48004ed0:	f94013e0 	ldr	x0, [sp, #32]
    48004ed4:	39405fe1 	ldrb	w1, [sp, #23]
    48004ed8:	b9000001 	str	w1, [x0]

    return RT_EOK;
    48004edc:	52800000 	mov	w0, #0x0                   	// #0
}
    48004ee0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48004ee4:	d65f03c0 	ret

0000000048004ee8 <uart_getc>:

static int uart_getc(struct rt_serial_device *serial)
{
    48004ee8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48004eec:	910003fd 	mov	x29, sp
    48004ef0:	f9000fe0 	str	x0, [sp, #24]
    rt_int8_t  ch = -1;
    48004ef4:	12800000 	mov	w0, #0xffffffff            	// #-1
    48004ef8:	3900ffe0 	strb	w0, [sp, #63]
    rt_ubase_t base;
    struct hw_uart_device *uart;

    RT_ASSERT(serial != RT_NULL);
    48004efc:	f9400fe0 	ldr	x0, [sp, #24]
    48004f00:	f100001f 	cmp	x0, #0x0
    48004f04:	540000e1 	b.ne	48004f20 <uart_getc+0x38>  // b.any
    48004f08:	d2800ee2 	mov	x2, #0x77                  	// #119
    48004f0c:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004f10:	9112c001 	add	x1, x0, #0x4b0
    48004f14:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004f18:	9110e000 	add	x0, x0, #0x438
    48004f1c:	94002c53 	bl	48010068 <rt_assert_handler>
    uart = (struct hw_uart_device *)serial->parent.user_data;
    48004f20:	f9400fe0 	ldr	x0, [sp, #24]
    48004f24:	f9404800 	ldr	x0, [x0, #144]
    48004f28:	f9001be0 	str	x0, [sp, #48]
    base = uart->hw_base;
    48004f2c:	f9401be0 	ldr	x0, [sp, #48]
    48004f30:	f9400000 	ldr	x0, [x0]
    48004f34:	f90017e0 	str	x0, [sp, #40]

    if((RK_UART_LSR(base) & (0x01 << 0))) {
    48004f38:	f94017e0 	ldr	x0, [sp, #40]
    48004f3c:	91005000 	add	x0, x0, #0x14
    48004f40:	b9400000 	ldr	w0, [x0]
    48004f44:	12000000 	and	w0, w0, #0x1
    48004f48:	7100001f 	cmp	w0, #0x0
    48004f4c:	54000080 	b.eq	48004f5c <uart_getc+0x74>  // b.none
        ch = RK_UART_RBR(base) & 0xff;
    48004f50:	f94017e0 	ldr	x0, [sp, #40]
    48004f54:	b9400000 	ldr	w0, [x0]
    48004f58:	3900ffe0 	strb	w0, [sp, #63]
    }
    return ch;
    48004f5c:	39c0ffe0 	ldrsb	w0, [sp, #63]
}
    48004f60:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48004f64:	d65f03c0 	ret

0000000048004f68 <rt_hw_uart_isr>:
    uart_putc,
    uart_getc,
};

static void rt_hw_uart_isr(int irqno, void *param)
{
    48004f68:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48004f6c:	910003fd 	mov	x29, sp
    48004f70:	b9001fe0 	str	w0, [sp, #28]
    48004f74:	f9000be1 	str	x1, [sp, #16]
    rt_ubase_t base;
    struct hw_uart_device *uart;
    struct rt_serial_device *serial = (struct rt_serial_device*)param;
    48004f78:	f9400be0 	ldr	x0, [sp, #16]
    48004f7c:	f9001fe0 	str	x0, [sp, #56]

    RT_ASSERT(serial != RT_NULL);
    48004f80:	f9401fe0 	ldr	x0, [sp, #56]
    48004f84:	f100001f 	cmp	x0, #0x0
    48004f88:	540000e1 	b.ne	48004fa4 <rt_hw_uart_isr+0x3c>  // b.any
    48004f8c:	d28011e2 	mov	x2, #0x8f                  	// #143
    48004f90:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004f94:	91130001 	add	x1, x0, #0x4c0
    48004f98:	d00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48004f9c:	9110e000 	add	x0, x0, #0x438
    48004fa0:	94002c32 	bl	48010068 <rt_assert_handler>

    uart = (struct hw_uart_device *)serial->parent.user_data;
    48004fa4:	f9401fe0 	ldr	x0, [sp, #56]
    48004fa8:	f9404800 	ldr	x0, [x0, #144]
    48004fac:	f9001be0 	str	x0, [sp, #48]
    base = uart->hw_base;
    48004fb0:	f9401be0 	ldr	x0, [sp, #48]
    48004fb4:	f9400000 	ldr	x0, [x0]
    48004fb8:	f90017e0 	str	x0, [sp, #40]
    rt_uint32_t pending = RK_UART_IRR(base);
    48004fbc:	f94017e0 	ldr	x0, [sp, #40]
    48004fc0:	91002000 	add	x0, x0, #0x8
    48004fc4:	b9400000 	ldr	w0, [x0]
    48004fc8:	b90027e0 	str	w0, [sp, #36]

    if((pending & 0x4) == 0x4) {
    48004fcc:	b94027e0 	ldr	w0, [sp, #36]
    48004fd0:	121e0000 	and	w0, w0, #0x4
    48004fd4:	7100001f 	cmp	w0, #0x0
    48004fd8:	54000080 	b.eq	48004fe8 <rt_hw_uart_isr+0x80>  // b.none
        rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_IND);
    48004fdc:	52800021 	mov	w1, #0x1                   	// #1
    48004fe0:	f9401fe0 	ldr	x0, [sp, #56]
    48004fe4:	9400429f 	bl	48015a60 <rt_hw_serial_isr>
    }
}
    48004fe8:	d503201f 	nop
    48004fec:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48004ff0:	d65f03c0 	ret

0000000048004ff4 <debug>:
};

static struct rt_serial_device _serial;

int debug(char c)
{
    48004ff4:	d10083ff 	sub	sp, sp, #0x20
    48004ff8:	39003fe0 	strb	w0, [sp, #15]
    rt_ubase_t base = RK_UART2_BASE;
    48004ffc:	d2bfe340 	mov	x0, #0xff1a0000            	// #4279894016
    48005000:	f9000fe0 	str	x0, [sp, #24]

    while((RK_UART_USR(base) & (0x01 << 1)) == 0);
    48005004:	d503201f 	nop
    48005008:	f9400fe0 	ldr	x0, [sp, #24]
    4800500c:	9101f000 	add	x0, x0, #0x7c
    48005010:	b9400000 	ldr	w0, [x0]
    48005014:	121f0000 	and	w0, w0, #0x2
    48005018:	7100001f 	cmp	w0, #0x0
    4800501c:	54ffff60 	b.eq	48005008 <debug+0x14>  // b.none

    RK_UART_THR(base) = c;
    48005020:	f9400fe0 	ldr	x0, [sp, #24]
    48005024:	39403fe1 	ldrb	w1, [sp, #15]
    48005028:	b9000001 	str	w1, [x0]

    return RT_EOK;
    4800502c:	52800000 	mov	w0, #0x0                   	// #0
}
    48005030:	910083ff 	add	sp, sp, #0x20
    48005034:	d65f03c0 	ret

0000000048005038 <rt_hw_uart_init>:

int rt_hw_uart_init(void)
{
    48005038:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800503c:	910003fd 	mov	x29, sp
    struct hw_uart_device  *uart;
    struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
    48005040:	52984000 	mov	w0, #0xc200                	// #49664
    48005044:	72a00020 	movk	w0, #0x1, lsl #16
    48005048:	b90013e0 	str	w0, [sp, #16]
    4800504c:	b94017e0 	ldr	w0, [sp, #20]
    48005050:	52800101 	mov	w1, #0x8                   	// #8
    48005054:	33000c20 	bfxil	w0, w1, #0, #4
    48005058:	b90017e0 	str	w0, [sp, #20]
    4800505c:	b94017e0 	ldr	w0, [sp, #20]
    48005060:	121a7400 	and	w0, w0, #0xffffffcf
    48005064:	b90017e0 	str	w0, [sp, #20]
    48005068:	b94017e0 	ldr	w0, [sp, #20]
    4800506c:	12187400 	and	w0, w0, #0xffffff3f
    48005070:	b90017e0 	str	w0, [sp, #20]
    48005074:	b94017e0 	ldr	w0, [sp, #20]
    48005078:	12177800 	and	w0, w0, #0xfffffeff
    4800507c:	b90017e0 	str	w0, [sp, #20]
    48005080:	b94017e0 	ldr	w0, [sp, #20]
    48005084:	12167800 	and	w0, w0, #0xfffffdff
    48005088:	b90017e0 	str	w0, [sp, #20]
    4800508c:	b94017e0 	ldr	w0, [sp, #20]
    48005090:	52800801 	mov	w1, #0x40                  	// #64
    48005094:	33163c20 	bfi	w0, w1, #10, #16
    48005098:	b90017e0 	str	w0, [sp, #20]
    4800509c:	b94017e0 	ldr	w0, [sp, #20]
    480050a0:	12057800 	and	w0, w0, #0xfbffffff
    480050a4:	b90017e0 	str	w0, [sp, #20]
    480050a8:	b94017e0 	ldr	w0, [sp, #20]
    480050ac:	12006800 	and	w0, w0, #0x7ffffff
    480050b0:	b90017e0 	str	w0, [sp, #20]

    uart = &_uart2_device;
    480050b4:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480050b8:	91152000 	add	x0, x0, #0x548
    480050bc:	f9000fe0 	str	x0, [sp, #24]

    _serial.ops    = &_uart_ops;
    480050c0:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480050c4:	91010000 	add	x0, x0, #0x40
    480050c8:	b00000c1 	adrp	x1, 4801e000 <__FUNCTION__.14+0x10>
    480050cc:	91114021 	add	x1, x1, #0x450
    480050d0:	f9004c01 	str	x1, [x0, #152]
    _serial.config = config;
    480050d4:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480050d8:	91010000 	add	x0, x0, #0x40
    480050dc:	f9400be1 	ldr	x1, [sp, #16]
    480050e0:	f9005001 	str	x1, [x0, #160]

    /* register UART1 device */
    rt_hw_serial_register(&_serial, "uart",
    480050e4:	f9400fe3 	ldr	x3, [sp, #24]
    480050e8:	52802062 	mov	w2, #0x103                 	// #259
    480050ec:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480050f0:	9111e001 	add	x1, x0, #0x478
    480050f4:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480050f8:	91010000 	add	x0, x0, #0x40
    480050fc:	94004219 	bl	48015960 <rt_hw_serial_register>
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                          uart);

    rt_hw_interrupt_install(uart->irqno, rt_hw_uart_isr, &_serial, "uart");
    48005100:	f9400fe0 	ldr	x0, [sp, #24]
    48005104:	b9400800 	ldr	w0, [x0, #8]
    48005108:	2a0003e4 	mov	w4, w0
    4800510c:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005110:	9111e003 	add	x3, x0, #0x478
    48005114:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005118:	91010002 	add	x2, x0, #0x40
    4800511c:	f0ffffe0 	adrp	x0, 48004000 <rt_hw_show_register+0x6c>
    48005120:	913da001 	add	x1, x0, #0xf68
    48005124:	2a0403e0 	mov	w0, w4
    48005128:	97fffb07 	bl	48003d44 <rt_hw_interrupt_install>

    return 0;
    4800512c:	52800000 	mov	w0, #0x0                   	// #0
    48005130:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48005134:	d65f03c0 	ret

0000000048005138 <platform_get_gic_redist_base>:
    return GIC_500_REDISTRIBUTOR_PPTR;
    48005138:	52bfde00 	mov	w0, #0xfef00000            	// #-17825792
}
    4800513c:	d65f03c0 	ret

0000000048005140 <rt_tick_set_period>:
int rt_hw_get_gtimer_val(void);
int rt_hw_get_cntpct_val(void);
int rt_hw_get_cntpct_val(void);
void rt_hw_gtimer_enable(void);
void rt_tick_set_period(void)
{
    48005140:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48005144:	910003fd 	mov	x29, sp
    rt_uint64_t timerStep;
    rt_uint64_t timerFreq;
    rt_uint64_t timerCnt;
    timerFreq = rt_hw_get_gtimer_frq();
    48005148:	97fffcb7 	bl	48004424 <rt_hw_get_gtimer_frq>
    4800514c:	93407c00 	sxtw	x0, w0
    48005150:	f90017e0 	str	x0, [sp, #40]
    timerStep = rt_hw_get_cntpct_val();
    48005154:	97fffcb2 	bl	4800441c <rt_hw_get_cntpct_val>
    48005158:	93407c00 	sxtw	x0, w0
    4800515c:	f90013e0 	str	x0, [sp, #32]
    timerCnt =  timerStep + timerFreq / RT_TICK_PER_SECOND;
    48005160:	f94017e0 	ldr	x0, [sp, #40]
    48005164:	d342fc01 	lsr	x1, x0, #2
    48005168:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    4800516c:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    48005170:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    48005174:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    48005178:	9bc07c20 	umulh	x0, x1, x0
    4800517c:	d342fc00 	lsr	x0, x0, #2
    48005180:	f94013e1 	ldr	x1, [sp, #32]
    48005184:	8b000020 	add	x0, x1, x0
    48005188:	f9000fe0 	str	x0, [sp, #24]
    asm volatile("msr CNTP_CVAL_EL0, %0" :  :"r" (timerCnt));
    4800518c:	f9400fe0 	ldr	x0, [sp, #24]
    48005190:	d51be240 	msr	cntp_cval_el0, x0
    rt_hw_gtimer_enable();
    48005194:	97fffc9b 	bl	48004400 <rt_hw_gtimer_enable>
}
    48005198:	d503201f 	nop
    4800519c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480051a0:	d65f03c0 	ret

00000000480051a4 <rt_hw_timer_isr>:

void rt_hw_timer_isr(int vector, void *parameter)
{
    480051a4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480051a8:	910003fd 	mov	x29, sp
    480051ac:	b9001fe0 	str	w0, [sp, #28]
    480051b0:	f9000be1 	str	x1, [sp, #16]
    static rt_uint32_t tick = 0;
    rt_ubase_t base = RK_TIMER3_BASE;
    480051b4:	d2800c00 	mov	x0, #0x60                  	// #96
    480051b8:	f2bff0a0 	movk	x0, #0xff85, lsl #16
    480051bc:	f90017e0 	str	x0, [sp, #40]

    tick++;
    480051c0:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480051c4:	9103e000 	add	x0, x0, #0xf8
    480051c8:	b9400000 	ldr	w0, [x0]
    480051cc:	11000401 	add	w1, w0, #0x1
    480051d0:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480051d4:	9103e000 	add	x0, x0, #0xf8
    480051d8:	b9000001 	str	w1, [x0]
#if 0
    RK_TIMER_INIT_STATUS(base) = 0x01;  //clrear interrupt
#else
    rt_tick_set_period();
    480051dc:	97ffffd9 	bl	48005140 <rt_tick_set_period>
#endif
    rt_tick_increase();
    480051e0:	94002bd5 	bl	48010134 <rt_tick_increase>
    // if(tick > 100) {
    //     rk_led_mode(3);
    // } else {
    //     rk_led_mode(0);
    // }
    tick = tick > 200? 0 : tick;
    480051e4:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480051e8:	9103e000 	add	x0, x0, #0xf8
    480051ec:	b9400000 	ldr	w0, [x0]
    480051f0:	7103201f 	cmp	w0, #0xc8
    480051f4:	540000a8 	b.hi	48005208 <rt_hw_timer_isr+0x64>  // b.pmore
    480051f8:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480051fc:	9103e000 	add	x0, x0, #0xf8
    48005200:	b9400000 	ldr	w0, [x0]
    48005204:	14000002 	b	4800520c <rt_hw_timer_isr+0x68>
    48005208:	52800000 	mov	w0, #0x0                   	// #0
    4800520c:	f0000181 	adrp	x1, 48038000 <isr_table+0x1fd8>
    48005210:	9103e021 	add	x1, x1, #0xf8
    48005214:	b9000020 	str	w0, [x1]
}
    48005218:	d503201f 	nop
    4800521c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48005220:	d65f03c0 	ret

0000000048005224 <rt_hw_timer_init>:

void rt_hw_timer_init(void)
{
    48005224:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48005228:	910003fd 	mov	x29, sp
    RK_TIMER_CUR_VALUE0(base)  = RK_TIMER_CLK / RT_TICK_PER_SECOND;
    RK_TIMER_CTRL_REG(base)    = 0x05;          //auto reload & enable the timer

    rt_hw_interrupt_umask(RK_TIMER3_IRQ);
#else
    rt_hw_interrupt_install(30, rt_hw_timer_isr, RT_NULL, "tick");
    4800522c:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005230:	91134003 	add	x3, x0, #0x4d0
    48005234:	d2800002 	mov	x2, #0x0                   	// #0
    48005238:	90000000 	adrp	x0, 48005000 <debug+0xc>
    4800523c:	91069001 	add	x1, x0, #0x1a4
    48005240:	528003c0 	mov	w0, #0x1e                  	// #30
    48005244:	97fffac0 	bl	48003d44 <rt_hw_interrupt_install>
    rt_tick_set_period();
    48005248:	97ffffbe 	bl	48005140 <rt_tick_set_period>
    rt_hw_interrupt_umask(30);
    4800524c:	528003c0 	mov	w0, #0x1e                  	// #30
    48005250:	97fffaea 	bl	48003df8 <rt_hw_interrupt_umask>
#endif
}
    48005254:	d503201f 	nop
    48005258:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4800525c:	d65f03c0 	ret

0000000048005260 <optee_smccc_smc>:
static void optee_smccc_smc(unsigned long a0, unsigned long a1,
			    unsigned long a2, unsigned long a3,
			    unsigned long a4, unsigned long a5,
			    unsigned long a6, unsigned long a7,
			    struct arm_smccc_res *res)
{
    48005260:	d10183ff 	sub	sp, sp, #0x60
    48005264:	a9017bfd 	stp	x29, x30, [sp, #16]
    48005268:	910043fd 	add	x29, sp, #0x10
    4800526c:	f9002fe0 	str	x0, [sp, #88]
    48005270:	f9002be1 	str	x1, [sp, #80]
    48005274:	f90027e2 	str	x2, [sp, #72]
    48005278:	f90023e3 	str	x3, [sp, #64]
    4800527c:	f9001fe4 	str	x4, [sp, #56]
    48005280:	f9001be5 	str	x5, [sp, #48]
    48005284:	f90017e6 	str	x6, [sp, #40]
    48005288:	f90013e7 	str	x7, [sp, #32]
	arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);
    4800528c:	f94033e0 	ldr	x0, [sp, #96]
    48005290:	f90003e0 	str	x0, [sp]
    48005294:	f94013e7 	ldr	x7, [sp, #32]
    48005298:	f94017e6 	ldr	x6, [sp, #40]
    4800529c:	f9401be5 	ldr	x5, [sp, #48]
    480052a0:	f9401fe4 	ldr	x4, [sp, #56]
    480052a4:	f94023e3 	ldr	x3, [sp, #64]
    480052a8:	f94027e2 	ldr	x2, [sp, #72]
    480052ac:	f9402be1 	ldr	x1, [sp, #80]
    480052b0:	f9402fe0 	ldr	x0, [sp, #88]
    480052b4:	97fffb31 	bl	48003f78 <arm_smccc_smc>
}
    480052b8:	d503201f 	nop
    480052bc:	a9417bfd 	ldp	x29, x30, [sp, #16]
    480052c0:	910183ff 	add	sp, sp, #0x60
    480052c4:	d65f03c0 	ret

00000000480052c8 <idle_wfi>:
void idle_wfi(void)
{
    asm volatile ("wfi");
    480052c8:	d503207f 	wfi
}
    480052cc:	d503201f 	nop
    480052d0:	d65f03c0 	ret

00000000480052d4 <cpu_on>:
void cpu_on(int x0)
{
    480052d4:	d10043ff 	sub	sp, sp, #0x10
    480052d8:	b9000fe0 	str	w0, [sp, #12]
    g_cpu_on = x0;
    480052dc:	b9400fe1 	ldr	w1, [sp, #12]
    480052e0:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480052e4:	91156000 	add	x0, x0, #0x558
    480052e8:	b9000001 	str	w1, [x0]
}
    480052ec:	d503201f 	nop
    480052f0:	910043ff 	add	sp, sp, #0x10
    480052f4:	d65f03c0 	ret

00000000480052f8 <rt_hw_board_init>:
/**
 *  Initialize the Hardware related stuffs. Called from rtthread_startup()
 *  after interrupt disabled.
 */
void rt_hw_board_init(void)
{
    480052f8:	d100c3ff 	sub	sp, sp, #0x30
    480052fc:	a9017bfd 	stp	x29, x30, [sp, #16]
    48005300:	910043fd 	add	x29, sp, #0x10
    rt_uint32_t  redist_base;
    mmu_init();
    48005304:	97ffebf1 	bl	480002c8 <mmu_init>
    armv8_map(0, 0, 0x80000000, MEM_ATTR_MEMORY);
    48005308:	d280c083 	mov	x3, #0x604                 	// #1540
    4800530c:	d2b00002 	mov	x2, #0x80000000            	// #2147483648
    48005310:	d2800001 	mov	x1, #0x0                   	// #0
    48005314:	d2800000 	mov	x0, #0x0                   	// #0
    48005318:	97ffed8a 	bl	48000940 <armv8_map>
    armv8_map(0xFF770000, 0xFF770000, 0x10000000,  MEM_ATTR_IO);         //GRF BASE
    4800531c:	d280c103 	mov	x3, #0x608                 	// #1544
    48005320:	d2a20002 	mov	x2, #0x10000000            	// #268435456
    48005324:	d2bfeee1 	mov	x1, #0xff770000            	// #4285988864
    48005328:	d2bfeee0 	mov	x0, #0xff770000            	// #4285988864
    4800532c:	97ffed85 	bl	48000940 <armv8_map>
    armv8_map(0xFF180000, 0xFF180000, 0x2000000,   MEM_ATTR_IO);         //UART BASE
    48005330:	d280c103 	mov	x3, #0x608                 	// #1544
    48005334:	d2a04002 	mov	x2, #0x2000000             	// #33554432
    48005338:	d2bfe301 	mov	x1, #0xff180000            	// #4279762944
    4800533c:	d2bfe300 	mov	x0, #0xff180000            	// #4279762944
    48005340:	97ffed80 	bl	48000940 <armv8_map>
    armv8_map(0xFF850000, 0xFF850000, 0x1000000,   MEM_ATTR_IO);         //GRF BASE
    48005344:	d280c103 	mov	x3, #0x608                 	// #1544
    48005348:	d2a02002 	mov	x2, #0x1000000             	// #16777216
    4800534c:	d2bff0a1 	mov	x1, #0xff850000            	// #4286906368
    48005350:	d2bff0a0 	mov	x0, #0xff850000            	// #4286906368
    48005354:	97ffed7b 	bl	48000940 <armv8_map>
    armv8_map(0xFEE00000, 0xFEE00000, 0x10000000,  MEM_ATTR_IO);         //GIC 
    48005358:	d280c103 	mov	x3, #0x608                 	// #1544
    4800535c:	d2a20002 	mov	x2, #0x10000000            	// #268435456
    48005360:	d2bfdc01 	mov	x1, #0xfee00000            	// #4276092928
    48005364:	d2bfdc00 	mov	x0, #0xfee00000            	// #4276092928
    48005368:	97ffed76 	bl	48000940 <armv8_map>
    mmu_enable(); 
    4800536c:	97ffebf8 	bl	4800034c <mmu_enable>

    optee_smccc_smc(0xC4000003, 1, _start, 0, 0, 0, 0, 0, 0);
    48005370:	f0ffffc0 	adrp	x0, 48000000 <_start>
    48005374:	91000000 	add	x0, x0, #0x0
    48005378:	f90003ff 	str	xzr, [sp]
    4800537c:	d2800007 	mov	x7, #0x0                   	// #0
    48005380:	d2800006 	mov	x6, #0x0                   	// #0
    48005384:	d2800005 	mov	x5, #0x0                   	// #0
    48005388:	d2800004 	mov	x4, #0x0                   	// #0
    4800538c:	d2800003 	mov	x3, #0x0                   	// #0
    48005390:	aa0003e2 	mov	x2, x0
    48005394:	d2800021 	mov	x1, #0x1                   	// #1
    48005398:	d2800060 	mov	x0, #0x3                   	// #3
    4800539c:	f2b88000 	movk	x0, #0xc400, lsl #16
    480053a0:	97ffffb0 	bl	48005260 <optee_smccc_smc>
    while(g_cpu_on -- );
    480053a4:	d503201f 	nop
    480053a8:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480053ac:	91156000 	add	x0, x0, #0x558
    480053b0:	b9400000 	ldr	w0, [x0]
    480053b4:	51000402 	sub	w2, w0, #0x1
    480053b8:	900000e1 	adrp	x1, 48021000 <__fsym_help_desc+0x8>
    480053bc:	91156021 	add	x1, x1, #0x558
    480053c0:	b9000022 	str	w2, [x1]
    480053c4:	7100001f 	cmp	w0, #0x0
    480053c8:	54ffff01 	b.ne	480053a8 <rt_hw_board_init+0xb0>  // b.any

    __asm_flush_dcache_all();
    480053cc:	97fffad5 	bl	48003f20 <__asm_flush_dcache_all>
    /* initialize hardware interrupt */
    rt_hw_vector_init();   
    480053d0:	97fffa45 	bl	48003ce4 <rt_hw_vector_init>

    redist_base = platform_get_gic_redist_base();
    480053d4:	97ffff59 	bl	48005138 <platform_get_gic_redist_base>
    480053d8:	b9002fe0 	str	w0, [sp, #44]

    arm_gic_redist_address_set(0, redist_base + (1U << 16), 0);
    480053dc:	b9402fe0 	ldr	w0, [sp, #44]
    480053e0:	11404000 	add	w0, w0, #0x10, lsl #12
    480053e4:	52800002 	mov	w2, #0x0                   	// #0
    480053e8:	2a0003e1 	mov	w1, w0
    480053ec:	52800000 	mov	w0, #0x0                   	// #0
    480053f0:	97fff8a1 	bl	48003674 <arm_gic_redist_address_set>
    arm_gic_redist_address_set(0, redist_base + (2U << 16), 1);
    480053f4:	b9402fe0 	ldr	w0, [sp, #44]
    480053f8:	11408000 	add	w0, w0, #0x20, lsl #12
    480053fc:	52800022 	mov	w2, #0x1                   	// #1
    48005400:	2a0003e1 	mov	w1, w0
    48005404:	52800000 	mov	w0, #0x0                   	// #0
    48005408:	97fff89b 	bl	48003674 <arm_gic_redist_address_set>

    rt_hw_interrupt_init(); 
    4800540c:	97fffa3e 	bl	48003d04 <rt_hw_interrupt_init>

    /* initialize uart */
    rt_hw_uart_init();
    48005410:	97ffff0a 	bl	48005038 <rt_hw_uart_init>
   
#ifdef RT_USING_CONSOLE
    /* set console device */
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
    48005414:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005418:	91136000 	add	x0, x0, #0x4d8
    4800541c:	940029fc 	bl	4800fc0c <rt_console_set_device>
#endif /* RT_USING_CONSOLE */


#ifdef RT_USING_HEAP
    /* initialize memory system */
    rt_kprintf("heap: 0x%08x - 0x%08x\n", RT_HW_HEAP_BEGIN, RT_HW_HEAP_END);
    48005420:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005424:	91150000 	add	x0, x0, #0x540
    48005428:	f9400000 	ldr	x0, [x0]
    4800542c:	aa0003e2 	mov	x2, x0
    48005430:	900001a0 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48005434:	9124e401 	add	x1, x0, #0x939
    48005438:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800543c:	91138000 	add	x0, x0, #0x4e0
    48005440:	94002a3c 	bl	4800fd30 <rt_kprintf>
    rt_system_heap_init(RT_HW_HEAP_BEGIN, RT_HW_HEAP_END);
    48005444:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005448:	91150000 	add	x0, x0, #0x540
    4800544c:	f9400000 	ldr	x0, [x0]
    48005450:	aa0003e1 	mov	x1, x0
    48005454:	900001a0 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48005458:	9124e400 	add	x0, x0, #0x939
    4800545c:	9400114e 	bl	48009994 <rt_system_heap_init>
#endif
    debug('s');
    48005460:	52800e60 	mov	w0, #0x73                  	// #115
    48005464:	97fffee4 	bl	48004ff4 <debug>
        /* initialize timer for os tick */
    rt_hw_timer_init();
    48005468:	97ffff6f 	bl	48005224 <rt_hw_timer_init>

    rt_thread_idle_sethook(idle_wfi);
    4800546c:	90000000 	adrp	x0, 48005000 <debug+0xc>
    48005470:	910b2000 	add	x0, x0, #0x2c8
    48005474:	940000b1 	bl	48005738 <rt_thread_idle_sethook>

#ifdef RT_USING_COMPONENTS_INIT
    rt_components_board_init();
    48005478:	94000026 	bl	48005510 <rt_components_board_init>
#endif

}
    4800547c:	d503201f 	nop
    48005480:	a9417bfd 	ldp	x29, x30, [sp, #16]
    48005484:	9100c3ff 	add	sp, sp, #0x30
    48005488:	d65f03c0 	ret

000000004800548c <rk_show>:
void rk_show()
{
    4800548c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48005490:	910003fd 	mov	x29, sp
    unsigned long long irqstat;
    rt_uint64_t timerStep;
    rt_uint64_t timerFreq;
    rt_uint64_t timerCnt;
    timerFreq = rt_hw_get_gtimer_frq();
    48005494:	97fffbe4 	bl	48004424 <rt_hw_get_gtimer_frq>
    48005498:	93407c00 	sxtw	x0, w0
    4800549c:	f90017e0 	str	x0, [sp, #40]
    timerStep = rt_hw_get_cntpct_val();
    480054a0:	97fffbdf 	bl	4800441c <rt_hw_get_cntpct_val>
    480054a4:	93407c00 	sxtw	x0, w0
    480054a8:	f90013e0 	str	x0, [sp, #32]
    asm volatile("mrs %0, CNTP_CVAL_EL0" : "=r" (timerCnt));
    480054ac:	d53be240 	mrs	x0, cntp_cval_el0
    480054b0:	f9000fe0 	str	x0, [sp, #24]
    rt_kprintf("timerCnt: 0x%x timerStep: 0x%x timerFreq: 0x%x\n", timerCnt, timerStep, timerFreq);
    480054b4:	f94017e3 	ldr	x3, [sp, #40]
    480054b8:	f94013e2 	ldr	x2, [sp, #32]
    480054bc:	f9400fe1 	ldr	x1, [sp, #24]
    480054c0:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480054c4:	9113e000 	add	x0, x0, #0x4f8
    480054c8:	94002a1a 	bl	4800fd30 <rt_kprintf>

    asm volatile("mrs %0, S3_0_C12_C12_0" : "=r" (irqstat));
    480054cc:	d538cc00 	mrs	x0, s3_0_c12_c12_0
    480054d0:	f9000be0 	str	x0, [sp, #16]

    rt_kprintf("show active irq: 0x%x\r\n", irqstat);
    480054d4:	f9400be1 	ldr	x1, [sp, #16]
    480054d8:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480054dc:	9114a000 	add	x0, x0, #0x528
    480054e0:	94002a14 	bl	4800fd30 <rt_kprintf>
}
    480054e4:	d503201f 	nop
    480054e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480054ec:	d65f03c0 	ret

00000000480054f0 <rti_start>:
 * INIT_APP_EXPORT(fn);
 * etc.
 */
static int rti_start(void)
{
    return 0;
    480054f0:	52800000 	mov	w0, #0x0                   	// #0
}
    480054f4:	d65f03c0 	ret

00000000480054f8 <rti_board_start>:
INIT_EXPORT(rti_start, "0");

static int rti_board_start(void)
{
    return 0;
    480054f8:	52800000 	mov	w0, #0x0                   	// #0
}
    480054fc:	d65f03c0 	ret

0000000048005500 <rti_board_end>:
INIT_EXPORT(rti_board_start, "0.end");

static int rti_board_end(void)
{
    return 0;
    48005500:	52800000 	mov	w0, #0x0                   	// #0
}
    48005504:	d65f03c0 	ret

0000000048005508 <rti_end>:
INIT_EXPORT(rti_board_end, "1.end");

static int rti_end(void)
{
    return 0;
    48005508:	52800000 	mov	w0, #0x0                   	// #0
}
    4800550c:	d65f03c0 	ret

0000000048005510 <rt_components_board_init>:
 * @brief  Onboard components initialization. In this function, the board-level
 *         initialization function will be called to complete the initialization
 *         of the on-board peripherals.
 */
void rt_components_board_init(void)
{
    48005510:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48005514:	910003fd 	mov	x29, sp
        rt_kprintf(":%d done\n", result);
    }
#else
    volatile const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
    48005518:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800551c:	91146000 	add	x0, x0, #0x518
    48005520:	f9000fe0 	str	x0, [sp, #24]
    48005524:	14000007 	b	48005540 <rt_components_board_init+0x30>
    {
        (*fn_ptr)();
    48005528:	f9400fe0 	ldr	x0, [sp, #24]
    4800552c:	f9400000 	ldr	x0, [x0]
    48005530:	d63f0000 	blr	x0
    for (fn_ptr = &__rt_init_rti_board_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
    48005534:	f9400fe0 	ldr	x0, [sp, #24]
    48005538:	91002000 	add	x0, x0, #0x8
    4800553c:	f9000fe0 	str	x0, [sp, #24]
    48005540:	f9400fe1 	ldr	x1, [sp, #24]
    48005544:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48005548:	91148000 	add	x0, x0, #0x520
    4800554c:	eb00003f 	cmp	x1, x0
    48005550:	54fffec3 	b.cc	48005528 <rt_components_board_init+0x18>  // b.lo, b.ul, b.last
    }
#endif /* RT_DEBUG_INIT */
}
    48005554:	d503201f 	nop
    48005558:	d503201f 	nop
    4800555c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48005560:	d65f03c0 	ret

0000000048005564 <rt_components_init>:

/**
 * @brief  RT-Thread Components Initialization.
 */
void rt_components_init(void)
{
    48005564:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48005568:	910003fd 	mov	x29, sp
        rt_kprintf(":%d done\n", result);
    }
#else
    volatile const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
    4800556c:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48005570:	91148000 	add	x0, x0, #0x520
    48005574:	f9000fe0 	str	x0, [sp, #24]
    48005578:	14000007 	b	48005594 <rt_components_init+0x30>
    {
        (*fn_ptr)();
    4800557c:	f9400fe0 	ldr	x0, [sp, #24]
    48005580:	f9400000 	ldr	x0, [x0]
    48005584:	d63f0000 	blr	x0
    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
    48005588:	f9400fe0 	ldr	x0, [sp, #24]
    4800558c:	91002000 	add	x0, x0, #0x8
    48005590:	f9000fe0 	str	x0, [sp, #24]
    48005594:	f9400fe1 	ldr	x1, [sp, #24]
    48005598:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800559c:	9114e000 	add	x0, x0, #0x538
    480055a0:	eb00003f 	cmp	x1, x0
    480055a4:	54fffec3 	b.cc	4800557c <rt_components_init+0x18>  // b.lo, b.ul, b.last
    }
#endif /* RT_DEBUG_INIT */
}
    480055a8:	d503201f 	nop
    480055ac:	d503201f 	nop
    480055b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480055b4:	d65f03c0 	ret

00000000480055b8 <entry>:
    return 0;
}
#elif defined(__GNUC__)
/* Add -eentry to arm-none-eabi-gcc argument */
int entry(void)
{
    480055b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    480055bc:	910003fd 	mov	x29, sp
    rtthread_startup();
    480055c0:	94000026 	bl	48005658 <rtthread_startup>
    return 0;
    480055c4:	52800000 	mov	w0, #0x0                   	// #0
}
    480055c8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    480055cc:	d65f03c0 	ret

00000000480055d0 <main_thread_entry>:
 * @brief  The system main thread. In this thread will call the rt_components_init()
 *         for initialization of RT-Thread Components and call the user's programming
 *         entry main().
 */
void main_thread_entry(void *parameter)
{
    480055d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480055d4:	910003fd 	mov	x29, sp
    480055d8:	f9000fe0 	str	x0, [sp, #24]
    extern int main(void);

#ifdef RT_USING_COMPONENTS_INIT
    /* RT-Thread components initialization */
    rt_components_init();
    480055dc:	97ffffe2 	bl	48005564 <rt_components_init>
    {
        extern int $Super$$main(void);
        $Super$$main(); /* for ARMCC. */
    }
#elif defined(__ICCARM__) || defined(__GNUC__) || defined(__TASKING__)
    main();
    480055e0:	97ffeb00 	bl	480001e0 <main>
#endif
}
    480055e4:	d503201f 	nop
    480055e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480055ec:	d65f03c0 	ret

00000000480055f0 <rt_application_init>:
/**
 * @brief  This function will create and start the main thread, but this thread
 *         will not run until the scheduler starts.
 */
void rt_application_init(void)
{
    480055f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480055f4:	910003fd 	mov	x29, sp
    rt_thread_t tid;

#ifdef RT_USING_HEAP
    tid = rt_thread_create("main", main_thread_entry, RT_NULL,
    480055f8:	52800285 	mov	w5, #0x14                  	// #20
    480055fc:	52800144 	mov	w4, #0xa                   	// #10
    48005600:	52810003 	mov	w3, #0x800                 	// #2048
    48005604:	d2800002 	mov	x2, #0x0                   	// #0
    48005608:	90000000 	adrp	x0, 48005000 <debug+0xc>
    4800560c:	91174001 	add	x1, x0, #0x5d0
    48005610:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005614:	91152000 	add	x0, x0, #0x548
    48005618:	940019e6 	bl	4800bdb0 <rt_thread_create>
    4800561c:	f9000fe0 	str	x0, [sp, #24]
                           RT_MAIN_THREAD_STACK_SIZE, RT_MAIN_THREAD_PRIORITY, 20);
    RT_ASSERT(tid != RT_NULL);
    48005620:	f9400fe0 	ldr	x0, [sp, #24]
    48005624:	f100001f 	cmp	x0, #0x0
    48005628:	540000e1 	b.ne	48005644 <rt_application_init+0x54>  // b.any
    4800562c:	d2801aa2 	mov	x2, #0xd5                  	// #213
    48005630:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005634:	91158001 	add	x1, x0, #0x560
    48005638:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800563c:	91154000 	add	x0, x0, #0x550
    48005640:	94002a8a 	bl	48010068 <rt_assert_handler>

    /* if not define RT_USING_HEAP, using to eliminate the warning */
    (void)result;
#endif /* RT_USING_HEAP */

    rt_thread_startup(tid);
    48005644:	f9400fe0 	ldr	x0, [sp, #24]
    48005648:	94001959 	bl	4800bbac <rt_thread_startup>
}
    4800564c:	d503201f 	nop
    48005650:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48005654:	d65f03c0 	ret

0000000048005658 <rtthread_startup>:
/**
 * @brief  This function will call all levels of initialization functions to complete
 *         the initialization of the system, and finally start the scheduler.
 */
int rtthread_startup(void)
{
    48005658:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4800565c:	910003fd 	mov	x29, sp
    rt_hw_interrupt_disable();
    48005660:	97fffb73 	bl	4800442c <rt_hw_interrupt_disable>

    /* board level initialization
     * NOTE: please initialize heap inside board initialization.
     */
    rt_hw_board_init();
    48005664:	97ffff25 	bl	480052f8 <rt_hw_board_init>

    /* show RT-Thread version */
    rt_show_version();
    48005668:	94002543 	bl	4800eb74 <rt_show_version>

    /* timer system initialization */
    rt_system_timer_init();
    4800566c:	9400180c 	bl	4800b69c <rt_system_timer_init>

    /* scheduler system initialization */
    rt_system_scheduler_init();
    48005670:	94001f1d 	bl	4800d2e4 <rt_system_scheduler_init>
    /* signal system initialization */
    rt_system_signal_init();
#endif /* RT_USING_SIGNALS */

    /* create init_thread */
    rt_application_init();
    48005674:	97ffffdf 	bl	480055f0 <rt_application_init>

    /* timer thread initialization */
    rt_system_timer_thread_init();
    48005678:	9400181d 	bl	4800b6ec <rt_system_timer_thread_init>

    /* idle thread initialization */
    rt_thread_idle_init();
    4800567c:	940000e9 	bl	48005a20 <rt_thread_idle_init>
#ifdef RT_USING_SMP
    rt_hw_spin_lock(&_cpus_lock);
#endif /* RT_USING_SMP */

    /* start scheduler */
    rt_system_scheduler_start();
    48005680:	94001f30 	bl	4800d340 <rt_system_scheduler_start>

    /* never reach here */
    return 0;
    48005684:	52800000 	mov	w0, #0x0                   	// #0
}
    48005688:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4800568c:	d65f03c0 	ret

0000000048005690 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
    48005690:	d10043ff 	sub	sp, sp, #0x10
    48005694:	f90007e0 	str	x0, [sp, #8]
    48005698:	f90003e1 	str	x1, [sp]
    l->next->prev = n;
    4800569c:	f94007e0 	ldr	x0, [sp, #8]
    480056a0:	f9400000 	ldr	x0, [x0]
    480056a4:	f94003e1 	ldr	x1, [sp]
    480056a8:	f9000401 	str	x1, [x0, #8]
    n->next = l->next;
    480056ac:	f94007e0 	ldr	x0, [sp, #8]
    480056b0:	f9400001 	ldr	x1, [x0]
    480056b4:	f94003e0 	ldr	x0, [sp]
    480056b8:	f9000001 	str	x1, [x0]

    l->next = n;
    480056bc:	f94007e0 	ldr	x0, [sp, #8]
    480056c0:	f94003e1 	ldr	x1, [sp]
    480056c4:	f9000001 	str	x1, [x0]
    n->prev = l;
    480056c8:	f94003e0 	ldr	x0, [sp]
    480056cc:	f94007e1 	ldr	x1, [sp, #8]
    480056d0:	f9000401 	str	x1, [x0, #8]
}
    480056d4:	d503201f 	nop
    480056d8:	910043ff 	add	sp, sp, #0x10
    480056dc:	d65f03c0 	ret

00000000480056e0 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
    480056e0:	d10043ff 	sub	sp, sp, #0x10
    480056e4:	f90007e0 	str	x0, [sp, #8]
    n->next->prev = n->prev;
    480056e8:	f94007e0 	ldr	x0, [sp, #8]
    480056ec:	f9400000 	ldr	x0, [x0]
    480056f0:	f94007e1 	ldr	x1, [sp, #8]
    480056f4:	f9400421 	ldr	x1, [x1, #8]
    480056f8:	f9000401 	str	x1, [x0, #8]
    n->prev->next = n->next;
    480056fc:	f94007e0 	ldr	x0, [sp, #8]
    48005700:	f9400400 	ldr	x0, [x0, #8]
    48005704:	f94007e1 	ldr	x1, [sp, #8]
    48005708:	f9400021 	ldr	x1, [x1]
    4800570c:	f9000001 	str	x1, [x0]

    n->next = n->prev = n;
    48005710:	f94007e0 	ldr	x0, [sp, #8]
    48005714:	f94007e1 	ldr	x1, [sp, #8]
    48005718:	f9000401 	str	x1, [x0, #8]
    4800571c:	f94007e0 	ldr	x0, [sp, #8]
    48005720:	f9400401 	ldr	x1, [x0, #8]
    48005724:	f94007e0 	ldr	x0, [sp, #8]
    48005728:	f9000001 	str	x1, [x0]
}
    4800572c:	d503201f 	nop
    48005730:	910043ff 	add	sp, sp, #0x10
    48005734:	d65f03c0 	ret

0000000048005738 <rt_thread_idle_sethook>:
 *         -RT_EFULL: hook list is full.
 *
 * @note the hook function must be simple and never be blocked or suspend.
 */
rt_err_t rt_thread_idle_sethook(void (*hook)(void))
{
    48005738:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800573c:	910003fd 	mov	x29, sp
    48005740:	f9000fe0 	str	x0, [sp, #24]
    rt_size_t i;
    rt_base_t level;
    rt_err_t ret = -RT_EFULL;
    48005744:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48005748:	f9001be0 	str	x0, [sp, #48]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800574c:	97fffb38 	bl	4800442c <rt_hw_interrupt_disable>
    48005750:	f90017e0 	str	x0, [sp, #40]

    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
    48005754:	f9001fff 	str	xzr, [sp, #56]
    48005758:	14000011 	b	4800579c <rt_thread_idle_sethook+0x64>
    {
        if (idle_hook_list[i] == RT_NULL)
    4800575c:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005760:	91276000 	add	x0, x0, #0x9d8
    48005764:	f9401fe1 	ldr	x1, [sp, #56]
    48005768:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    4800576c:	f100001f 	cmp	x0, #0x0
    48005770:	54000101 	b.ne	48005790 <rt_thread_idle_sethook+0x58>  // b.any
        {
            idle_hook_list[i] = hook;
    48005774:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005778:	91276000 	add	x0, x0, #0x9d8
    4800577c:	f9401fe1 	ldr	x1, [sp, #56]
    48005780:	f9400fe2 	ldr	x2, [sp, #24]
    48005784:	f8217802 	str	x2, [x0, x1, lsl #3]
            ret = RT_EOK;
    48005788:	f9001bff 	str	xzr, [sp, #48]
            break;
    4800578c:	14000007 	b	480057a8 <rt_thread_idle_sethook+0x70>
    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
    48005790:	f9401fe0 	ldr	x0, [sp, #56]
    48005794:	91000400 	add	x0, x0, #0x1
    48005798:	f9001fe0 	str	x0, [sp, #56]
    4800579c:	f9401fe0 	ldr	x0, [sp, #56]
    480057a0:	f1000c1f 	cmp	x0, #0x3
    480057a4:	54fffdc9 	b.ls	4800575c <rt_thread_idle_sethook+0x24>  // b.plast
        }
    }
    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    480057a8:	f94017e0 	ldr	x0, [sp, #40]
    480057ac:	97fffb24 	bl	4800443c <rt_hw_interrupt_enable>

    return ret;
    480057b0:	f9401be0 	ldr	x0, [sp, #48]
}
    480057b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480057b8:	d65f03c0 	ret

00000000480057bc <rt_thread_idle_delhook>:
 *
 * @return RT_EOK: delete OK.
 *         -RT_ENOSYS: hook was not found.
 */
rt_err_t rt_thread_idle_delhook(void (*hook)(void))
{
    480057bc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480057c0:	910003fd 	mov	x29, sp
    480057c4:	f9000fe0 	str	x0, [sp, #24]
    rt_size_t i;
    rt_base_t level;
    rt_err_t ret = -RT_ENOSYS;
    480057c8:	928000a0 	mov	x0, #0xfffffffffffffffa    	// #-6
    480057cc:	f9001be0 	str	x0, [sp, #48]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    480057d0:	97fffb17 	bl	4800442c <rt_hw_interrupt_disable>
    480057d4:	f90017e0 	str	x0, [sp, #40]

    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
    480057d8:	f9001fff 	str	xzr, [sp, #56]
    480057dc:	14000011 	b	48005820 <rt_thread_idle_delhook+0x64>
    {
        if (idle_hook_list[i] == hook)
    480057e0:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480057e4:	91276000 	add	x0, x0, #0x9d8
    480057e8:	f9401fe1 	ldr	x1, [sp, #56]
    480057ec:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    480057f0:	f9400fe1 	ldr	x1, [sp, #24]
    480057f4:	eb00003f 	cmp	x1, x0
    480057f8:	540000e1 	b.ne	48005814 <rt_thread_idle_delhook+0x58>  // b.any
        {
            idle_hook_list[i] = RT_NULL;
    480057fc:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005800:	91276000 	add	x0, x0, #0x9d8
    48005804:	f9401fe1 	ldr	x1, [sp, #56]
    48005808:	f821781f 	str	xzr, [x0, x1, lsl #3]
            ret = RT_EOK;
    4800580c:	f9001bff 	str	xzr, [sp, #48]
            break;
    48005810:	14000007 	b	4800582c <rt_thread_idle_delhook+0x70>
    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
    48005814:	f9401fe0 	ldr	x0, [sp, #56]
    48005818:	91000400 	add	x0, x0, #0x1
    4800581c:	f9001fe0 	str	x0, [sp, #56]
    48005820:	f9401fe0 	ldr	x0, [sp, #56]
    48005824:	f1000c1f 	cmp	x0, #0x3
    48005828:	54fffdc9 	b.ls	480057e0 <rt_thread_idle_delhook+0x24>  // b.plast
        }
    }
    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800582c:	f94017e0 	ldr	x0, [sp, #40]
    48005830:	97fffb03 	bl	4800443c <rt_hw_interrupt_enable>

    return ret;
    48005834:	f9401be0 	ldr	x0, [sp, #48]
}
    48005838:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800583c:	d65f03c0 	ret

0000000048005840 <rt_thread_defunct_enqueue>:
 * @brief Enqueue a thread to defunct queue.
 *
 * @note It must be called between rt_hw_interrupt_disable and rt_hw_interrupt_enable
 */
void rt_thread_defunct_enqueue(rt_thread_t thread)
{
    48005840:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48005844:	910003fd 	mov	x29, sp
    48005848:	f9000fe0 	str	x0, [sp, #24]
    rt_list_insert_after(&_rt_thread_defunct, &thread->tlist);
    4800584c:	f9400fe0 	ldr	x0, [sp, #24]
    48005850:	91008000 	add	x0, x0, #0x20
    48005854:	aa0003e1 	mov	x1, x0
    48005858:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800585c:	91158000 	add	x0, x0, #0x560
    48005860:	97ffff8c 	bl	48005690 <rt_list_insert_after>
#ifdef RT_USING_SMP
    rt_sem_release(&system_sem);
#endif
}
    48005864:	d503201f 	nop
    48005868:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800586c:	d65f03c0 	ret

0000000048005870 <rt_thread_defunct_dequeue>:
 * @brief Dequeue a thread from defunct queue.
 *
 * @note It must be called between rt_hw_interrupt_disable and rt_hw_interrupt_enable.
 */
rt_thread_t rt_thread_defunct_dequeue(void)
{
    48005870:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48005874:	910003fd 	mov	x29, sp
    rt_thread_t thread = RT_NULL;
    48005878:	f9000fff 	str	xzr, [sp, #24]
    rt_list_t *l = &_rt_thread_defunct;
    4800587c:	900000e0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48005880:	91158000 	add	x0, x0, #0x560
    48005884:	f9000be0 	str	x0, [sp, #16]

    if (l->next != l)
    48005888:	f9400be0 	ldr	x0, [sp, #16]
    4800588c:	f9400000 	ldr	x0, [x0]
    48005890:	f9400be1 	ldr	x1, [sp, #16]
    48005894:	eb00003f 	cmp	x1, x0
    48005898:	54000100 	b.eq	480058b8 <rt_thread_defunct_dequeue+0x48>  // b.none
    {
        thread = rt_list_entry(l->next,
    4800589c:	f9400be0 	ldr	x0, [sp, #16]
    480058a0:	f9400000 	ldr	x0, [x0]
    480058a4:	d1008000 	sub	x0, x0, #0x20
    480058a8:	f9000fe0 	str	x0, [sp, #24]
                struct rt_thread,
                tlist);
        rt_list_remove(&(thread->tlist));
    480058ac:	f9400fe0 	ldr	x0, [sp, #24]
    480058b0:	91008000 	add	x0, x0, #0x20
    480058b4:	97ffff8b 	bl	480056e0 <rt_list_remove>
    }
    return thread;
    480058b8:	f9400fe0 	ldr	x0, [sp, #24]
}
    480058bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480058c0:	d65f03c0 	ret

00000000480058c4 <rt_defunct_execute>:

/**
 * @brief This function will perform system background job when system idle.
 */
static void rt_defunct_execute(void)
{
    480058c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480058c8:	910003fd 	mov	x29, sp
        void (*cleanup)(struct rt_thread *tid);

#ifdef RT_USING_MODULE
        struct rt_dlmodule *module = RT_NULL;
#endif
        RT_DEBUG_NOT_IN_INTERRUPT;
    480058cc:	97fffad8 	bl	4800442c <rt_hw_interrupt_disable>
    480058d0:	f90013e0 	str	x0, [sp, #32]
    480058d4:	94000f8f 	bl	48009710 <rt_interrupt_get_nest>
    480058d8:	12001c00 	and	w0, w0, #0xff
    480058dc:	7100001f 	cmp	w0, #0x0
    480058e0:	54000180 	b.eq	48005910 <rt_defunct_execute+0x4c>  // b.none
    480058e4:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480058e8:	9116c001 	add	x1, x0, #0x5b0
    480058ec:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480058f0:	9115e000 	add	x0, x0, #0x578
    480058f4:	9400290f 	bl	4800fd30 <rt_kprintf>
    480058f8:	d2801982 	mov	x2, #0xcc                  	// #204
    480058fc:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005900:	9116c001 	add	x1, x0, #0x5b0
    48005904:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005908:	91168000 	add	x0, x0, #0x5a0
    4800590c:	940029d7 	bl	48010068 <rt_assert_handler>
    48005910:	f94013e0 	ldr	x0, [sp, #32]
    48005914:	97fffaca 	bl	4800443c <rt_hw_interrupt_enable>

        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
    48005918:	97fffac5 	bl	4800442c <rt_hw_interrupt_disable>
    4800591c:	f90017e0 	str	x0, [sp, #40]
            dlmodule_destroy(module);
        }
        /* remove defunct thread */
        rt_list_remove(&(thread->tlist));
#else
        thread = rt_thread_defunct_dequeue();
    48005920:	97ffffd4 	bl	48005870 <rt_thread_defunct_dequeue>
    48005924:	f9000fe0 	str	x0, [sp, #24]
        if (!thread)
    48005928:	f9400fe0 	ldr	x0, [sp, #24]
    4800592c:	f100001f 	cmp	x0, #0x0
    48005930:	54000081 	b.ne	48005940 <rt_defunct_execute+0x7c>  // b.any
        {
            rt_hw_interrupt_enable(lock);
    48005934:	f94017e0 	ldr	x0, [sp, #40]
    48005938:	97fffac1 	bl	4800443c <rt_hw_interrupt_enable>
            break;
    4800593c:	1400001f 	b	480059b8 <rt_defunct_execute+0xf4>
        }
#endif
        /* invoke thread cleanup */
        cleanup = thread->cleanup;
    48005940:	f9400fe0 	ldr	x0, [sp, #24]
    48005944:	f9406400 	ldr	x0, [x0, #200]
    48005948:	f9000be0 	str	x0, [sp, #16]
        if (cleanup != RT_NULL)
    4800594c:	f9400be0 	ldr	x0, [sp, #16]
    48005950:	f100001f 	cmp	x0, #0x0
    48005954:	54000100 	b.eq	48005974 <rt_defunct_execute+0xb0>  // b.none
        {
            rt_hw_interrupt_enable(lock);
    48005958:	f94017e0 	ldr	x0, [sp, #40]
    4800595c:	97fffab8 	bl	4800443c <rt_hw_interrupt_enable>
            cleanup(thread);
    48005960:	f9400be1 	ldr	x1, [sp, #16]
    48005964:	f9400fe0 	ldr	x0, [sp, #24]
    48005968:	d63f0020 	blr	x1
            lock = rt_hw_interrupt_disable();
    4800596c:	97fffab0 	bl	4800442c <rt_hw_interrupt_disable>
    48005970:	f90017e0 	str	x0, [sp, #40]
#ifdef RT_USING_SIGNALS
        rt_thread_free_sig(thread);
#endif

        /* if it's a system object, not delete it */
        if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
    48005974:	f9400fe0 	ldr	x0, [sp, #24]
    48005978:	940021b8 	bl	4800e058 <rt_object_is_systemobject>
    4800597c:	7100041f 	cmp	w0, #0x1
    48005980:	540000c1 	b.ne	48005998 <rt_defunct_execute+0xd4>  // b.any
        {
            /* detach this object */
            rt_object_detach((rt_object_t)thread);
    48005984:	f9400fe0 	ldr	x0, [sp, #24]
    48005988:	94002109 	bl	4800ddac <rt_object_detach>
            /* enable interrupt */
            rt_hw_interrupt_enable(lock);
    4800598c:	f94017e0 	ldr	x0, [sp, #40]
    48005990:	97fffaab 	bl	4800443c <rt_hw_interrupt_enable>
    48005994:	17ffffce 	b	480058cc <rt_defunct_execute+0x8>
        }
        else
        {
            rt_hw_interrupt_enable(lock);
    48005998:	f94017e0 	ldr	x0, [sp, #40]
    4800599c:	97fffaa8 	bl	4800443c <rt_hw_interrupt_enable>
#ifdef RT_USING_HEAP
            /* release thread's stack */
            RT_KERNEL_FREE(thread->stack_addr);
    480059a0:	f9400fe0 	ldr	x0, [sp, #24]
    480059a4:	f9402400 	ldr	x0, [x0, #72]
    480059a8:	94001287 	bl	4800a3c4 <rt_free>
            /* delete thread object */
            rt_object_delete((rt_object_t)thread);
    480059ac:	f9400fe0 	ldr	x0, [sp, #24]
    480059b0:	94002179 	bl	4800df94 <rt_object_delete>
    {
    480059b4:	17ffffc6 	b	480058cc <rt_defunct_execute+0x8>
#endif
        }
    }
}
    480059b8:	d503201f 	nop
    480059bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480059c0:	d65f03c0 	ret

00000000480059c4 <rt_thread_idle_entry>:

extern void rt_system_power_manager(void);
static void rt_thread_idle_entry(void *parameter)
{
    480059c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480059c8:	910003fd 	mov	x29, sp
    480059cc:	f9000fe0 	str	x0, [sp, #24]
    {
#ifdef RT_USING_IDLE_HOOK
        rt_size_t i;
        void (*idle_hook)(void);

        for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
    480059d0:	f90017ff 	str	xzr, [sp, #40]
    480059d4:	1400000e 	b	48005a0c <rt_thread_idle_entry+0x48>
        {
            idle_hook = idle_hook_list[i];
    480059d8:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480059dc:	91276000 	add	x0, x0, #0x9d8
    480059e0:	f94017e1 	ldr	x1, [sp, #40]
    480059e4:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    480059e8:	f90013e0 	str	x0, [sp, #32]
            if (idle_hook != RT_NULL)
    480059ec:	f94013e0 	ldr	x0, [sp, #32]
    480059f0:	f100001f 	cmp	x0, #0x0
    480059f4:	54000060 	b.eq	48005a00 <rt_thread_idle_entry+0x3c>  // b.none
            {
                idle_hook();
    480059f8:	f94013e0 	ldr	x0, [sp, #32]
    480059fc:	d63f0000 	blr	x0
        for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
    48005a00:	f94017e0 	ldr	x0, [sp, #40]
    48005a04:	91000400 	add	x0, x0, #0x1
    48005a08:	f90017e0 	str	x0, [sp, #40]
    48005a0c:	f94017e0 	ldr	x0, [sp, #40]
    48005a10:	f1000c1f 	cmp	x0, #0x3
    48005a14:	54fffe29 	b.ls	480059d8 <rt_thread_idle_entry+0x14>  // b.plast
            }
        }
#endif /* RT_USING_IDLE_HOOK */

#ifndef RT_USING_SMP
        rt_defunct_execute();
    48005a18:	97ffffab 	bl	480058c4 <rt_defunct_execute>
    {
    48005a1c:	17ffffed 	b	480059d0 <rt_thread_idle_entry+0xc>

0000000048005a20 <rt_thread_idle_init>:
 * @brief This function will initialize idle thread, then start it.
 *
 * @note this function must be invoked when system init.
 */
void rt_thread_idle_init(void)
{
    48005a20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48005a24:	910003fd 	mov	x29, sp
    rt_ubase_t i;
    char tidle_name[RT_NAME_MAX];

    for (i = 0; i < _CPUS_NR; i++)
    48005a28:	f9000fff 	str	xzr, [sp, #24]
    48005a2c:	14000026 	b	48005ac4 <rt_thread_idle_init+0xa4>
    {
        rt_sprintf(tidle_name, "tidle%d", i);
    48005a30:	910043e3 	add	x3, sp, #0x10
    48005a34:	f9400fe2 	ldr	x2, [sp, #24]
    48005a38:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005a3c:	9116a001 	add	x1, x0, #0x5a8
    48005a40:	aa0303e0 	mov	x0, x3
    48005a44:	94002843 	bl	4800fb50 <rt_sprintf>
        rt_thread_init(&idle[i],
    48005a48:	f9400fe1 	ldr	x1, [sp, #24]
    48005a4c:	d2801b00 	mov	x0, #0xd8                  	// #216
    48005a50:	9b007c21 	mul	x1, x1, x0
    48005a54:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005a58:	91040000 	add	x0, x0, #0x100
    48005a5c:	8b000028 	add	x8, x1, x0
                tidle_name,
                rt_thread_idle_entry,
                RT_NULL,
                &rt_thread_stack[i][0],
    48005a60:	f9400fe0 	ldr	x0, [sp, #24]
    48005a64:	d375d001 	lsl	x1, x0, #11
    48005a68:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005a6c:	91076000 	add	x0, x0, #0x1d8
    48005a70:	8b000020 	add	x0, x1, x0
        rt_thread_init(&idle[i],
    48005a74:	910043e1 	add	x1, sp, #0x10
    48005a78:	52800407 	mov	w7, #0x20                  	// #32
    48005a7c:	528003e6 	mov	w6, #0x1f                  	// #31
    48005a80:	52810005 	mov	w5, #0x800                 	// #2048
    48005a84:	aa0003e4 	mov	x4, x0
    48005a88:	d2800003 	mov	x3, #0x0                   	// #0
    48005a8c:	90000000 	adrp	x0, 48005000 <debug+0xc>
    48005a90:	91271002 	add	x2, x0, #0x9c4
    48005a94:	aa0803e0 	mov	x0, x8
    48005a98:	94001816 	bl	4800baf0 <rt_thread_init>
                32);
#ifdef RT_USING_SMP
        rt_thread_control(&idle[i], RT_THREAD_CTRL_BIND_CPU, (void*)i);
#endif /* RT_USING_SMP */
        /* startup */
        rt_thread_startup(&idle[i]);
    48005a9c:	f9400fe1 	ldr	x1, [sp, #24]
    48005aa0:	d2801b00 	mov	x0, #0xd8                  	// #216
    48005aa4:	9b007c21 	mul	x1, x1, x0
    48005aa8:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005aac:	91040000 	add	x0, x0, #0x100
    48005ab0:	8b000020 	add	x0, x1, x0
    48005ab4:	9400183e 	bl	4800bbac <rt_thread_startup>
    for (i = 0; i < _CPUS_NR; i++)
    48005ab8:	f9400fe0 	ldr	x0, [sp, #24]
    48005abc:	91000400 	add	x0, x0, #0x1
    48005ac0:	f9000fe0 	str	x0, [sp, #24]
    48005ac4:	f9400fe0 	ldr	x0, [sp, #24]
    48005ac8:	f100001f 	cmp	x0, #0x0
    48005acc:	54fffb20 	b.eq	48005a30 <rt_thread_idle_init+0x10>  // b.none
            RT_THREAD_PRIORITY_MAX - 2,
            32);
    /* startup */
    rt_thread_startup(&rt_system_thread);
#endif
}
    48005ad0:	d503201f 	nop
    48005ad4:	d503201f 	nop
    48005ad8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48005adc:	d65f03c0 	ret

0000000048005ae0 <rt_thread_idle_gethandler>:

/**
 * @brief This function will get the handler of the idle thread.
 */
rt_thread_t rt_thread_idle_gethandler(void)
{
    48005ae0:	f81f0ff3 	str	x19, [sp, #-16]!
#ifdef RT_USING_SMP
    register int id = rt_hw_cpu_id();
#else
    register int id = 0;
    48005ae4:	52800013 	mov	w19, #0x0                   	// #0
#endif /* RT_USING_SMP */

    return (rt_thread_t)(&idle[id]);
    48005ae8:	93407e61 	sxtw	x1, w19
    48005aec:	d2801b00 	mov	x0, #0xd8                  	// #216
    48005af0:	9b007c21 	mul	x1, x1, x0
    48005af4:	f0000180 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48005af8:	91040000 	add	x0, x0, #0x100
    48005afc:	8b000020 	add	x0, x1, x0
}
    48005b00:	f84107f3 	ldr	x19, [sp], #16
    48005b04:	d65f03c0 	ret

0000000048005b08 <rt_list_init>:
{
    48005b08:	d10043ff 	sub	sp, sp, #0x10
    48005b0c:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    48005b10:	f94007e0 	ldr	x0, [sp, #8]
    48005b14:	f94007e1 	ldr	x1, [sp, #8]
    48005b18:	f9000401 	str	x1, [x0, #8]
    48005b1c:	f94007e0 	ldr	x0, [sp, #8]
    48005b20:	f9400401 	ldr	x1, [x0, #8]
    48005b24:	f94007e0 	ldr	x0, [sp, #8]
    48005b28:	f9000001 	str	x1, [x0]
}
    48005b2c:	d503201f 	nop
    48005b30:	910043ff 	add	sp, sp, #0x10
    48005b34:	d65f03c0 	ret

0000000048005b38 <rt_list_insert_before>:
{
    48005b38:	d10043ff 	sub	sp, sp, #0x10
    48005b3c:	f90007e0 	str	x0, [sp, #8]
    48005b40:	f90003e1 	str	x1, [sp]
    l->prev->next = n;
    48005b44:	f94007e0 	ldr	x0, [sp, #8]
    48005b48:	f9400400 	ldr	x0, [x0, #8]
    48005b4c:	f94003e1 	ldr	x1, [sp]
    48005b50:	f9000001 	str	x1, [x0]
    n->prev = l->prev;
    48005b54:	f94007e0 	ldr	x0, [sp, #8]
    48005b58:	f9400401 	ldr	x1, [x0, #8]
    48005b5c:	f94003e0 	ldr	x0, [sp]
    48005b60:	f9000401 	str	x1, [x0, #8]
    l->prev = n;
    48005b64:	f94007e0 	ldr	x0, [sp, #8]
    48005b68:	f94003e1 	ldr	x1, [sp]
    48005b6c:	f9000401 	str	x1, [x0, #8]
    n->next = l;
    48005b70:	f94003e0 	ldr	x0, [sp]
    48005b74:	f94007e1 	ldr	x1, [sp, #8]
    48005b78:	f9000001 	str	x1, [x0]
}
    48005b7c:	d503201f 	nop
    48005b80:	910043ff 	add	sp, sp, #0x10
    48005b84:	d65f03c0 	ret

0000000048005b88 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
    48005b88:	d10043ff 	sub	sp, sp, #0x10
    48005b8c:	f90007e0 	str	x0, [sp, #8]
    return l->next == l;
    48005b90:	f94007e0 	ldr	x0, [sp, #8]
    48005b94:	f9400000 	ldr	x0, [x0]
    48005b98:	f94007e1 	ldr	x1, [sp, #8]
    48005b9c:	eb00003f 	cmp	x1, x0
    48005ba0:	1a9f17e0 	cset	w0, eq  // eq = none
    48005ba4:	12001c00 	and	w0, w0, #0xff
}
    48005ba8:	910043ff 	add	sp, sp, #0x10
    48005bac:	d65f03c0 	ret

0000000048005bb0 <_ipc_object_init>:
 *           When the return value is any other values, it means the initialization failed.
 *
 * @warning  This function can be called from all IPC initialization and creation.
 */
rt_inline rt_err_t _ipc_object_init(struct rt_ipc_object *ipc)
{
    48005bb0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48005bb4:	910003fd 	mov	x29, sp
    48005bb8:	f9000fe0 	str	x0, [sp, #24]
    /* initialize ipc object */
    rt_list_init(&(ipc->suspend_thread));
    48005bbc:	f9400fe0 	ldr	x0, [sp, #24]
    48005bc0:	91008000 	add	x0, x0, #0x20
    48005bc4:	97ffffd1 	bl	48005b08 <rt_list_init>

    return RT_EOK;
    48005bc8:	d2800000 	mov	x0, #0x0                   	// #0
}
    48005bcc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48005bd0:	d65f03c0 	ret

0000000048005bd4 <_ipc_list_suspend>:
 *           rt_mb_recv(),   rt_mq_recv(),     rt_mq_send_wait()
 */
rt_inline rt_err_t _ipc_list_suspend(rt_list_t        *list,
                                     struct rt_thread *thread,
                                     rt_uint8_t        flag)
{
    48005bd4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48005bd8:	910003fd 	mov	x29, sp
    48005bdc:	f90017e0 	str	x0, [sp, #40]
    48005be0:	f90013e1 	str	x1, [sp, #32]
    48005be4:	39007fe2 	strb	w2, [sp, #31]
    /* suspend thread */
    rt_thread_suspend(thread);
    48005be8:	f94013e0 	ldr	x0, [sp, #32]
    48005bec:	940019ef 	bl	4800c3a8 <rt_thread_suspend>

    switch (flag)
    48005bf0:	39407fe0 	ldrb	w0, [sp, #31]
    48005bf4:	7100001f 	cmp	w0, #0x0
    48005bf8:	54000080 	b.eq	48005c08 <_ipc_list_suspend+0x34>  // b.none
    48005bfc:	7100041f 	cmp	w0, #0x1
    48005c00:	54000100 	b.eq	48005c20 <_ipc_list_suspend+0x4c>  // b.none
    48005c04:	1400002d 	b	48005cb8 <_ipc_list_suspend+0xe4>
    {
    case RT_IPC_FLAG_FIFO:
        rt_list_insert_before(list, &(thread->tlist));
    48005c08:	f94013e0 	ldr	x0, [sp, #32]
    48005c0c:	91008000 	add	x0, x0, #0x20
    48005c10:	aa0003e1 	mov	x1, x0
    48005c14:	f94017e0 	ldr	x0, [sp, #40]
    48005c18:	97ffffc8 	bl	48005b38 <rt_list_insert_before>
        break; /* RT_IPC_FLAG_FIFO */
    48005c1c:	1400002f 	b	48005cd8 <_ipc_list_suspend+0x104>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
    48005c20:	f94017e0 	ldr	x0, [sp, #40]
    48005c24:	f9400000 	ldr	x0, [x0]
    48005c28:	f9001fe0 	str	x0, [sp, #56]
    48005c2c:	14000015 	b	48005c80 <_ipc_list_suspend+0xac>
            {
                sthread = rt_list_entry(n, struct rt_thread, tlist);
    48005c30:	f9401fe0 	ldr	x0, [sp, #56]
    48005c34:	d1008000 	sub	x0, x0, #0x20
    48005c38:	f9001be0 	str	x0, [sp, #48]

                /* find out */
                if (thread->current_priority < sthread->current_priority)
    48005c3c:	f94013e0 	ldr	x0, [sp, #32]
    48005c40:	39418401 	ldrb	w1, [x0, #97]
    48005c44:	f9401be0 	ldr	x0, [sp, #48]
    48005c48:	39418400 	ldrb	w0, [x0, #97]
    48005c4c:	6b00003f 	cmp	w1, w0
    48005c50:	54000122 	b.cs	48005c74 <_ipc_list_suspend+0xa0>  // b.hs, b.nlast
                {
                    /* insert this thread before the sthread */
                    rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
    48005c54:	f9401be0 	ldr	x0, [sp, #48]
    48005c58:	91008002 	add	x2, x0, #0x20
    48005c5c:	f94013e0 	ldr	x0, [sp, #32]
    48005c60:	91008000 	add	x0, x0, #0x20
    48005c64:	aa0003e1 	mov	x1, x0
    48005c68:	aa0203e0 	mov	x0, x2
    48005c6c:	97ffffb3 	bl	48005b38 <rt_list_insert_before>
                    break;
    48005c70:	14000008 	b	48005c90 <_ipc_list_suspend+0xbc>
            for (n = list->next; n != list; n = n->next)
    48005c74:	f9401fe0 	ldr	x0, [sp, #56]
    48005c78:	f9400000 	ldr	x0, [x0]
    48005c7c:	f9001fe0 	str	x0, [sp, #56]
    48005c80:	f9401fe1 	ldr	x1, [sp, #56]
    48005c84:	f94017e0 	ldr	x0, [sp, #40]
    48005c88:	eb00003f 	cmp	x1, x0
    48005c8c:	54fffd21 	b.ne	48005c30 <_ipc_list_suspend+0x5c>  // b.any

            /*
             * not found a suitable position,
             * append to the end of suspend_thread list
             */
            if (n == list)
    48005c90:	f9401fe1 	ldr	x1, [sp, #56]
    48005c94:	f94017e0 	ldr	x0, [sp, #40]
    48005c98:	eb00003f 	cmp	x1, x0
    48005c9c:	540001c1 	b.ne	48005cd4 <_ipc_list_suspend+0x100>  // b.any
                rt_list_insert_before(list, &(thread->tlist));
    48005ca0:	f94013e0 	ldr	x0, [sp, #32]
    48005ca4:	91008000 	add	x0, x0, #0x20
    48005ca8:	aa0003e1 	mov	x1, x0
    48005cac:	f94017e0 	ldr	x0, [sp, #40]
    48005cb0:	97ffffa2 	bl	48005b38 <rt_list_insert_before>
        }
        break;/* RT_IPC_FLAG_PRIO */
    48005cb4:	14000008 	b	48005cd4 <_ipc_list_suspend+0x100>

    default:
        RT_ASSERT(0);
    48005cb8:	d28012e2 	mov	x2, #0x97                  	// #151
    48005cbc:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005cc0:	912c2001 	add	x1, x0, #0xb08
    48005cc4:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005cc8:	91172000 	add	x0, x0, #0x5c8
    48005ccc:	940028e7 	bl	48010068 <rt_assert_handler>
        break;
    48005cd0:	14000002 	b	48005cd8 <_ipc_list_suspend+0x104>
        break;/* RT_IPC_FLAG_PRIO */
    48005cd4:	d503201f 	nop
    }

    return RT_EOK;
    48005cd8:	d2800000 	mov	x0, #0x0                   	// #0
}
    48005cdc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48005ce0:	d65f03c0 	ret

0000000048005ce4 <_ipc_list_resume>:
 * @warning  This function is generally called by the following functions:
 *           rt_sem_release(),    rt_mutex_release(),    rt_mb_send_wait(),    rt_mq_send_wait(),
 *           rt_mb_urgent(),      rt_mb_recv(),          rt_mq_urgent(),       rt_mq_recv(),
 */
rt_inline rt_err_t _ipc_list_resume(rt_list_t *list)
{
    48005ce4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48005ce8:	910003fd 	mov	x29, sp
    48005cec:	f9000fe0 	str	x0, [sp, #24]
    struct rt_thread *thread;

    /* get thread entry */
    thread = rt_list_entry(list->next, struct rt_thread, tlist);
    48005cf0:	f9400fe0 	ldr	x0, [sp, #24]
    48005cf4:	f9400000 	ldr	x0, [x0]
    48005cf8:	d1008000 	sub	x0, x0, #0x20
    48005cfc:	f90017e0 	str	x0, [sp, #40]

    RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));

    /* resume it */
    rt_thread_resume(thread);
    48005d00:	f94017e0 	ldr	x0, [sp, #40]
    48005d04:	940019f9 	bl	4800c4e8 <rt_thread_resume>

    return RT_EOK;
    48005d08:	d2800000 	mov	x0, #0x0                   	// #0
}
    48005d0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48005d10:	d65f03c0 	ret

0000000048005d14 <_ipc_list_resume_all>:
 * @return   Return the operation status. When the return value is RT_EOK, the function is successfully executed.
 *           When the return value is any other values, it means this operation failed.
 *
 */
rt_inline rt_err_t _ipc_list_resume_all(rt_list_t *list)
{
    48005d14:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48005d18:	910003fd 	mov	x29, sp
    48005d1c:	f9000bf3 	str	x19, [sp, #16]
    48005d20:	f90017e0 	str	x0, [sp, #40]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspended threads */
    while (!rt_list_isempty(list))
    48005d24:	1400000e 	b	48005d5c <_ipc_list_resume_all+0x48>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
    48005d28:	97fff9c1 	bl	4800442c <rt_hw_interrupt_disable>
    48005d2c:	aa0003f3 	mov	x19, x0

        /* get next suspended thread */
        thread = rt_list_entry(list->next, struct rt_thread, tlist);
    48005d30:	f94017e0 	ldr	x0, [sp, #40]
    48005d34:	f9400000 	ldr	x0, [x0]
    48005d38:	d1008000 	sub	x0, x0, #0x20
    48005d3c:	f9001fe0 	str	x0, [sp, #56]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
    48005d40:	f9401fe0 	ldr	x0, [sp, #56]
    48005d44:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    48005d48:	f9002c01 	str	x1, [x0, #88]
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspended list
         */
        rt_thread_resume(thread);
    48005d4c:	f9401fe0 	ldr	x0, [sp, #56]
    48005d50:	940019e6 	bl	4800c4e8 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48005d54:	aa1303e0 	mov	x0, x19
    48005d58:	97fff9b9 	bl	4800443c <rt_hw_interrupt_enable>
    while (!rt_list_isempty(list))
    48005d5c:	f94017e0 	ldr	x0, [sp, #40]
    48005d60:	97ffff8a 	bl	48005b88 <rt_list_isempty>
    48005d64:	7100001f 	cmp	w0, #0x0
    48005d68:	54fffe00 	b.eq	48005d28 <_ipc_list_resume_all+0x14>  // b.none
    }

    return RT_EOK;
    48005d6c:	d2800000 	mov	x0, #0x0                   	// #0
}
    48005d70:	f9400bf3 	ldr	x19, [sp, #16]
    48005d74:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48005d78:	d65f03c0 	ret

0000000048005d7c <rt_sem_init>:
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
    48005d7c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48005d80:	910003fd 	mov	x29, sp
    48005d84:	f90017e0 	str	x0, [sp, #40]
    48005d88:	f90013e1 	str	x1, [sp, #32]
    48005d8c:	b9001fe2 	str	w2, [sp, #28]
    48005d90:	39006fe3 	strb	w3, [sp, #27]
    RT_ASSERT(sem != RT_NULL);
    48005d94:	f94017e0 	ldr	x0, [sp, #40]
    48005d98:	f100001f 	cmp	x0, #0x0
    48005d9c:	540000e1 	b.ne	48005db8 <rt_sem_init+0x3c>  // b.any
    48005da0:	d2802402 	mov	x2, #0x120                 	// #288
    48005da4:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005da8:	912ae001 	add	x1, x0, #0xab8
    48005dac:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005db0:	91174000 	add	x0, x0, #0x5d0
    48005db4:	940028ad 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(value < 0x10000U);
    48005db8:	b9401fe1 	ldr	w1, [sp, #28]
    48005dbc:	529fffe0 	mov	w0, #0xffff                	// #65535
    48005dc0:	6b00003f 	cmp	w1, w0
    48005dc4:	540000e9 	b.ls	48005de0 <rt_sem_init+0x64>  // b.plast
    48005dc8:	d2802422 	mov	x2, #0x121                 	// #289
    48005dcc:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005dd0:	912ae001 	add	x1, x0, #0xab8
    48005dd4:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005dd8:	91178000 	add	x0, x0, #0x5e0
    48005ddc:	940028a3 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    48005de0:	39406fe0 	ldrb	w0, [sp, #27]
    48005de4:	7100001f 	cmp	w0, #0x0
    48005de8:	54000140 	b.eq	48005e10 <rt_sem_init+0x94>  // b.none
    48005dec:	39406fe0 	ldrb	w0, [sp, #27]
    48005df0:	7100041f 	cmp	w0, #0x1
    48005df4:	540000e0 	b.eq	48005e10 <rt_sem_init+0x94>  // b.none
    48005df8:	d2802442 	mov	x2, #0x122                 	// #290
    48005dfc:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005e00:	912ae001 	add	x1, x0, #0xab8
    48005e04:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005e08:	9117e000 	add	x0, x0, #0x5f8
    48005e0c:	94002897 	bl	48010068 <rt_assert_handler>

    /* initialize object */
    rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
    48005e10:	f94017e0 	ldr	x0, [sp, #40]
    48005e14:	f94013e2 	ldr	x2, [sp, #32]
    48005e18:	52800041 	mov	w1, #0x2                   	// #2
    48005e1c:	94001f90 	bl	4800dc5c <rt_object_init>

    /* initialize ipc object */
    _ipc_object_init(&(sem->parent));
    48005e20:	f94017e0 	ldr	x0, [sp, #40]
    48005e24:	97ffff63 	bl	48005bb0 <_ipc_object_init>

    /* set initial value */
    sem->value = (rt_uint16_t)value;
    48005e28:	b9401fe0 	ldr	w0, [sp, #28]
    48005e2c:	12003c01 	and	w1, w0, #0xffff
    48005e30:	f94017e0 	ldr	x0, [sp, #40]
    48005e34:	79006001 	strh	w1, [x0, #48]

    /* set parent */
    sem->parent.parent.flag = flag;
    48005e38:	f94017e0 	ldr	x0, [sp, #40]
    48005e3c:	39406fe1 	ldrb	w1, [sp, #27]
    48005e40:	39002401 	strb	w1, [x0, #9]

    return RT_EOK;
    48005e44:	d2800000 	mov	x0, #0x0                   	// #0
}
    48005e48:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48005e4c:	d65f03c0 	ret

0000000048005e50 <rt_sem_detach>:
 * @warning  This function can ONLY detach a static semaphore initialized by the rt_sem_init() function.
 *           If the semaphore is created by the rt_sem_create() function, you MUST NOT USE this function to detach it,
 *           ONLY USE the rt_sem_delete() function to complete the deletion.
 */
rt_err_t rt_sem_detach(rt_sem_t sem)
{
    48005e50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48005e54:	910003fd 	mov	x29, sp
    48005e58:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(sem != RT_NULL);
    48005e5c:	f9400fe0 	ldr	x0, [sp, #24]
    48005e60:	f100001f 	cmp	x0, #0x0
    48005e64:	540000e1 	b.ne	48005e80 <rt_sem_detach+0x30>  // b.any
    48005e68:	d2802942 	mov	x2, #0x14a                 	// #330
    48005e6c:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005e70:	912b2001 	add	x1, x0, #0xac8
    48005e74:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005e78:	91174000 	add	x0, x0, #0x5d0
    48005e7c:	9400287b 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
    48005e80:	f9400fe0 	ldr	x0, [sp, #24]
    48005e84:	9400208b 	bl	4800e0b0 <rt_object_get_type>
    48005e88:	12001c00 	and	w0, w0, #0xff
    48005e8c:	7100081f 	cmp	w0, #0x2
    48005e90:	540000e0 	b.eq	48005eac <rt_sem_detach+0x5c>  // b.none
    48005e94:	d2802962 	mov	x2, #0x14b                 	// #331
    48005e98:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005e9c:	912b2001 	add	x1, x0, #0xac8
    48005ea0:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005ea4:	9118e000 	add	x0, x0, #0x638
    48005ea8:	94002870 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent));
    48005eac:	f9400fe0 	ldr	x0, [sp, #24]
    48005eb0:	9400206a 	bl	4800e058 <rt_object_is_systemobject>
    48005eb4:	7100001f 	cmp	w0, #0x0
    48005eb8:	540000e1 	b.ne	48005ed4 <rt_sem_detach+0x84>  // b.any
    48005ebc:	d2802982 	mov	x2, #0x14c                 	// #332
    48005ec0:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005ec4:	912b2001 	add	x1, x0, #0xac8
    48005ec8:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005ecc:	911a0000 	add	x0, x0, #0x680
    48005ed0:	94002866 	bl	48010068 <rt_assert_handler>

    /* wakeup all suspended threads */
    _ipc_list_resume_all(&(sem->parent.suspend_thread));
    48005ed4:	f9400fe0 	ldr	x0, [sp, #24]
    48005ed8:	91008000 	add	x0, x0, #0x20
    48005edc:	97ffff8e 	bl	48005d14 <_ipc_list_resume_all>

    /* detach semaphore object */
    rt_object_detach(&(sem->parent.parent));
    48005ee0:	f9400fe0 	ldr	x0, [sp, #24]
    48005ee4:	94001fb2 	bl	4800ddac <rt_object_detach>

    return RT_EOK;
    48005ee8:	d2800000 	mov	x0, #0x0                   	// #0
}
    48005eec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48005ef0:	d65f03c0 	ret

0000000048005ef4 <rt_sem_create>:
 * @return   Return a pointer to the semaphore object. When the return value is RT_NULL, it means the creation failed.
 *
 * @warning  This function can NOT be called in interrupt context. You can use macor RT_DEBUG_NOT_IN_INTERRUPT to check it.
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
    48005ef4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48005ef8:	910003fd 	mov	x29, sp
    48005efc:	f9000fe0 	str	x0, [sp, #24]
    48005f00:	b90017e1 	str	w1, [sp, #20]
    48005f04:	39004fe2 	strb	w2, [sp, #19]
    rt_sem_t sem;

    RT_ASSERT(value < 0x10000U);
    48005f08:	b94017e1 	ldr	w1, [sp, #20]
    48005f0c:	529fffe0 	mov	w0, #0xffff                	// #65535
    48005f10:	6b00003f 	cmp	w1, w0
    48005f14:	540000e9 	b.ls	48005f30 <rt_sem_create+0x3c>  // b.plast
    48005f18:	d2802fa2 	mov	x2, #0x17d                 	// #381
    48005f1c:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f20:	912b6001 	add	x1, x0, #0xad8
    48005f24:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f28:	91178000 	add	x0, x0, #0x5e0
    48005f2c:	9400284f 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    48005f30:	39404fe0 	ldrb	w0, [sp, #19]
    48005f34:	7100001f 	cmp	w0, #0x0
    48005f38:	54000140 	b.eq	48005f60 <rt_sem_create+0x6c>  // b.none
    48005f3c:	39404fe0 	ldrb	w0, [sp, #19]
    48005f40:	7100041f 	cmp	w0, #0x1
    48005f44:	540000e0 	b.eq	48005f60 <rt_sem_create+0x6c>  // b.none
    48005f48:	d2802fc2 	mov	x2, #0x17e                 	// #382
    48005f4c:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f50:	912b6001 	add	x1, x0, #0xad8
    48005f54:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f58:	9117e000 	add	x0, x0, #0x5f8
    48005f5c:	94002843 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    48005f60:	97fff933 	bl	4800442c <rt_hw_interrupt_disable>
    48005f64:	f90017e0 	str	x0, [sp, #40]
    48005f68:	94000dea 	bl	48009710 <rt_interrupt_get_nest>
    48005f6c:	12001c00 	and	w0, w0, #0xff
    48005f70:	7100001f 	cmp	w0, #0x0
    48005f74:	54000180 	b.eq	48005fa4 <rt_sem_create+0xb0>  // b.none
    48005f78:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f7c:	912b6001 	add	x1, x0, #0xad8
    48005f80:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f84:	911ac000 	add	x0, x0, #0x6b0
    48005f88:	9400276a 	bl	4800fd30 <rt_kprintf>
    48005f8c:	d2803002 	mov	x2, #0x180                 	// #384
    48005f90:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f94:	912b6001 	add	x1, x0, #0xad8
    48005f98:	b00000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48005f9c:	91172000 	add	x0, x0, #0x5c8
    48005fa0:	94002832 	bl	48010068 <rt_assert_handler>
    48005fa4:	f94017e0 	ldr	x0, [sp, #40]
    48005fa8:	97fff925 	bl	4800443c <rt_hw_interrupt_enable>

    /* allocate object */
    sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
    48005fac:	f9400fe1 	ldr	x1, [sp, #24]
    48005fb0:	52800040 	mov	w0, #0x2                   	// #2
    48005fb4:	94001fa2 	bl	4800de3c <rt_object_allocate>
    48005fb8:	f90013e0 	str	x0, [sp, #32]
    if (sem == RT_NULL)
    48005fbc:	f94013e0 	ldr	x0, [sp, #32]
    48005fc0:	f100001f 	cmp	x0, #0x0
    48005fc4:	54000061 	b.ne	48005fd0 <rt_sem_create+0xdc>  // b.any
        return sem;
    48005fc8:	f94013e0 	ldr	x0, [sp, #32]
    48005fcc:	1400000b 	b	48005ff8 <rt_sem_create+0x104>

    /* initialize ipc object */
    _ipc_object_init(&(sem->parent));
    48005fd0:	f94013e0 	ldr	x0, [sp, #32]
    48005fd4:	97fffef7 	bl	48005bb0 <_ipc_object_init>

    /* set initial value */
    sem->value = value;
    48005fd8:	b94017e0 	ldr	w0, [sp, #20]
    48005fdc:	12003c01 	and	w1, w0, #0xffff
    48005fe0:	f94013e0 	ldr	x0, [sp, #32]
    48005fe4:	79006001 	strh	w1, [x0, #48]

    /* set parent */
    sem->parent.parent.flag = flag;
    48005fe8:	f94013e0 	ldr	x0, [sp, #32]
    48005fec:	39404fe1 	ldrb	w1, [sp, #19]
    48005ff0:	39002401 	strb	w1, [x0, #9]

    return sem;
    48005ff4:	f94013e0 	ldr	x0, [sp, #32]
}
    48005ff8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48005ffc:	d65f03c0 	ret

0000000048006000 <rt_sem_delete>:
 * @warning  This function can ONLY delete a semaphore initialized by the rt_sem_create() function.
 *           If the semaphore is initialized by the rt_sem_init() function, you MUST NOT USE this function to delete it,
 *           ONLY USE the rt_sem_detach() function to complete the detachment.
 */
rt_err_t rt_sem_delete(rt_sem_t sem)
{
    48006000:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48006004:	910003fd 	mov	x29, sp
    48006008:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(sem != RT_NULL);
    4800600c:	f9400fe0 	ldr	x0, [sp, #24]
    48006010:	f100001f 	cmp	x0, #0x0
    48006014:	540000e1 	b.ne	48006030 <rt_sem_delete+0x30>  // b.any
    48006018:	d2803542 	mov	x2, #0x1aa                 	// #426
    4800601c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006020:	912ba001 	add	x1, x0, #0xae8
    48006024:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006028:	91174000 	add	x0, x0, #0x5d0
    4800602c:	9400280f 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
    48006030:	f9400fe0 	ldr	x0, [sp, #24]
    48006034:	9400201f 	bl	4800e0b0 <rt_object_get_type>
    48006038:	12001c00 	and	w0, w0, #0xff
    4800603c:	7100081f 	cmp	w0, #0x2
    48006040:	540000e0 	b.eq	4800605c <rt_sem_delete+0x5c>  // b.none
    48006044:	d2803562 	mov	x2, #0x1ab                 	// #427
    48006048:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800604c:	912ba001 	add	x1, x0, #0xae8
    48006050:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006054:	9118e000 	add	x0, x0, #0x638
    48006058:	94002804 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent) == RT_FALSE);
    4800605c:	f9400fe0 	ldr	x0, [sp, #24]
    48006060:	94001ffe 	bl	4800e058 <rt_object_is_systemobject>
    48006064:	7100001f 	cmp	w0, #0x0
    48006068:	540000e0 	b.eq	48006084 <rt_sem_delete+0x84>  // b.none
    4800606c:	d2803582 	mov	x2, #0x1ac                 	// #428
    48006070:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006074:	912ba001 	add	x1, x0, #0xae8
    48006078:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800607c:	911b6000 	add	x0, x0, #0x6d8
    48006080:	940027fa 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    48006084:	97fff8ea 	bl	4800442c <rt_hw_interrupt_disable>
    48006088:	f90017e0 	str	x0, [sp, #40]
    4800608c:	94000da1 	bl	48009710 <rt_interrupt_get_nest>
    48006090:	12001c00 	and	w0, w0, #0xff
    48006094:	7100001f 	cmp	w0, #0x0
    48006098:	54000180 	b.eq	480060c8 <rt_sem_delete+0xc8>  // b.none
    4800609c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480060a0:	912ba001 	add	x1, x0, #0xae8
    480060a4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480060a8:	911ac000 	add	x0, x0, #0x6b0
    480060ac:	94002721 	bl	4800fd30 <rt_kprintf>
    480060b0:	d28035c2 	mov	x2, #0x1ae                 	// #430
    480060b4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480060b8:	912ba001 	add	x1, x0, #0xae8
    480060bc:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480060c0:	91172000 	add	x0, x0, #0x5c8
    480060c4:	940027e9 	bl	48010068 <rt_assert_handler>
    480060c8:	f94017e0 	ldr	x0, [sp, #40]
    480060cc:	97fff8dc 	bl	4800443c <rt_hw_interrupt_enable>

    /* wakeup all suspended threads */
    _ipc_list_resume_all(&(sem->parent.suspend_thread));
    480060d0:	f9400fe0 	ldr	x0, [sp, #24]
    480060d4:	91008000 	add	x0, x0, #0x20
    480060d8:	97ffff0f 	bl	48005d14 <_ipc_list_resume_all>

    /* delete semaphore object */
    rt_object_delete(&(sem->parent.parent));
    480060dc:	f9400fe0 	ldr	x0, [sp, #24]
    480060e0:	94001fad 	bl	4800df94 <rt_object_delete>

    return RT_EOK;
    480060e4:	d2800000 	mov	x0, #0x0                   	// #0
}
    480060e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480060ec:	d65f03c0 	ret

00000000480060f0 <rt_sem_take>:
 *           If the return value is any other values, it means that the semaphore take failed.
 *
 * @warning  This function can ONLY be called in the thread context. It MUST NOT BE called in interrupt context.
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
    480060f0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    480060f4:	910003fd 	mov	x29, sp
    480060f8:	f9000bf3 	str	x19, [sp, #16]
    480060fc:	f90017e0 	str	x0, [sp, #40]
    48006100:	b90027e1 	str	w1, [sp, #36]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* parameter check */
    RT_ASSERT(sem != RT_NULL);
    48006104:	f94017e0 	ldr	x0, [sp, #40]
    48006108:	f100001f 	cmp	x0, #0x0
    4800610c:	540000e1 	b.ne	48006128 <rt_sem_take+0x38>  // b.any
    48006110:	d2803b22 	mov	x2, #0x1d9                 	// #473
    48006114:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006118:	912be001 	add	x1, x0, #0xaf8
    4800611c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006120:	91174000 	add	x0, x0, #0x5d0
    48006124:	940027d1 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
    48006128:	f94017e0 	ldr	x0, [sp, #40]
    4800612c:	94001fe1 	bl	4800e0b0 <rt_object_get_type>
    48006130:	12001c00 	and	w0, w0, #0xff
    48006134:	7100081f 	cmp	w0, #0x2
    48006138:	540000e0 	b.eq	48006154 <rt_sem_take+0x64>  // b.none
    4800613c:	d2803b42 	mov	x2, #0x1da                 	// #474
    48006140:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006144:	912be001 	add	x1, x0, #0xaf8
    48006148:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800614c:	9118e000 	add	x0, x0, #0x638
    48006150:	940027c6 	bl	48010068 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
    48006154:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48006158:	91176000 	add	x0, x0, #0x5d8
    4800615c:	f9400000 	ldr	x0, [x0]
    48006160:	f100001f 	cmp	x0, #0x0
    48006164:	540000c0 	b.eq	4800617c <rt_sem_take+0x8c>  // b.none
    48006168:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800616c:	91176000 	add	x0, x0, #0x5d8
    48006170:	f9400001 	ldr	x1, [x0]
    48006174:	f94017e0 	ldr	x0, [sp, #40]
    48006178:	d63f0020 	blr	x1

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    4800617c:	97fff8ac 	bl	4800442c <rt_hw_interrupt_disable>
    48006180:	aa0003f3 	mov	x19, x0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (sem->value > 0)
    48006184:	f94017e0 	ldr	x0, [sp, #40]
    48006188:	79406000 	ldrh	w0, [x0, #48]
    4800618c:	7100001f 	cmp	w0, #0x0
    48006190:	54000140 	b.eq	480061b8 <rt_sem_take+0xc8>  // b.none
    {
        /* semaphore is available */
        sem->value --;
    48006194:	f94017e0 	ldr	x0, [sp, #40]
    48006198:	79406000 	ldrh	w0, [x0, #48]
    4800619c:	51000400 	sub	w0, w0, #0x1
    480061a0:	12003c01 	and	w1, w0, #0xffff
    480061a4:	f94017e0 	ldr	x0, [sp, #40]
    480061a8:	79006001 	strh	w1, [x0, #48]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    480061ac:	aa1303e0 	mov	x0, x19
    480061b0:	97fff8a3 	bl	4800443c <rt_hw_interrupt_enable>
    480061b4:	1400004f 	b	480062f0 <rt_sem_take+0x200>
    }
    else
    {
        /* no waiting, return with timeout */
        if (time == 0)
    480061b8:	b94027e0 	ldr	w0, [sp, #36]
    480061bc:	7100001f 	cmp	w0, #0x0
    480061c0:	540000a1 	b.ne	480061d4 <rt_sem_take+0xe4>  // b.any
        {
            rt_hw_interrupt_enable(temp);
    480061c4:	aa1303e0 	mov	x0, x19
    480061c8:	97fff89d 	bl	4800443c <rt_hw_interrupt_enable>

            return -RT_ETIMEOUT;
    480061cc:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    480061d0:	14000053 	b	4800631c <rt_sem_take+0x22c>
        }
        else
        {
            /* current context checking */
            RT_DEBUG_IN_THREAD_CONTEXT;
    480061d4:	97fff896 	bl	4800442c <rt_hw_interrupt_disable>
    480061d8:	f90027e0 	str	x0, [sp, #72]
    480061dc:	94001670 	bl	4800bb9c <rt_thread_self>
    480061e0:	f100001f 	cmp	x0, #0x0
    480061e4:	54000181 	b.ne	48006214 <rt_sem_take+0x124>  // b.any
    480061e8:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480061ec:	912be001 	add	x1, x0, #0xaf8
    480061f0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480061f4:	911c6000 	add	x0, x0, #0x718
    480061f8:	940026ce 	bl	4800fd30 <rt_kprintf>
    480061fc:	d2803f42 	mov	x2, #0x1fa                 	// #506
    48006200:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006204:	912be001 	add	x1, x0, #0xaf8
    48006208:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800620c:	91172000 	add	x0, x0, #0x5c8
    48006210:	94002796 	bl	48010068 <rt_assert_handler>
    48006214:	97fff886 	bl	4800442c <rt_hw_interrupt_disable>
    48006218:	f90023e0 	str	x0, [sp, #64]
    4800621c:	94000d3d 	bl	48009710 <rt_interrupt_get_nest>
    48006220:	12001c00 	and	w0, w0, #0xff
    48006224:	7100001f 	cmp	w0, #0x0
    48006228:	54000180 	b.eq	48006258 <rt_sem_take+0x168>  // b.none
    4800622c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006230:	912be001 	add	x1, x0, #0xaf8
    48006234:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006238:	911ac000 	add	x0, x0, #0x6b0
    4800623c:	940026bd 	bl	4800fd30 <rt_kprintf>
    48006240:	d2803f42 	mov	x2, #0x1fa                 	// #506
    48006244:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006248:	912be001 	add	x1, x0, #0xaf8
    4800624c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006250:	91172000 	add	x0, x0, #0x5c8
    48006254:	94002785 	bl	48010068 <rt_assert_handler>
    48006258:	f94023e0 	ldr	x0, [sp, #64]
    4800625c:	97fff878 	bl	4800443c <rt_hw_interrupt_enable>
    48006260:	f94027e0 	ldr	x0, [sp, #72]
    48006264:	97fff876 	bl	4800443c <rt_hw_interrupt_enable>

            /* semaphore is unavailable, push to suspend list */
            /* get current thread */
            thread = rt_thread_self();
    48006268:	9400164d 	bl	4800bb9c <rt_thread_self>
    4800626c:	f9001fe0 	str	x0, [sp, #56]

            /* reset thread error number */
            thread->error = RT_EOK;
    48006270:	f9401fe0 	ldr	x0, [sp, #56]
    48006274:	f9002c1f 	str	xzr, [x0, #88]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
                                        thread->name));

            /* suspend thread */
            _ipc_list_suspend(&(sem->parent.suspend_thread),
    48006278:	f94017e0 	ldr	x0, [sp, #40]
    4800627c:	91008003 	add	x3, x0, #0x20
    48006280:	f94017e0 	ldr	x0, [sp, #40]
    48006284:	39402400 	ldrb	w0, [x0, #9]
    48006288:	2a0003e2 	mov	w2, w0
    4800628c:	f9401fe1 	ldr	x1, [sp, #56]
    48006290:	aa0303e0 	mov	x0, x3
    48006294:	97fffe50 	bl	48005bd4 <_ipc_list_suspend>
                                thread,
                                sem->parent.parent.flag);

            /* has waiting time, start thread timer */
            if (time > 0)
    48006298:	b94027e0 	ldr	w0, [sp, #36]
    4800629c:	7100001f 	cmp	w0, #0x0
    480062a0:	5400014d 	b.le	480062c8 <rt_sem_take+0x1d8>
            {
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                            thread->name));

                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
    480062a4:	f9401fe0 	ldr	x0, [sp, #56]
    480062a8:	91020000 	add	x0, x0, #0x80
    480062ac:	910093e1 	add	x1, sp, #0x24
    480062b0:	aa0103e2 	mov	x2, x1
    480062b4:	52800001 	mov	w1, #0x0                   	// #0
    480062b8:	9400139a 	bl	4800b120 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &time);
                rt_timer_start(&(thread->thread_timer));
    480062bc:	f9401fe0 	ldr	x0, [sp, #56]
    480062c0:	91020000 	add	x0, x0, #0x80
    480062c4:	94001270 	bl	4800ac84 <rt_timer_start>
            }

            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
    480062c8:	aa1303e0 	mov	x0, x19
    480062cc:	97fff85c 	bl	4800443c <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
    480062d0:	94001c2f 	bl	4800d38c <rt_schedule>

            if (thread->error != RT_EOK)
    480062d4:	f9401fe0 	ldr	x0, [sp, #56]
    480062d8:	f9402c00 	ldr	x0, [x0, #88]
    480062dc:	f100001f 	cmp	x0, #0x0
    480062e0:	54000080 	b.eq	480062f0 <rt_sem_take+0x200>  // b.none
            {
                return thread->error;
    480062e4:	f9401fe0 	ldr	x0, [sp, #56]
    480062e8:	f9402c00 	ldr	x0, [x0, #88]
    480062ec:	1400000c 	b	4800631c <rt_sem_take+0x22c>
            }
        }
    }

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
    480062f0:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480062f4:	91178000 	add	x0, x0, #0x5e0
    480062f8:	f9400000 	ldr	x0, [x0]
    480062fc:	f100001f 	cmp	x0, #0x0
    48006300:	540000c0 	b.eq	48006318 <rt_sem_take+0x228>  // b.none
    48006304:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48006308:	91178000 	add	x0, x0, #0x5e0
    4800630c:	f9400001 	ldr	x1, [x0]
    48006310:	f94017e0 	ldr	x0, [sp, #40]
    48006314:	d63f0020 	blr	x1

    return RT_EOK;
    48006318:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800631c:	f9400bf3 	ldr	x19, [sp, #16]
    48006320:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48006324:	d65f03c0 	ret

0000000048006328 <rt_sem_trytake>:
 *
 * @return   Return the operation status. ONLY When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the semaphore take failed.
 */
rt_err_t rt_sem_trytake(rt_sem_t sem)
{
    48006328:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800632c:	910003fd 	mov	x29, sp
    48006330:	f9000fe0 	str	x0, [sp, #24]
    return rt_sem_take(sem, RT_WAITING_NO);
    48006334:	52800001 	mov	w1, #0x0                   	// #0
    48006338:	f9400fe0 	ldr	x0, [sp, #24]
    4800633c:	97ffff6d 	bl	480060f0 <rt_sem_take>
}
    48006340:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48006344:	d65f03c0 	ret

0000000048006348 <rt_sem_release>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the semaphore release failed.
 */
rt_err_t rt_sem_release(rt_sem_t sem)
{
    48006348:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800634c:	910003fd 	mov	x29, sp
    48006350:	a90153f3 	stp	x19, x20, [sp, #16]
    48006354:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t temp;
    register rt_bool_t need_schedule;

    /* parameter check */
    RT_ASSERT(sem != RT_NULL);
    48006358:	f94017e0 	ldr	x0, [sp, #40]
    4800635c:	f100001f 	cmp	x0, #0x0
    48006360:	540000e1 	b.ne	4800637c <rt_sem_release+0x34>  // b.any
    48006364:	d2804a62 	mov	x2, #0x253                 	// #595
    48006368:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800636c:	912c8001 	add	x1, x0, #0xb20
    48006370:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006374:	91174000 	add	x0, x0, #0x5d0
    48006378:	9400273c 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
    4800637c:	f94017e0 	ldr	x0, [sp, #40]
    48006380:	94001f4c 	bl	4800e0b0 <rt_object_get_type>
    48006384:	12001c00 	and	w0, w0, #0xff
    48006388:	7100081f 	cmp	w0, #0x2
    4800638c:	540000e0 	b.eq	480063a8 <rt_sem_release+0x60>  // b.none
    48006390:	d2804a82 	mov	x2, #0x254                 	// #596
    48006394:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006398:	912c8001 	add	x1, x0, #0xb20
    4800639c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480063a0:	9118e000 	add	x0, x0, #0x638
    480063a4:	94002731 	bl	48010068 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
    480063a8:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480063ac:	9117a000 	add	x0, x0, #0x5e8
    480063b0:	f9400000 	ldr	x0, [x0]
    480063b4:	f100001f 	cmp	x0, #0x0
    480063b8:	540000c0 	b.eq	480063d0 <rt_sem_release+0x88>  // b.none
    480063bc:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480063c0:	9117a000 	add	x0, x0, #0x5e8
    480063c4:	f9400001 	ldr	x1, [x0]
    480063c8:	f94017e0 	ldr	x0, [sp, #40]
    480063cc:	d63f0020 	blr	x1

    need_schedule = RT_FALSE;
    480063d0:	52800013 	mov	w19, #0x0                   	// #0

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    480063d4:	97fff816 	bl	4800442c <rt_hw_interrupt_disable>
    480063d8:	aa0003f4 	mov	x20, x0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (!rt_list_isempty(&sem->parent.suspend_thread))
    480063dc:	f94017e0 	ldr	x0, [sp, #40]
    480063e0:	91008000 	add	x0, x0, #0x20
    480063e4:	97fffde9 	bl	48005b88 <rt_list_isempty>
    480063e8:	7100001f 	cmp	w0, #0x0
    480063ec:	540000c1 	b.ne	48006404 <rt_sem_release+0xbc>  // b.any
    {
        /* resume the suspended thread */
        _ipc_list_resume(&(sem->parent.suspend_thread));
    480063f0:	f94017e0 	ldr	x0, [sp, #40]
    480063f4:	91008000 	add	x0, x0, #0x20
    480063f8:	97fffe3b 	bl	48005ce4 <_ipc_list_resume>
        need_schedule = RT_TRUE;
    480063fc:	52800033 	mov	w19, #0x1                   	// #1
    48006400:	14000011 	b	48006444 <rt_sem_release+0xfc>
    }
    else
    {
        if(sem->value < RT_SEM_VALUE_MAX)
    48006404:	f94017e0 	ldr	x0, [sp, #40]
    48006408:	79406001 	ldrh	w1, [x0, #48]
    4800640c:	529fffe0 	mov	w0, #0xffff                	// #65535
    48006410:	6b00003f 	cmp	w1, w0
    48006414:	54000100 	b.eq	48006434 <rt_sem_release+0xec>  // b.none
        {
            sem->value ++; /* increase value */
    48006418:	f94017e0 	ldr	x0, [sp, #40]
    4800641c:	79406000 	ldrh	w0, [x0, #48]
    48006420:	11000400 	add	w0, w0, #0x1
    48006424:	12003c01 	and	w1, w0, #0xffff
    48006428:	f94017e0 	ldr	x0, [sp, #40]
    4800642c:	79006001 	strh	w1, [x0, #48]
    48006430:	14000005 	b	48006444 <rt_sem_release+0xfc>
        }
        else
        {
            rt_hw_interrupt_enable(temp); /* enable interrupt */
    48006434:	aa1403e0 	mov	x0, x20
    48006438:	97fff801 	bl	4800443c <rt_hw_interrupt_enable>
            return -RT_EFULL; /* value overflowed */
    4800643c:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48006440:	14000007 	b	4800645c <rt_sem_release+0x114>
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48006444:	aa1403e0 	mov	x0, x20
    48006448:	97fff7fd 	bl	4800443c <rt_hw_interrupt_enable>

    /* resume a thread, re-schedule */
    if (need_schedule == RT_TRUE)
    4800644c:	7100067f 	cmp	w19, #0x1
    48006450:	54000041 	b.ne	48006458 <rt_sem_release+0x110>  // b.any
        rt_schedule();
    48006454:	94001bce 	bl	4800d38c <rt_schedule>

    return RT_EOK;
    48006458:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800645c:	a94153f3 	ldp	x19, x20, [sp, #16]
    48006460:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48006464:	d65f03c0 	ret

0000000048006468 <rt_sem_control>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that this function failed to execute.
 */
rt_err_t rt_sem_control(rt_sem_t sem, int cmd, void *arg)
{
    48006468:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800646c:	910003fd 	mov	x29, sp
    48006470:	f90017e0 	str	x0, [sp, #40]
    48006474:	b90027e1 	str	w1, [sp, #36]
    48006478:	f9000fe2 	str	x2, [sp, #24]
    rt_ubase_t level;

    /* parameter check */
    RT_ASSERT(sem != RT_NULL);
    4800647c:	f94017e0 	ldr	x0, [sp, #40]
    48006480:	f100001f 	cmp	x0, #0x0
    48006484:	540000e1 	b.ne	480064a0 <rt_sem_control+0x38>  // b.any
    48006488:	d2805282 	mov	x2, #0x294                 	// #660
    4800648c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006490:	912cc001 	add	x1, x0, #0xb30
    48006494:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006498:	91174000 	add	x0, x0, #0x5d0
    4800649c:	940026f3 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
    480064a0:	f94017e0 	ldr	x0, [sp, #40]
    480064a4:	94001f03 	bl	4800e0b0 <rt_object_get_type>
    480064a8:	12001c00 	and	w0, w0, #0xff
    480064ac:	7100081f 	cmp	w0, #0x2
    480064b0:	540000e0 	b.eq	480064cc <rt_sem_control+0x64>  // b.none
    480064b4:	d28052a2 	mov	x2, #0x295                 	// #661
    480064b8:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480064bc:	912cc001 	add	x1, x0, #0xb30
    480064c0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480064c4:	9118e000 	add	x0, x0, #0x638
    480064c8:	940026e8 	bl	48010068 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
    480064cc:	b94027e0 	ldr	w0, [sp, #36]
    480064d0:	7100041f 	cmp	w0, #0x1
    480064d4:	54000221 	b.ne	48006518 <rt_sem_control+0xb0>  // b.any
    {
        rt_ubase_t value;

        /* get value */
        value = (rt_ubase_t)arg;
    480064d8:	f9400fe0 	ldr	x0, [sp, #24]
    480064dc:	f9001fe0 	str	x0, [sp, #56]
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    480064e0:	97fff7d3 	bl	4800442c <rt_hw_interrupt_disable>
    480064e4:	f9001be0 	str	x0, [sp, #48]

        /* resume all waiting thread */
        _ipc_list_resume_all(&sem->parent.suspend_thread);
    480064e8:	f94017e0 	ldr	x0, [sp, #40]
    480064ec:	91008000 	add	x0, x0, #0x20
    480064f0:	97fffe09 	bl	48005d14 <_ipc_list_resume_all>

        /* set new value */
        sem->value = (rt_uint16_t)value;
    480064f4:	f9401fe0 	ldr	x0, [sp, #56]
    480064f8:	12003c01 	and	w1, w0, #0xffff
    480064fc:	f94017e0 	ldr	x0, [sp, #40]
    48006500:	79006001 	strh	w1, [x0, #48]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    48006504:	f9401be0 	ldr	x0, [sp, #48]
    48006508:	97fff7cd 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    4800650c:	94001ba0 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    48006510:	d2800000 	mov	x0, #0x0                   	// #0
    48006514:	14000002 	b	4800651c <rt_sem_control+0xb4>
    }

    return -RT_ERROR;
    48006518:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
    4800651c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48006520:	d65f03c0 	ret

0000000048006524 <rt_mutex_init>:
 *           If the return value is any other values, it represents the initialization failed.
 *
 * @warning  This function can ONLY be called from threads.
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
    48006524:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48006528:	910003fd 	mov	x29, sp
    4800652c:	f90017e0 	str	x0, [sp, #40]
    48006530:	f90013e1 	str	x1, [sp, #32]
    48006534:	39007fe2 	strb	w2, [sp, #31]
    (void)flag;

    /* parameter check */
    RT_ASSERT(mutex != RT_NULL);
    48006538:	f94017e0 	ldr	x0, [sp, #40]
    4800653c:	f100001f 	cmp	x0, #0x0
    48006540:	540000e1 	b.ne	4800655c <rt_mutex_init+0x38>  // b.any
    48006544:	d2805b42 	mov	x2, #0x2da                 	// #730
    48006548:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800654c:	912d0001 	add	x1, x0, #0xb40
    48006550:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006554:	911d4000 	add	x0, x0, #0x750
    48006558:	940026c4 	bl	48010068 <rt_assert_handler>

    /* initialize object */
    rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
    4800655c:	f94017e0 	ldr	x0, [sp, #40]
    48006560:	f94013e2 	ldr	x2, [sp, #32]
    48006564:	52800061 	mov	w1, #0x3                   	// #3
    48006568:	94001dbd 	bl	4800dc5c <rt_object_init>

    /* initialize ipc object */
    _ipc_object_init(&(mutex->parent));
    4800656c:	f94017e0 	ldr	x0, [sp, #40]
    48006570:	97fffd90 	bl	48005bb0 <_ipc_object_init>

    mutex->value = 1;
    48006574:	f94017e0 	ldr	x0, [sp, #40]
    48006578:	52800021 	mov	w1, #0x1                   	// #1
    4800657c:	79006001 	strh	w1, [x0, #48]
    mutex->owner = RT_NULL;
    48006580:	f94017e0 	ldr	x0, [sp, #40]
    48006584:	f9001c1f 	str	xzr, [x0, #56]
    mutex->original_priority = 0xFF;
    48006588:	f94017e0 	ldr	x0, [sp, #40]
    4800658c:	12800001 	mov	w1, #0xffffffff            	// #-1
    48006590:	3900c801 	strb	w1, [x0, #50]
    mutex->hold  = 0;
    48006594:	f94017e0 	ldr	x0, [sp, #40]
    48006598:	3900cc1f 	strb	wzr, [x0, #51]

    /* flag can only be RT_IPC_FLAG_PRIO. RT_IPC_FLAG_FIFO cannot solve the unbounded priority inversion problem */
    mutex->parent.parent.flag = RT_IPC_FLAG_PRIO;
    4800659c:	f94017e0 	ldr	x0, [sp, #40]
    480065a0:	52800021 	mov	w1, #0x1                   	// #1
    480065a4:	39002401 	strb	w1, [x0, #9]

    return RT_EOK;
    480065a8:	d2800000 	mov	x0, #0x0                   	// #0
}
    480065ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480065b0:	d65f03c0 	ret

00000000480065b4 <rt_mutex_detach>:
 * @warning  This function can ONLY detach a static mutex initialized by the rt_mutex_init() function.
 *           If the mutex is created by the rt_mutex_create() function, you MUST NOT USE this function to detach it,
 *           ONLY USE the rt_mutex_delete() function to complete the deletion.
 */
rt_err_t rt_mutex_detach(rt_mutex_t mutex)
{
    480065b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480065b8:	910003fd 	mov	x29, sp
    480065bc:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(mutex != RT_NULL);
    480065c0:	f9400fe0 	ldr	x0, [sp, #24]
    480065c4:	f100001f 	cmp	x0, #0x0
    480065c8:	540000e1 	b.ne	480065e4 <rt_mutex_detach+0x30>  // b.any
    480065cc:	d2806082 	mov	x2, #0x304                 	// #772
    480065d0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480065d4:	912d4001 	add	x1, x0, #0xb50
    480065d8:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480065dc:	911d4000 	add	x0, x0, #0x750
    480065e0:	940026a2 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
    480065e4:	f9400fe0 	ldr	x0, [sp, #24]
    480065e8:	94001eb2 	bl	4800e0b0 <rt_object_get_type>
    480065ec:	12001c00 	and	w0, w0, #0xff
    480065f0:	71000c1f 	cmp	w0, #0x3
    480065f4:	540000e0 	b.eq	48006610 <rt_mutex_detach+0x5c>  // b.none
    480065f8:	d28060a2 	mov	x2, #0x305                 	// #773
    480065fc:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006600:	912d4001 	add	x1, x0, #0xb50
    48006604:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006608:	911da000 	add	x0, x0, #0x768
    4800660c:	94002697 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent));
    48006610:	f9400fe0 	ldr	x0, [sp, #24]
    48006614:	94001e91 	bl	4800e058 <rt_object_is_systemobject>
    48006618:	7100001f 	cmp	w0, #0x0
    4800661c:	540000e1 	b.ne	48006638 <rt_mutex_detach+0x84>  // b.any
    48006620:	d28060c2 	mov	x2, #0x306                 	// #774
    48006624:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006628:	912d4001 	add	x1, x0, #0xb50
    4800662c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006630:	911ec000 	add	x0, x0, #0x7b0
    48006634:	9400268d 	bl	48010068 <rt_assert_handler>

    /* wakeup all suspended threads */
    _ipc_list_resume_all(&(mutex->parent.suspend_thread));
    48006638:	f9400fe0 	ldr	x0, [sp, #24]
    4800663c:	91008000 	add	x0, x0, #0x20
    48006640:	97fffdb5 	bl	48005d14 <_ipc_list_resume_all>

    /* detach mutex object */
    rt_object_detach(&(mutex->parent.parent));
    48006644:	f9400fe0 	ldr	x0, [sp, #24]
    48006648:	94001dd9 	bl	4800ddac <rt_object_detach>

    return RT_EOK;
    4800664c:	d2800000 	mov	x0, #0x0                   	// #0
}
    48006650:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48006654:	d65f03c0 	ret

0000000048006658 <rt_mutex_create>:
 * @return   Return a pointer to the mutex object. When the return value is RT_NULL, it means the creation failed.
 *
 * @warning  This function can ONLY be called from threads.
 */
rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
{
    48006658:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800665c:	910003fd 	mov	x29, sp
    48006660:	f9000fe0 	str	x0, [sp, #24]
    48006664:	39005fe1 	strb	w1, [sp, #23]
    struct rt_mutex *mutex;
    (void)flag;

    RT_DEBUG_NOT_IN_INTERRUPT;
    48006668:	97fff771 	bl	4800442c <rt_hw_interrupt_disable>
    4800666c:	f90017e0 	str	x0, [sp, #40]
    48006670:	94000c28 	bl	48009710 <rt_interrupt_get_nest>
    48006674:	12001c00 	and	w0, w0, #0xff
    48006678:	7100001f 	cmp	w0, #0x0
    4800667c:	54000180 	b.eq	480066ac <rt_mutex_create+0x54>  // b.none
    48006680:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006684:	912d8001 	add	x1, x0, #0xb60
    48006688:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800668c:	911ac000 	add	x0, x0, #0x6b0
    48006690:	940025a8 	bl	4800fd30 <rt_kprintf>
    48006694:	d2806562 	mov	x2, #0x32b                 	// #811
    48006698:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800669c:	912d8001 	add	x1, x0, #0xb60
    480066a0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480066a4:	91172000 	add	x0, x0, #0x5c8
    480066a8:	94002670 	bl	48010068 <rt_assert_handler>
    480066ac:	f94017e0 	ldr	x0, [sp, #40]
    480066b0:	97fff763 	bl	4800443c <rt_hw_interrupt_enable>

    /* allocate object */
    mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
    480066b4:	f9400fe1 	ldr	x1, [sp, #24]
    480066b8:	52800060 	mov	w0, #0x3                   	// #3
    480066bc:	94001de0 	bl	4800de3c <rt_object_allocate>
    480066c0:	f90013e0 	str	x0, [sp, #32]
    if (mutex == RT_NULL)
    480066c4:	f94013e0 	ldr	x0, [sp, #32]
    480066c8:	f100001f 	cmp	x0, #0x0
    480066cc:	54000061 	b.ne	480066d8 <rt_mutex_create+0x80>  // b.any
        return mutex;
    480066d0:	f94013e0 	ldr	x0, [sp, #32]
    480066d4:	14000011 	b	48006718 <rt_mutex_create+0xc0>

    /* initialize ipc object */
    _ipc_object_init(&(mutex->parent));
    480066d8:	f94013e0 	ldr	x0, [sp, #32]
    480066dc:	97fffd35 	bl	48005bb0 <_ipc_object_init>

    mutex->value              = 1;
    480066e0:	f94013e0 	ldr	x0, [sp, #32]
    480066e4:	52800021 	mov	w1, #0x1                   	// #1
    480066e8:	79006001 	strh	w1, [x0, #48]
    mutex->owner              = RT_NULL;
    480066ec:	f94013e0 	ldr	x0, [sp, #32]
    480066f0:	f9001c1f 	str	xzr, [x0, #56]
    mutex->original_priority  = 0xFF;
    480066f4:	f94013e0 	ldr	x0, [sp, #32]
    480066f8:	12800001 	mov	w1, #0xffffffff            	// #-1
    480066fc:	3900c801 	strb	w1, [x0, #50]
    mutex->hold               = 0;
    48006700:	f94013e0 	ldr	x0, [sp, #32]
    48006704:	3900cc1f 	strb	wzr, [x0, #51]

    /* flag can only be RT_IPC_FLAG_PRIO. RT_IPC_FLAG_FIFO cannot solve the unbounded priority inversion problem */
    mutex->parent.parent.flag = RT_IPC_FLAG_PRIO;
    48006708:	f94013e0 	ldr	x0, [sp, #32]
    4800670c:	52800021 	mov	w1, #0x1                   	// #1
    48006710:	39002401 	strb	w1, [x0, #9]

    return mutex;
    48006714:	f94013e0 	ldr	x0, [sp, #32]
}
    48006718:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800671c:	d65f03c0 	ret

0000000048006720 <rt_mutex_delete>:
 * @warning  This function can ONLY delete a mutex initialized by the rt_mutex_create() function.
 *           If the mutex is initialized by the rt_mutex_init() function, you MUST NOT USE this function to delete it,
 *           ONLY USE the rt_mutex_detach() function to complete the detachment.
 */
rt_err_t rt_mutex_delete(rt_mutex_t mutex)
{
    48006720:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48006724:	910003fd 	mov	x29, sp
    48006728:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(mutex != RT_NULL);
    4800672c:	f9400fe0 	ldr	x0, [sp, #24]
    48006730:	f100001f 	cmp	x0, #0x0
    48006734:	540000e1 	b.ne	48006750 <rt_mutex_delete+0x30>  // b.any
    48006738:	d2806ae2 	mov	x2, #0x357                 	// #855
    4800673c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006740:	912dc001 	add	x1, x0, #0xb70
    48006744:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006748:	911d4000 	add	x0, x0, #0x750
    4800674c:	94002647 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
    48006750:	f9400fe0 	ldr	x0, [sp, #24]
    48006754:	94001e57 	bl	4800e0b0 <rt_object_get_type>
    48006758:	12001c00 	and	w0, w0, #0xff
    4800675c:	71000c1f 	cmp	w0, #0x3
    48006760:	540000e0 	b.eq	4800677c <rt_mutex_delete+0x5c>  // b.none
    48006764:	d2806b02 	mov	x2, #0x358                 	// #856
    48006768:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800676c:	912dc001 	add	x1, x0, #0xb70
    48006770:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006774:	911da000 	add	x0, x0, #0x768
    48006778:	9400263c 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent) == RT_FALSE);
    4800677c:	f9400fe0 	ldr	x0, [sp, #24]
    48006780:	94001e36 	bl	4800e058 <rt_object_is_systemobject>
    48006784:	7100001f 	cmp	w0, #0x0
    48006788:	540000e0 	b.eq	480067a4 <rt_mutex_delete+0x84>  // b.none
    4800678c:	d2806b22 	mov	x2, #0x359                 	// #857
    48006790:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006794:	912dc001 	add	x1, x0, #0xb70
    48006798:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800679c:	911fa000 	add	x0, x0, #0x7e8
    480067a0:	94002632 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    480067a4:	97fff722 	bl	4800442c <rt_hw_interrupt_disable>
    480067a8:	f90017e0 	str	x0, [sp, #40]
    480067ac:	94000bd9 	bl	48009710 <rt_interrupt_get_nest>
    480067b0:	12001c00 	and	w0, w0, #0xff
    480067b4:	7100001f 	cmp	w0, #0x0
    480067b8:	54000180 	b.eq	480067e8 <rt_mutex_delete+0xc8>  // b.none
    480067bc:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480067c0:	912dc001 	add	x1, x0, #0xb70
    480067c4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480067c8:	911ac000 	add	x0, x0, #0x6b0
    480067cc:	94002559 	bl	4800fd30 <rt_kprintf>
    480067d0:	d2806b62 	mov	x2, #0x35b                 	// #859
    480067d4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480067d8:	912dc001 	add	x1, x0, #0xb70
    480067dc:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480067e0:	91172000 	add	x0, x0, #0x5c8
    480067e4:	94002621 	bl	48010068 <rt_assert_handler>
    480067e8:	f94017e0 	ldr	x0, [sp, #40]
    480067ec:	97fff714 	bl	4800443c <rt_hw_interrupt_enable>

    /* wakeup all suspended threads */
    _ipc_list_resume_all(&(mutex->parent.suspend_thread));
    480067f0:	f9400fe0 	ldr	x0, [sp, #24]
    480067f4:	91008000 	add	x0, x0, #0x20
    480067f8:	97fffd47 	bl	48005d14 <_ipc_list_resume_all>

    /* delete mutex object */
    rt_object_delete(&(mutex->parent.parent));
    480067fc:	f9400fe0 	ldr	x0, [sp, #24]
    48006800:	94001de5 	bl	4800df94 <rt_object_delete>

    return RT_EOK;
    48006804:	d2800000 	mov	x0, #0x0                   	// #0
}
    48006808:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800680c:	d65f03c0 	ret

0000000048006810 <rt_mutex_take>:
 *           If the return value is any other values, it means that the mutex take failed.
 *
 * @warning  This function can ONLY be called in the thread context. It MUST NOT BE called in interrupt context.
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
    48006810:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48006814:	910003fd 	mov	x29, sp
    48006818:	f9000bf3 	str	x19, [sp, #16]
    4800681c:	f90017e0 	str	x0, [sp, #40]
    48006820:	b90027e1 	str	w1, [sp, #36]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* this function must not be used in interrupt even if time = 0 */
    RT_DEBUG_IN_THREAD_CONTEXT;
    48006824:	97fff702 	bl	4800442c <rt_hw_interrupt_disable>
    48006828:	f90027e0 	str	x0, [sp, #72]
    4800682c:	940014dc 	bl	4800bb9c <rt_thread_self>
    48006830:	f100001f 	cmp	x0, #0x0
    48006834:	54000181 	b.ne	48006864 <rt_mutex_take+0x54>  // b.any
    48006838:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800683c:	912e0001 	add	x1, x0, #0xb80
    48006840:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006844:	911c6000 	add	x0, x0, #0x718
    48006848:	9400253a 	bl	4800fd30 <rt_kprintf>
    4800684c:	d28070c2 	mov	x2, #0x386                 	// #902
    48006850:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006854:	912e0001 	add	x1, x0, #0xb80
    48006858:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800685c:	91172000 	add	x0, x0, #0x5c8
    48006860:	94002602 	bl	48010068 <rt_assert_handler>
    48006864:	97fff6f2 	bl	4800442c <rt_hw_interrupt_disable>
    48006868:	f90023e0 	str	x0, [sp, #64]
    4800686c:	94000ba9 	bl	48009710 <rt_interrupt_get_nest>
    48006870:	12001c00 	and	w0, w0, #0xff
    48006874:	7100001f 	cmp	w0, #0x0
    48006878:	54000180 	b.eq	480068a8 <rt_mutex_take+0x98>  // b.none
    4800687c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006880:	912e0001 	add	x1, x0, #0xb80
    48006884:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006888:	911ac000 	add	x0, x0, #0x6b0
    4800688c:	94002529 	bl	4800fd30 <rt_kprintf>
    48006890:	d28070c2 	mov	x2, #0x386                 	// #902
    48006894:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006898:	912e0001 	add	x1, x0, #0xb80
    4800689c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480068a0:	91172000 	add	x0, x0, #0x5c8
    480068a4:	940025f1 	bl	48010068 <rt_assert_handler>
    480068a8:	f94023e0 	ldr	x0, [sp, #64]
    480068ac:	97fff6e4 	bl	4800443c <rt_hw_interrupt_enable>
    480068b0:	f94027e0 	ldr	x0, [sp, #72]
    480068b4:	97fff6e2 	bl	4800443c <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mutex != RT_NULL);
    480068b8:	f94017e0 	ldr	x0, [sp, #40]
    480068bc:	f100001f 	cmp	x0, #0x0
    480068c0:	540000e1 	b.ne	480068dc <rt_mutex_take+0xcc>  // b.any
    480068c4:	d2807122 	mov	x2, #0x389                 	// #905
    480068c8:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480068cc:	912e0001 	add	x1, x0, #0xb80
    480068d0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480068d4:	911d4000 	add	x0, x0, #0x750
    480068d8:	940025e4 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
    480068dc:	f94017e0 	ldr	x0, [sp, #40]
    480068e0:	94001df4 	bl	4800e0b0 <rt_object_get_type>
    480068e4:	12001c00 	and	w0, w0, #0xff
    480068e8:	71000c1f 	cmp	w0, #0x3
    480068ec:	540000e0 	b.eq	48006908 <rt_mutex_take+0xf8>  // b.none
    480068f0:	d2807142 	mov	x2, #0x38a                 	// #906
    480068f4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480068f8:	912e0001 	add	x1, x0, #0xb80
    480068fc:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006900:	911da000 	add	x0, x0, #0x768
    48006904:	940025d9 	bl	48010068 <rt_assert_handler>

    /* get current thread */
    thread = rt_thread_self();
    48006908:	940014a5 	bl	4800bb9c <rt_thread_self>
    4800690c:	f9001fe0 	str	x0, [sp, #56]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48006910:	97fff6c7 	bl	4800442c <rt_hw_interrupt_disable>
    48006914:	aa0003f3 	mov	x19, x0

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
    48006918:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800691c:	91176000 	add	x0, x0, #0x5d8
    48006920:	f9400000 	ldr	x0, [x0]
    48006924:	f100001f 	cmp	x0, #0x0
    48006928:	540000c0 	b.eq	48006940 <rt_mutex_take+0x130>  // b.none
    4800692c:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48006930:	91176000 	add	x0, x0, #0x5d8
    48006934:	f9400001 	ldr	x1, [x0]
    48006938:	f94017e0 	ldr	x0, [sp, #40]
    4800693c:	d63f0020 	blr	x1
    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    /* reset thread error */
    thread->error = RT_EOK;
    48006940:	f9401fe0 	ldr	x0, [sp, #56]
    48006944:	f9002c1f 	str	xzr, [x0, #88]

    if (mutex->owner == thread)
    48006948:	f94017e0 	ldr	x0, [sp, #40]
    4800694c:	f9401c00 	ldr	x0, [x0, #56]
    48006950:	f9401fe1 	ldr	x1, [sp, #56]
    48006954:	eb00003f 	cmp	x1, x0
    48006958:	54000201 	b.ne	48006998 <rt_mutex_take+0x188>  // b.any
    {
        if(mutex->hold < RT_MUTEX_HOLD_MAX)
    4800695c:	f94017e0 	ldr	x0, [sp, #40]
    48006960:	3940cc00 	ldrb	w0, [x0, #51]
    48006964:	7103fc1f 	cmp	w0, #0xff
    48006968:	54000100 	b.eq	48006988 <rt_mutex_take+0x178>  // b.none
        {
            /* it's the same thread */
            mutex->hold ++;
    4800696c:	f94017e0 	ldr	x0, [sp, #40]
    48006970:	3940cc00 	ldrb	w0, [x0, #51]
    48006974:	11000400 	add	w0, w0, #0x1
    48006978:	12001c01 	and	w1, w0, #0xff
    4800697c:	f94017e0 	ldr	x0, [sp, #40]
    48006980:	3900cc01 	strb	w1, [x0, #51]
    48006984:	1400005e 	b	48006afc <rt_mutex_take+0x2ec>
        }
        else
        {
            rt_hw_interrupt_enable(temp); /* enable interrupt */
    48006988:	aa1303e0 	mov	x0, x19
    4800698c:	97fff6ac 	bl	4800443c <rt_hw_interrupt_enable>
            return -RT_EFULL; /* value overflowed */
    48006990:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48006994:	14000067 	b	48006b30 <rt_mutex_take+0x320>
__again:
#endif /* RT_USING_SIGNALS */
        /* The value of mutex is 1 in initial status. Therefore, if the
         * value is great than 0, it indicates the mutex is avaible.
         */
        if (mutex->value > 0)
    48006998:	f94017e0 	ldr	x0, [sp, #40]
    4800699c:	79406000 	ldrh	w0, [x0, #48]
    480069a0:	7100001f 	cmp	w0, #0x0
    480069a4:	540003a0 	b.eq	48006a18 <rt_mutex_take+0x208>  // b.none
        {
            /* mutex is available */
            mutex->value --;
    480069a8:	f94017e0 	ldr	x0, [sp, #40]
    480069ac:	79406000 	ldrh	w0, [x0, #48]
    480069b0:	51000400 	sub	w0, w0, #0x1
    480069b4:	12003c01 	and	w1, w0, #0xffff
    480069b8:	f94017e0 	ldr	x0, [sp, #40]
    480069bc:	79006001 	strh	w1, [x0, #48]

            /* set mutex owner and original priority */
            mutex->owner             = thread;
    480069c0:	f94017e0 	ldr	x0, [sp, #40]
    480069c4:	f9401fe1 	ldr	x1, [sp, #56]
    480069c8:	f9001c01 	str	x1, [x0, #56]
            mutex->original_priority = thread->current_priority;
    480069cc:	f9401fe0 	ldr	x0, [sp, #56]
    480069d0:	39418401 	ldrb	w1, [x0, #97]
    480069d4:	f94017e0 	ldr	x0, [sp, #40]
    480069d8:	3900c801 	strb	w1, [x0, #50]
            if(mutex->hold < RT_MUTEX_HOLD_MAX)
    480069dc:	f94017e0 	ldr	x0, [sp, #40]
    480069e0:	3940cc00 	ldrb	w0, [x0, #51]
    480069e4:	7103fc1f 	cmp	w0, #0xff
    480069e8:	54000100 	b.eq	48006a08 <rt_mutex_take+0x1f8>  // b.none
            {
                mutex->hold ++;
    480069ec:	f94017e0 	ldr	x0, [sp, #40]
    480069f0:	3940cc00 	ldrb	w0, [x0, #51]
    480069f4:	11000400 	add	w0, w0, #0x1
    480069f8:	12001c01 	and	w1, w0, #0xff
    480069fc:	f94017e0 	ldr	x0, [sp, #40]
    48006a00:	3900cc01 	strb	w1, [x0, #51]
    48006a04:	1400003e 	b	48006afc <rt_mutex_take+0x2ec>
            }
            else
            {
                rt_hw_interrupt_enable(temp); /* enable interrupt */
    48006a08:	aa1303e0 	mov	x0, x19
    48006a0c:	97fff68c 	bl	4800443c <rt_hw_interrupt_enable>
                return -RT_EFULL; /* value overflowed */
    48006a10:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48006a14:	14000047 	b	48006b30 <rt_mutex_take+0x320>
            }
        }
        else
        {
            /* no waiting, return with timeout */
            if (time == 0)
    48006a18:	b94027e0 	ldr	w0, [sp, #36]
    48006a1c:	7100001f 	cmp	w0, #0x0
    48006a20:	54000101 	b.ne	48006a40 <rt_mutex_take+0x230>  // b.any
            {
                /* set error as timeout */
                thread->error = -RT_ETIMEOUT;
    48006a24:	f9401fe0 	ldr	x0, [sp, #56]
    48006a28:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    48006a2c:	f9002c01 	str	x1, [x0, #88]

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
    48006a30:	aa1303e0 	mov	x0, x19
    48006a34:	97fff682 	bl	4800443c <rt_hw_interrupt_enable>

                return -RT_ETIMEOUT;
    48006a38:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    48006a3c:	1400003d 	b	48006b30 <rt_mutex_take+0x320>
                /* mutex is unavailable, push to suspend list */
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
                                            thread->name));

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
    48006a40:	f9401fe0 	ldr	x0, [sp, #56]
    48006a44:	39418401 	ldrb	w1, [x0, #97]
    48006a48:	f94017e0 	ldr	x0, [sp, #40]
    48006a4c:	f9401c00 	ldr	x0, [x0, #56]
    48006a50:	39418400 	ldrb	w0, [x0, #97]
    48006a54:	6b00003f 	cmp	w1, w0
    48006a58:	54000122 	b.cs	48006a7c <rt_mutex_take+0x26c>  // b.hs, b.nlast
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
    48006a5c:	f94017e0 	ldr	x0, [sp, #40]
    48006a60:	f9401c03 	ldr	x3, [x0, #56]
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
    48006a64:	f9401fe0 	ldr	x0, [sp, #56]
    48006a68:	91018400 	add	x0, x0, #0x61
                    rt_thread_control(mutex->owner,
    48006a6c:	aa0003e2 	mov	x2, x0
    48006a70:	52800041 	mov	w1, #0x2                   	// #2
    48006a74:	aa0303e0 	mov	x0, x3
    48006a78:	940015e8 	bl	4800c218 <rt_thread_control>
                }

                /* suspend current thread */
                _ipc_list_suspend(&(mutex->parent.suspend_thread),
    48006a7c:	f94017e0 	ldr	x0, [sp, #40]
    48006a80:	91008003 	add	x3, x0, #0x20
    48006a84:	f94017e0 	ldr	x0, [sp, #40]
    48006a88:	39402400 	ldrb	w0, [x0, #9]
    48006a8c:	2a0003e2 	mov	w2, w0
    48006a90:	f9401fe1 	ldr	x1, [sp, #56]
    48006a94:	aa0303e0 	mov	x0, x3
    48006a98:	97fffc4f 	bl	48005bd4 <_ipc_list_suspend>
                                    thread,
                                    mutex->parent.parent.flag);

                /* has waiting time, start thread timer */
                if (time > 0)
    48006a9c:	b94027e0 	ldr	w0, [sp, #36]
    48006aa0:	7100001f 	cmp	w0, #0x0
    48006aa4:	5400014d 	b.le	48006acc <rt_mutex_take+0x2bc>
                    RT_DEBUG_LOG(RT_DEBUG_IPC,
                                 ("mutex_take: start the timer of thread:%s\n",
                                  thread->name));

                    /* reset the timeout of thread timer and start it */
                    rt_timer_control(&(thread->thread_timer),
    48006aa8:	f9401fe0 	ldr	x0, [sp, #56]
    48006aac:	91020000 	add	x0, x0, #0x80
    48006ab0:	910093e1 	add	x1, sp, #0x24
    48006ab4:	aa0103e2 	mov	x2, x1
    48006ab8:	52800001 	mov	w1, #0x0                   	// #0
    48006abc:	94001199 	bl	4800b120 <rt_timer_control>
                                     RT_TIMER_CTRL_SET_TIME,
                                     &time);
                    rt_timer_start(&(thread->thread_timer));
    48006ac0:	f9401fe0 	ldr	x0, [sp, #56]
    48006ac4:	91020000 	add	x0, x0, #0x80
    48006ac8:	9400106f 	bl	4800ac84 <rt_timer_start>
                }

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
    48006acc:	aa1303e0 	mov	x0, x19
    48006ad0:	97fff65b 	bl	4800443c <rt_hw_interrupt_enable>

                /* do schedule */
                rt_schedule();
    48006ad4:	94001a2e 	bl	4800d38c <rt_schedule>

                if (thread->error != RT_EOK)
    48006ad8:	f9401fe0 	ldr	x0, [sp, #56]
    48006adc:	f9402c00 	ldr	x0, [x0, #88]
    48006ae0:	f100001f 	cmp	x0, #0x0
    48006ae4:	54000080 	b.eq	48006af4 <rt_mutex_take+0x2e4>  // b.none
                    /* interrupt by signal, try it again */
                    if (thread->error == -RT_EINTR) goto __again;
#endif /* RT_USING_SIGNALS */

                    /* return error */
                    return thread->error;
    48006ae8:	f9401fe0 	ldr	x0, [sp, #56]
    48006aec:	f9402c00 	ldr	x0, [x0, #88]
    48006af0:	14000010 	b	48006b30 <rt_mutex_take+0x320>
                }
                else
                {
                    /* the mutex is taken successfully. */
                    /* disable interrupt */
                    temp = rt_hw_interrupt_disable();
    48006af4:	97fff64e 	bl	4800442c <rt_hw_interrupt_disable>
    48006af8:	aa0003f3 	mov	x19, x0
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48006afc:	aa1303e0 	mov	x0, x19
    48006b00:	97fff64f 	bl	4800443c <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
    48006b04:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48006b08:	91178000 	add	x0, x0, #0x5e0
    48006b0c:	f9400000 	ldr	x0, [x0]
    48006b10:	f100001f 	cmp	x0, #0x0
    48006b14:	540000c0 	b.eq	48006b2c <rt_mutex_take+0x31c>  // b.none
    48006b18:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48006b1c:	91178000 	add	x0, x0, #0x5e0
    48006b20:	f9400001 	ldr	x1, [x0]
    48006b24:	f94017e0 	ldr	x0, [sp, #40]
    48006b28:	d63f0020 	blr	x1

    return RT_EOK;
    48006b2c:	d2800000 	mov	x0, #0x0                   	// #0
}
    48006b30:	f9400bf3 	ldr	x19, [sp, #16]
    48006b34:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48006b38:	d65f03c0 	ret

0000000048006b3c <rt_mutex_trytake>:
 *
 * @return   Return the operation status. ONLY When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the mutex take failed.
 */
rt_err_t rt_mutex_trytake(rt_mutex_t mutex)
{
    48006b3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48006b40:	910003fd 	mov	x29, sp
    48006b44:	f9000fe0 	str	x0, [sp, #24]
    return rt_mutex_take(mutex, RT_WAITING_NO);
    48006b48:	52800001 	mov	w1, #0x0                   	// #0
    48006b4c:	f9400fe0 	ldr	x0, [sp, #24]
    48006b50:	97ffff30 	bl	48006810 <rt_mutex_take>
}
    48006b54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48006b58:	d65f03c0 	ret

0000000048006b5c <rt_mutex_release>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the mutex release failed.
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
    48006b5c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48006b60:	910003fd 	mov	x29, sp
    48006b64:	f9000bf3 	str	x19, [sp, #16]
    48006b68:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t temp;
    struct rt_thread *thread;
    rt_bool_t need_schedule;

    /* parameter check */
    RT_ASSERT(mutex != RT_NULL);
    48006b6c:	f94017e0 	ldr	x0, [sp, #40]
    48006b70:	f100001f 	cmp	x0, #0x0
    48006b74:	540000e1 	b.ne	48006b90 <rt_mutex_release+0x34>  // b.any
    48006b78:	d28087c2 	mov	x2, #0x43e                 	// #1086
    48006b7c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006b80:	912e4001 	add	x1, x0, #0xb90
    48006b84:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006b88:	911d4000 	add	x0, x0, #0x750
    48006b8c:	94002537 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
    48006b90:	f94017e0 	ldr	x0, [sp, #40]
    48006b94:	94001d47 	bl	4800e0b0 <rt_object_get_type>
    48006b98:	12001c00 	and	w0, w0, #0xff
    48006b9c:	71000c1f 	cmp	w0, #0x3
    48006ba0:	540000e0 	b.eq	48006bbc <rt_mutex_release+0x60>  // b.none
    48006ba4:	d28087e2 	mov	x2, #0x43f                 	// #1087
    48006ba8:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006bac:	912e4001 	add	x1, x0, #0xb90
    48006bb0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006bb4:	911da000 	add	x0, x0, #0x768
    48006bb8:	9400252c 	bl	48010068 <rt_assert_handler>

    need_schedule = RT_FALSE;
    48006bbc:	b9004fff 	str	wzr, [sp, #76]

    /* only thread could release mutex because we need test the ownership */
    RT_DEBUG_IN_THREAD_CONTEXT;
    48006bc0:	97fff61b 	bl	4800442c <rt_hw_interrupt_disable>
    48006bc4:	f90023e0 	str	x0, [sp, #64]
    48006bc8:	940013f5 	bl	4800bb9c <rt_thread_self>
    48006bcc:	f100001f 	cmp	x0, #0x0
    48006bd0:	54000181 	b.ne	48006c00 <rt_mutex_release+0xa4>  // b.any
    48006bd4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006bd8:	912e4001 	add	x1, x0, #0xb90
    48006bdc:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006be0:	911c6000 	add	x0, x0, #0x718
    48006be4:	94002453 	bl	4800fd30 <rt_kprintf>
    48006be8:	d2808882 	mov	x2, #0x444                 	// #1092
    48006bec:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006bf0:	912e4001 	add	x1, x0, #0xb90
    48006bf4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006bf8:	91172000 	add	x0, x0, #0x5c8
    48006bfc:	9400251b 	bl	48010068 <rt_assert_handler>
    48006c00:	97fff60b 	bl	4800442c <rt_hw_interrupt_disable>
    48006c04:	f9001fe0 	str	x0, [sp, #56]
    48006c08:	94000ac2 	bl	48009710 <rt_interrupt_get_nest>
    48006c0c:	12001c00 	and	w0, w0, #0xff
    48006c10:	7100001f 	cmp	w0, #0x0
    48006c14:	54000180 	b.eq	48006c44 <rt_mutex_release+0xe8>  // b.none
    48006c18:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006c1c:	912e4001 	add	x1, x0, #0xb90
    48006c20:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006c24:	911ac000 	add	x0, x0, #0x6b0
    48006c28:	94002442 	bl	4800fd30 <rt_kprintf>
    48006c2c:	d2808882 	mov	x2, #0x444                 	// #1092
    48006c30:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006c34:	912e4001 	add	x1, x0, #0xb90
    48006c38:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006c3c:	91172000 	add	x0, x0, #0x5c8
    48006c40:	9400250a 	bl	48010068 <rt_assert_handler>
    48006c44:	f9401fe0 	ldr	x0, [sp, #56]
    48006c48:	97fff5fd 	bl	4800443c <rt_hw_interrupt_enable>
    48006c4c:	f94023e0 	ldr	x0, [sp, #64]
    48006c50:	97fff5fb 	bl	4800443c <rt_hw_interrupt_enable>

    /* get current thread */
    thread = rt_thread_self();
    48006c54:	940013d2 	bl	4800bb9c <rt_thread_self>
    48006c58:	f9001be0 	str	x0, [sp, #48]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48006c5c:	97fff5f4 	bl	4800442c <rt_hw_interrupt_disable>
    48006c60:	aa0003f3 	mov	x19, x0

    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
    48006c64:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48006c68:	9117a000 	add	x0, x0, #0x5e8
    48006c6c:	f9400000 	ldr	x0, [x0]
    48006c70:	f100001f 	cmp	x0, #0x0
    48006c74:	540000c0 	b.eq	48006c8c <rt_mutex_release+0x130>  // b.none
    48006c78:	f0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48006c7c:	9117a000 	add	x0, x0, #0x5e8
    48006c80:	f9400001 	ldr	x1, [x0]
    48006c84:	f94017e0 	ldr	x0, [sp, #40]
    48006c88:	d63f0020 	blr	x1

    /* mutex only can be released by owner */
    if (thread != mutex->owner)
    48006c8c:	f94017e0 	ldr	x0, [sp, #40]
    48006c90:	f9401c00 	ldr	x0, [x0, #56]
    48006c94:	f9401be1 	ldr	x1, [sp, #48]
    48006c98:	eb00003f 	cmp	x1, x0
    48006c9c:	54000100 	b.eq	48006cbc <rt_mutex_release+0x160>  // b.none
    {
        thread->error = -RT_ERROR;
    48006ca0:	f9401be0 	ldr	x0, [sp, #48]
    48006ca4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    48006ca8:	f9002c01 	str	x1, [x0, #88]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48006cac:	aa1303e0 	mov	x0, x19
    48006cb0:	97fff5e3 	bl	4800443c <rt_hw_interrupt_enable>

        return -RT_ERROR;
    48006cb4:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    48006cb8:	1400005a 	b	48006e20 <rt_mutex_release+0x2c4>
    }

    /* decrease hold */
    mutex->hold --;
    48006cbc:	f94017e0 	ldr	x0, [sp, #40]
    48006cc0:	3940cc00 	ldrb	w0, [x0, #51]
    48006cc4:	51000400 	sub	w0, w0, #0x1
    48006cc8:	12001c01 	and	w1, w0, #0xff
    48006ccc:	f94017e0 	ldr	x0, [sp, #40]
    48006cd0:	3900cc01 	strb	w1, [x0, #51]
    /* if no hold */
    if (mutex->hold == 0)
    48006cd4:	f94017e0 	ldr	x0, [sp, #40]
    48006cd8:	3940cc00 	ldrb	w0, [x0, #51]
    48006cdc:	7100001f 	cmp	w0, #0x0
    48006ce0:	54000921 	b.ne	48006e04 <rt_mutex_release+0x2a8>  // b.any
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
    48006ce4:	f94017e0 	ldr	x0, [sp, #40]
    48006ce8:	3940c801 	ldrb	w1, [x0, #50]
    48006cec:	f94017e0 	ldr	x0, [sp, #40]
    48006cf0:	f9401c00 	ldr	x0, [x0, #56]
    48006cf4:	39418400 	ldrb	w0, [x0, #97]
    48006cf8:	6b00003f 	cmp	w1, w0
    48006cfc:	54000120 	b.eq	48006d20 <rt_mutex_release+0x1c4>  // b.none
        {
            rt_thread_control(mutex->owner,
    48006d00:	f94017e0 	ldr	x0, [sp, #40]
    48006d04:	f9401c03 	ldr	x3, [x0, #56]
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
    48006d08:	f94017e0 	ldr	x0, [sp, #40]
    48006d0c:	9100c800 	add	x0, x0, #0x32
            rt_thread_control(mutex->owner,
    48006d10:	aa0003e2 	mov	x2, x0
    48006d14:	52800041 	mov	w1, #0x2                   	// #2
    48006d18:	aa0303e0 	mov	x0, x3
    48006d1c:	9400153f 	bl	4800c218 <rt_thread_control>
        }

        /* wakeup suspended thread */
        if (!rt_list_isempty(&mutex->parent.suspend_thread))
    48006d20:	f94017e0 	ldr	x0, [sp, #40]
    48006d24:	91008000 	add	x0, x0, #0x20
    48006d28:	97fffb98 	bl	48005b88 <rt_list_isempty>
    48006d2c:	7100001f 	cmp	w0, #0x0
    48006d30:	54000401 	b.ne	48006db0 <rt_mutex_release+0x254>  // b.any
        {
            /* get suspended thread */
            thread = rt_list_entry(mutex->parent.suspend_thread.next,
    48006d34:	f94017e0 	ldr	x0, [sp, #40]
    48006d38:	f9401000 	ldr	x0, [x0, #32]
    48006d3c:	d1008000 	sub	x0, x0, #0x20
    48006d40:	f9001be0 	str	x0, [sp, #48]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
                                        thread->name));

            /* set new owner and priority */
            mutex->owner             = thread;
    48006d44:	f94017e0 	ldr	x0, [sp, #40]
    48006d48:	f9401be1 	ldr	x1, [sp, #48]
    48006d4c:	f9001c01 	str	x1, [x0, #56]
            mutex->original_priority = thread->current_priority;
    48006d50:	f9401be0 	ldr	x0, [sp, #48]
    48006d54:	39418401 	ldrb	w1, [x0, #97]
    48006d58:	f94017e0 	ldr	x0, [sp, #40]
    48006d5c:	3900c801 	strb	w1, [x0, #50]

            if(mutex->hold < RT_MUTEX_HOLD_MAX)
    48006d60:	f94017e0 	ldr	x0, [sp, #40]
    48006d64:	3940cc00 	ldrb	w0, [x0, #51]
    48006d68:	7103fc1f 	cmp	w0, #0xff
    48006d6c:	540001a0 	b.eq	48006da0 <rt_mutex_release+0x244>  // b.none
            {
                mutex->hold ++;
    48006d70:	f94017e0 	ldr	x0, [sp, #40]
    48006d74:	3940cc00 	ldrb	w0, [x0, #51]
    48006d78:	11000400 	add	w0, w0, #0x1
    48006d7c:	12001c01 	and	w1, w0, #0xff
    48006d80:	f94017e0 	ldr	x0, [sp, #40]
    48006d84:	3900cc01 	strb	w1, [x0, #51]
                rt_hw_interrupt_enable(temp); /* enable interrupt */
                return -RT_EFULL; /* value overflowed */
            }

            /* resume thread */
            _ipc_list_resume(&(mutex->parent.suspend_thread));
    48006d88:	f94017e0 	ldr	x0, [sp, #40]
    48006d8c:	91008000 	add	x0, x0, #0x20
    48006d90:	97fffbd5 	bl	48005ce4 <_ipc_list_resume>

            need_schedule = RT_TRUE;
    48006d94:	52800020 	mov	w0, #0x1                   	// #1
    48006d98:	b9004fe0 	str	w0, [sp, #76]
    48006d9c:	1400001a 	b	48006e04 <rt_mutex_release+0x2a8>
                rt_hw_interrupt_enable(temp); /* enable interrupt */
    48006da0:	aa1303e0 	mov	x0, x19
    48006da4:	97fff5a6 	bl	4800443c <rt_hw_interrupt_enable>
                return -RT_EFULL; /* value overflowed */
    48006da8:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48006dac:	1400001d 	b	48006e20 <rt_mutex_release+0x2c4>
        }
        else
        {
            if(mutex->value < RT_MUTEX_VALUE_MAX)
    48006db0:	f94017e0 	ldr	x0, [sp, #40]
    48006db4:	79406001 	ldrh	w1, [x0, #48]
    48006db8:	529fffe0 	mov	w0, #0xffff                	// #65535
    48006dbc:	6b00003f 	cmp	w1, w0
    48006dc0:	540001a0 	b.eq	48006df4 <rt_mutex_release+0x298>  // b.none
            {
                /* increase value */
                mutex->value ++;
    48006dc4:	f94017e0 	ldr	x0, [sp, #40]
    48006dc8:	79406000 	ldrh	w0, [x0, #48]
    48006dcc:	11000400 	add	w0, w0, #0x1
    48006dd0:	12003c01 	and	w1, w0, #0xffff
    48006dd4:	f94017e0 	ldr	x0, [sp, #40]
    48006dd8:	79006001 	strh	w1, [x0, #48]
                rt_hw_interrupt_enable(temp); /* enable interrupt */
                return -RT_EFULL; /* value overflowed */
            }

            /* clear owner */
            mutex->owner             = RT_NULL;
    48006ddc:	f94017e0 	ldr	x0, [sp, #40]
    48006de0:	f9001c1f 	str	xzr, [x0, #56]
            mutex->original_priority = 0xff;
    48006de4:	f94017e0 	ldr	x0, [sp, #40]
    48006de8:	12800001 	mov	w1, #0xffffffff            	// #-1
    48006dec:	3900c801 	strb	w1, [x0, #50]
    48006df0:	14000005 	b	48006e04 <rt_mutex_release+0x2a8>
                rt_hw_interrupt_enable(temp); /* enable interrupt */
    48006df4:	aa1303e0 	mov	x0, x19
    48006df8:	97fff591 	bl	4800443c <rt_hw_interrupt_enable>
                return -RT_EFULL; /* value overflowed */
    48006dfc:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48006e00:	14000008 	b	48006e20 <rt_mutex_release+0x2c4>
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48006e04:	aa1303e0 	mov	x0, x19
    48006e08:	97fff58d 	bl	4800443c <rt_hw_interrupt_enable>

    /* perform a schedule */
    if (need_schedule == RT_TRUE)
    48006e0c:	b9404fe0 	ldr	w0, [sp, #76]
    48006e10:	7100041f 	cmp	w0, #0x1
    48006e14:	54000041 	b.ne	48006e1c <rt_mutex_release+0x2c0>  // b.any
        rt_schedule();
    48006e18:	9400195d 	bl	4800d38c <rt_schedule>

    return RT_EOK;
    48006e1c:	d2800000 	mov	x0, #0x0                   	// #0
}
    48006e20:	f9400bf3 	ldr	x19, [sp, #16]
    48006e24:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48006e28:	d65f03c0 	ret

0000000048006e2c <rt_mutex_control>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that this function failed to execute.
 */
rt_err_t rt_mutex_control(rt_mutex_t mutex, int cmd, void *arg)
{
    48006e2c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48006e30:	910003fd 	mov	x29, sp
    48006e34:	f90017e0 	str	x0, [sp, #40]
    48006e38:	b90027e1 	str	w1, [sp, #36]
    48006e3c:	f9000fe2 	str	x2, [sp, #24]
    /* parameter check */
    RT_ASSERT(mutex != RT_NULL);
    48006e40:	f94017e0 	ldr	x0, [sp, #40]
    48006e44:	f100001f 	cmp	x0, #0x0
    48006e48:	540000e1 	b.ne	48006e64 <rt_mutex_control+0x38>  // b.any
    48006e4c:	d2809702 	mov	x2, #0x4b8                 	// #1208
    48006e50:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006e54:	912ea001 	add	x1, x0, #0xba8
    48006e58:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006e5c:	911d4000 	add	x0, x0, #0x750
    48006e60:	94002482 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
    48006e64:	f94017e0 	ldr	x0, [sp, #40]
    48006e68:	94001c92 	bl	4800e0b0 <rt_object_get_type>
    48006e6c:	12001c00 	and	w0, w0, #0xff
    48006e70:	71000c1f 	cmp	w0, #0x3
    48006e74:	540000e0 	b.eq	48006e90 <rt_mutex_control+0x64>  // b.none
    48006e78:	d2809722 	mov	x2, #0x4b9                 	// #1209
    48006e7c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006e80:	912ea001 	add	x1, x0, #0xba8
    48006e84:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006e88:	911da000 	add	x0, x0, #0x768
    48006e8c:	94002477 	bl	48010068 <rt_assert_handler>

    return -RT_ERROR;
    48006e90:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
    48006e94:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48006e98:	d65f03c0 	ret

0000000048006e9c <rt_event_init>:
 *           If the return value is any other values, it represents the initialization failed.
 *
 * @warning  This function can ONLY be called from threads.
 */
rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
{
    48006e9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48006ea0:	910003fd 	mov	x29, sp
    48006ea4:	f90017e0 	str	x0, [sp, #40]
    48006ea8:	f90013e1 	str	x1, [sp, #32]
    48006eac:	39007fe2 	strb	w2, [sp, #31]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
    48006eb0:	f94017e0 	ldr	x0, [sp, #40]
    48006eb4:	f100001f 	cmp	x0, #0x0
    48006eb8:	540000e1 	b.ne	48006ed4 <rt_event_init+0x38>  // b.any
    48006ebc:	d2809dc2 	mov	x2, #0x4ee                 	// #1262
    48006ec0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006ec4:	912f0001 	add	x1, x0, #0xbc0
    48006ec8:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006ecc:	9120a000 	add	x0, x0, #0x828
    48006ed0:	94002466 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    48006ed4:	39407fe0 	ldrb	w0, [sp, #31]
    48006ed8:	7100001f 	cmp	w0, #0x0
    48006edc:	54000140 	b.eq	48006f04 <rt_event_init+0x68>  // b.none
    48006ee0:	39407fe0 	ldrb	w0, [sp, #31]
    48006ee4:	7100041f 	cmp	w0, #0x1
    48006ee8:	540000e0 	b.eq	48006f04 <rt_event_init+0x68>  // b.none
    48006eec:	d2809de2 	mov	x2, #0x4ef                 	// #1263
    48006ef0:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006ef4:	912f0001 	add	x1, x0, #0xbc0
    48006ef8:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006efc:	9117e000 	add	x0, x0, #0x5f8
    48006f00:	9400245a 	bl	48010068 <rt_assert_handler>

    /* initialize object */
    rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
    48006f04:	f94017e0 	ldr	x0, [sp, #40]
    48006f08:	f94013e2 	ldr	x2, [sp, #32]
    48006f0c:	52800081 	mov	w1, #0x4                   	// #4
    48006f10:	94001b53 	bl	4800dc5c <rt_object_init>

    /* set parent flag */
    event->parent.parent.flag = flag;
    48006f14:	f94017e0 	ldr	x0, [sp, #40]
    48006f18:	39407fe1 	ldrb	w1, [sp, #31]
    48006f1c:	39002401 	strb	w1, [x0, #9]

    /* initialize ipc object */
    _ipc_object_init(&(event->parent));
    48006f20:	f94017e0 	ldr	x0, [sp, #40]
    48006f24:	97fffb23 	bl	48005bb0 <_ipc_object_init>

    /* initialize event */
    event->set = 0;
    48006f28:	f94017e0 	ldr	x0, [sp, #40]
    48006f2c:	b900301f 	str	wzr, [x0, #48]

    return RT_EOK;
    48006f30:	d2800000 	mov	x0, #0x0                   	// #0
}
    48006f34:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48006f38:	d65f03c0 	ret

0000000048006f3c <rt_event_detach>:
 * @warning  This function can ONLY detach a static event initialized by the rt_event_init() function.
 *           If the event is created by the rt_event_create() function, you MUST NOT USE this function to detach it,
 *           ONLY USE the rt_event_delete() function to complete the deletion.
 */
rt_err_t rt_event_detach(rt_event_t event)
{
    48006f3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48006f40:	910003fd 	mov	x29, sp
    48006f44:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
    48006f48:	f9400fe0 	ldr	x0, [sp, #24]
    48006f4c:	f100001f 	cmp	x0, #0x0
    48006f50:	540000e1 	b.ne	48006f6c <rt_event_detach+0x30>  // b.any
    48006f54:	d280a2e2 	mov	x2, #0x517                 	// #1303
    48006f58:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006f5c:	912f4001 	add	x1, x0, #0xbd0
    48006f60:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006f64:	9120a000 	add	x0, x0, #0x828
    48006f68:	94002440 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
    48006f6c:	f9400fe0 	ldr	x0, [sp, #24]
    48006f70:	94001c50 	bl	4800e0b0 <rt_object_get_type>
    48006f74:	12001c00 	and	w0, w0, #0xff
    48006f78:	7100101f 	cmp	w0, #0x4
    48006f7c:	540000e0 	b.eq	48006f98 <rt_event_detach+0x5c>  // b.none
    48006f80:	d280a302 	mov	x2, #0x518                 	// #1304
    48006f84:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006f88:	912f4001 	add	x1, x0, #0xbd0
    48006f8c:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006f90:	91210000 	add	x0, x0, #0x840
    48006f94:	94002435 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&event->parent.parent));
    48006f98:	f9400fe0 	ldr	x0, [sp, #24]
    48006f9c:	94001c2f 	bl	4800e058 <rt_object_is_systemobject>
    48006fa0:	7100001f 	cmp	w0, #0x0
    48006fa4:	540000e1 	b.ne	48006fc0 <rt_event_detach+0x84>  // b.any
    48006fa8:	d280a322 	mov	x2, #0x519                 	// #1305
    48006fac:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006fb0:	912f4001 	add	x1, x0, #0xbd0
    48006fb4:	900000c0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48006fb8:	91222000 	add	x0, x0, #0x888
    48006fbc:	9400242b 	bl	48010068 <rt_assert_handler>

    /* resume all suspended thread */
    _ipc_list_resume_all(&(event->parent.suspend_thread));
    48006fc0:	f9400fe0 	ldr	x0, [sp, #24]
    48006fc4:	91008000 	add	x0, x0, #0x20
    48006fc8:	97fffb53 	bl	48005d14 <_ipc_list_resume_all>

    /* detach event object */
    rt_object_detach(&(event->parent.parent));
    48006fcc:	f9400fe0 	ldr	x0, [sp, #24]
    48006fd0:	94001b77 	bl	4800ddac <rt_object_detach>

    return RT_EOK;
    48006fd4:	d2800000 	mov	x0, #0x0                   	// #0
}
    48006fd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48006fdc:	d65f03c0 	ret

0000000048006fe0 <rt_event_create>:
 * @return   Return a pointer to the event object. When the return value is RT_NULL, it means the creation failed.
 *
 * @warning  This function can ONLY be called from threads.
 */
rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
{
    48006fe0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48006fe4:	910003fd 	mov	x29, sp
    48006fe8:	f9000fe0 	str	x0, [sp, #24]
    48006fec:	39005fe1 	strb	w1, [sp, #23]
    rt_event_t event;

    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    48006ff0:	39405fe0 	ldrb	w0, [sp, #23]
    48006ff4:	7100001f 	cmp	w0, #0x0
    48006ff8:	54000140 	b.eq	48007020 <rt_event_create+0x40>  // b.none
    48006ffc:	39405fe0 	ldrb	w0, [sp, #23]
    48007000:	7100041f 	cmp	w0, #0x1
    48007004:	540000e0 	b.eq	48007020 <rt_event_create+0x40>  // b.none
    48007008:	d280a8c2 	mov	x2, #0x546                 	// #1350
    4800700c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007010:	912f8001 	add	x1, x0, #0xbe0
    48007014:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007018:	9117e000 	add	x0, x0, #0x5f8
    4800701c:	94002413 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    48007020:	97fff503 	bl	4800442c <rt_hw_interrupt_disable>
    48007024:	f90017e0 	str	x0, [sp, #40]
    48007028:	940009ba 	bl	48009710 <rt_interrupt_get_nest>
    4800702c:	12001c00 	and	w0, w0, #0xff
    48007030:	7100001f 	cmp	w0, #0x0
    48007034:	54000180 	b.eq	48007064 <rt_event_create+0x84>  // b.none
    48007038:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800703c:	912f8001 	add	x1, x0, #0xbe0
    48007040:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007044:	911ac000 	add	x0, x0, #0x6b0
    48007048:	9400233a 	bl	4800fd30 <rt_kprintf>
    4800704c:	d280a902 	mov	x2, #0x548                 	// #1352
    48007050:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007054:	912f8001 	add	x1, x0, #0xbe0
    48007058:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800705c:	91172000 	add	x0, x0, #0x5c8
    48007060:	94002402 	bl	48010068 <rt_assert_handler>
    48007064:	f94017e0 	ldr	x0, [sp, #40]
    48007068:	97fff4f5 	bl	4800443c <rt_hw_interrupt_enable>

    /* allocate object */
    event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
    4800706c:	f9400fe1 	ldr	x1, [sp, #24]
    48007070:	52800080 	mov	w0, #0x4                   	// #4
    48007074:	94001b72 	bl	4800de3c <rt_object_allocate>
    48007078:	f90013e0 	str	x0, [sp, #32]
    if (event == RT_NULL)
    4800707c:	f94013e0 	ldr	x0, [sp, #32]
    48007080:	f100001f 	cmp	x0, #0x0
    48007084:	54000061 	b.ne	48007090 <rt_event_create+0xb0>  // b.any
        return event;
    48007088:	f94013e0 	ldr	x0, [sp, #32]
    4800708c:	14000009 	b	480070b0 <rt_event_create+0xd0>

    /* set parent */
    event->parent.parent.flag = flag;
    48007090:	f94013e0 	ldr	x0, [sp, #32]
    48007094:	39405fe1 	ldrb	w1, [sp, #23]
    48007098:	39002401 	strb	w1, [x0, #9]

    /* initialize ipc object */
    _ipc_object_init(&(event->parent));
    4800709c:	f94013e0 	ldr	x0, [sp, #32]
    480070a0:	97fffac4 	bl	48005bb0 <_ipc_object_init>

    /* initialize event */
    event->set = 0;
    480070a4:	f94013e0 	ldr	x0, [sp, #32]
    480070a8:	b900301f 	str	wzr, [x0, #48]

    return event;
    480070ac:	f94013e0 	ldr	x0, [sp, #32]
}
    480070b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480070b4:	d65f03c0 	ret

00000000480070b8 <rt_event_delete>:
 * @warning  This function can ONLY delete an event initialized by the rt_event_create() function.
 *           If the event is initialized by the rt_event_init() function, you MUST NOT USE this function to delete it,
 *           ONLY USE the rt_event_detach() function to complete the detachment.
 */
rt_err_t rt_event_delete(rt_event_t event)
{
    480070b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480070bc:	910003fd 	mov	x29, sp
    480070c0:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
    480070c4:	f9400fe0 	ldr	x0, [sp, #24]
    480070c8:	f100001f 	cmp	x0, #0x0
    480070cc:	540000e1 	b.ne	480070e8 <rt_event_delete+0x30>  // b.any
    480070d0:	d280ae42 	mov	x2, #0x572                 	// #1394
    480070d4:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480070d8:	912fc001 	add	x1, x0, #0xbf0
    480070dc:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480070e0:	9120a000 	add	x0, x0, #0x828
    480070e4:	940023e1 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
    480070e8:	f9400fe0 	ldr	x0, [sp, #24]
    480070ec:	94001bf1 	bl	4800e0b0 <rt_object_get_type>
    480070f0:	12001c00 	and	w0, w0, #0xff
    480070f4:	7100101f 	cmp	w0, #0x4
    480070f8:	540000e0 	b.eq	48007114 <rt_event_delete+0x5c>  // b.none
    480070fc:	d280ae62 	mov	x2, #0x573                 	// #1395
    48007100:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007104:	912fc001 	add	x1, x0, #0xbf0
    48007108:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800710c:	91210000 	add	x0, x0, #0x840
    48007110:	940023d6 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&event->parent.parent) == RT_FALSE);
    48007114:	f9400fe0 	ldr	x0, [sp, #24]
    48007118:	94001bd0 	bl	4800e058 <rt_object_is_systemobject>
    4800711c:	7100001f 	cmp	w0, #0x0
    48007120:	540000e0 	b.eq	4800713c <rt_event_delete+0x84>  // b.none
    48007124:	d280ae82 	mov	x2, #0x574                 	// #1396
    48007128:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800712c:	912fc001 	add	x1, x0, #0xbf0
    48007130:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007134:	91230000 	add	x0, x0, #0x8c0
    48007138:	940023cc 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    4800713c:	97fff4bc 	bl	4800442c <rt_hw_interrupt_disable>
    48007140:	f90017e0 	str	x0, [sp, #40]
    48007144:	94000973 	bl	48009710 <rt_interrupt_get_nest>
    48007148:	12001c00 	and	w0, w0, #0xff
    4800714c:	7100001f 	cmp	w0, #0x0
    48007150:	54000180 	b.eq	48007180 <rt_event_delete+0xc8>  // b.none
    48007154:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007158:	912fc001 	add	x1, x0, #0xbf0
    4800715c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007160:	911ac000 	add	x0, x0, #0x6b0
    48007164:	940022f3 	bl	4800fd30 <rt_kprintf>
    48007168:	d280aec2 	mov	x2, #0x576                 	// #1398
    4800716c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007170:	912fc001 	add	x1, x0, #0xbf0
    48007174:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007178:	91172000 	add	x0, x0, #0x5c8
    4800717c:	940023bb 	bl	48010068 <rt_assert_handler>
    48007180:	f94017e0 	ldr	x0, [sp, #40]
    48007184:	97fff4ae 	bl	4800443c <rt_hw_interrupt_enable>

    /* resume all suspended thread */
    _ipc_list_resume_all(&(event->parent.suspend_thread));
    48007188:	f9400fe0 	ldr	x0, [sp, #24]
    4800718c:	91008000 	add	x0, x0, #0x20
    48007190:	97fffae1 	bl	48005d14 <_ipc_list_resume_all>

    /* delete event object */
    rt_object_delete(&(event->parent.parent));
    48007194:	f9400fe0 	ldr	x0, [sp, #24]
    48007198:	94001b7f 	bl	4800df94 <rt_object_delete>

    return RT_EOK;
    4800719c:	d2800000 	mov	x0, #0x0                   	// #0
}
    480071a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480071a4:	d65f03c0 	ret

00000000480071a8 <rt_event_send>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the event detach failed.
 */
rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
{
    480071a8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    480071ac:	910003fd 	mov	x29, sp
    480071b0:	a90153f3 	stp	x19, x20, [sp, #16]
    480071b4:	f90017e0 	str	x0, [sp, #40]
    480071b8:	b90027e1 	str	w1, [sp, #36]
    register rt_ubase_t level;
    register rt_base_t status;
    rt_bool_t need_schedule;

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
    480071bc:	f94017e0 	ldr	x0, [sp, #40]
    480071c0:	f100001f 	cmp	x0, #0x0
    480071c4:	540000e1 	b.ne	480071e0 <rt_event_send+0x38>  // b.any
    480071c8:	d280b3c2 	mov	x2, #0x59e                 	// #1438
    480071cc:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480071d0:	91300001 	add	x1, x0, #0xc00
    480071d4:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480071d8:	9120a000 	add	x0, x0, #0x828
    480071dc:	940023a3 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
    480071e0:	f94017e0 	ldr	x0, [sp, #40]
    480071e4:	94001bb3 	bl	4800e0b0 <rt_object_get_type>
    480071e8:	12001c00 	and	w0, w0, #0xff
    480071ec:	7100101f 	cmp	w0, #0x4
    480071f0:	540000e0 	b.eq	4800720c <rt_event_send+0x64>  // b.none
    480071f4:	d280b3e2 	mov	x2, #0x59f                 	// #1439
    480071f8:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480071fc:	91300001 	add	x1, x0, #0xc00
    48007200:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007204:	91210000 	add	x0, x0, #0x840
    48007208:	94002398 	bl	48010068 <rt_assert_handler>

    if (set == 0)
    4800720c:	b94027e0 	ldr	w0, [sp, #36]
    48007210:	7100001f 	cmp	w0, #0x0
    48007214:	54000061 	b.ne	48007220 <rt_event_send+0x78>  // b.any
        return -RT_ERROR;
    48007218:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800721c:	1400006c 	b	480073cc <rt_event_send+0x224>

    need_schedule = RT_FALSE;
    48007220:	b90047ff 	str	wzr, [sp, #68]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    48007224:	97fff482 	bl	4800442c <rt_hw_interrupt_disable>
    48007228:	aa0003f4 	mov	x20, x0

    /* set event */
    event->set |= set;
    4800722c:	f94017e0 	ldr	x0, [sp, #40]
    48007230:	b9403001 	ldr	w1, [x0, #48]
    48007234:	b94027e0 	ldr	w0, [sp, #36]
    48007238:	2a000021 	orr	w1, w1, w0
    4800723c:	f94017e0 	ldr	x0, [sp, #40]
    48007240:	b9003001 	str	w1, [x0, #48]

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
    48007244:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48007248:	9117a000 	add	x0, x0, #0x5e8
    4800724c:	f9400000 	ldr	x0, [x0]
    48007250:	f100001f 	cmp	x0, #0x0
    48007254:	540000c0 	b.eq	4800726c <rt_event_send+0xc4>  // b.none
    48007258:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800725c:	9117a000 	add	x0, x0, #0x5e8
    48007260:	f9400001 	ldr	x1, [x0]
    48007264:	f94017e0 	ldr	x0, [sp, #40]
    48007268:	d63f0020 	blr	x1

    if (!rt_list_isempty(&event->parent.suspend_thread))
    4800726c:	f94017e0 	ldr	x0, [sp, #40]
    48007270:	91008000 	add	x0, x0, #0x20
    48007274:	97fffa45 	bl	48005b88 <rt_list_isempty>
    48007278:	7100001f 	cmp	w0, #0x0
    4800727c:	540009a1 	b.ne	480073b0 <rt_event_send+0x208>  // b.any
    {
        /* search thread list to resume thread */
        n = event->parent.suspend_thread.next;
    48007280:	f94017e0 	ldr	x0, [sp, #40]
    48007284:	f9401000 	ldr	x0, [x0, #32]
    48007288:	f90027e0 	str	x0, [sp, #72]
        while (n != &(event->parent.suspend_thread))
    4800728c:	14000044 	b	4800739c <rt_event_send+0x1f4>
        {
            /* get thread */
            thread = rt_list_entry(n, struct rt_thread, tlist);
    48007290:	f94027e0 	ldr	x0, [sp, #72]
    48007294:	d1008000 	sub	x0, x0, #0x20
    48007298:	f9001fe0 	str	x0, [sp, #56]

            status = -RT_ERROR;
    4800729c:	92800013 	mov	x19, #0xffffffffffffffff    	// #-1
            if (thread->event_info & RT_EVENT_FLAG_AND)
    480072a0:	f9401fe0 	ldr	x0, [sp, #56]
    480072a4:	3941b000 	ldrb	w0, [x0, #108]
    480072a8:	12000000 	and	w0, w0, #0x1
    480072ac:	7100001f 	cmp	w0, #0x0
    480072b0:	54000180 	b.eq	480072e0 <rt_event_send+0x138>  // b.none
            {
                if ((thread->event_set & event->set) == thread->event_set)
    480072b4:	f9401fe0 	ldr	x0, [sp, #56]
    480072b8:	b9406801 	ldr	w1, [x0, #104]
    480072bc:	f94017e0 	ldr	x0, [sp, #40]
    480072c0:	b9403000 	ldr	w0, [x0, #48]
    480072c4:	0a000021 	and	w1, w1, w0
    480072c8:	f9401fe0 	ldr	x0, [sp, #56]
    480072cc:	b9406800 	ldr	w0, [x0, #104]
    480072d0:	6b00003f 	cmp	w1, w0
    480072d4:	54000381 	b.ne	48007344 <rt_event_send+0x19c>  // b.any
                {
                    /* received an AND event */
                    status = RT_EOK;
    480072d8:	d2800013 	mov	x19, #0x0                   	// #0
    480072dc:	1400001a 	b	48007344 <rt_event_send+0x19c>
                }
            }
            else if (thread->event_info & RT_EVENT_FLAG_OR)
    480072e0:	f9401fe0 	ldr	x0, [sp, #56]
    480072e4:	3941b000 	ldrb	w0, [x0, #108]
    480072e8:	121f0000 	and	w0, w0, #0x2
    480072ec:	7100001f 	cmp	w0, #0x0
    480072f0:	54000220 	b.eq	48007334 <rt_event_send+0x18c>  // b.none
            {
                if (thread->event_set & event->set)
    480072f4:	f9401fe0 	ldr	x0, [sp, #56]
    480072f8:	b9406801 	ldr	w1, [x0, #104]
    480072fc:	f94017e0 	ldr	x0, [sp, #40]
    48007300:	b9403000 	ldr	w0, [x0, #48]
    48007304:	0a000020 	and	w0, w1, w0
    48007308:	7100001f 	cmp	w0, #0x0
    4800730c:	540001c0 	b.eq	48007344 <rt_event_send+0x19c>  // b.none
                {
                    /* save the received event set */
                    thread->event_set = thread->event_set & event->set;
    48007310:	f9401fe0 	ldr	x0, [sp, #56]
    48007314:	b9406801 	ldr	w1, [x0, #104]
    48007318:	f94017e0 	ldr	x0, [sp, #40]
    4800731c:	b9403000 	ldr	w0, [x0, #48]
    48007320:	0a000021 	and	w1, w1, w0
    48007324:	f9401fe0 	ldr	x0, [sp, #56]
    48007328:	b9006801 	str	w1, [x0, #104]

                    /* received an OR event */
                    status = RT_EOK;
    4800732c:	d2800013 	mov	x19, #0x0                   	// #0
    48007330:	14000005 	b	48007344 <rt_event_send+0x19c>
                }
            }
            else
            {
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
    48007334:	aa1403e0 	mov	x0, x20
    48007338:	97fff441 	bl	4800443c <rt_hw_interrupt_enable>

                return -RT_EINVAL;
    4800733c:	92800120 	mov	x0, #0xfffffffffffffff6    	// #-10
    48007340:	14000023 	b	480073cc <rt_event_send+0x224>
            }

            /* move node to the next */
            n = n->next;
    48007344:	f94027e0 	ldr	x0, [sp, #72]
    48007348:	f9400000 	ldr	x0, [x0]
    4800734c:	f90027e0 	str	x0, [sp, #72]

            /* condition is satisfied, resume thread */
            if (status == RT_EOK)
    48007350:	f100027f 	cmp	x19, #0x0
    48007354:	54000241 	b.ne	4800739c <rt_event_send+0x1f4>  // b.any
            {
                /* clear event */
                if (thread->event_info & RT_EVENT_FLAG_CLEAR)
    48007358:	f9401fe0 	ldr	x0, [sp, #56]
    4800735c:	3941b000 	ldrb	w0, [x0, #108]
    48007360:	121e0000 	and	w0, w0, #0x4
    48007364:	7100001f 	cmp	w0, #0x0
    48007368:	54000120 	b.eq	4800738c <rt_event_send+0x1e4>  // b.none
                    event->set &= ~thread->event_set;
    4800736c:	f94017e0 	ldr	x0, [sp, #40]
    48007370:	b9403001 	ldr	w1, [x0, #48]
    48007374:	f9401fe0 	ldr	x0, [sp, #56]
    48007378:	b9406800 	ldr	w0, [x0, #104]
    4800737c:	2a2003e0 	mvn	w0, w0
    48007380:	0a000021 	and	w1, w1, w0
    48007384:	f94017e0 	ldr	x0, [sp, #40]
    48007388:	b9003001 	str	w1, [x0, #48]

                /* resume thread, and thread list breaks out */
                rt_thread_resume(thread);
    4800738c:	f9401fe0 	ldr	x0, [sp, #56]
    48007390:	94001456 	bl	4800c4e8 <rt_thread_resume>

                /* need do a scheduling */
                need_schedule = RT_TRUE;
    48007394:	52800020 	mov	w0, #0x1                   	// #1
    48007398:	b90047e0 	str	w0, [sp, #68]
        while (n != &(event->parent.suspend_thread))
    4800739c:	f94017e0 	ldr	x0, [sp, #40]
    480073a0:	91008000 	add	x0, x0, #0x20
    480073a4:	f94027e1 	ldr	x1, [sp, #72]
    480073a8:	eb00003f 	cmp	x1, x0
    480073ac:	54fff721 	b.ne	48007290 <rt_event_send+0xe8>  // b.any
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    480073b0:	aa1403e0 	mov	x0, x20
    480073b4:	97fff422 	bl	4800443c <rt_hw_interrupt_enable>

    /* do a schedule */
    if (need_schedule == RT_TRUE)
    480073b8:	b94047e0 	ldr	w0, [sp, #68]
    480073bc:	7100041f 	cmp	w0, #0x1
    480073c0:	54000041 	b.ne	480073c8 <rt_event_send+0x220>  // b.any
        rt_schedule();
    480073c4:	940017f2 	bl	4800d38c <rt_schedule>

    return RT_EOK;
    480073c8:	d2800000 	mov	x0, #0x0                   	// #0
}
    480073cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    480073d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480073d4:	d65f03c0 	ret

00000000480073d8 <rt_event_recv>:
rt_err_t rt_event_recv(rt_event_t   event,
                       rt_uint32_t  set,
                       rt_uint8_t   option,
                       rt_int32_t   timeout,
                       rt_uint32_t *recved)
{
    480073d8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    480073dc:	910003fd 	mov	x29, sp
    480073e0:	a90153f3 	stp	x19, x20, [sp, #16]
    480073e4:	f9001fe0 	str	x0, [sp, #56]
    480073e8:	b90037e1 	str	w1, [sp, #52]
    480073ec:	3900cfe2 	strb	w2, [sp, #51]
    480073f0:	b9002fe3 	str	w3, [sp, #44]
    480073f4:	f90013e4 	str	x4, [sp, #32]
    struct rt_thread *thread;
    register rt_ubase_t level;
    register rt_base_t status;

    RT_DEBUG_IN_THREAD_CONTEXT;
    480073f8:	97fff40d 	bl	4800442c <rt_hw_interrupt_disable>
    480073fc:	f9002fe0 	str	x0, [sp, #88]
    48007400:	940011e7 	bl	4800bb9c <rt_thread_self>
    48007404:	f100001f 	cmp	x0, #0x0
    48007408:	54000181 	b.ne	48007438 <rt_event_recv+0x60>  // b.any
    4800740c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007410:	91304001 	add	x1, x0, #0xc10
    48007414:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007418:	911c6000 	add	x0, x0, #0x718
    4800741c:	94002245 	bl	4800fd30 <rt_kprintf>
    48007420:	d280c382 	mov	x2, #0x61c                 	// #1564
    48007424:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007428:	91304001 	add	x1, x0, #0xc10
    4800742c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007430:	91172000 	add	x0, x0, #0x5c8
    48007434:	9400230d 	bl	48010068 <rt_assert_handler>
    48007438:	97fff3fd 	bl	4800442c <rt_hw_interrupt_disable>
    4800743c:	f9002be0 	str	x0, [sp, #80]
    48007440:	940008b4 	bl	48009710 <rt_interrupt_get_nest>
    48007444:	12001c00 	and	w0, w0, #0xff
    48007448:	7100001f 	cmp	w0, #0x0
    4800744c:	54000180 	b.eq	4800747c <rt_event_recv+0xa4>  // b.none
    48007450:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007454:	91304001 	add	x1, x0, #0xc10
    48007458:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800745c:	911ac000 	add	x0, x0, #0x6b0
    48007460:	94002234 	bl	4800fd30 <rt_kprintf>
    48007464:	d280c382 	mov	x2, #0x61c                 	// #1564
    48007468:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800746c:	91304001 	add	x1, x0, #0xc10
    48007470:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007474:	91172000 	add	x0, x0, #0x5c8
    48007478:	940022fc 	bl	48010068 <rt_assert_handler>
    4800747c:	f9402be0 	ldr	x0, [sp, #80]
    48007480:	97fff3ef 	bl	4800443c <rt_hw_interrupt_enable>
    48007484:	f9402fe0 	ldr	x0, [sp, #88]
    48007488:	97fff3ed 	bl	4800443c <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
    4800748c:	f9401fe0 	ldr	x0, [sp, #56]
    48007490:	f100001f 	cmp	x0, #0x0
    48007494:	540000e1 	b.ne	480074b0 <rt_event_recv+0xd8>  // b.any
    48007498:	d280c3e2 	mov	x2, #0x61f                 	// #1567
    4800749c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480074a0:	91304001 	add	x1, x0, #0xc10
    480074a4:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480074a8:	9120a000 	add	x0, x0, #0x828
    480074ac:	940022ef 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
    480074b0:	f9401fe0 	ldr	x0, [sp, #56]
    480074b4:	94001aff 	bl	4800e0b0 <rt_object_get_type>
    480074b8:	12001c00 	and	w0, w0, #0xff
    480074bc:	7100101f 	cmp	w0, #0x4
    480074c0:	540000e0 	b.eq	480074dc <rt_event_recv+0x104>  // b.none
    480074c4:	d280c402 	mov	x2, #0x620                 	// #1568
    480074c8:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480074cc:	91304001 	add	x1, x0, #0xc10
    480074d0:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480074d4:	91210000 	add	x0, x0, #0x840
    480074d8:	940022e4 	bl	48010068 <rt_assert_handler>

    if (set == 0)
    480074dc:	b94037e0 	ldr	w0, [sp, #52]
    480074e0:	7100001f 	cmp	w0, #0x0
    480074e4:	54000061 	b.ne	480074f0 <rt_event_recv+0x118>  // b.any
        return -RT_ERROR;
    480074e8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    480074ec:	14000096 	b	48007744 <rt_event_recv+0x36c>

    /* initialize status */
    status = -RT_ERROR;
    480074f0:	92800013 	mov	x19, #0xffffffffffffffff    	// #-1
    /* get current thread */
    thread = rt_thread_self();
    480074f4:	940011aa 	bl	4800bb9c <rt_thread_self>
    480074f8:	f90027e0 	str	x0, [sp, #72]
    /* reset thread error */
    thread->error = RT_EOK;
    480074fc:	f94027e0 	ldr	x0, [sp, #72]
    48007500:	f9002c1f 	str	xzr, [x0, #88]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
    48007504:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48007508:	91176000 	add	x0, x0, #0x5d8
    4800750c:	f9400000 	ldr	x0, [x0]
    48007510:	f100001f 	cmp	x0, #0x0
    48007514:	540000c0 	b.eq	4800752c <rt_event_recv+0x154>  // b.none
    48007518:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800751c:	91176000 	add	x0, x0, #0x5d8
    48007520:	f9400001 	ldr	x1, [x0]
    48007524:	f9401fe0 	ldr	x0, [sp, #56]
    48007528:	d63f0020 	blr	x1

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800752c:	97fff3c0 	bl	4800442c <rt_hw_interrupt_disable>
    48007530:	aa0003f4 	mov	x20, x0

    /* check event set */
    if (option & RT_EVENT_FLAG_AND)
    48007534:	3940cfe0 	ldrb	w0, [sp, #51]
    48007538:	12000000 	and	w0, w0, #0x1
    4800753c:	7100001f 	cmp	w0, #0x0
    48007540:	54000140 	b.eq	48007568 <rt_event_recv+0x190>  // b.none
    {
        if ((event->set & set) == set)
    48007544:	f9401fe0 	ldr	x0, [sp, #56]
    48007548:	b9403001 	ldr	w1, [x0, #48]
    4800754c:	b94037e0 	ldr	w0, [sp, #52]
    48007550:	0a000020 	and	w0, w1, w0
    48007554:	b94037e1 	ldr	w1, [sp, #52]
    48007558:	6b00003f 	cmp	w1, w0
    4800755c:	540002a1 	b.ne	480075b0 <rt_event_recv+0x1d8>  // b.any
            status = RT_EOK;
    48007560:	d2800013 	mov	x19, #0x0                   	// #0
    48007564:	14000013 	b	480075b0 <rt_event_recv+0x1d8>
    }
    else if (option & RT_EVENT_FLAG_OR)
    48007568:	3940cfe0 	ldrb	w0, [sp, #51]
    4800756c:	121f0000 	and	w0, w0, #0x2
    48007570:	7100001f 	cmp	w0, #0x0
    48007574:	54000120 	b.eq	48007598 <rt_event_recv+0x1c0>  // b.none
    {
        if (event->set & set)
    48007578:	f9401fe0 	ldr	x0, [sp, #56]
    4800757c:	b9403001 	ldr	w1, [x0, #48]
    48007580:	b94037e0 	ldr	w0, [sp, #52]
    48007584:	0a000020 	and	w0, w1, w0
    48007588:	7100001f 	cmp	w0, #0x0
    4800758c:	54000120 	b.eq	480075b0 <rt_event_recv+0x1d8>  // b.none
            status = RT_EOK;
    48007590:	d2800013 	mov	x19, #0x0                   	// #0
    48007594:	14000007 	b	480075b0 <rt_event_recv+0x1d8>
    }
    else
    {
        /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
        RT_ASSERT(0);
    48007598:	d280c7e2 	mov	x2, #0x63f                 	// #1599
    4800759c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480075a0:	91304001 	add	x1, x0, #0xc10
    480075a4:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480075a8:	91172000 	add	x0, x0, #0x5c8
    480075ac:	940022af 	bl	48010068 <rt_assert_handler>
    }

    if (status == RT_EOK)
    480075b0:	f100027f 	cmp	x19, #0x0
    480075b4:	540003e1 	b.ne	48007630 <rt_event_recv+0x258>  // b.any
    {
        /* set received event */
        if (recved)
    480075b8:	f94013e0 	ldr	x0, [sp, #32]
    480075bc:	f100001f 	cmp	x0, #0x0
    480075c0:	540000e0 	b.eq	480075dc <rt_event_recv+0x204>  // b.none
            *recved = (event->set & set);
    480075c4:	f9401fe0 	ldr	x0, [sp, #56]
    480075c8:	b9403001 	ldr	w1, [x0, #48]
    480075cc:	b94037e0 	ldr	w0, [sp, #52]
    480075d0:	0a000021 	and	w1, w1, w0
    480075d4:	f94013e0 	ldr	x0, [sp, #32]
    480075d8:	b9000001 	str	w1, [x0]

        /* fill thread event info */
        thread->event_set = (event->set & set);
    480075dc:	f9401fe0 	ldr	x0, [sp, #56]
    480075e0:	b9403001 	ldr	w1, [x0, #48]
    480075e4:	b94037e0 	ldr	w0, [sp, #52]
    480075e8:	0a000021 	and	w1, w1, w0
    480075ec:	f94027e0 	ldr	x0, [sp, #72]
    480075f0:	b9006801 	str	w1, [x0, #104]
        thread->event_info = option;
    480075f4:	f94027e0 	ldr	x0, [sp, #72]
    480075f8:	3940cfe1 	ldrb	w1, [sp, #51]
    480075fc:	3901b001 	strb	w1, [x0, #108]

        /* received event */
        if (option & RT_EVENT_FLAG_CLEAR)
    48007600:	3940cfe0 	ldrb	w0, [sp, #51]
    48007604:	121e0000 	and	w0, w0, #0x4
    48007608:	7100001f 	cmp	w0, #0x0
    4800760c:	54000800 	b.eq	4800770c <rt_event_recv+0x334>  // b.none
            event->set &= ~set;
    48007610:	f9401fe0 	ldr	x0, [sp, #56]
    48007614:	b9403001 	ldr	w1, [x0, #48]
    48007618:	b94037e0 	ldr	w0, [sp, #52]
    4800761c:	2a2003e0 	mvn	w0, w0
    48007620:	0a000021 	and	w1, w1, w0
    48007624:	f9401fe0 	ldr	x0, [sp, #56]
    48007628:	b9003001 	str	w1, [x0, #48]
    4800762c:	14000038 	b	4800770c <rt_event_recv+0x334>
    }
    else if (timeout == 0)
    48007630:	b9402fe0 	ldr	w0, [sp, #44]
    48007634:	7100001f 	cmp	w0, #0x0
    48007638:	54000101 	b.ne	48007658 <rt_event_recv+0x280>  // b.any
    {
        /* no waiting */
        thread->error = -RT_ETIMEOUT;
    4800763c:	f94027e0 	ldr	x0, [sp, #72]
    48007640:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    48007644:	f9002c01 	str	x1, [x0, #88]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    48007648:	aa1403e0 	mov	x0, x20
    4800764c:	97fff37c 	bl	4800443c <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
    48007650:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    48007654:	1400003c 	b	48007744 <rt_event_recv+0x36c>
    }
    else
    {
        /* fill thread event info */
        thread->event_set  = set;
    48007658:	f94027e0 	ldr	x0, [sp, #72]
    4800765c:	b94037e1 	ldr	w1, [sp, #52]
    48007660:	b9006801 	str	w1, [x0, #104]
        thread->event_info = option;
    48007664:	f94027e0 	ldr	x0, [sp, #72]
    48007668:	3940cfe1 	ldrb	w1, [sp, #51]
    4800766c:	3901b001 	strb	w1, [x0, #108]

        /* put thread to suspended thread list */
        _ipc_list_suspend(&(event->parent.suspend_thread),
    48007670:	f9401fe0 	ldr	x0, [sp, #56]
    48007674:	91008003 	add	x3, x0, #0x20
    48007678:	f9401fe0 	ldr	x0, [sp, #56]
    4800767c:	39402400 	ldrb	w0, [x0, #9]
    48007680:	2a0003e2 	mov	w2, w0
    48007684:	f94027e1 	ldr	x1, [sp, #72]
    48007688:	aa0303e0 	mov	x0, x3
    4800768c:	97fff952 	bl	48005bd4 <_ipc_list_suspend>
                            thread,
                            event->parent.parent.flag);

        /* if there is a waiting timeout, active thread timer */
        if (timeout > 0)
    48007690:	b9402fe0 	ldr	w0, [sp, #44]
    48007694:	7100001f 	cmp	w0, #0x0
    48007698:	5400014d 	b.le	480076c0 <rt_event_recv+0x2e8>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
    4800769c:	f94027e0 	ldr	x0, [sp, #72]
    480076a0:	91020000 	add	x0, x0, #0x80
    480076a4:	9100b3e1 	add	x1, sp, #0x2c
    480076a8:	aa0103e2 	mov	x2, x1
    480076ac:	52800001 	mov	w1, #0x0                   	// #0
    480076b0:	94000e9c 	bl	4800b120 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
    480076b4:	f94027e0 	ldr	x0, [sp, #72]
    480076b8:	91020000 	add	x0, x0, #0x80
    480076bc:	94000d72 	bl	4800ac84 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    480076c0:	aa1403e0 	mov	x0, x20
    480076c4:	97fff35e 	bl	4800443c <rt_hw_interrupt_enable>

        /* do a schedule */
        rt_schedule();
    480076c8:	94001731 	bl	4800d38c <rt_schedule>

        if (thread->error != RT_EOK)
    480076cc:	f94027e0 	ldr	x0, [sp, #72]
    480076d0:	f9402c00 	ldr	x0, [x0, #88]
    480076d4:	f100001f 	cmp	x0, #0x0
    480076d8:	54000080 	b.eq	480076e8 <rt_event_recv+0x310>  // b.none
        {
            /* return error */
            return thread->error;
    480076dc:	f94027e0 	ldr	x0, [sp, #72]
    480076e0:	f9402c00 	ldr	x0, [x0, #88]
    480076e4:	14000018 	b	48007744 <rt_event_recv+0x36c>
        }

        /* received an event, disable interrupt to protect */
        level = rt_hw_interrupt_disable();
    480076e8:	97fff351 	bl	4800442c <rt_hw_interrupt_disable>
    480076ec:	aa0003f4 	mov	x20, x0

        /* set received event */
        if (recved)
    480076f0:	f94013e0 	ldr	x0, [sp, #32]
    480076f4:	f100001f 	cmp	x0, #0x0
    480076f8:	540000a0 	b.eq	4800770c <rt_event_recv+0x334>  // b.none
            *recved = thread->event_set;
    480076fc:	f94027e0 	ldr	x0, [sp, #72]
    48007700:	b9406801 	ldr	w1, [x0, #104]
    48007704:	f94013e0 	ldr	x0, [sp, #32]
    48007708:	b9000001 	str	w1, [x0]
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800770c:	aa1403e0 	mov	x0, x20
    48007710:	97fff34b 	bl	4800443c <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
    48007714:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48007718:	91178000 	add	x0, x0, #0x5e0
    4800771c:	f9400000 	ldr	x0, [x0]
    48007720:	f100001f 	cmp	x0, #0x0
    48007724:	540000c0 	b.eq	4800773c <rt_event_recv+0x364>  // b.none
    48007728:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800772c:	91178000 	add	x0, x0, #0x5e0
    48007730:	f9400001 	ldr	x1, [x0]
    48007734:	f9401fe0 	ldr	x0, [sp, #56]
    48007738:	d63f0020 	blr	x1

    return thread->error;
    4800773c:	f94027e0 	ldr	x0, [sp, #72]
    48007740:	f9402c00 	ldr	x0, [x0, #88]
}
    48007744:	a94153f3 	ldp	x19, x20, [sp, #16]
    48007748:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4800774c:	d65f03c0 	ret

0000000048007750 <rt_event_control>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that this function failed to execute.
 */
rt_err_t rt_event_control(rt_event_t event, int cmd, void *arg)
{
    48007750:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48007754:	910003fd 	mov	x29, sp
    48007758:	f90017e0 	str	x0, [sp, #40]
    4800775c:	b90027e1 	str	w1, [sp, #36]
    48007760:	f9000fe2 	str	x2, [sp, #24]
    rt_ubase_t level;

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
    48007764:	f94017e0 	ldr	x0, [sp, #40]
    48007768:	f100001f 	cmp	x0, #0x0
    4800776c:	540000e1 	b.ne	48007788 <rt_event_control+0x38>  // b.any
    48007770:	d280d402 	mov	x2, #0x6a0                 	// #1696
    48007774:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007778:	91308001 	add	x1, x0, #0xc20
    4800777c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007780:	9120a000 	add	x0, x0, #0x828
    48007784:	94002239 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
    48007788:	f94017e0 	ldr	x0, [sp, #40]
    4800778c:	94001a49 	bl	4800e0b0 <rt_object_get_type>
    48007790:	12001c00 	and	w0, w0, #0xff
    48007794:	7100101f 	cmp	w0, #0x4
    48007798:	540000e0 	b.eq	480077b4 <rt_event_control+0x64>  // b.none
    4800779c:	d280d422 	mov	x2, #0x6a1                 	// #1697
    480077a0:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480077a4:	91308001 	add	x1, x0, #0xc20
    480077a8:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480077ac:	91210000 	add	x0, x0, #0x840
    480077b0:	9400222e 	bl	48010068 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
    480077b4:	b94027e0 	ldr	w0, [sp, #36]
    480077b8:	7100041f 	cmp	w0, #0x1
    480077bc:	540001a1 	b.ne	480077f0 <rt_event_control+0xa0>  // b.any
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    480077c0:	97fff31b 	bl	4800442c <rt_hw_interrupt_disable>
    480077c4:	f9001fe0 	str	x0, [sp, #56]

        /* resume all waiting thread */
        _ipc_list_resume_all(&event->parent.suspend_thread);
    480077c8:	f94017e0 	ldr	x0, [sp, #40]
    480077cc:	91008000 	add	x0, x0, #0x20
    480077d0:	97fff951 	bl	48005d14 <_ipc_list_resume_all>

        /* initialize event set */
        event->set = 0;
    480077d4:	f94017e0 	ldr	x0, [sp, #40]
    480077d8:	b900301f 	str	wzr, [x0, #48]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    480077dc:	f9401fe0 	ldr	x0, [sp, #56]
    480077e0:	97fff317 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    480077e4:	940016ea 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    480077e8:	d2800000 	mov	x0, #0x0                   	// #0
    480077ec:	14000002 	b	480077f4 <rt_event_control+0xa4>
    }

    return -RT_ERROR;
    480077f0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
    480077f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480077f8:	d65f03c0 	ret

00000000480077fc <rt_mb_init>:
rt_err_t rt_mb_init(rt_mailbox_t mb,
                    const char  *name,
                    void        *msgpool,
                    rt_size_t    size,
                    rt_uint8_t   flag)
{
    480077fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48007800:	910003fd 	mov	x29, sp
    48007804:	f9001fe0 	str	x0, [sp, #56]
    48007808:	f9001be1 	str	x1, [sp, #48]
    4800780c:	f90017e2 	str	x2, [sp, #40]
    48007810:	f90013e3 	str	x3, [sp, #32]
    48007814:	39007fe4 	strb	w4, [sp, #31]
    RT_ASSERT(mb != RT_NULL);
    48007818:	f9401fe0 	ldr	x0, [sp, #56]
    4800781c:	f100001f 	cmp	x0, #0x0
    48007820:	540000e1 	b.ne	4800783c <rt_mb_init+0x40>  // b.any
    48007824:	d280ddc2 	mov	x2, #0x6ee                 	// #1774
    48007828:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800782c:	9130e001 	add	x1, x0, #0xc38
    48007830:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007834:	91240000 	add	x0, x0, #0x900
    48007838:	9400220c 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    4800783c:	39407fe0 	ldrb	w0, [sp, #31]
    48007840:	7100001f 	cmp	w0, #0x0
    48007844:	54000140 	b.eq	4800786c <rt_mb_init+0x70>  // b.none
    48007848:	39407fe0 	ldrb	w0, [sp, #31]
    4800784c:	7100041f 	cmp	w0, #0x1
    48007850:	540000e0 	b.eq	4800786c <rt_mb_init+0x70>  // b.none
    48007854:	d280dde2 	mov	x2, #0x6ef                 	// #1775
    48007858:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800785c:	9130e001 	add	x1, x0, #0xc38
    48007860:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007864:	9117e000 	add	x0, x0, #0x5f8
    48007868:	94002200 	bl	48010068 <rt_assert_handler>

    /* initialize object */
    rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
    4800786c:	f9401fe0 	ldr	x0, [sp, #56]
    48007870:	f9401be2 	ldr	x2, [sp, #48]
    48007874:	528000a1 	mov	w1, #0x5                   	// #5
    48007878:	940018f9 	bl	4800dc5c <rt_object_init>

    /* set parent flag */
    mb->parent.parent.flag = flag;
    4800787c:	f9401fe0 	ldr	x0, [sp, #56]
    48007880:	39407fe1 	ldrb	w1, [sp, #31]
    48007884:	39002401 	strb	w1, [x0, #9]

    /* initialize ipc object */
    _ipc_object_init(&(mb->parent));
    48007888:	f9401fe0 	ldr	x0, [sp, #56]
    4800788c:	97fff8c9 	bl	48005bb0 <_ipc_object_init>

    /* initialize mailbox */
    mb->msg_pool   = (rt_ubase_t *)msgpool;
    48007890:	f9401fe0 	ldr	x0, [sp, #56]
    48007894:	f94017e1 	ldr	x1, [sp, #40]
    48007898:	f9001801 	str	x1, [x0, #48]
    mb->size       = size;
    4800789c:	f94013e0 	ldr	x0, [sp, #32]
    480078a0:	12003c01 	and	w1, w0, #0xffff
    480078a4:	f9401fe0 	ldr	x0, [sp, #56]
    480078a8:	79007001 	strh	w1, [x0, #56]
    mb->entry      = 0;
    480078ac:	f9401fe0 	ldr	x0, [sp, #56]
    480078b0:	7900741f 	strh	wzr, [x0, #58]
    mb->in_offset  = 0;
    480078b4:	f9401fe0 	ldr	x0, [sp, #56]
    480078b8:	7900781f 	strh	wzr, [x0, #60]
    mb->out_offset = 0;
    480078bc:	f9401fe0 	ldr	x0, [sp, #56]
    480078c0:	79007c1f 	strh	wzr, [x0, #62]

    /* initialize an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
    480078c4:	f9401fe0 	ldr	x0, [sp, #56]
    480078c8:	91010000 	add	x0, x0, #0x40
    480078cc:	97fff88f 	bl	48005b08 <rt_list_init>

    return RT_EOK;
    480078d0:	d2800000 	mov	x0, #0x0                   	// #0
}
    480078d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480078d8:	d65f03c0 	ret

00000000480078dc <rt_mb_detach>:
 * @warning  This function can ONLY detach a static mailbox initialized by the rt_mb_init() function.
 *           If the mailbox is created by the rt_mb_create() function, you MUST NOT USE this function to detach it,
 *           ONLY USE the rt_mb_delete() function to complete the deletion.
 */
rt_err_t rt_mb_detach(rt_mailbox_t mb)
{
    480078dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480078e0:	910003fd 	mov	x29, sp
    480078e4:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
    480078e8:	f9400fe0 	ldr	x0, [sp, #24]
    480078ec:	f100001f 	cmp	x0, #0x0
    480078f0:	540000e1 	b.ne	4800790c <rt_mb_detach+0x30>  // b.any
    480078f4:	d280e3c2 	mov	x2, #0x71e                 	// #1822
    480078f8:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480078fc:	91312001 	add	x1, x0, #0xc48
    48007900:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007904:	91240000 	add	x0, x0, #0x900
    48007908:	940021d8 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
    4800790c:	f9400fe0 	ldr	x0, [sp, #24]
    48007910:	940019e8 	bl	4800e0b0 <rt_object_get_type>
    48007914:	12001c00 	and	w0, w0, #0xff
    48007918:	7100141f 	cmp	w0, #0x5
    4800791c:	540000e0 	b.eq	48007938 <rt_mb_detach+0x5c>  // b.none
    48007920:	d280e3e2 	mov	x2, #0x71f                 	// #1823
    48007924:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007928:	91312001 	add	x1, x0, #0xc48
    4800792c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007930:	91244000 	add	x0, x0, #0x910
    48007934:	940021cd 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent));
    48007938:	f9400fe0 	ldr	x0, [sp, #24]
    4800793c:	940019c7 	bl	4800e058 <rt_object_is_systemobject>
    48007940:	7100001f 	cmp	w0, #0x0
    48007944:	540000e1 	b.ne	48007960 <rt_mb_detach+0x84>  // b.any
    48007948:	d280e402 	mov	x2, #0x720                 	// #1824
    4800794c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007950:	91312001 	add	x1, x0, #0xc48
    48007954:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007958:	91256000 	add	x0, x0, #0x958
    4800795c:	940021c3 	bl	48010068 <rt_assert_handler>

    /* resume all suspended thread */
    _ipc_list_resume_all(&(mb->parent.suspend_thread));
    48007960:	f9400fe0 	ldr	x0, [sp, #24]
    48007964:	91008000 	add	x0, x0, #0x20
    48007968:	97fff8eb 	bl	48005d14 <_ipc_list_resume_all>
    /* also resume all mailbox private suspended thread */
    _ipc_list_resume_all(&(mb->suspend_sender_thread));
    4800796c:	f9400fe0 	ldr	x0, [sp, #24]
    48007970:	91010000 	add	x0, x0, #0x40
    48007974:	97fff8e8 	bl	48005d14 <_ipc_list_resume_all>

    /* detach mailbox object */
    rt_object_detach(&(mb->parent.parent));
    48007978:	f9400fe0 	ldr	x0, [sp, #24]
    4800797c:	9400190c 	bl	4800ddac <rt_object_detach>

    return RT_EOK;
    48007980:	d2800000 	mov	x0, #0x0                   	// #0
}
    48007984:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48007988:	d65f03c0 	ret

000000004800798c <rt_mb_create>:
 * @return   Return a pointer to the mailbox object. When the return value is RT_NULL, it means the creation failed.
 *
 * @warning  This function can ONLY be called from threads.
 */
rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
{
    4800798c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48007990:	910003fd 	mov	x29, sp
    48007994:	f90017e0 	str	x0, [sp, #40]
    48007998:	f90013e1 	str	x1, [sp, #32]
    4800799c:	39007fe2 	strb	w2, [sp, #31]
    rt_mailbox_t mb;

    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    480079a0:	39407fe0 	ldrb	w0, [sp, #31]
    480079a4:	7100001f 	cmp	w0, #0x0
    480079a8:	54000140 	b.eq	480079d0 <rt_mb_create+0x44>  // b.none
    480079ac:	39407fe0 	ldrb	w0, [sp, #31]
    480079b0:	7100041f 	cmp	w0, #0x1
    480079b4:	540000e0 	b.eq	480079d0 <rt_mb_create+0x44>  // b.none
    480079b8:	d280ea42 	mov	x2, #0x752                 	// #1874
    480079bc:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480079c0:	91316001 	add	x1, x0, #0xc58
    480079c4:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480079c8:	9117e000 	add	x0, x0, #0x5f8
    480079cc:	940021a7 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    480079d0:	97fff297 	bl	4800442c <rt_hw_interrupt_disable>
    480079d4:	f9001fe0 	str	x0, [sp, #56]
    480079d8:	9400074e 	bl	48009710 <rt_interrupt_get_nest>
    480079dc:	12001c00 	and	w0, w0, #0xff
    480079e0:	7100001f 	cmp	w0, #0x0
    480079e4:	54000180 	b.eq	48007a14 <rt_mb_create+0x88>  // b.none
    480079e8:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480079ec:	91316001 	add	x1, x0, #0xc58
    480079f0:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480079f4:	911ac000 	add	x0, x0, #0x6b0
    480079f8:	940020ce 	bl	4800fd30 <rt_kprintf>
    480079fc:	d280ea82 	mov	x2, #0x754                 	// #1876
    48007a00:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007a04:	91316001 	add	x1, x0, #0xc58
    48007a08:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007a0c:	91172000 	add	x0, x0, #0x5c8
    48007a10:	94002196 	bl	48010068 <rt_assert_handler>
    48007a14:	f9401fe0 	ldr	x0, [sp, #56]
    48007a18:	97fff289 	bl	4800443c <rt_hw_interrupt_enable>

    /* allocate object */
    mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
    48007a1c:	f94017e1 	ldr	x1, [sp, #40]
    48007a20:	528000a0 	mov	w0, #0x5                   	// #5
    48007a24:	94001906 	bl	4800de3c <rt_object_allocate>
    48007a28:	f9001be0 	str	x0, [sp, #48]
    if (mb == RT_NULL)
    48007a2c:	f9401be0 	ldr	x0, [sp, #48]
    48007a30:	f100001f 	cmp	x0, #0x0
    48007a34:	54000061 	b.ne	48007a40 <rt_mb_create+0xb4>  // b.any
        return mb;
    48007a38:	f9401be0 	ldr	x0, [sp, #48]
    48007a3c:	14000024 	b	48007acc <rt_mb_create+0x140>

    /* set parent */
    mb->parent.parent.flag = flag;
    48007a40:	f9401be0 	ldr	x0, [sp, #48]
    48007a44:	39407fe1 	ldrb	w1, [sp, #31]
    48007a48:	39002401 	strb	w1, [x0, #9]

    /* initialize ipc object */
    _ipc_object_init(&(mb->parent));
    48007a4c:	f9401be0 	ldr	x0, [sp, #48]
    48007a50:	97fff858 	bl	48005bb0 <_ipc_object_init>

    /* initialize mailbox */
    mb->size     = size;
    48007a54:	f94013e0 	ldr	x0, [sp, #32]
    48007a58:	12003c01 	and	w1, w0, #0xffff
    48007a5c:	f9401be0 	ldr	x0, [sp, #48]
    48007a60:	79007001 	strh	w1, [x0, #56]
    mb->msg_pool = (rt_ubase_t *)RT_KERNEL_MALLOC(mb->size * sizeof(rt_ubase_t));
    48007a64:	f9401be0 	ldr	x0, [sp, #48]
    48007a68:	79407000 	ldrh	w0, [x0, #56]
    48007a6c:	92403c00 	and	x0, x0, #0xffff
    48007a70:	d37df000 	lsl	x0, x0, #3
    48007a74:	94000845 	bl	48009b88 <rt_malloc>
    48007a78:	aa0003e1 	mov	x1, x0
    48007a7c:	f9401be0 	ldr	x0, [sp, #48]
    48007a80:	f9001801 	str	x1, [x0, #48]
    if (mb->msg_pool == RT_NULL)
    48007a84:	f9401be0 	ldr	x0, [sp, #48]
    48007a88:	f9401800 	ldr	x0, [x0, #48]
    48007a8c:	f100001f 	cmp	x0, #0x0
    48007a90:	540000a1 	b.ne	48007aa4 <rt_mb_create+0x118>  // b.any
    {
        /* delete mailbox object */
        rt_object_delete(&(mb->parent.parent));
    48007a94:	f9401be0 	ldr	x0, [sp, #48]
    48007a98:	9400193f 	bl	4800df94 <rt_object_delete>

        return RT_NULL;
    48007a9c:	d2800000 	mov	x0, #0x0                   	// #0
    48007aa0:	1400000b 	b	48007acc <rt_mb_create+0x140>
    }
    mb->entry      = 0;
    48007aa4:	f9401be0 	ldr	x0, [sp, #48]
    48007aa8:	7900741f 	strh	wzr, [x0, #58]
    mb->in_offset  = 0;
    48007aac:	f9401be0 	ldr	x0, [sp, #48]
    48007ab0:	7900781f 	strh	wzr, [x0, #60]
    mb->out_offset = 0;
    48007ab4:	f9401be0 	ldr	x0, [sp, #48]
    48007ab8:	79007c1f 	strh	wzr, [x0, #62]

    /* initialize an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
    48007abc:	f9401be0 	ldr	x0, [sp, #48]
    48007ac0:	91010000 	add	x0, x0, #0x40
    48007ac4:	97fff811 	bl	48005b08 <rt_list_init>

    return mb;
    48007ac8:	f9401be0 	ldr	x0, [sp, #48]
}
    48007acc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48007ad0:	d65f03c0 	ret

0000000048007ad4 <rt_mb_delete>:
 * @warning  This function can only delete mailbox created by the rt_mb_create() function.
 *           If the mailbox is initialized by the rt_mb_init() function, you MUST NOT USE this function to delete it,
 *           ONLY USE the rt_mb_detach() function to complete the detachment.
 */
rt_err_t rt_mb_delete(rt_mailbox_t mb)
{
    48007ad4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48007ad8:	910003fd 	mov	x29, sp
    48007adc:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
    48007ae0:	f9400fe0 	ldr	x0, [sp, #24]
    48007ae4:	f100001f 	cmp	x0, #0x0
    48007ae8:	540000e1 	b.ne	48007b04 <rt_mb_delete+0x30>  // b.any
    48007aec:	d280f182 	mov	x2, #0x78c                 	// #1932
    48007af0:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007af4:	9131a001 	add	x1, x0, #0xc68
    48007af8:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007afc:	91240000 	add	x0, x0, #0x900
    48007b00:	9400215a 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
    48007b04:	f9400fe0 	ldr	x0, [sp, #24]
    48007b08:	9400196a 	bl	4800e0b0 <rt_object_get_type>
    48007b0c:	12001c00 	and	w0, w0, #0xff
    48007b10:	7100141f 	cmp	w0, #0x5
    48007b14:	540000e0 	b.eq	48007b30 <rt_mb_delete+0x5c>  // b.none
    48007b18:	d280f1a2 	mov	x2, #0x78d                 	// #1933
    48007b1c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b20:	9131a001 	add	x1, x0, #0xc68
    48007b24:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b28:	91244000 	add	x0, x0, #0x910
    48007b2c:	9400214f 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent) == RT_FALSE);
    48007b30:	f9400fe0 	ldr	x0, [sp, #24]
    48007b34:	94001949 	bl	4800e058 <rt_object_is_systemobject>
    48007b38:	7100001f 	cmp	w0, #0x0
    48007b3c:	540000e0 	b.eq	48007b58 <rt_mb_delete+0x84>  // b.none
    48007b40:	d280f1c2 	mov	x2, #0x78e                 	// #1934
    48007b44:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b48:	9131a001 	add	x1, x0, #0xc68
    48007b4c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b50:	91262000 	add	x0, x0, #0x988
    48007b54:	94002145 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    48007b58:	97fff235 	bl	4800442c <rt_hw_interrupt_disable>
    48007b5c:	f90017e0 	str	x0, [sp, #40]
    48007b60:	940006ec 	bl	48009710 <rt_interrupt_get_nest>
    48007b64:	12001c00 	and	w0, w0, #0xff
    48007b68:	7100001f 	cmp	w0, #0x0
    48007b6c:	54000180 	b.eq	48007b9c <rt_mb_delete+0xc8>  // b.none
    48007b70:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b74:	9131a001 	add	x1, x0, #0xc68
    48007b78:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b7c:	911ac000 	add	x0, x0, #0x6b0
    48007b80:	9400206c 	bl	4800fd30 <rt_kprintf>
    48007b84:	d280f202 	mov	x2, #0x790                 	// #1936
    48007b88:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b8c:	9131a001 	add	x1, x0, #0xc68
    48007b90:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007b94:	91172000 	add	x0, x0, #0x5c8
    48007b98:	94002134 	bl	48010068 <rt_assert_handler>
    48007b9c:	f94017e0 	ldr	x0, [sp, #40]
    48007ba0:	97fff227 	bl	4800443c <rt_hw_interrupt_enable>

    /* resume all suspended thread */
    _ipc_list_resume_all(&(mb->parent.suspend_thread));
    48007ba4:	f9400fe0 	ldr	x0, [sp, #24]
    48007ba8:	91008000 	add	x0, x0, #0x20
    48007bac:	97fff85a 	bl	48005d14 <_ipc_list_resume_all>

    /* also resume all mailbox private suspended thread */
    _ipc_list_resume_all(&(mb->suspend_sender_thread));
    48007bb0:	f9400fe0 	ldr	x0, [sp, #24]
    48007bb4:	91010000 	add	x0, x0, #0x40
    48007bb8:	97fff857 	bl	48005d14 <_ipc_list_resume_all>

    /* free mailbox pool */
    RT_KERNEL_FREE(mb->msg_pool);
    48007bbc:	f9400fe0 	ldr	x0, [sp, #24]
    48007bc0:	f9401800 	ldr	x0, [x0, #48]
    48007bc4:	94000a00 	bl	4800a3c4 <rt_free>

    /* delete mailbox object */
    rt_object_delete(&(mb->parent.parent));
    48007bc8:	f9400fe0 	ldr	x0, [sp, #24]
    48007bcc:	940018f2 	bl	4800df94 <rt_object_delete>

    return RT_EOK;
    48007bd0:	d2800000 	mov	x0, #0x0                   	// #0
}
    48007bd4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48007bd8:	d65f03c0 	ret

0000000048007bdc <rt_mb_send_wait>:
 * @warning  This function can be called in interrupt context and thread context.
 */
rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
                         rt_ubase_t   value,
                         rt_int32_t   timeout)
{
    48007bdc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    48007be0:	910003fd 	mov	x29, sp
    48007be4:	f9000bf3 	str	x19, [sp, #16]
    48007be8:	f9001fe0 	str	x0, [sp, #56]
    48007bec:	f9001be1 	str	x1, [sp, #48]
    48007bf0:	b9002fe2 	str	w2, [sp, #44]
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
    48007bf4:	f9401fe0 	ldr	x0, [sp, #56]
    48007bf8:	f100001f 	cmp	x0, #0x0
    48007bfc:	540000e1 	b.ne	48007c18 <rt_mb_send_wait+0x3c>  // b.any
    48007c00:	d280f882 	mov	x2, #0x7c4                 	// #1988
    48007c04:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007c08:	9131e001 	add	x1, x0, #0xc78
    48007c0c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007c10:	91240000 	add	x0, x0, #0x900
    48007c14:	94002115 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
    48007c18:	f9401fe0 	ldr	x0, [sp, #56]
    48007c1c:	94001925 	bl	4800e0b0 <rt_object_get_type>
    48007c20:	12001c00 	and	w0, w0, #0xff
    48007c24:	7100141f 	cmp	w0, #0x5
    48007c28:	540000e0 	b.eq	48007c44 <rt_mb_send_wait+0x68>  // b.none
    48007c2c:	d280f8a2 	mov	x2, #0x7c5                 	// #1989
    48007c30:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007c34:	9131e001 	add	x1, x0, #0xc78
    48007c38:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007c3c:	91244000 	add	x0, x0, #0x910
    48007c40:	9400210a 	bl	48010068 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
    48007c44:	b9005fff 	str	wzr, [sp, #92]
    /* get current thread */
    thread = rt_thread_self();
    48007c48:	94000fd5 	bl	4800bb9c <rt_thread_self>
    48007c4c:	f9002be0 	str	x0, [sp, #80]

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
    48007c50:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48007c54:	9117a000 	add	x0, x0, #0x5e8
    48007c58:	f9400000 	ldr	x0, [x0]
    48007c5c:	f100001f 	cmp	x0, #0x0
    48007c60:	540000c0 	b.eq	48007c78 <rt_mb_send_wait+0x9c>  // b.none
    48007c64:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48007c68:	9117a000 	add	x0, x0, #0x5e8
    48007c6c:	f9400001 	ldr	x1, [x0]
    48007c70:	f9401fe0 	ldr	x0, [sp, #56]
    48007c74:	d63f0020 	blr	x1

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48007c78:	97fff1ed 	bl	4800442c <rt_hw_interrupt_disable>
    48007c7c:	aa0003f3 	mov	x19, x0

    /* for non-blocking call */
    if (mb->entry == mb->size && timeout == 0)
    48007c80:	f9401fe0 	ldr	x0, [sp, #56]
    48007c84:	79407401 	ldrh	w1, [x0, #58]
    48007c88:	f9401fe0 	ldr	x0, [sp, #56]
    48007c8c:	79407000 	ldrh	w0, [x0, #56]
    48007c90:	6b00003f 	cmp	w1, w0
    48007c94:	54000d21 	b.ne	48007e38 <rt_mb_send_wait+0x25c>  // b.any
    48007c98:	b9402fe0 	ldr	w0, [sp, #44]
    48007c9c:	7100001f 	cmp	w0, #0x0
    48007ca0:	54000cc1 	b.ne	48007e38 <rt_mb_send_wait+0x25c>  // b.any
    {
        rt_hw_interrupt_enable(temp);
    48007ca4:	aa1303e0 	mov	x0, x19
    48007ca8:	97fff1e5 	bl	4800443c <rt_hw_interrupt_enable>
        return -RT_EFULL;
    48007cac:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48007cb0:	1400009f 	b	48007f2c <rt_mb_send_wait+0x350>

    /* mailbox is full */
    while (mb->entry == mb->size)
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
    48007cb4:	f9402be0 	ldr	x0, [sp, #80]
    48007cb8:	f9002c1f 	str	xzr, [x0, #88]

        /* no waiting, return timeout */
        if (timeout == 0)
    48007cbc:	b9402fe0 	ldr	w0, [sp, #44]
    48007cc0:	7100001f 	cmp	w0, #0x0
    48007cc4:	540000a1 	b.ne	48007cd8 <rt_mb_send_wait+0xfc>  // b.any
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
    48007cc8:	aa1303e0 	mov	x0, x19
    48007ccc:	97fff1dc 	bl	4800443c <rt_hw_interrupt_enable>

            return -RT_EFULL;
    48007cd0:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48007cd4:	14000096 	b	48007f2c <rt_mb_send_wait+0x350>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
    48007cd8:	97fff1d5 	bl	4800442c <rt_hw_interrupt_disable>
    48007cdc:	f90027e0 	str	x0, [sp, #72]
    48007ce0:	94000faf 	bl	4800bb9c <rt_thread_self>
    48007ce4:	f100001f 	cmp	x0, #0x0
    48007ce8:	54000181 	b.ne	48007d18 <rt_mb_send_wait+0x13c>  // b.any
    48007cec:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007cf0:	9131e001 	add	x1, x0, #0xc78
    48007cf4:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007cf8:	911c6000 	add	x0, x0, #0x718
    48007cfc:	9400200d 	bl	4800fd30 <rt_kprintf>
    48007d00:	d280fce2 	mov	x2, #0x7e7                 	// #2023
    48007d04:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007d08:	9131e001 	add	x1, x0, #0xc78
    48007d0c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007d10:	91172000 	add	x0, x0, #0x5c8
    48007d14:	940020d5 	bl	48010068 <rt_assert_handler>
    48007d18:	97fff1c5 	bl	4800442c <rt_hw_interrupt_disable>
    48007d1c:	f90023e0 	str	x0, [sp, #64]
    48007d20:	9400067c 	bl	48009710 <rt_interrupt_get_nest>
    48007d24:	12001c00 	and	w0, w0, #0xff
    48007d28:	7100001f 	cmp	w0, #0x0
    48007d2c:	54000180 	b.eq	48007d5c <rt_mb_send_wait+0x180>  // b.none
    48007d30:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007d34:	9131e001 	add	x1, x0, #0xc78
    48007d38:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007d3c:	911ac000 	add	x0, x0, #0x6b0
    48007d40:	94001ffc 	bl	4800fd30 <rt_kprintf>
    48007d44:	d280fce2 	mov	x2, #0x7e7                 	// #2023
    48007d48:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007d4c:	9131e001 	add	x1, x0, #0xc78
    48007d50:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007d54:	91172000 	add	x0, x0, #0x5c8
    48007d58:	940020c4 	bl	48010068 <rt_assert_handler>
    48007d5c:	f94023e0 	ldr	x0, [sp, #64]
    48007d60:	97fff1b7 	bl	4800443c <rt_hw_interrupt_enable>
    48007d64:	f94027e0 	ldr	x0, [sp, #72]
    48007d68:	97fff1b5 	bl	4800443c <rt_hw_interrupt_enable>
        /* suspend current thread */
        _ipc_list_suspend(&(mb->suspend_sender_thread),
    48007d6c:	f9401fe0 	ldr	x0, [sp, #56]
    48007d70:	91010003 	add	x3, x0, #0x40
    48007d74:	f9401fe0 	ldr	x0, [sp, #56]
    48007d78:	39402400 	ldrb	w0, [x0, #9]
    48007d7c:	2a0003e2 	mov	w2, w0
    48007d80:	f9402be1 	ldr	x1, [sp, #80]
    48007d84:	aa0303e0 	mov	x0, x3
    48007d88:	97fff793 	bl	48005bd4 <_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
    48007d8c:	b9402fe0 	ldr	w0, [sp, #44]
    48007d90:	7100001f 	cmp	w0, #0x0
    48007d94:	5400018d 	b.le	48007dc4 <rt_mb_send_wait+0x1e8>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
    48007d98:	940020d5 	bl	480100ec <rt_tick_get>
    48007d9c:	b9005fe0 	str	w0, [sp, #92]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
    48007da0:	f9402be0 	ldr	x0, [sp, #80]
    48007da4:	91020000 	add	x0, x0, #0x80
    48007da8:	9100b3e1 	add	x1, sp, #0x2c
    48007dac:	aa0103e2 	mov	x2, x1
    48007db0:	52800001 	mov	w1, #0x0                   	// #0
    48007db4:	94000cdb 	bl	4800b120 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
    48007db8:	f9402be0 	ldr	x0, [sp, #80]
    48007dbc:	91020000 	add	x0, x0, #0x80
    48007dc0:	94000bb1 	bl	4800ac84 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48007dc4:	aa1303e0 	mov	x0, x19
    48007dc8:	97fff19d 	bl	4800443c <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
    48007dcc:	94001570 	bl	4800d38c <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
    48007dd0:	f9402be0 	ldr	x0, [sp, #80]
    48007dd4:	f9402c00 	ldr	x0, [x0, #88]
    48007dd8:	f100001f 	cmp	x0, #0x0
    48007ddc:	54000080 	b.eq	48007dec <rt_mb_send_wait+0x210>  // b.none
        {
            /* return error */
            return thread->error;
    48007de0:	f9402be0 	ldr	x0, [sp, #80]
    48007de4:	f9402c00 	ldr	x0, [x0, #88]
    48007de8:	14000051 	b	48007f2c <rt_mb_send_wait+0x350>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
    48007dec:	97fff190 	bl	4800442c <rt_hw_interrupt_disable>
    48007df0:	aa0003f3 	mov	x19, x0

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
    48007df4:	b9402fe0 	ldr	w0, [sp, #44]
    48007df8:	7100001f 	cmp	w0, #0x0
    48007dfc:	540001ed 	b.le	48007e38 <rt_mb_send_wait+0x25c>
        {
            tick_delta = rt_tick_get() - tick_delta;
    48007e00:	940020bb 	bl	480100ec <rt_tick_get>
    48007e04:	2a0003e1 	mov	w1, w0
    48007e08:	b9405fe0 	ldr	w0, [sp, #92]
    48007e0c:	4b000020 	sub	w0, w1, w0
    48007e10:	b9005fe0 	str	w0, [sp, #92]
            timeout -= tick_delta;
    48007e14:	b9402fe0 	ldr	w0, [sp, #44]
    48007e18:	2a0003e1 	mov	w1, w0
    48007e1c:	b9405fe0 	ldr	w0, [sp, #92]
    48007e20:	4b000020 	sub	w0, w1, w0
    48007e24:	b9002fe0 	str	w0, [sp, #44]
            if (timeout < 0)
    48007e28:	b9402fe0 	ldr	w0, [sp, #44]
    48007e2c:	7100001f 	cmp	w0, #0x0
    48007e30:	5400004a 	b.ge	48007e38 <rt_mb_send_wait+0x25c>  // b.tcont
                timeout = 0;
    48007e34:	b9002fff 	str	wzr, [sp, #44]
    while (mb->entry == mb->size)
    48007e38:	f9401fe0 	ldr	x0, [sp, #56]
    48007e3c:	79407401 	ldrh	w1, [x0, #58]
    48007e40:	f9401fe0 	ldr	x0, [sp, #56]
    48007e44:	79407000 	ldrh	w0, [x0, #56]
    48007e48:	6b00003f 	cmp	w1, w0
    48007e4c:	54fff340 	b.eq	48007cb4 <rt_mb_send_wait+0xd8>  // b.none
        }
    }

    /* set ptr */
    mb->msg_pool[mb->in_offset] = value;
    48007e50:	f9401fe0 	ldr	x0, [sp, #56]
    48007e54:	f9401801 	ldr	x1, [x0, #48]
    48007e58:	f9401fe0 	ldr	x0, [sp, #56]
    48007e5c:	79407800 	ldrh	w0, [x0, #60]
    48007e60:	92403c00 	and	x0, x0, #0xffff
    48007e64:	d37df000 	lsl	x0, x0, #3
    48007e68:	8b000020 	add	x0, x1, x0
    48007e6c:	f9401be1 	ldr	x1, [sp, #48]
    48007e70:	f9000001 	str	x1, [x0]
    /* increase input offset */
    ++ mb->in_offset;
    48007e74:	f9401fe0 	ldr	x0, [sp, #56]
    48007e78:	79407800 	ldrh	w0, [x0, #60]
    48007e7c:	11000400 	add	w0, w0, #0x1
    48007e80:	12003c01 	and	w1, w0, #0xffff
    48007e84:	f9401fe0 	ldr	x0, [sp, #56]
    48007e88:	79007801 	strh	w1, [x0, #60]
    if (mb->in_offset >= mb->size)
    48007e8c:	f9401fe0 	ldr	x0, [sp, #56]
    48007e90:	79407801 	ldrh	w1, [x0, #60]
    48007e94:	f9401fe0 	ldr	x0, [sp, #56]
    48007e98:	79407000 	ldrh	w0, [x0, #56]
    48007e9c:	6b00003f 	cmp	w1, w0
    48007ea0:	54000063 	b.cc	48007eac <rt_mb_send_wait+0x2d0>  // b.lo, b.ul, b.last
        mb->in_offset = 0;
    48007ea4:	f9401fe0 	ldr	x0, [sp, #56]
    48007ea8:	7900781f 	strh	wzr, [x0, #60]

    if(mb->entry < RT_MB_ENTRY_MAX)
    48007eac:	f9401fe0 	ldr	x0, [sp, #56]
    48007eb0:	79407401 	ldrh	w1, [x0, #58]
    48007eb4:	529fffe0 	mov	w0, #0xffff                	// #65535
    48007eb8:	6b00003f 	cmp	w1, w0
    48007ebc:	540001a0 	b.eq	48007ef0 <rt_mb_send_wait+0x314>  // b.none
    {
        /* increase message entry */
        mb->entry ++;
    48007ec0:	f9401fe0 	ldr	x0, [sp, #56]
    48007ec4:	79407400 	ldrh	w0, [x0, #58]
    48007ec8:	11000400 	add	w0, w0, #0x1
    48007ecc:	12003c01 	and	w1, w0, #0xffff
    48007ed0:	f9401fe0 	ldr	x0, [sp, #56]
    48007ed4:	79007401 	strh	w1, [x0, #58]
        rt_hw_interrupt_enable(temp); /* enable interrupt */
        return -RT_EFULL; /* value overflowed */
    }

    /* resume suspended thread */
    if (!rt_list_isempty(&mb->parent.suspend_thread))
    48007ed8:	f9401fe0 	ldr	x0, [sp, #56]
    48007edc:	91008000 	add	x0, x0, #0x20
    48007ee0:	97fff72a 	bl	48005b88 <rt_list_isempty>
    48007ee4:	7100001f 	cmp	w0, #0x0
    48007ee8:	540001c1 	b.ne	48007f20 <rt_mb_send_wait+0x344>  // b.any
    48007eec:	14000005 	b	48007f00 <rt_mb_send_wait+0x324>
        rt_hw_interrupt_enable(temp); /* enable interrupt */
    48007ef0:	aa1303e0 	mov	x0, x19
    48007ef4:	97fff152 	bl	4800443c <rt_hw_interrupt_enable>
        return -RT_EFULL; /* value overflowed */
    48007ef8:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48007efc:	1400000c 	b	48007f2c <rt_mb_send_wait+0x350>
    {
        _ipc_list_resume(&(mb->parent.suspend_thread));
    48007f00:	f9401fe0 	ldr	x0, [sp, #56]
    48007f04:	91008000 	add	x0, x0, #0x20
    48007f08:	97fff777 	bl	48005ce4 <_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48007f0c:	aa1303e0 	mov	x0, x19
    48007f10:	97fff14b 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    48007f14:	9400151e 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    48007f18:	d2800000 	mov	x0, #0x0                   	// #0
    48007f1c:	14000004 	b	48007f2c <rt_mb_send_wait+0x350>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48007f20:	aa1303e0 	mov	x0, x19
    48007f24:	97fff146 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    48007f28:	d2800000 	mov	x0, #0x0                   	// #0
}
    48007f2c:	f9400bf3 	ldr	x19, [sp, #16]
    48007f30:	a8c67bfd 	ldp	x29, x30, [sp], #96
    48007f34:	d65f03c0 	ret

0000000048007f38 <rt_mb_send>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the mailbox detach failed.
 */
rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value)
{
    48007f38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48007f3c:	910003fd 	mov	x29, sp
    48007f40:	f9000fe0 	str	x0, [sp, #24]
    48007f44:	f9000be1 	str	x1, [sp, #16]
    return rt_mb_send_wait(mb, value, 0);
    48007f48:	52800002 	mov	w2, #0x0                   	// #0
    48007f4c:	f9400be1 	ldr	x1, [sp, #16]
    48007f50:	f9400fe0 	ldr	x0, [sp, #24]
    48007f54:	97ffff22 	bl	48007bdc <rt_mb_send_wait>
}
    48007f58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48007f5c:	d65f03c0 	ret

0000000048007f60 <rt_mb_urgent>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the mailbox detach failed.
 */
rt_err_t rt_mb_urgent(rt_mailbox_t mb, rt_ubase_t value)
{
    48007f60:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48007f64:	910003fd 	mov	x29, sp
    48007f68:	f9000bf3 	str	x19, [sp, #16]
    48007f6c:	f90017e0 	str	x0, [sp, #40]
    48007f70:	f90013e1 	str	x1, [sp, #32]
    register rt_ubase_t temp;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
    48007f74:	f94017e0 	ldr	x0, [sp, #40]
    48007f78:	f100001f 	cmp	x0, #0x0
    48007f7c:	540000e1 	b.ne	48007f98 <rt_mb_urgent+0x38>  // b.any
    48007f80:	d2810d62 	mov	x2, #0x86b                 	// #2155
    48007f84:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007f88:	91322001 	add	x1, x0, #0xc88
    48007f8c:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007f90:	91240000 	add	x0, x0, #0x900
    48007f94:	94002035 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
    48007f98:	f94017e0 	ldr	x0, [sp, #40]
    48007f9c:	94001845 	bl	4800e0b0 <rt_object_get_type>
    48007fa0:	12001c00 	and	w0, w0, #0xff
    48007fa4:	7100141f 	cmp	w0, #0x5
    48007fa8:	540000e0 	b.eq	48007fc4 <rt_mb_urgent+0x64>  // b.none
    48007fac:	d2810d82 	mov	x2, #0x86c                 	// #2156
    48007fb0:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007fb4:	91322001 	add	x1, x0, #0xc88
    48007fb8:	f00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48007fbc:	91244000 	add	x0, x0, #0x910
    48007fc0:	9400202a 	bl	48010068 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
    48007fc4:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48007fc8:	9117a000 	add	x0, x0, #0x5e8
    48007fcc:	f9400000 	ldr	x0, [x0]
    48007fd0:	f100001f 	cmp	x0, #0x0
    48007fd4:	540000c0 	b.eq	48007fec <rt_mb_urgent+0x8c>  // b.none
    48007fd8:	d0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48007fdc:	9117a000 	add	x0, x0, #0x5e8
    48007fe0:	f9400001 	ldr	x1, [x0]
    48007fe4:	f94017e0 	ldr	x0, [sp, #40]
    48007fe8:	d63f0020 	blr	x1

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48007fec:	97fff110 	bl	4800442c <rt_hw_interrupt_disable>
    48007ff0:	aa0003f3 	mov	x19, x0

    if (mb->entry == mb->size)
    48007ff4:	f94017e0 	ldr	x0, [sp, #40]
    48007ff8:	79407401 	ldrh	w1, [x0, #58]
    48007ffc:	f94017e0 	ldr	x0, [sp, #40]
    48008000:	79407000 	ldrh	w0, [x0, #56]
    48008004:	6b00003f 	cmp	w1, w0
    48008008:	540000a1 	b.ne	4800801c <rt_mb_urgent+0xbc>  // b.any
    {
        rt_hw_interrupt_enable(temp);
    4800800c:	aa1303e0 	mov	x0, x19
    48008010:	97fff10b 	bl	4800443c <rt_hw_interrupt_enable>
        return -RT_EFULL;
    48008014:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48008018:	14000031 	b	480080dc <rt_mb_urgent+0x17c>
    }

    /* rewind to the previous position */
    if (mb->out_offset > 0)
    4800801c:	f94017e0 	ldr	x0, [sp, #40]
    48008020:	79407c00 	ldrh	w0, [x0, #62]
    48008024:	7100001f 	cmp	w0, #0x0
    48008028:	54000100 	b.eq	48008048 <rt_mb_urgent+0xe8>  // b.none
    {
        mb->out_offset --;
    4800802c:	f94017e0 	ldr	x0, [sp, #40]
    48008030:	79407c00 	ldrh	w0, [x0, #62]
    48008034:	51000400 	sub	w0, w0, #0x1
    48008038:	12003c01 	and	w1, w0, #0xffff
    4800803c:	f94017e0 	ldr	x0, [sp, #40]
    48008040:	79007c01 	strh	w1, [x0, #62]
    48008044:	14000007 	b	48008060 <rt_mb_urgent+0x100>
    }
    else
    {
        mb->out_offset = mb->size - 1;
    48008048:	f94017e0 	ldr	x0, [sp, #40]
    4800804c:	79407000 	ldrh	w0, [x0, #56]
    48008050:	51000400 	sub	w0, w0, #0x1
    48008054:	12003c01 	and	w1, w0, #0xffff
    48008058:	f94017e0 	ldr	x0, [sp, #40]
    4800805c:	79007c01 	strh	w1, [x0, #62]
    }

    /* set ptr */
    mb->msg_pool[mb->out_offset] = value;
    48008060:	f94017e0 	ldr	x0, [sp, #40]
    48008064:	f9401801 	ldr	x1, [x0, #48]
    48008068:	f94017e0 	ldr	x0, [sp, #40]
    4800806c:	79407c00 	ldrh	w0, [x0, #62]
    48008070:	92403c00 	and	x0, x0, #0xffff
    48008074:	d37df000 	lsl	x0, x0, #3
    48008078:	8b000020 	add	x0, x1, x0
    4800807c:	f94013e1 	ldr	x1, [sp, #32]
    48008080:	f9000001 	str	x1, [x0]

    /* increase message entry */
    mb->entry ++;
    48008084:	f94017e0 	ldr	x0, [sp, #40]
    48008088:	79407400 	ldrh	w0, [x0, #58]
    4800808c:	11000400 	add	w0, w0, #0x1
    48008090:	12003c01 	and	w1, w0, #0xffff
    48008094:	f94017e0 	ldr	x0, [sp, #40]
    48008098:	79007401 	strh	w1, [x0, #58]

    /* resume suspended thread */
    if (!rt_list_isempty(&mb->parent.suspend_thread))
    4800809c:	f94017e0 	ldr	x0, [sp, #40]
    480080a0:	91008000 	add	x0, x0, #0x20
    480080a4:	97fff6b9 	bl	48005b88 <rt_list_isempty>
    480080a8:	7100001f 	cmp	w0, #0x0
    480080ac:	54000121 	b.ne	480080d0 <rt_mb_urgent+0x170>  // b.any
    {
        _ipc_list_resume(&(mb->parent.suspend_thread));
    480080b0:	f94017e0 	ldr	x0, [sp, #40]
    480080b4:	91008000 	add	x0, x0, #0x20
    480080b8:	97fff70b 	bl	48005ce4 <_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    480080bc:	aa1303e0 	mov	x0, x19
    480080c0:	97fff0df 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    480080c4:	940014b2 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    480080c8:	d2800000 	mov	x0, #0x0                   	// #0
    480080cc:	14000004 	b	480080dc <rt_mb_urgent+0x17c>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    480080d0:	aa1303e0 	mov	x0, x19
    480080d4:	97fff0da 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    480080d8:	d2800000 	mov	x0, #0x0                   	// #0
}
    480080dc:	f9400bf3 	ldr	x19, [sp, #16]
    480080e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480080e4:	d65f03c0 	ret

00000000480080e8 <rt_mb_recv>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the mailbox release failed.
 */
rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout)
{
    480080e8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    480080ec:	910003fd 	mov	x29, sp
    480080f0:	f9000bf3 	str	x19, [sp, #16]
    480080f4:	f9001fe0 	str	x0, [sp, #56]
    480080f8:	f9001be1 	str	x1, [sp, #48]
    480080fc:	b9002fe2 	str	w2, [sp, #44]
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
    48008100:	f9401fe0 	ldr	x0, [sp, #56]
    48008104:	f100001f 	cmp	x0, #0x0
    48008108:	540000e1 	b.ne	48008124 <rt_mb_recv+0x3c>  // b.any
    4800810c:	d28116e2 	mov	x2, #0x8b7                 	// #2231
    48008110:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008114:	91326001 	add	x1, x0, #0xc98
    48008118:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800811c:	91240000 	add	x0, x0, #0x900
    48008120:	94001fd2 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
    48008124:	f9401fe0 	ldr	x0, [sp, #56]
    48008128:	940017e2 	bl	4800e0b0 <rt_object_get_type>
    4800812c:	12001c00 	and	w0, w0, #0xff
    48008130:	7100141f 	cmp	w0, #0x5
    48008134:	540000e0 	b.eq	48008150 <rt_mb_recv+0x68>  // b.none
    48008138:	d2811702 	mov	x2, #0x8b8                 	// #2232
    4800813c:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008140:	91326001 	add	x1, x0, #0xc98
    48008144:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008148:	91244000 	add	x0, x0, #0x910
    4800814c:	94001fc7 	bl	48010068 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
    48008150:	b9005fff 	str	wzr, [sp, #92]
    /* get current thread */
    thread = rt_thread_self();
    48008154:	94000e92 	bl	4800bb9c <rt_thread_self>
    48008158:	f9002be0 	str	x0, [sp, #80]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
    4800815c:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008160:	91176000 	add	x0, x0, #0x5d8
    48008164:	f9400000 	ldr	x0, [x0]
    48008168:	f100001f 	cmp	x0, #0x0
    4800816c:	540000c0 	b.eq	48008184 <rt_mb_recv+0x9c>  // b.none
    48008170:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008174:	91176000 	add	x0, x0, #0x5d8
    48008178:	f9400001 	ldr	x1, [x0]
    4800817c:	f9401fe0 	ldr	x0, [sp, #56]
    48008180:	d63f0020 	blr	x1

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48008184:	97fff0aa 	bl	4800442c <rt_hw_interrupt_disable>
    48008188:	aa0003f3 	mov	x19, x0

    /* for non-blocking call */
    if (mb->entry == 0 && timeout == 0)
    4800818c:	f9401fe0 	ldr	x0, [sp, #56]
    48008190:	79407400 	ldrh	w0, [x0, #58]
    48008194:	7100001f 	cmp	w0, #0x0
    48008198:	54000d81 	b.ne	48008348 <rt_mb_recv+0x260>  // b.any
    4800819c:	b9402fe0 	ldr	w0, [sp, #44]
    480081a0:	7100001f 	cmp	w0, #0x0
    480081a4:	54000d21 	b.ne	48008348 <rt_mb_recv+0x260>  // b.any
    {
        rt_hw_interrupt_enable(temp);
    480081a8:	aa1303e0 	mov	x0, x19
    480081ac:	97fff0a4 	bl	4800443c <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
    480081b0:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    480081b4:	140000af 	b	48008470 <rt_mb_recv+0x388>

    /* mailbox is empty */
    while (mb->entry == 0)
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
    480081b8:	f9402be0 	ldr	x0, [sp, #80]
    480081bc:	f9002c1f 	str	xzr, [x0, #88]

        /* no waiting, return timeout */
        if (timeout == 0)
    480081c0:	b9402fe0 	ldr	w0, [sp, #44]
    480081c4:	7100001f 	cmp	w0, #0x0
    480081c8:	54000101 	b.ne	480081e8 <rt_mb_recv+0x100>  // b.any
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
    480081cc:	aa1303e0 	mov	x0, x19
    480081d0:	97fff09b 	bl	4800443c <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
    480081d4:	f9402be0 	ldr	x0, [sp, #80]
    480081d8:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    480081dc:	f9002c01 	str	x1, [x0, #88]

            return -RT_ETIMEOUT;
    480081e0:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    480081e4:	140000a3 	b	48008470 <rt_mb_recv+0x388>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
    480081e8:	97fff091 	bl	4800442c <rt_hw_interrupt_disable>
    480081ec:	f90027e0 	str	x0, [sp, #72]
    480081f0:	94000e6b 	bl	4800bb9c <rt_thread_self>
    480081f4:	f100001f 	cmp	x0, #0x0
    480081f8:	54000181 	b.ne	48008228 <rt_mb_recv+0x140>  // b.any
    480081fc:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008200:	91326001 	add	x1, x0, #0xc98
    48008204:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008208:	911c6000 	add	x0, x0, #0x718
    4800820c:	94001ec9 	bl	4800fd30 <rt_kprintf>
    48008210:	d2811ba2 	mov	x2, #0x8dd                 	// #2269
    48008214:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008218:	91326001 	add	x1, x0, #0xc98
    4800821c:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008220:	91172000 	add	x0, x0, #0x5c8
    48008224:	94001f91 	bl	48010068 <rt_assert_handler>
    48008228:	97fff081 	bl	4800442c <rt_hw_interrupt_disable>
    4800822c:	f90023e0 	str	x0, [sp, #64]
    48008230:	94000538 	bl	48009710 <rt_interrupt_get_nest>
    48008234:	12001c00 	and	w0, w0, #0xff
    48008238:	7100001f 	cmp	w0, #0x0
    4800823c:	54000180 	b.eq	4800826c <rt_mb_recv+0x184>  // b.none
    48008240:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008244:	91326001 	add	x1, x0, #0xc98
    48008248:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800824c:	911ac000 	add	x0, x0, #0x6b0
    48008250:	94001eb8 	bl	4800fd30 <rt_kprintf>
    48008254:	d2811ba2 	mov	x2, #0x8dd                 	// #2269
    48008258:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800825c:	91326001 	add	x1, x0, #0xc98
    48008260:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008264:	91172000 	add	x0, x0, #0x5c8
    48008268:	94001f80 	bl	48010068 <rt_assert_handler>
    4800826c:	f94023e0 	ldr	x0, [sp, #64]
    48008270:	97fff073 	bl	4800443c <rt_hw_interrupt_enable>
    48008274:	f94027e0 	ldr	x0, [sp, #72]
    48008278:	97fff071 	bl	4800443c <rt_hw_interrupt_enable>
        /* suspend current thread */
        _ipc_list_suspend(&(mb->parent.suspend_thread),
    4800827c:	f9401fe0 	ldr	x0, [sp, #56]
    48008280:	91008003 	add	x3, x0, #0x20
    48008284:	f9401fe0 	ldr	x0, [sp, #56]
    48008288:	39402400 	ldrb	w0, [x0, #9]
    4800828c:	2a0003e2 	mov	w2, w0
    48008290:	f9402be1 	ldr	x1, [sp, #80]
    48008294:	aa0303e0 	mov	x0, x3
    48008298:	97fff64f 	bl	48005bd4 <_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
    4800829c:	b9402fe0 	ldr	w0, [sp, #44]
    480082a0:	7100001f 	cmp	w0, #0x0
    480082a4:	5400018d 	b.le	480082d4 <rt_mb_recv+0x1ec>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
    480082a8:	94001f91 	bl	480100ec <rt_tick_get>
    480082ac:	b9005fe0 	str	w0, [sp, #92]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
    480082b0:	f9402be0 	ldr	x0, [sp, #80]
    480082b4:	91020000 	add	x0, x0, #0x80
    480082b8:	9100b3e1 	add	x1, sp, #0x2c
    480082bc:	aa0103e2 	mov	x2, x1
    480082c0:	52800001 	mov	w1, #0x0                   	// #0
    480082c4:	94000b97 	bl	4800b120 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
    480082c8:	f9402be0 	ldr	x0, [sp, #80]
    480082cc:	91020000 	add	x0, x0, #0x80
    480082d0:	94000a6d 	bl	4800ac84 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    480082d4:	aa1303e0 	mov	x0, x19
    480082d8:	97fff059 	bl	4800443c <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
    480082dc:	9400142c 	bl	4800d38c <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
    480082e0:	f9402be0 	ldr	x0, [sp, #80]
    480082e4:	f9402c00 	ldr	x0, [x0, #88]
    480082e8:	f100001f 	cmp	x0, #0x0
    480082ec:	54000080 	b.eq	480082fc <rt_mb_recv+0x214>  // b.none
        {
            /* return error */
            return thread->error;
    480082f0:	f9402be0 	ldr	x0, [sp, #80]
    480082f4:	f9402c00 	ldr	x0, [x0, #88]
    480082f8:	1400005e 	b	48008470 <rt_mb_recv+0x388>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
    480082fc:	97fff04c 	bl	4800442c <rt_hw_interrupt_disable>
    48008300:	aa0003f3 	mov	x19, x0

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
    48008304:	b9402fe0 	ldr	w0, [sp, #44]
    48008308:	7100001f 	cmp	w0, #0x0
    4800830c:	540001ed 	b.le	48008348 <rt_mb_recv+0x260>
        {
            tick_delta = rt_tick_get() - tick_delta;
    48008310:	94001f77 	bl	480100ec <rt_tick_get>
    48008314:	2a0003e1 	mov	w1, w0
    48008318:	b9405fe0 	ldr	w0, [sp, #92]
    4800831c:	4b000020 	sub	w0, w1, w0
    48008320:	b9005fe0 	str	w0, [sp, #92]
            timeout -= tick_delta;
    48008324:	b9402fe0 	ldr	w0, [sp, #44]
    48008328:	2a0003e1 	mov	w1, w0
    4800832c:	b9405fe0 	ldr	w0, [sp, #92]
    48008330:	4b000020 	sub	w0, w1, w0
    48008334:	b9002fe0 	str	w0, [sp, #44]
            if (timeout < 0)
    48008338:	b9402fe0 	ldr	w0, [sp, #44]
    4800833c:	7100001f 	cmp	w0, #0x0
    48008340:	5400004a 	b.ge	48008348 <rt_mb_recv+0x260>  // b.tcont
                timeout = 0;
    48008344:	b9002fff 	str	wzr, [sp, #44]
    while (mb->entry == 0)
    48008348:	f9401fe0 	ldr	x0, [sp, #56]
    4800834c:	79407400 	ldrh	w0, [x0, #58]
    48008350:	7100001f 	cmp	w0, #0x0
    48008354:	54fff320 	b.eq	480081b8 <rt_mb_recv+0xd0>  // b.none
        }
    }

    /* fill ptr */
    *value = mb->msg_pool[mb->out_offset];
    48008358:	f9401fe0 	ldr	x0, [sp, #56]
    4800835c:	f9401801 	ldr	x1, [x0, #48]
    48008360:	f9401fe0 	ldr	x0, [sp, #56]
    48008364:	79407c00 	ldrh	w0, [x0, #62]
    48008368:	92403c00 	and	x0, x0, #0xffff
    4800836c:	d37df000 	lsl	x0, x0, #3
    48008370:	8b000020 	add	x0, x1, x0
    48008374:	f9400001 	ldr	x1, [x0]
    48008378:	f9401be0 	ldr	x0, [sp, #48]
    4800837c:	f9000001 	str	x1, [x0]

    /* increase output offset */
    ++ mb->out_offset;
    48008380:	f9401fe0 	ldr	x0, [sp, #56]
    48008384:	79407c00 	ldrh	w0, [x0, #62]
    48008388:	11000400 	add	w0, w0, #0x1
    4800838c:	12003c01 	and	w1, w0, #0xffff
    48008390:	f9401fe0 	ldr	x0, [sp, #56]
    48008394:	79007c01 	strh	w1, [x0, #62]
    if (mb->out_offset >= mb->size)
    48008398:	f9401fe0 	ldr	x0, [sp, #56]
    4800839c:	79407c01 	ldrh	w1, [x0, #62]
    480083a0:	f9401fe0 	ldr	x0, [sp, #56]
    480083a4:	79407000 	ldrh	w0, [x0, #56]
    480083a8:	6b00003f 	cmp	w1, w0
    480083ac:	54000063 	b.cc	480083b8 <rt_mb_recv+0x2d0>  // b.lo, b.ul, b.last
        mb->out_offset = 0;
    480083b0:	f9401fe0 	ldr	x0, [sp, #56]
    480083b4:	79007c1f 	strh	wzr, [x0, #62]

    /* decrease message entry */
    if(mb->entry > 0)
    480083b8:	f9401fe0 	ldr	x0, [sp, #56]
    480083bc:	79407400 	ldrh	w0, [x0, #58]
    480083c0:	7100001f 	cmp	w0, #0x0
    480083c4:	540000e0 	b.eq	480083e0 <rt_mb_recv+0x2f8>  // b.none
    {
        mb->entry --;
    480083c8:	f9401fe0 	ldr	x0, [sp, #56]
    480083cc:	79407400 	ldrh	w0, [x0, #58]
    480083d0:	51000400 	sub	w0, w0, #0x1
    480083d4:	12003c01 	and	w1, w0, #0xffff
    480083d8:	f9401fe0 	ldr	x0, [sp, #56]
    480083dc:	79007401 	strh	w1, [x0, #58]
    }

    /* resume suspended thread */
    if (!rt_list_isempty(&(mb->suspend_sender_thread)))
    480083e0:	f9401fe0 	ldr	x0, [sp, #56]
    480083e4:	91010000 	add	x0, x0, #0x40
    480083e8:	97fff5e8 	bl	48005b88 <rt_list_isempty>
    480083ec:	7100001f 	cmp	w0, #0x0
    480083f0:	54000261 	b.ne	4800843c <rt_mb_recv+0x354>  // b.any
    {
        _ipc_list_resume(&(mb->suspend_sender_thread));
    480083f4:	f9401fe0 	ldr	x0, [sp, #56]
    480083f8:	91010000 	add	x0, x0, #0x40
    480083fc:	97fff63a 	bl	48005ce4 <_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48008400:	aa1303e0 	mov	x0, x19
    48008404:	97fff00e 	bl	4800443c <rt_hw_interrupt_enable>

        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
    48008408:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800840c:	91178000 	add	x0, x0, #0x5e0
    48008410:	f9400000 	ldr	x0, [x0]
    48008414:	f100001f 	cmp	x0, #0x0
    48008418:	540000c0 	b.eq	48008430 <rt_mb_recv+0x348>  // b.none
    4800841c:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008420:	91178000 	add	x0, x0, #0x5e0
    48008424:	f9400001 	ldr	x1, [x0]
    48008428:	f9401fe0 	ldr	x0, [sp, #56]
    4800842c:	d63f0020 	blr	x1

        rt_schedule();
    48008430:	940013d7 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    48008434:	d2800000 	mov	x0, #0x0                   	// #0
    48008438:	1400000e 	b	48008470 <rt_mb_recv+0x388>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    4800843c:	aa1303e0 	mov	x0, x19
    48008440:	97ffefff 	bl	4800443c <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
    48008444:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008448:	91178000 	add	x0, x0, #0x5e0
    4800844c:	f9400000 	ldr	x0, [x0]
    48008450:	f100001f 	cmp	x0, #0x0
    48008454:	540000c0 	b.eq	4800846c <rt_mb_recv+0x384>  // b.none
    48008458:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800845c:	91178000 	add	x0, x0, #0x5e0
    48008460:	f9400001 	ldr	x1, [x0]
    48008464:	f9401fe0 	ldr	x0, [sp, #56]
    48008468:	d63f0020 	blr	x1

    return RT_EOK;
    4800846c:	d2800000 	mov	x0, #0x0                   	// #0
}
    48008470:	f9400bf3 	ldr	x19, [sp, #16]
    48008474:	a8c67bfd 	ldp	x29, x30, [sp], #96
    48008478:	d65f03c0 	ret

000000004800847c <rt_mb_control>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that this function failed to execute.
 */
rt_err_t rt_mb_control(rt_mailbox_t mb, int cmd, void *arg)
{
    4800847c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48008480:	910003fd 	mov	x29, sp
    48008484:	f90017e0 	str	x0, [sp, #40]
    48008488:	b90027e1 	str	w1, [sp, #36]
    4800848c:	f9000fe2 	str	x2, [sp, #24]
    rt_ubase_t level;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
    48008490:	f94017e0 	ldr	x0, [sp, #40]
    48008494:	f100001f 	cmp	x0, #0x0
    48008498:	540000e1 	b.ne	480084b4 <rt_mb_control+0x38>  // b.any
    4800849c:	d28128e2 	mov	x2, #0x947                 	// #2375
    480084a0:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480084a4:	9132a001 	add	x1, x0, #0xca8
    480084a8:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480084ac:	91240000 	add	x0, x0, #0x900
    480084b0:	94001eee 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
    480084b4:	f94017e0 	ldr	x0, [sp, #40]
    480084b8:	940016fe 	bl	4800e0b0 <rt_object_get_type>
    480084bc:	12001c00 	and	w0, w0, #0xff
    480084c0:	7100141f 	cmp	w0, #0x5
    480084c4:	540000e0 	b.eq	480084e0 <rt_mb_control+0x64>  // b.none
    480084c8:	d2812902 	mov	x2, #0x948                 	// #2376
    480084cc:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480084d0:	9132a001 	add	x1, x0, #0xca8
    480084d4:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480084d8:	91244000 	add	x0, x0, #0x910
    480084dc:	94001ee3 	bl	48010068 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
    480084e0:	b94027e0 	ldr	w0, [sp, #36]
    480084e4:	7100041f 	cmp	w0, #0x1
    480084e8:	54000281 	b.ne	48008538 <rt_mb_control+0xbc>  // b.any
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    480084ec:	97ffefd0 	bl	4800442c <rt_hw_interrupt_disable>
    480084f0:	f9001fe0 	str	x0, [sp, #56]

        /* resume all waiting thread */
        _ipc_list_resume_all(&(mb->parent.suspend_thread));
    480084f4:	f94017e0 	ldr	x0, [sp, #40]
    480084f8:	91008000 	add	x0, x0, #0x20
    480084fc:	97fff606 	bl	48005d14 <_ipc_list_resume_all>
        /* also resume all mailbox private suspended thread */
        _ipc_list_resume_all(&(mb->suspend_sender_thread));
    48008500:	f94017e0 	ldr	x0, [sp, #40]
    48008504:	91010000 	add	x0, x0, #0x40
    48008508:	97fff603 	bl	48005d14 <_ipc_list_resume_all>

        /* re-init mailbox */
        mb->entry      = 0;
    4800850c:	f94017e0 	ldr	x0, [sp, #40]
    48008510:	7900741f 	strh	wzr, [x0, #58]
        mb->in_offset  = 0;
    48008514:	f94017e0 	ldr	x0, [sp, #40]
    48008518:	7900781f 	strh	wzr, [x0, #60]
        mb->out_offset = 0;
    4800851c:	f94017e0 	ldr	x0, [sp, #40]
    48008520:	79007c1f 	strh	wzr, [x0, #62]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    48008524:	f9401fe0 	ldr	x0, [sp, #56]
    48008528:	97ffefc5 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    4800852c:	94001398 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    48008530:	d2800000 	mov	x0, #0x0                   	// #0
    48008534:	14000002 	b	4800853c <rt_mb_control+0xc0>
    }

    return -RT_ERROR;
    48008538:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
    4800853c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48008540:	d65f03c0 	ret

0000000048008544 <rt_mq_init>:
                    const char *name,
                    void       *msgpool,
                    rt_size_t   msg_size,
                    rt_size_t   pool_size,
                    rt_uint8_t  flag)
{
    48008544:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    48008548:	910003fd 	mov	x29, sp
    4800854c:	f9000bf3 	str	x19, [sp, #16]
    48008550:	f90027e0 	str	x0, [sp, #72]
    48008554:	f90023e1 	str	x1, [sp, #64]
    48008558:	f9001fe2 	str	x2, [sp, #56]
    4800855c:	f9001be3 	str	x3, [sp, #48]
    48008560:	f90017e4 	str	x4, [sp, #40]
    48008564:	39009fe5 	strb	w5, [sp, #39]
    struct rt_mq_message *head;
    register rt_base_t temp;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
    48008568:	f94027e0 	ldr	x0, [sp, #72]
    4800856c:	f100001f 	cmp	x0, #0x0
    48008570:	540000e1 	b.ne	4800858c <rt_mq_init+0x48>  // b.any
    48008574:	d2813542 	mov	x2, #0x9aa                 	// #2474
    48008578:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800857c:	9132e001 	add	x1, x0, #0xcb8
    48008580:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008584:	91272000 	add	x0, x0, #0x9c8
    48008588:	94001eb8 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    4800858c:	39409fe0 	ldrb	w0, [sp, #39]
    48008590:	7100001f 	cmp	w0, #0x0
    48008594:	54000140 	b.eq	480085bc <rt_mq_init+0x78>  // b.none
    48008598:	39409fe0 	ldrb	w0, [sp, #39]
    4800859c:	7100041f 	cmp	w0, #0x1
    480085a0:	540000e0 	b.eq	480085bc <rt_mq_init+0x78>  // b.none
    480085a4:	d2813562 	mov	x2, #0x9ab                 	// #2475
    480085a8:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480085ac:	9132e001 	add	x1, x0, #0xcb8
    480085b0:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480085b4:	9117e000 	add	x0, x0, #0x5f8
    480085b8:	94001eac 	bl	48010068 <rt_assert_handler>

    /* initialize object */
    rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
    480085bc:	f94027e0 	ldr	x0, [sp, #72]
    480085c0:	f94023e2 	ldr	x2, [sp, #64]
    480085c4:	528000c1 	mov	w1, #0x6                   	// #6
    480085c8:	940015a5 	bl	4800dc5c <rt_object_init>

    /* set parent flag */
    mq->parent.parent.flag = flag;
    480085cc:	f94027e0 	ldr	x0, [sp, #72]
    480085d0:	39409fe1 	ldrb	w1, [sp, #39]
    480085d4:	39002401 	strb	w1, [x0, #9]

    /* initialize ipc object */
    _ipc_object_init(&(mq->parent));
    480085d8:	f94027e0 	ldr	x0, [sp, #72]
    480085dc:	97fff575 	bl	48005bb0 <_ipc_object_init>

    /* set message pool */
    mq->msg_pool = msgpool;
    480085e0:	f94027e0 	ldr	x0, [sp, #72]
    480085e4:	f9401fe1 	ldr	x1, [sp, #56]
    480085e8:	f9001801 	str	x1, [x0, #48]

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
    480085ec:	f9401be0 	ldr	x0, [sp, #48]
    480085f0:	12003c00 	and	w0, w0, #0xffff
    480085f4:	11000c00 	add	w0, w0, #0x3
    480085f8:	12003c00 	and	w0, w0, #0xffff
    480085fc:	121e7400 	and	w0, w0, #0xfffffffc
    48008600:	12003c01 	and	w1, w0, #0xffff
    48008604:	f94027e0 	ldr	x0, [sp, #72]
    48008608:	79007001 	strh	w1, [x0, #56]
    mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
    4800860c:	f94027e0 	ldr	x0, [sp, #72]
    48008610:	79407000 	ldrh	w0, [x0, #56]
    48008614:	92403c00 	and	x0, x0, #0xffff
    48008618:	91002000 	add	x0, x0, #0x8
    4800861c:	f94017e1 	ldr	x1, [sp, #40]
    48008620:	9ac00820 	udiv	x0, x1, x0
    48008624:	12003c01 	and	w1, w0, #0xffff
    48008628:	f94027e0 	ldr	x0, [sp, #72]
    4800862c:	79007401 	strh	w1, [x0, #58]

    /* initialize message list */
    mq->msg_queue_head = RT_NULL;
    48008630:	f94027e0 	ldr	x0, [sp, #72]
    48008634:	f900201f 	str	xzr, [x0, #64]
    mq->msg_queue_tail = RT_NULL;
    48008638:	f94027e0 	ldr	x0, [sp, #72]
    4800863c:	f900241f 	str	xzr, [x0, #72]

    /* initialize message empty list */
    mq->msg_queue_free = RT_NULL;
    48008640:	f94027e0 	ldr	x0, [sp, #72]
    48008644:	f900281f 	str	xzr, [x0, #80]
    for (temp = 0; temp < mq->max_msgs; temp ++)
    48008648:	d2800013 	mov	x19, #0x0                   	// #0
    4800864c:	14000013 	b	48008698 <rt_mq_init+0x154>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
    48008650:	f94027e0 	ldr	x0, [sp, #72]
    48008654:	f9401801 	ldr	x1, [x0, #48]
                                        temp * (mq->msg_size + sizeof(struct rt_mq_message)));
    48008658:	f94027e0 	ldr	x0, [sp, #72]
    4800865c:	79407000 	ldrh	w0, [x0, #56]
    48008660:	92403c00 	and	x0, x0, #0xffff
    48008664:	91002000 	add	x0, x0, #0x8
    48008668:	aa1303e2 	mov	x2, x19
    4800866c:	9b027c00 	mul	x0, x0, x2
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
    48008670:	8b000020 	add	x0, x1, x0
    48008674:	f9002fe0 	str	x0, [sp, #88]
        head->next = (struct rt_mq_message *)mq->msg_queue_free;
    48008678:	f94027e0 	ldr	x0, [sp, #72]
    4800867c:	f9402801 	ldr	x1, [x0, #80]
    48008680:	f9402fe0 	ldr	x0, [sp, #88]
    48008684:	f9000001 	str	x1, [x0]
        mq->msg_queue_free = head;
    48008688:	f94027e0 	ldr	x0, [sp, #72]
    4800868c:	f9402fe1 	ldr	x1, [sp, #88]
    48008690:	f9002801 	str	x1, [x0, #80]
    for (temp = 0; temp < mq->max_msgs; temp ++)
    48008694:	91000673 	add	x19, x19, #0x1
    48008698:	f94027e0 	ldr	x0, [sp, #72]
    4800869c:	79407400 	ldrh	w0, [x0, #58]
    480086a0:	92403c00 	and	x0, x0, #0xffff
    480086a4:	eb00027f 	cmp	x19, x0
    480086a8:	54fffd4b 	b.lt	48008650 <rt_mq_init+0x10c>  // b.tstop
    }

    /* the initial entry is zero */
    mq->entry = 0;
    480086ac:	f94027e0 	ldr	x0, [sp, #72]
    480086b0:	7900781f 	strh	wzr, [x0, #60]

    /* initialize an additional list of sender suspend thread */
    rt_list_init(&(mq->suspend_sender_thread));
    480086b4:	f94027e0 	ldr	x0, [sp, #72]
    480086b8:	91016000 	add	x0, x0, #0x58
    480086bc:	97fff513 	bl	48005b08 <rt_list_init>

    return RT_EOK;
    480086c0:	d2800000 	mov	x0, #0x0                   	// #0
}
    480086c4:	f9400bf3 	ldr	x19, [sp, #16]
    480086c8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    480086cc:	d65f03c0 	ret

00000000480086d0 <rt_mq_detach>:
 * @warning  This function can ONLY detach a static messagequeue initialized by the rt_mq_init() function.
 *           If the messagequeue is created by the rt_mq_create() function, you MUST NOT USE this function to detach it,
 *           and ONLY USE the rt_mq_delete() function to complete the deletion.
 */
rt_err_t rt_mq_detach(rt_mq_t mq)
{
    480086d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480086d4:	910003fd 	mov	x29, sp
    480086d8:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
    480086dc:	f9400fe0 	ldr	x0, [sp, #24]
    480086e0:	f100001f 	cmp	x0, #0x0
    480086e4:	540000e1 	b.ne	48008700 <rt_mq_detach+0x30>  // b.any
    480086e8:	d2813d62 	mov	x2, #0x9eb                 	// #2539
    480086ec:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480086f0:	91332001 	add	x1, x0, #0xcc8
    480086f4:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480086f8:	91272000 	add	x0, x0, #0x9c8
    480086fc:	94001e5b 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
    48008700:	f9400fe0 	ldr	x0, [sp, #24]
    48008704:	9400166b 	bl	4800e0b0 <rt_object_get_type>
    48008708:	12001c00 	and	w0, w0, #0xff
    4800870c:	7100181f 	cmp	w0, #0x6
    48008710:	540000e0 	b.eq	4800872c <rt_mq_detach+0x5c>  // b.none
    48008714:	d2813d82 	mov	x2, #0x9ec                 	// #2540
    48008718:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800871c:	91332001 	add	x1, x0, #0xcc8
    48008720:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008724:	91276000 	add	x0, x0, #0x9d8
    48008728:	94001e50 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&mq->parent.parent));
    4800872c:	f9400fe0 	ldr	x0, [sp, #24]
    48008730:	9400164a 	bl	4800e058 <rt_object_is_systemobject>
    48008734:	7100001f 	cmp	w0, #0x0
    48008738:	540000e1 	b.ne	48008754 <rt_mq_detach+0x84>  // b.any
    4800873c:	d2813da2 	mov	x2, #0x9ed                 	// #2541
    48008740:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008744:	91332001 	add	x1, x0, #0xcc8
    48008748:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800874c:	91288000 	add	x0, x0, #0xa20
    48008750:	94001e46 	bl	48010068 <rt_assert_handler>

    /* resume all suspended thread */
    _ipc_list_resume_all(&mq->parent.suspend_thread);
    48008754:	f9400fe0 	ldr	x0, [sp, #24]
    48008758:	91008000 	add	x0, x0, #0x20
    4800875c:	97fff56e 	bl	48005d14 <_ipc_list_resume_all>
    /* also resume all message queue private suspended thread */
    _ipc_list_resume_all(&(mq->suspend_sender_thread));
    48008760:	f9400fe0 	ldr	x0, [sp, #24]
    48008764:	91016000 	add	x0, x0, #0x58
    48008768:	97fff56b 	bl	48005d14 <_ipc_list_resume_all>

    /* detach message queue object */
    rt_object_detach(&(mq->parent.parent));
    4800876c:	f9400fe0 	ldr	x0, [sp, #24]
    48008770:	9400158f 	bl	4800ddac <rt_object_detach>

    return RT_EOK;
    48008774:	d2800000 	mov	x0, #0x0                   	// #0
}
    48008778:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800877c:	d65f03c0 	ret

0000000048008780 <rt_mq_create>:
 */
rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
    48008780:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    48008784:	910003fd 	mov	x29, sp
    48008788:	f9000bf3 	str	x19, [sp, #16]
    4800878c:	f9001fe0 	str	x0, [sp, #56]
    48008790:	f9001be1 	str	x1, [sp, #48]
    48008794:	f90017e2 	str	x2, [sp, #40]
    48008798:	39009fe3 	strb	w3, [sp, #39]
    struct rt_messagequeue *mq;
    struct rt_mq_message *head;
    register rt_base_t temp;

    RT_ASSERT((flag == RT_IPC_FLAG_FIFO) || (flag == RT_IPC_FLAG_PRIO));
    4800879c:	39409fe0 	ldrb	w0, [sp, #39]
    480087a0:	7100001f 	cmp	w0, #0x0
    480087a4:	54000140 	b.eq	480087cc <rt_mq_create+0x4c>  // b.none
    480087a8:	39409fe0 	ldrb	w0, [sp, #39]
    480087ac:	7100041f 	cmp	w0, #0x1
    480087b0:	540000e0 	b.eq	480087cc <rt_mq_create+0x4c>  // b.none
    480087b4:	d28144a2 	mov	x2, #0xa25                 	// #2597
    480087b8:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480087bc:	91336001 	add	x1, x0, #0xcd8
    480087c0:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480087c4:	9117e000 	add	x0, x0, #0x5f8
    480087c8:	94001e28 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    480087cc:	97ffef18 	bl	4800442c <rt_hw_interrupt_disable>
    480087d0:	f9002fe0 	str	x0, [sp, #88]
    480087d4:	940003cf 	bl	48009710 <rt_interrupt_get_nest>
    480087d8:	12001c00 	and	w0, w0, #0xff
    480087dc:	7100001f 	cmp	w0, #0x0
    480087e0:	54000180 	b.eq	48008810 <rt_mq_create+0x90>  // b.none
    480087e4:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480087e8:	91336001 	add	x1, x0, #0xcd8
    480087ec:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480087f0:	911ac000 	add	x0, x0, #0x6b0
    480087f4:	94001d4f 	bl	4800fd30 <rt_kprintf>
    480087f8:	d28144e2 	mov	x2, #0xa27                 	// #2599
    480087fc:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008800:	91336001 	add	x1, x0, #0xcd8
    48008804:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008808:	91172000 	add	x0, x0, #0x5c8
    4800880c:	94001e17 	bl	48010068 <rt_assert_handler>
    48008810:	f9402fe0 	ldr	x0, [sp, #88]
    48008814:	97ffef0a 	bl	4800443c <rt_hw_interrupt_enable>

    /* allocate object */
    mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
    48008818:	f9401fe1 	ldr	x1, [sp, #56]
    4800881c:	528000c0 	mov	w0, #0x6                   	// #6
    48008820:	94001587 	bl	4800de3c <rt_object_allocate>
    48008824:	f9002be0 	str	x0, [sp, #80]
    if (mq == RT_NULL)
    48008828:	f9402be0 	ldr	x0, [sp, #80]
    4800882c:	f100001f 	cmp	x0, #0x0
    48008830:	54000061 	b.ne	4800883c <rt_mq_create+0xbc>  // b.any
        return mq;
    48008834:	f9402be0 	ldr	x0, [sp, #80]
    48008838:	1400004b 	b	48008964 <rt_mq_create+0x1e4>

    /* set parent */
    mq->parent.parent.flag = flag;
    4800883c:	f9402be0 	ldr	x0, [sp, #80]
    48008840:	39409fe1 	ldrb	w1, [sp, #39]
    48008844:	39002401 	strb	w1, [x0, #9]

    /* initialize ipc object */
    _ipc_object_init(&(mq->parent));
    48008848:	f9402be0 	ldr	x0, [sp, #80]
    4800884c:	97fff4d9 	bl	48005bb0 <_ipc_object_init>

    /* initialize message queue */

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
    48008850:	f9401be0 	ldr	x0, [sp, #48]
    48008854:	12003c00 	and	w0, w0, #0xffff
    48008858:	11000c00 	add	w0, w0, #0x3
    4800885c:	12003c00 	and	w0, w0, #0xffff
    48008860:	121e7400 	and	w0, w0, #0xfffffffc
    48008864:	12003c01 	and	w1, w0, #0xffff
    48008868:	f9402be0 	ldr	x0, [sp, #80]
    4800886c:	79007001 	strh	w1, [x0, #56]
    mq->max_msgs = max_msgs;
    48008870:	f94017e0 	ldr	x0, [sp, #40]
    48008874:	12003c01 	and	w1, w0, #0xffff
    48008878:	f9402be0 	ldr	x0, [sp, #80]
    4800887c:	79007401 	strh	w1, [x0, #58]

    /* allocate message pool */
    mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message)) * mq->max_msgs);
    48008880:	f9402be0 	ldr	x0, [sp, #80]
    48008884:	79407000 	ldrh	w0, [x0, #56]
    48008888:	92403c00 	and	x0, x0, #0xffff
    4800888c:	91002001 	add	x1, x0, #0x8
    48008890:	f9402be0 	ldr	x0, [sp, #80]
    48008894:	79407400 	ldrh	w0, [x0, #58]
    48008898:	92403c00 	and	x0, x0, #0xffff
    4800889c:	9b007c20 	mul	x0, x1, x0
    480088a0:	940004ba 	bl	48009b88 <rt_malloc>
    480088a4:	aa0003e1 	mov	x1, x0
    480088a8:	f9402be0 	ldr	x0, [sp, #80]
    480088ac:	f9001801 	str	x1, [x0, #48]
    if (mq->msg_pool == RT_NULL)
    480088b0:	f9402be0 	ldr	x0, [sp, #80]
    480088b4:	f9401800 	ldr	x0, [x0, #48]
    480088b8:	f100001f 	cmp	x0, #0x0
    480088bc:	540000a1 	b.ne	480088d0 <rt_mq_create+0x150>  // b.any
    {
        rt_object_delete(&(mq->parent.parent));
    480088c0:	f9402be0 	ldr	x0, [sp, #80]
    480088c4:	940015b4 	bl	4800df94 <rt_object_delete>

        return RT_NULL;
    480088c8:	d2800000 	mov	x0, #0x0                   	// #0
    480088cc:	14000026 	b	48008964 <rt_mq_create+0x1e4>
    }

    /* initialize message list */
    mq->msg_queue_head = RT_NULL;
    480088d0:	f9402be0 	ldr	x0, [sp, #80]
    480088d4:	f900201f 	str	xzr, [x0, #64]
    mq->msg_queue_tail = RT_NULL;
    480088d8:	f9402be0 	ldr	x0, [sp, #80]
    480088dc:	f900241f 	str	xzr, [x0, #72]

    /* initialize message empty list */
    mq->msg_queue_free = RT_NULL;
    480088e0:	f9402be0 	ldr	x0, [sp, #80]
    480088e4:	f900281f 	str	xzr, [x0, #80]
    for (temp = 0; temp < mq->max_msgs; temp ++)
    480088e8:	d2800013 	mov	x19, #0x0                   	// #0
    480088ec:	14000013 	b	48008938 <rt_mq_create+0x1b8>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
    480088f0:	f9402be0 	ldr	x0, [sp, #80]
    480088f4:	f9401801 	ldr	x1, [x0, #48]
                                        temp * (mq->msg_size + sizeof(struct rt_mq_message)));
    480088f8:	f9402be0 	ldr	x0, [sp, #80]
    480088fc:	79407000 	ldrh	w0, [x0, #56]
    48008900:	92403c00 	and	x0, x0, #0xffff
    48008904:	91002000 	add	x0, x0, #0x8
    48008908:	aa1303e2 	mov	x2, x19
    4800890c:	9b027c00 	mul	x0, x0, x2
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
    48008910:	8b000020 	add	x0, x1, x0
    48008914:	f90027e0 	str	x0, [sp, #72]
        head->next = (struct rt_mq_message *)mq->msg_queue_free;
    48008918:	f9402be0 	ldr	x0, [sp, #80]
    4800891c:	f9402801 	ldr	x1, [x0, #80]
    48008920:	f94027e0 	ldr	x0, [sp, #72]
    48008924:	f9000001 	str	x1, [x0]
        mq->msg_queue_free = head;
    48008928:	f9402be0 	ldr	x0, [sp, #80]
    4800892c:	f94027e1 	ldr	x1, [sp, #72]
    48008930:	f9002801 	str	x1, [x0, #80]
    for (temp = 0; temp < mq->max_msgs; temp ++)
    48008934:	91000673 	add	x19, x19, #0x1
    48008938:	f9402be0 	ldr	x0, [sp, #80]
    4800893c:	79407400 	ldrh	w0, [x0, #58]
    48008940:	92403c00 	and	x0, x0, #0xffff
    48008944:	eb00027f 	cmp	x19, x0
    48008948:	54fffd4b 	b.lt	480088f0 <rt_mq_create+0x170>  // b.tstop
    }

    /* the initial entry is zero */
    mq->entry = 0;
    4800894c:	f9402be0 	ldr	x0, [sp, #80]
    48008950:	7900781f 	strh	wzr, [x0, #60]

    /* initialize an additional list of sender suspend thread */
    rt_list_init(&(mq->suspend_sender_thread));
    48008954:	f9402be0 	ldr	x0, [sp, #80]
    48008958:	91016000 	add	x0, x0, #0x58
    4800895c:	97fff46b 	bl	48005b08 <rt_list_init>

    return mq;
    48008960:	f9402be0 	ldr	x0, [sp, #80]
}
    48008964:	f9400bf3 	ldr	x19, [sp, #16]
    48008968:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4800896c:	d65f03c0 	ret

0000000048008970 <rt_mq_delete>:
 *           If the messagequeue is initialized by the rt_mq_init() function, you MUST NOT USE this function to delete it,
 *           ONLY USE the rt_mq_detach() function to complete the detachment.
 *           for example,the rt_mq_create() function, it cannot be called in interrupt context.
 */
rt_err_t rt_mq_delete(rt_mq_t mq)
{
    48008970:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48008974:	910003fd 	mov	x29, sp
    48008978:	f9000fe0 	str	x0, [sp, #24]
    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
    4800897c:	f9400fe0 	ldr	x0, [sp, #24]
    48008980:	f100001f 	cmp	x0, #0x0
    48008984:	540000e1 	b.ne	480089a0 <rt_mq_delete+0x30>  // b.any
    48008988:	d2814e42 	mov	x2, #0xa72                 	// #2674
    4800898c:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008990:	9133a001 	add	x1, x0, #0xce8
    48008994:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008998:	91272000 	add	x0, x0, #0x9c8
    4800899c:	94001db3 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
    480089a0:	f9400fe0 	ldr	x0, [sp, #24]
    480089a4:	940015c3 	bl	4800e0b0 <rt_object_get_type>
    480089a8:	12001c00 	and	w0, w0, #0xff
    480089ac:	7100181f 	cmp	w0, #0x6
    480089b0:	540000e0 	b.eq	480089cc <rt_mq_delete+0x5c>  // b.none
    480089b4:	d2814e62 	mov	x2, #0xa73                 	// #2675
    480089b8:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480089bc:	9133a001 	add	x1, x0, #0xce8
    480089c0:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480089c4:	91276000 	add	x0, x0, #0x9d8
    480089c8:	94001da8 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&mq->parent.parent) == RT_FALSE);
    480089cc:	f9400fe0 	ldr	x0, [sp, #24]
    480089d0:	940015a2 	bl	4800e058 <rt_object_is_systemobject>
    480089d4:	7100001f 	cmp	w0, #0x0
    480089d8:	540000e0 	b.eq	480089f4 <rt_mq_delete+0x84>  // b.none
    480089dc:	d2814e82 	mov	x2, #0xa74                 	// #2676
    480089e0:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480089e4:	9133a001 	add	x1, x0, #0xce8
    480089e8:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480089ec:	91294000 	add	x0, x0, #0xa50
    480089f0:	94001d9e 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
    480089f4:	97ffee8e 	bl	4800442c <rt_hw_interrupt_disable>
    480089f8:	f90017e0 	str	x0, [sp, #40]
    480089fc:	94000345 	bl	48009710 <rt_interrupt_get_nest>
    48008a00:	12001c00 	and	w0, w0, #0xff
    48008a04:	7100001f 	cmp	w0, #0x0
    48008a08:	54000180 	b.eq	48008a38 <rt_mq_delete+0xc8>  // b.none
    48008a0c:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008a10:	9133a001 	add	x1, x0, #0xce8
    48008a14:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008a18:	911ac000 	add	x0, x0, #0x6b0
    48008a1c:	94001cc5 	bl	4800fd30 <rt_kprintf>
    48008a20:	d2814ec2 	mov	x2, #0xa76                 	// #2678
    48008a24:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008a28:	9133a001 	add	x1, x0, #0xce8
    48008a2c:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008a30:	91172000 	add	x0, x0, #0x5c8
    48008a34:	94001d8d 	bl	48010068 <rt_assert_handler>
    48008a38:	f94017e0 	ldr	x0, [sp, #40]
    48008a3c:	97ffee80 	bl	4800443c <rt_hw_interrupt_enable>

    /* resume all suspended thread */
    _ipc_list_resume_all(&(mq->parent.suspend_thread));
    48008a40:	f9400fe0 	ldr	x0, [sp, #24]
    48008a44:	91008000 	add	x0, x0, #0x20
    48008a48:	97fff4b3 	bl	48005d14 <_ipc_list_resume_all>
    /* also resume all message queue private suspended thread */
    _ipc_list_resume_all(&(mq->suspend_sender_thread));
    48008a4c:	f9400fe0 	ldr	x0, [sp, #24]
    48008a50:	91016000 	add	x0, x0, #0x58
    48008a54:	97fff4b0 	bl	48005d14 <_ipc_list_resume_all>

    /* free message queue pool */
    RT_KERNEL_FREE(mq->msg_pool);
    48008a58:	f9400fe0 	ldr	x0, [sp, #24]
    48008a5c:	f9401800 	ldr	x0, [x0, #48]
    48008a60:	94000659 	bl	4800a3c4 <rt_free>

    /* delete message queue object */
    rt_object_delete(&(mq->parent.parent));
    48008a64:	f9400fe0 	ldr	x0, [sp, #24]
    48008a68:	9400154b 	bl	4800df94 <rt_object_delete>

    return RT_EOK;
    48008a6c:	d2800000 	mov	x0, #0x0                   	// #0
}
    48008a70:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48008a74:	d65f03c0 	ret

0000000048008a78 <rt_mq_send_wait>:
 */
rt_err_t rt_mq_send_wait(rt_mq_t     mq,
                         const void *buffer,
                         rt_size_t   size,
                         rt_int32_t  timeout)
{
    48008a78:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    48008a7c:	910003fd 	mov	x29, sp
    48008a80:	f9000bf3 	str	x19, [sp, #16]
    48008a84:	f9001fe0 	str	x0, [sp, #56]
    48008a88:	f9001be1 	str	x1, [sp, #48]
    48008a8c:	f90017e2 	str	x2, [sp, #40]
    48008a90:	b90027e3 	str	w3, [sp, #36]
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;
    struct rt_thread *thread;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
    48008a94:	f9401fe0 	ldr	x0, [sp, #56]
    48008a98:	f100001f 	cmp	x0, #0x0
    48008a9c:	540000e1 	b.ne	48008ab8 <rt_mq_send_wait+0x40>  // b.any
    48008aa0:	d2815622 	mov	x2, #0xab1                 	// #2737
    48008aa4:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008aa8:	9133e001 	add	x1, x0, #0xcf8
    48008aac:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008ab0:	91272000 	add	x0, x0, #0x9c8
    48008ab4:	94001d6d 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
    48008ab8:	f9401fe0 	ldr	x0, [sp, #56]
    48008abc:	9400157d 	bl	4800e0b0 <rt_object_get_type>
    48008ac0:	12001c00 	and	w0, w0, #0xff
    48008ac4:	7100181f 	cmp	w0, #0x6
    48008ac8:	540000e0 	b.eq	48008ae4 <rt_mq_send_wait+0x6c>  // b.none
    48008acc:	d2815642 	mov	x2, #0xab2                 	// #2738
    48008ad0:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008ad4:	9133e001 	add	x1, x0, #0xcf8
    48008ad8:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008adc:	91276000 	add	x0, x0, #0x9d8
    48008ae0:	94001d62 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
    48008ae4:	f9401be0 	ldr	x0, [sp, #48]
    48008ae8:	f100001f 	cmp	x0, #0x0
    48008aec:	540000e1 	b.ne	48008b08 <rt_mq_send_wait+0x90>  // b.any
    48008af0:	d2815662 	mov	x2, #0xab3                 	// #2739
    48008af4:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008af8:	9133e001 	add	x1, x0, #0xcf8
    48008afc:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008b00:	912a4000 	add	x0, x0, #0xa90
    48008b04:	94001d59 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(size != 0);
    48008b08:	f94017e0 	ldr	x0, [sp, #40]
    48008b0c:	f100001f 	cmp	x0, #0x0
    48008b10:	540000e1 	b.ne	48008b2c <rt_mq_send_wait+0xb4>  // b.any
    48008b14:	d2815682 	mov	x2, #0xab4                 	// #2740
    48008b18:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008b1c:	9133e001 	add	x1, x0, #0xcf8
    48008b20:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008b24:	912aa000 	add	x0, x0, #0xaa8
    48008b28:	94001d50 	bl	48010068 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
    48008b2c:	f9401fe0 	ldr	x0, [sp, #56]
    48008b30:	79407000 	ldrh	w0, [x0, #56]
    48008b34:	92403c00 	and	x0, x0, #0xffff
    48008b38:	f94017e1 	ldr	x1, [sp, #40]
    48008b3c:	eb00003f 	cmp	x1, x0
    48008b40:	54000069 	b.ls	48008b4c <rt_mq_send_wait+0xd4>  // b.plast
        return -RT_ERROR;
    48008b44:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    48008b48:	140000c5 	b	48008e5c <rt_mq_send_wait+0x3e4>

    /* initialize delta tick */
    tick_delta = 0;
    48008b4c:	b9006fff 	str	wzr, [sp, #108]
    /* get current thread */
    thread = rt_thread_self();
    48008b50:	94000c13 	bl	4800bb9c <rt_thread_self>
    48008b54:	f90033e0 	str	x0, [sp, #96]

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
    48008b58:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008b5c:	9117a000 	add	x0, x0, #0x5e8
    48008b60:	f9400000 	ldr	x0, [x0]
    48008b64:	f100001f 	cmp	x0, #0x0
    48008b68:	540000c0 	b.eq	48008b80 <rt_mq_send_wait+0x108>  // b.none
    48008b6c:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008b70:	9117a000 	add	x0, x0, #0x5e8
    48008b74:	f9400001 	ldr	x1, [x0]
    48008b78:	f9401fe0 	ldr	x0, [sp, #56]
    48008b7c:	d63f0020 	blr	x1

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48008b80:	97ffee2b 	bl	4800442c <rt_hw_interrupt_disable>
    48008b84:	aa0003f3 	mov	x19, x0

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message *)mq->msg_queue_free;
    48008b88:	f9401fe0 	ldr	x0, [sp, #56]
    48008b8c:	f9402800 	ldr	x0, [x0, #80]
    48008b90:	f9002fe0 	str	x0, [sp, #88]
    /* for non-blocking call */
    if (msg == RT_NULL && timeout == 0)
    48008b94:	f9402fe0 	ldr	x0, [sp, #88]
    48008b98:	f100001f 	cmp	x0, #0x0
    48008b9c:	54000d21 	b.ne	48008d40 <rt_mq_send_wait+0x2c8>  // b.any
    48008ba0:	b94027e0 	ldr	w0, [sp, #36]
    48008ba4:	7100001f 	cmp	w0, #0x0
    48008ba8:	54000cc1 	b.ne	48008d40 <rt_mq_send_wait+0x2c8>  // b.any
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48008bac:	aa1303e0 	mov	x0, x19
    48008bb0:	97ffee23 	bl	4800443c <rt_hw_interrupt_enable>

        return -RT_EFULL;
    48008bb4:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48008bb8:	140000a9 	b	48008e5c <rt_mq_send_wait+0x3e4>

    /* message queue is full */
    while ((msg = (struct rt_mq_message *)mq->msg_queue_free) == RT_NULL)
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
    48008bbc:	f94033e0 	ldr	x0, [sp, #96]
    48008bc0:	f9002c1f 	str	xzr, [x0, #88]

        /* no waiting, return timeout */
        if (timeout == 0)
    48008bc4:	b94027e0 	ldr	w0, [sp, #36]
    48008bc8:	7100001f 	cmp	w0, #0x0
    48008bcc:	540000a1 	b.ne	48008be0 <rt_mq_send_wait+0x168>  // b.any
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
    48008bd0:	aa1303e0 	mov	x0, x19
    48008bd4:	97ffee1a 	bl	4800443c <rt_hw_interrupt_enable>

            return -RT_EFULL;
    48008bd8:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48008bdc:	140000a0 	b	48008e5c <rt_mq_send_wait+0x3e4>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
    48008be0:	97ffee13 	bl	4800442c <rt_hw_interrupt_disable>
    48008be4:	f9002be0 	str	x0, [sp, #80]
    48008be8:	94000bed 	bl	4800bb9c <rt_thread_self>
    48008bec:	f100001f 	cmp	x0, #0x0
    48008bf0:	54000181 	b.ne	48008c20 <rt_mq_send_wait+0x1a8>  // b.any
    48008bf4:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008bf8:	9133e001 	add	x1, x0, #0xcf8
    48008bfc:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008c00:	911c6000 	add	x0, x0, #0x718
    48008c04:	94001c4b 	bl	4800fd30 <rt_kprintf>
    48008c08:	d2815bc2 	mov	x2, #0xade                 	// #2782
    48008c0c:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008c10:	9133e001 	add	x1, x0, #0xcf8
    48008c14:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008c18:	91172000 	add	x0, x0, #0x5c8
    48008c1c:	94001d13 	bl	48010068 <rt_assert_handler>
    48008c20:	97ffee03 	bl	4800442c <rt_hw_interrupt_disable>
    48008c24:	f90027e0 	str	x0, [sp, #72]
    48008c28:	940002ba 	bl	48009710 <rt_interrupt_get_nest>
    48008c2c:	12001c00 	and	w0, w0, #0xff
    48008c30:	7100001f 	cmp	w0, #0x0
    48008c34:	54000180 	b.eq	48008c64 <rt_mq_send_wait+0x1ec>  // b.none
    48008c38:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008c3c:	9133e001 	add	x1, x0, #0xcf8
    48008c40:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008c44:	911ac000 	add	x0, x0, #0x6b0
    48008c48:	94001c3a 	bl	4800fd30 <rt_kprintf>
    48008c4c:	d2815bc2 	mov	x2, #0xade                 	// #2782
    48008c50:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008c54:	9133e001 	add	x1, x0, #0xcf8
    48008c58:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008c5c:	91172000 	add	x0, x0, #0x5c8
    48008c60:	94001d02 	bl	48010068 <rt_assert_handler>
    48008c64:	f94027e0 	ldr	x0, [sp, #72]
    48008c68:	97ffedf5 	bl	4800443c <rt_hw_interrupt_enable>
    48008c6c:	f9402be0 	ldr	x0, [sp, #80]
    48008c70:	97ffedf3 	bl	4800443c <rt_hw_interrupt_enable>
        /* suspend current thread */
        _ipc_list_suspend(&(mq->suspend_sender_thread),
    48008c74:	f9401fe0 	ldr	x0, [sp, #56]
    48008c78:	91016003 	add	x3, x0, #0x58
    48008c7c:	f9401fe0 	ldr	x0, [sp, #56]
    48008c80:	39402400 	ldrb	w0, [x0, #9]
    48008c84:	2a0003e2 	mov	w2, w0
    48008c88:	f94033e1 	ldr	x1, [sp, #96]
    48008c8c:	aa0303e0 	mov	x0, x3
    48008c90:	97fff3d1 	bl	48005bd4 <_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
    48008c94:	b94027e0 	ldr	w0, [sp, #36]
    48008c98:	7100001f 	cmp	w0, #0x0
    48008c9c:	5400018d 	b.le	48008ccc <rt_mq_send_wait+0x254>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
    48008ca0:	94001d13 	bl	480100ec <rt_tick_get>
    48008ca4:	b9006fe0 	str	w0, [sp, #108]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mq_send_wait: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
    48008ca8:	f94033e0 	ldr	x0, [sp, #96]
    48008cac:	91020000 	add	x0, x0, #0x80
    48008cb0:	910093e1 	add	x1, sp, #0x24
    48008cb4:	aa0103e2 	mov	x2, x1
    48008cb8:	52800001 	mov	w1, #0x0                   	// #0
    48008cbc:	94000919 	bl	4800b120 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
    48008cc0:	f94033e0 	ldr	x0, [sp, #96]
    48008cc4:	91020000 	add	x0, x0, #0x80
    48008cc8:	940007ef 	bl	4800ac84 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48008ccc:	aa1303e0 	mov	x0, x19
    48008cd0:	97ffeddb 	bl	4800443c <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
    48008cd4:	940011ae 	bl	4800d38c <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
    48008cd8:	f94033e0 	ldr	x0, [sp, #96]
    48008cdc:	f9402c00 	ldr	x0, [x0, #88]
    48008ce0:	f100001f 	cmp	x0, #0x0
    48008ce4:	54000080 	b.eq	48008cf4 <rt_mq_send_wait+0x27c>  // b.none
        {
            /* return error */
            return thread->error;
    48008ce8:	f94033e0 	ldr	x0, [sp, #96]
    48008cec:	f9402c00 	ldr	x0, [x0, #88]
    48008cf0:	1400005b 	b	48008e5c <rt_mq_send_wait+0x3e4>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
    48008cf4:	97ffedce 	bl	4800442c <rt_hw_interrupt_disable>
    48008cf8:	aa0003f3 	mov	x19, x0

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
    48008cfc:	b94027e0 	ldr	w0, [sp, #36]
    48008d00:	7100001f 	cmp	w0, #0x0
    48008d04:	540001ed 	b.le	48008d40 <rt_mq_send_wait+0x2c8>
        {
            tick_delta = rt_tick_get() - tick_delta;
    48008d08:	94001cf9 	bl	480100ec <rt_tick_get>
    48008d0c:	2a0003e1 	mov	w1, w0
    48008d10:	b9406fe0 	ldr	w0, [sp, #108]
    48008d14:	4b000020 	sub	w0, w1, w0
    48008d18:	b9006fe0 	str	w0, [sp, #108]
            timeout -= tick_delta;
    48008d1c:	b94027e0 	ldr	w0, [sp, #36]
    48008d20:	2a0003e1 	mov	w1, w0
    48008d24:	b9406fe0 	ldr	w0, [sp, #108]
    48008d28:	4b000020 	sub	w0, w1, w0
    48008d2c:	b90027e0 	str	w0, [sp, #36]
            if (timeout < 0)
    48008d30:	b94027e0 	ldr	w0, [sp, #36]
    48008d34:	7100001f 	cmp	w0, #0x0
    48008d38:	5400004a 	b.ge	48008d40 <rt_mq_send_wait+0x2c8>  // b.tcont
                timeout = 0;
    48008d3c:	b90027ff 	str	wzr, [sp, #36]
    while ((msg = (struct rt_mq_message *)mq->msg_queue_free) == RT_NULL)
    48008d40:	f9401fe0 	ldr	x0, [sp, #56]
    48008d44:	f9402800 	ldr	x0, [x0, #80]
    48008d48:	f9002fe0 	str	x0, [sp, #88]
    48008d4c:	f9402fe0 	ldr	x0, [sp, #88]
    48008d50:	f100001f 	cmp	x0, #0x0
    48008d54:	54fff340 	b.eq	48008bbc <rt_mq_send_wait+0x144>  // b.none
        }
    }

    /* move free list pointer */
    mq->msg_queue_free = msg->next;
    48008d58:	f9402fe0 	ldr	x0, [sp, #88]
    48008d5c:	f9400001 	ldr	x1, [x0]
    48008d60:	f9401fe0 	ldr	x0, [sp, #56]
    48008d64:	f9002801 	str	x1, [x0, #80]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48008d68:	aa1303e0 	mov	x0, x19
    48008d6c:	97ffedb4 	bl	4800443c <rt_hw_interrupt_enable>

    /* the msg is the new tailer of list, the next shall be NULL */
    msg->next = RT_NULL;
    48008d70:	f9402fe0 	ldr	x0, [sp, #88]
    48008d74:	f900001f 	str	xzr, [x0]
    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
    48008d78:	f9402fe0 	ldr	x0, [sp, #88]
    48008d7c:	91002000 	add	x0, x0, #0x8
    48008d80:	f94017e2 	ldr	x2, [sp, #40]
    48008d84:	f9401be1 	ldr	x1, [sp, #48]
    48008d88:	940015c1 	bl	4800e48c <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48008d8c:	97ffeda8 	bl	4800442c <rt_hw_interrupt_disable>
    48008d90:	aa0003f3 	mov	x19, x0
    /* link msg to message queue */
    if (mq->msg_queue_tail != RT_NULL)
    48008d94:	f9401fe0 	ldr	x0, [sp, #56]
    48008d98:	f9402400 	ldr	x0, [x0, #72]
    48008d9c:	f100001f 	cmp	x0, #0x0
    48008da0:	540000a0 	b.eq	48008db4 <rt_mq_send_wait+0x33c>  // b.none
    {
        /* if the tail exists, */
        ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
    48008da4:	f9401fe0 	ldr	x0, [sp, #56]
    48008da8:	f9402400 	ldr	x0, [x0, #72]
    48008dac:	f9402fe1 	ldr	x1, [sp, #88]
    48008db0:	f9000001 	str	x1, [x0]
    }

    /* set new tail */
    mq->msg_queue_tail = msg;
    48008db4:	f9401fe0 	ldr	x0, [sp, #56]
    48008db8:	f9402fe1 	ldr	x1, [sp, #88]
    48008dbc:	f9002401 	str	x1, [x0, #72]
    /* if the head is empty, set head */
    if (mq->msg_queue_head == RT_NULL)
    48008dc0:	f9401fe0 	ldr	x0, [sp, #56]
    48008dc4:	f9402000 	ldr	x0, [x0, #64]
    48008dc8:	f100001f 	cmp	x0, #0x0
    48008dcc:	54000081 	b.ne	48008ddc <rt_mq_send_wait+0x364>  // b.any
        mq->msg_queue_head = msg;
    48008dd0:	f9401fe0 	ldr	x0, [sp, #56]
    48008dd4:	f9402fe1 	ldr	x1, [sp, #88]
    48008dd8:	f9002001 	str	x1, [x0, #64]

    if(mq->entry < RT_MQ_ENTRY_MAX)
    48008ddc:	f9401fe0 	ldr	x0, [sp, #56]
    48008de0:	79407801 	ldrh	w1, [x0, #60]
    48008de4:	529fffe0 	mov	w0, #0xffff                	// #65535
    48008de8:	6b00003f 	cmp	w1, w0
    48008dec:	540001a0 	b.eq	48008e20 <rt_mq_send_wait+0x3a8>  // b.none
    {
        /* increase message entry */
        mq->entry ++;
    48008df0:	f9401fe0 	ldr	x0, [sp, #56]
    48008df4:	79407800 	ldrh	w0, [x0, #60]
    48008df8:	11000400 	add	w0, w0, #0x1
    48008dfc:	12003c01 	and	w1, w0, #0xffff
    48008e00:	f9401fe0 	ldr	x0, [sp, #56]
    48008e04:	79007801 	strh	w1, [x0, #60]
        rt_hw_interrupt_enable(temp); /* enable interrupt */
        return -RT_EFULL; /* value overflowed */
    }

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
    48008e08:	f9401fe0 	ldr	x0, [sp, #56]
    48008e0c:	91008000 	add	x0, x0, #0x20
    48008e10:	97fff35e 	bl	48005b88 <rt_list_isempty>
    48008e14:	7100001f 	cmp	w0, #0x0
    48008e18:	540001c1 	b.ne	48008e50 <rt_mq_send_wait+0x3d8>  // b.any
    48008e1c:	14000005 	b	48008e30 <rt_mq_send_wait+0x3b8>
        rt_hw_interrupt_enable(temp); /* enable interrupt */
    48008e20:	aa1303e0 	mov	x0, x19
    48008e24:	97ffed86 	bl	4800443c <rt_hw_interrupt_enable>
        return -RT_EFULL; /* value overflowed */
    48008e28:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48008e2c:	1400000c 	b	48008e5c <rt_mq_send_wait+0x3e4>
    {
        _ipc_list_resume(&(mq->parent.suspend_thread));
    48008e30:	f9401fe0 	ldr	x0, [sp, #56]
    48008e34:	91008000 	add	x0, x0, #0x20
    48008e38:	97fff3ab 	bl	48005ce4 <_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48008e3c:	aa1303e0 	mov	x0, x19
    48008e40:	97ffed7f 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    48008e44:	94001152 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    48008e48:	d2800000 	mov	x0, #0x0                   	// #0
    48008e4c:	14000004 	b	48008e5c <rt_mq_send_wait+0x3e4>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48008e50:	aa1303e0 	mov	x0, x19
    48008e54:	97ffed7a 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    48008e58:	d2800000 	mov	x0, #0x0                   	// #0
}
    48008e5c:	f9400bf3 	ldr	x19, [sp, #16]
    48008e60:	a8c77bfd 	ldp	x29, x30, [sp], #112
    48008e64:	d65f03c0 	ret

0000000048008e68 <rt_mq_send>:
 *           If the return value is any other values, it means that the messagequeue detach failed.
 *
 * @warning  This function can be called in interrupt context and thread context.
 */
rt_err_t rt_mq_send(rt_mq_t mq, const void *buffer, rt_size_t size)
{
    48008e68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48008e6c:	910003fd 	mov	x29, sp
    48008e70:	f90017e0 	str	x0, [sp, #40]
    48008e74:	f90013e1 	str	x1, [sp, #32]
    48008e78:	f9000fe2 	str	x2, [sp, #24]
    return rt_mq_send_wait(mq, buffer, size, 0);
    48008e7c:	52800003 	mov	w3, #0x0                   	// #0
    48008e80:	f9400fe2 	ldr	x2, [sp, #24]
    48008e84:	f94013e1 	ldr	x1, [sp, #32]
    48008e88:	f94017e0 	ldr	x0, [sp, #40]
    48008e8c:	97fffefb 	bl	48008a78 <rt_mq_send_wait>
}
    48008e90:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48008e94:	d65f03c0 	ret

0000000048008e98 <rt_mq_urgent>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that the mailbox detach failed.
 */
rt_err_t rt_mq_urgent(rt_mq_t mq, const void *buffer, rt_size_t size)
{
    48008e98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48008e9c:	910003fd 	mov	x29, sp
    48008ea0:	f9000bf3 	str	x19, [sp, #16]
    48008ea4:	f9001fe0 	str	x0, [sp, #56]
    48008ea8:	f9001be1 	str	x1, [sp, #48]
    48008eac:	f90017e2 	str	x2, [sp, #40]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
    48008eb0:	f9401fe0 	ldr	x0, [sp, #56]
    48008eb4:	f100001f 	cmp	x0, #0x0
    48008eb8:	540000e1 	b.ne	48008ed4 <rt_mq_urgent+0x3c>  // b.any
    48008ebc:	d2816fa2 	mov	x2, #0xb7d                 	// #2941
    48008ec0:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008ec4:	91342001 	add	x1, x0, #0xd08
    48008ec8:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008ecc:	91272000 	add	x0, x0, #0x9c8
    48008ed0:	94001c66 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
    48008ed4:	f9401fe0 	ldr	x0, [sp, #56]
    48008ed8:	94001476 	bl	4800e0b0 <rt_object_get_type>
    48008edc:	12001c00 	and	w0, w0, #0xff
    48008ee0:	7100181f 	cmp	w0, #0x6
    48008ee4:	540000e0 	b.eq	48008f00 <rt_mq_urgent+0x68>  // b.none
    48008ee8:	d2816fc2 	mov	x2, #0xb7e                 	// #2942
    48008eec:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008ef0:	91342001 	add	x1, x0, #0xd08
    48008ef4:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008ef8:	91276000 	add	x0, x0, #0x9d8
    48008efc:	94001c5b 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
    48008f00:	f9401be0 	ldr	x0, [sp, #48]
    48008f04:	f100001f 	cmp	x0, #0x0
    48008f08:	540000e1 	b.ne	48008f24 <rt_mq_urgent+0x8c>  // b.any
    48008f0c:	d2816fe2 	mov	x2, #0xb7f                 	// #2943
    48008f10:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008f14:	91342001 	add	x1, x0, #0xd08
    48008f18:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008f1c:	912a4000 	add	x0, x0, #0xa90
    48008f20:	94001c52 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(size != 0);
    48008f24:	f94017e0 	ldr	x0, [sp, #40]
    48008f28:	f100001f 	cmp	x0, #0x0
    48008f2c:	540000e1 	b.ne	48008f48 <rt_mq_urgent+0xb0>  // b.any
    48008f30:	d2817002 	mov	x2, #0xb80                 	// #2944
    48008f34:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008f38:	91342001 	add	x1, x0, #0xd08
    48008f3c:	d00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48008f40:	912aa000 	add	x0, x0, #0xaa8
    48008f44:	94001c49 	bl	48010068 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
    48008f48:	f9401fe0 	ldr	x0, [sp, #56]
    48008f4c:	79407000 	ldrh	w0, [x0, #56]
    48008f50:	92403c00 	and	x0, x0, #0xffff
    48008f54:	f94017e1 	ldr	x1, [sp, #40]
    48008f58:	eb00003f 	cmp	x1, x0
    48008f5c:	54000069 	b.ls	48008f68 <rt_mq_urgent+0xd0>  // b.plast
        return -RT_ERROR;
    48008f60:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    48008f64:	14000052 	b	480090ac <rt_mq_urgent+0x214>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
    48008f68:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008f6c:	9117a000 	add	x0, x0, #0x5e8
    48008f70:	f9400000 	ldr	x0, [x0]
    48008f74:	f100001f 	cmp	x0, #0x0
    48008f78:	540000c0 	b.eq	48008f90 <rt_mq_urgent+0xf8>  // b.none
    48008f7c:	b0000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48008f80:	9117a000 	add	x0, x0, #0x5e8
    48008f84:	f9400001 	ldr	x1, [x0]
    48008f88:	f9401fe0 	ldr	x0, [sp, #56]
    48008f8c:	d63f0020 	blr	x1

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48008f90:	97ffed27 	bl	4800442c <rt_hw_interrupt_disable>
    48008f94:	aa0003f3 	mov	x19, x0

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message *)mq->msg_queue_free;
    48008f98:	f9401fe0 	ldr	x0, [sp, #56]
    48008f9c:	f9402800 	ldr	x0, [x0, #80]
    48008fa0:	f90027e0 	str	x0, [sp, #72]
    /* message queue is full */
    if (msg == RT_NULL)
    48008fa4:	f94027e0 	ldr	x0, [sp, #72]
    48008fa8:	f100001f 	cmp	x0, #0x0
    48008fac:	540000a1 	b.ne	48008fc0 <rt_mq_urgent+0x128>  // b.any
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48008fb0:	aa1303e0 	mov	x0, x19
    48008fb4:	97ffed22 	bl	4800443c <rt_hw_interrupt_enable>

        return -RT_EFULL;
    48008fb8:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    48008fbc:	1400003c 	b	480090ac <rt_mq_urgent+0x214>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
    48008fc0:	f94027e0 	ldr	x0, [sp, #72]
    48008fc4:	f9400001 	ldr	x1, [x0]
    48008fc8:	f9401fe0 	ldr	x0, [sp, #56]
    48008fcc:	f9002801 	str	x1, [x0, #80]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48008fd0:	aa1303e0 	mov	x0, x19
    48008fd4:	97ffed1a 	bl	4800443c <rt_hw_interrupt_enable>

    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
    48008fd8:	f94027e0 	ldr	x0, [sp, #72]
    48008fdc:	91002000 	add	x0, x0, #0x8
    48008fe0:	f94017e2 	ldr	x2, [sp, #40]
    48008fe4:	f9401be1 	ldr	x1, [sp, #48]
    48008fe8:	94001529 	bl	4800e48c <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48008fec:	97ffed10 	bl	4800442c <rt_hw_interrupt_disable>
    48008ff0:	aa0003f3 	mov	x19, x0

    /* link msg to the beginning of message queue */
    msg->next = (struct rt_mq_message *)mq->msg_queue_head;
    48008ff4:	f9401fe0 	ldr	x0, [sp, #56]
    48008ff8:	f9402001 	ldr	x1, [x0, #64]
    48008ffc:	f94027e0 	ldr	x0, [sp, #72]
    48009000:	f9000001 	str	x1, [x0]
    mq->msg_queue_head = msg;
    48009004:	f9401fe0 	ldr	x0, [sp, #56]
    48009008:	f94027e1 	ldr	x1, [sp, #72]
    4800900c:	f9002001 	str	x1, [x0, #64]

    /* if there is no tail */
    if (mq->msg_queue_tail == RT_NULL)
    48009010:	f9401fe0 	ldr	x0, [sp, #56]
    48009014:	f9402400 	ldr	x0, [x0, #72]
    48009018:	f100001f 	cmp	x0, #0x0
    4800901c:	54000081 	b.ne	4800902c <rt_mq_urgent+0x194>  // b.any
        mq->msg_queue_tail = msg;
    48009020:	f9401fe0 	ldr	x0, [sp, #56]
    48009024:	f94027e1 	ldr	x1, [sp, #72]
    48009028:	f9002401 	str	x1, [x0, #72]

    if(mq->entry < RT_MQ_ENTRY_MAX)
    4800902c:	f9401fe0 	ldr	x0, [sp, #56]
    48009030:	79407801 	ldrh	w1, [x0, #60]
    48009034:	529fffe0 	mov	w0, #0xffff                	// #65535
    48009038:	6b00003f 	cmp	w1, w0
    4800903c:	540001a0 	b.eq	48009070 <rt_mq_urgent+0x1d8>  // b.none
    {
        /* increase message entry */
        mq->entry ++;
    48009040:	f9401fe0 	ldr	x0, [sp, #56]
    48009044:	79407800 	ldrh	w0, [x0, #60]
    48009048:	11000400 	add	w0, w0, #0x1
    4800904c:	12003c01 	and	w1, w0, #0xffff
    48009050:	f9401fe0 	ldr	x0, [sp, #56]
    48009054:	79007801 	strh	w1, [x0, #60]
        rt_hw_interrupt_enable(temp); /* enable interrupt */
        return -RT_EFULL; /* value overflowed */
    }

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
    48009058:	f9401fe0 	ldr	x0, [sp, #56]
    4800905c:	91008000 	add	x0, x0, #0x20
    48009060:	97fff2ca 	bl	48005b88 <rt_list_isempty>
    48009064:	7100001f 	cmp	w0, #0x0
    48009068:	540001c1 	b.ne	480090a0 <rt_mq_urgent+0x208>  // b.any
    4800906c:	14000005 	b	48009080 <rt_mq_urgent+0x1e8>
        rt_hw_interrupt_enable(temp); /* enable interrupt */
    48009070:	aa1303e0 	mov	x0, x19
    48009074:	97ffecf2 	bl	4800443c <rt_hw_interrupt_enable>
        return -RT_EFULL; /* value overflowed */
    48009078:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    4800907c:	1400000c 	b	480090ac <rt_mq_urgent+0x214>
    {
        _ipc_list_resume(&(mq->parent.suspend_thread));
    48009080:	f9401fe0 	ldr	x0, [sp, #56]
    48009084:	91008000 	add	x0, x0, #0x20
    48009088:	97fff317 	bl	48005ce4 <_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    4800908c:	aa1303e0 	mov	x0, x19
    48009090:	97ffeceb 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    48009094:	940010be 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    48009098:	d2800000 	mov	x0, #0x0                   	// #0
    4800909c:	14000004 	b	480090ac <rt_mq_urgent+0x214>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    480090a0:	aa1303e0 	mov	x0, x19
    480090a4:	97ffece6 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    480090a8:	d2800000 	mov	x0, #0x0                   	// #0
}
    480090ac:	f9400bf3 	ldr	x19, [sp, #16]
    480090b0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480090b4:	d65f03c0 	ret

00000000480090b8 <rt_mq_recv>:
 */
rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
    480090b8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    480090bc:	910003fd 	mov	x29, sp
    480090c0:	f9000bf3 	str	x19, [sp, #16]
    480090c4:	f9001fe0 	str	x0, [sp, #56]
    480090c8:	f9001be1 	str	x1, [sp, #48]
    480090cc:	f90017e2 	str	x2, [sp, #40]
    480090d0:	b90027e3 	str	w3, [sp, #36]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
    480090d4:	f9401fe0 	ldr	x0, [sp, #56]
    480090d8:	f100001f 	cmp	x0, #0x0
    480090dc:	540000e1 	b.ne	480090f8 <rt_mq_recv+0x40>  // b.any
    480090e0:	d2817ce2 	mov	x2, #0xbe7                 	// #3047
    480090e4:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480090e8:	91346001 	add	x1, x0, #0xd18
    480090ec:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480090f0:	91272000 	add	x0, x0, #0x9c8
    480090f4:	94001bdd 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
    480090f8:	f9401fe0 	ldr	x0, [sp, #56]
    480090fc:	940013ed 	bl	4800e0b0 <rt_object_get_type>
    48009100:	12001c00 	and	w0, w0, #0xff
    48009104:	7100181f 	cmp	w0, #0x6
    48009108:	540000e0 	b.eq	48009124 <rt_mq_recv+0x6c>  // b.none
    4800910c:	d2817d02 	mov	x2, #0xbe8                 	// #3048
    48009110:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009114:	91346001 	add	x1, x0, #0xd18
    48009118:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800911c:	91276000 	add	x0, x0, #0x9d8
    48009120:	94001bd2 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
    48009124:	f9401be0 	ldr	x0, [sp, #48]
    48009128:	f100001f 	cmp	x0, #0x0
    4800912c:	540000e1 	b.ne	48009148 <rt_mq_recv+0x90>  // b.any
    48009130:	d2817d22 	mov	x2, #0xbe9                 	// #3049
    48009134:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009138:	91346001 	add	x1, x0, #0xd18
    4800913c:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009140:	912a4000 	add	x0, x0, #0xa90
    48009144:	94001bc9 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(size != 0);
    48009148:	f94017e0 	ldr	x0, [sp, #40]
    4800914c:	f100001f 	cmp	x0, #0x0
    48009150:	540000e1 	b.ne	4800916c <rt_mq_recv+0xb4>  // b.any
    48009154:	d2817d42 	mov	x2, #0xbea                 	// #3050
    48009158:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800915c:	91346001 	add	x1, x0, #0xd18
    48009160:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009164:	912aa000 	add	x0, x0, #0xaa8
    48009168:	94001bc0 	bl	48010068 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
    4800916c:	b9006fff 	str	wzr, [sp, #108]
    /* get current thread */
    thread = rt_thread_self();
    48009170:	94000a8b 	bl	4800bb9c <rt_thread_self>
    48009174:	f90033e0 	str	x0, [sp, #96]
    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
    48009178:	90000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800917c:	91176000 	add	x0, x0, #0x5d8
    48009180:	f9400000 	ldr	x0, [x0]
    48009184:	f100001f 	cmp	x0, #0x0
    48009188:	540000c0 	b.eq	480091a0 <rt_mq_recv+0xe8>  // b.none
    4800918c:	90000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48009190:	91176000 	add	x0, x0, #0x5d8
    48009194:	f9400001 	ldr	x1, [x0]
    48009198:	f9401fe0 	ldr	x0, [sp, #56]
    4800919c:	d63f0020 	blr	x1

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    480091a0:	97ffeca3 	bl	4800442c <rt_hw_interrupt_disable>
    480091a4:	aa0003f3 	mov	x19, x0

    /* for non-blocking call */
    if (mq->entry == 0 && timeout == 0)
    480091a8:	f9401fe0 	ldr	x0, [sp, #56]
    480091ac:	79407800 	ldrh	w0, [x0, #60]
    480091b0:	7100001f 	cmp	w0, #0x0
    480091b4:	54000d81 	b.ne	48009364 <rt_mq_recv+0x2ac>  // b.any
    480091b8:	b94027e0 	ldr	w0, [sp, #36]
    480091bc:	7100001f 	cmp	w0, #0x0
    480091c0:	54000d21 	b.ne	48009364 <rt_mq_recv+0x2ac>  // b.any
    {
        rt_hw_interrupt_enable(temp);
    480091c4:	aa1303e0 	mov	x0, x19
    480091c8:	97ffec9d 	bl	4800443c <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
    480091cc:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    480091d0:	140000bd 	b	480094c4 <rt_mq_recv+0x40c>
    }

    /* message queue is empty */
    while (mq->entry == 0)
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
    480091d4:	97ffec96 	bl	4800442c <rt_hw_interrupt_disable>
    480091d8:	f9002be0 	str	x0, [sp, #80]
    480091dc:	94000a70 	bl	4800bb9c <rt_thread_self>
    480091e0:	f100001f 	cmp	x0, #0x0
    480091e4:	54000181 	b.ne	48009214 <rt_mq_recv+0x15c>  // b.any
    480091e8:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480091ec:	91346001 	add	x1, x0, #0xd18
    480091f0:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480091f4:	911c6000 	add	x0, x0, #0x718
    480091f8:	94001ace 	bl	4800fd30 <rt_kprintf>
    480091fc:	d2818002 	mov	x2, #0xc00                 	// #3072
    48009200:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009204:	91346001 	add	x1, x0, #0xd18
    48009208:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800920c:	91172000 	add	x0, x0, #0x5c8
    48009210:	94001b96 	bl	48010068 <rt_assert_handler>
    48009214:	97ffec86 	bl	4800442c <rt_hw_interrupt_disable>
    48009218:	f90027e0 	str	x0, [sp, #72]
    4800921c:	9400013d 	bl	48009710 <rt_interrupt_get_nest>
    48009220:	12001c00 	and	w0, w0, #0xff
    48009224:	7100001f 	cmp	w0, #0x0
    48009228:	54000180 	b.eq	48009258 <rt_mq_recv+0x1a0>  // b.none
    4800922c:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009230:	91346001 	add	x1, x0, #0xd18
    48009234:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009238:	911ac000 	add	x0, x0, #0x6b0
    4800923c:	94001abd 	bl	4800fd30 <rt_kprintf>
    48009240:	d2818002 	mov	x2, #0xc00                 	// #3072
    48009244:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009248:	91346001 	add	x1, x0, #0xd18
    4800924c:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009250:	91172000 	add	x0, x0, #0x5c8
    48009254:	94001b85 	bl	48010068 <rt_assert_handler>
    48009258:	f94027e0 	ldr	x0, [sp, #72]
    4800925c:	97ffec78 	bl	4800443c <rt_hw_interrupt_enable>
    48009260:	f9402be0 	ldr	x0, [sp, #80]
    48009264:	97ffec76 	bl	4800443c <rt_hw_interrupt_enable>

        /* reset error number in thread */
        thread->error = RT_EOK;
    48009268:	f94033e0 	ldr	x0, [sp, #96]
    4800926c:	f9002c1f 	str	xzr, [x0, #88]

        /* no waiting, return timeout */
        if (timeout == 0)
    48009270:	b94027e0 	ldr	w0, [sp, #36]
    48009274:	7100001f 	cmp	w0, #0x0
    48009278:	54000101 	b.ne	48009298 <rt_mq_recv+0x1e0>  // b.any
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
    4800927c:	aa1303e0 	mov	x0, x19
    48009280:	97ffec6f 	bl	4800443c <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
    48009284:	f94033e0 	ldr	x0, [sp, #96]
    48009288:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    4800928c:	f9002c01 	str	x1, [x0, #88]

            return -RT_ETIMEOUT;
    48009290:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    48009294:	1400008c 	b	480094c4 <rt_mq_recv+0x40c>
        }

        /* suspend current thread */
        _ipc_list_suspend(&(mq->parent.suspend_thread),
    48009298:	f9401fe0 	ldr	x0, [sp, #56]
    4800929c:	91008003 	add	x3, x0, #0x20
    480092a0:	f9401fe0 	ldr	x0, [sp, #56]
    480092a4:	39402400 	ldrb	w0, [x0, #9]
    480092a8:	2a0003e2 	mov	w2, w0
    480092ac:	f94033e1 	ldr	x1, [sp, #96]
    480092b0:	aa0303e0 	mov	x0, x3
    480092b4:	97fff248 	bl	48005bd4 <_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
    480092b8:	b94027e0 	ldr	w0, [sp, #36]
    480092bc:	7100001f 	cmp	w0, #0x0
    480092c0:	5400018d 	b.le	480092f0 <rt_mq_recv+0x238>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
    480092c4:	94001b8a 	bl	480100ec <rt_tick_get>
    480092c8:	b9006fe0 	str	w0, [sp, #108]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
    480092cc:	f94033e0 	ldr	x0, [sp, #96]
    480092d0:	91020000 	add	x0, x0, #0x80
    480092d4:	910093e1 	add	x1, sp, #0x24
    480092d8:	aa0103e2 	mov	x2, x1
    480092dc:	52800001 	mov	w1, #0x0                   	// #0
    480092e0:	94000790 	bl	4800b120 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
    480092e4:	f94033e0 	ldr	x0, [sp, #96]
    480092e8:	91020000 	add	x0, x0, #0x80
    480092ec:	94000666 	bl	4800ac84 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    480092f0:	aa1303e0 	mov	x0, x19
    480092f4:	97ffec52 	bl	4800443c <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
    480092f8:	94001025 	bl	4800d38c <rt_schedule>

        /* recv message */
        if (thread->error != RT_EOK)
    480092fc:	f94033e0 	ldr	x0, [sp, #96]
    48009300:	f9402c00 	ldr	x0, [x0, #88]
    48009304:	f100001f 	cmp	x0, #0x0
    48009308:	54000080 	b.eq	48009318 <rt_mq_recv+0x260>  // b.none
        {
            /* return error */
            return thread->error;
    4800930c:	f94033e0 	ldr	x0, [sp, #96]
    48009310:	f9402c00 	ldr	x0, [x0, #88]
    48009314:	1400006c 	b	480094c4 <rt_mq_recv+0x40c>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
    48009318:	97ffec45 	bl	4800442c <rt_hw_interrupt_disable>
    4800931c:	aa0003f3 	mov	x19, x0

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
    48009320:	b94027e0 	ldr	w0, [sp, #36]
    48009324:	7100001f 	cmp	w0, #0x0
    48009328:	540001ed 	b.le	48009364 <rt_mq_recv+0x2ac>
        {
            tick_delta = rt_tick_get() - tick_delta;
    4800932c:	94001b70 	bl	480100ec <rt_tick_get>
    48009330:	2a0003e1 	mov	w1, w0
    48009334:	b9406fe0 	ldr	w0, [sp, #108]
    48009338:	4b000020 	sub	w0, w1, w0
    4800933c:	b9006fe0 	str	w0, [sp, #108]
            timeout -= tick_delta;
    48009340:	b94027e0 	ldr	w0, [sp, #36]
    48009344:	2a0003e1 	mov	w1, w0
    48009348:	b9406fe0 	ldr	w0, [sp, #108]
    4800934c:	4b000020 	sub	w0, w1, w0
    48009350:	b90027e0 	str	w0, [sp, #36]
            if (timeout < 0)
    48009354:	b94027e0 	ldr	w0, [sp, #36]
    48009358:	7100001f 	cmp	w0, #0x0
    4800935c:	5400004a 	b.ge	48009364 <rt_mq_recv+0x2ac>  // b.tcont
                timeout = 0;
    48009360:	b90027ff 	str	wzr, [sp, #36]
    while (mq->entry == 0)
    48009364:	f9401fe0 	ldr	x0, [sp, #56]
    48009368:	79407800 	ldrh	w0, [x0, #60]
    4800936c:	7100001f 	cmp	w0, #0x0
    48009370:	54fff320 	b.eq	480091d4 <rt_mq_recv+0x11c>  // b.none
        }
    }

    /* get message from queue */
    msg = (struct rt_mq_message *)mq->msg_queue_head;
    48009374:	f9401fe0 	ldr	x0, [sp, #56]
    48009378:	f9402000 	ldr	x0, [x0, #64]
    4800937c:	f9002fe0 	str	x0, [sp, #88]

    /* move message queue head */
    mq->msg_queue_head = msg->next;
    48009380:	f9402fe0 	ldr	x0, [sp, #88]
    48009384:	f9400001 	ldr	x1, [x0]
    48009388:	f9401fe0 	ldr	x0, [sp, #56]
    4800938c:	f9002001 	str	x1, [x0, #64]
    /* reach queue tail, set to NULL */
    if (mq->msg_queue_tail == msg)
    48009390:	f9401fe0 	ldr	x0, [sp, #56]
    48009394:	f9402400 	ldr	x0, [x0, #72]
    48009398:	f9402fe1 	ldr	x1, [sp, #88]
    4800939c:	eb00003f 	cmp	x1, x0
    480093a0:	54000061 	b.ne	480093ac <rt_mq_recv+0x2f4>  // b.any
        mq->msg_queue_tail = RT_NULL;
    480093a4:	f9401fe0 	ldr	x0, [sp, #56]
    480093a8:	f900241f 	str	xzr, [x0, #72]

    /* decrease message entry */
    if(mq->entry > 0)
    480093ac:	f9401fe0 	ldr	x0, [sp, #56]
    480093b0:	79407800 	ldrh	w0, [x0, #60]
    480093b4:	7100001f 	cmp	w0, #0x0
    480093b8:	540000e0 	b.eq	480093d4 <rt_mq_recv+0x31c>  // b.none
    {
        mq->entry --;
    480093bc:	f9401fe0 	ldr	x0, [sp, #56]
    480093c0:	79407800 	ldrh	w0, [x0, #60]
    480093c4:	51000400 	sub	w0, w0, #0x1
    480093c8:	12003c01 	and	w1, w0, #0xffff
    480093cc:	f9401fe0 	ldr	x0, [sp, #56]
    480093d0:	79007801 	strh	w1, [x0, #60]
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    480093d4:	aa1303e0 	mov	x0, x19
    480093d8:	97ffec19 	bl	4800443c <rt_hw_interrupt_enable>

    /* copy message */
    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
    480093dc:	f9402fe0 	ldr	x0, [sp, #88]
    480093e0:	91002003 	add	x3, x0, #0x8
    480093e4:	f9401fe0 	ldr	x0, [sp, #56]
    480093e8:	79407000 	ldrh	w0, [x0, #56]
    480093ec:	92403c00 	and	x0, x0, #0xffff
    480093f0:	f94017e2 	ldr	x2, [sp, #40]
    480093f4:	f94017e1 	ldr	x1, [sp, #40]
    480093f8:	eb00005f 	cmp	x2, x0
    480093fc:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
    48009400:	aa0003e2 	mov	x2, x0
    48009404:	aa0303e1 	mov	x1, x3
    48009408:	f9401be0 	ldr	x0, [sp, #48]
    4800940c:	94001420 	bl	4800e48c <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    48009410:	97ffec07 	bl	4800442c <rt_hw_interrupt_disable>
    48009414:	aa0003f3 	mov	x19, x0
    /* put message to free list */
    msg->next = (struct rt_mq_message *)mq->msg_queue_free;
    48009418:	f9401fe0 	ldr	x0, [sp, #56]
    4800941c:	f9402801 	ldr	x1, [x0, #80]
    48009420:	f9402fe0 	ldr	x0, [sp, #88]
    48009424:	f9000001 	str	x1, [x0]
    mq->msg_queue_free = msg;
    48009428:	f9401fe0 	ldr	x0, [sp, #56]
    4800942c:	f9402fe1 	ldr	x1, [sp, #88]
    48009430:	f9002801 	str	x1, [x0, #80]

    /* resume suspended thread */
    if (!rt_list_isempty(&(mq->suspend_sender_thread)))
    48009434:	f9401fe0 	ldr	x0, [sp, #56]
    48009438:	91016000 	add	x0, x0, #0x58
    4800943c:	97fff1d3 	bl	48005b88 <rt_list_isempty>
    48009440:	7100001f 	cmp	w0, #0x0
    48009444:	54000261 	b.ne	48009490 <rt_mq_recv+0x3d8>  // b.any
    {
        _ipc_list_resume(&(mq->suspend_sender_thread));
    48009448:	f9401fe0 	ldr	x0, [sp, #56]
    4800944c:	91016000 	add	x0, x0, #0x58
    48009450:	97fff225 	bl	48005ce4 <_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    48009454:	aa1303e0 	mov	x0, x19
    48009458:	97ffebf9 	bl	4800443c <rt_hw_interrupt_enable>

        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
    4800945c:	90000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48009460:	91178000 	add	x0, x0, #0x5e0
    48009464:	f9400000 	ldr	x0, [x0]
    48009468:	f100001f 	cmp	x0, #0x0
    4800946c:	540000c0 	b.eq	48009484 <rt_mq_recv+0x3cc>  // b.none
    48009470:	90000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48009474:	91178000 	add	x0, x0, #0x5e0
    48009478:	f9400001 	ldr	x1, [x0]
    4800947c:	f9401fe0 	ldr	x0, [sp, #56]
    48009480:	d63f0020 	blr	x1

        rt_schedule();
    48009484:	94000fc2 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    48009488:	d2800000 	mov	x0, #0x0                   	// #0
    4800948c:	1400000e 	b	480094c4 <rt_mq_recv+0x40c>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    48009490:	aa1303e0 	mov	x0, x19
    48009494:	97ffebea 	bl	4800443c <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
    48009498:	90000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800949c:	91178000 	add	x0, x0, #0x5e0
    480094a0:	f9400000 	ldr	x0, [x0]
    480094a4:	f100001f 	cmp	x0, #0x0
    480094a8:	540000c0 	b.eq	480094c0 <rt_mq_recv+0x408>  // b.none
    480094ac:	90000180 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480094b0:	91178000 	add	x0, x0, #0x5e0
    480094b4:	f9400001 	ldr	x1, [x0]
    480094b8:	f9401fe0 	ldr	x0, [sp, #56]
    480094bc:	d63f0020 	blr	x1

    return RT_EOK;
    480094c0:	d2800000 	mov	x0, #0x0                   	// #0
}
    480094c4:	f9400bf3 	ldr	x19, [sp, #16]
    480094c8:	a8c77bfd 	ldp	x29, x30, [sp], #112
    480094cc:	d65f03c0 	ret

00000000480094d0 <rt_mq_control>:
 *
 * @return   Return the operation status. When the return value is RT_EOK, the operation is successful.
 *           If the return value is any other values, it means that this function failed to execute.
 */
rt_err_t rt_mq_control(rt_mq_t mq, int cmd, void *arg)
{
    480094d0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480094d4:	910003fd 	mov	x29, sp
    480094d8:	f90017e0 	str	x0, [sp, #40]
    480094dc:	b90027e1 	str	w1, [sp, #36]
    480094e0:	f9000fe2 	str	x2, [sp, #24]
    rt_ubase_t level;
    struct rt_mq_message *msg;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
    480094e4:	f94017e0 	ldr	x0, [sp, #40]
    480094e8:	f100001f 	cmp	x0, #0x0
    480094ec:	540000e1 	b.ne	48009508 <rt_mq_control+0x38>  // b.any
    480094f0:	d28190e2 	mov	x2, #0xc87                 	// #3207
    480094f4:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480094f8:	9134a001 	add	x1, x0, #0xd28
    480094fc:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009500:	91272000 	add	x0, x0, #0x9c8
    48009504:	94001ad9 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&mq->parent.parent) == RT_Object_Class_MessageQueue);
    48009508:	f94017e0 	ldr	x0, [sp, #40]
    4800950c:	940012e9 	bl	4800e0b0 <rt_object_get_type>
    48009510:	12001c00 	and	w0, w0, #0xff
    48009514:	7100181f 	cmp	w0, #0x6
    48009518:	540000e0 	b.eq	48009534 <rt_mq_control+0x64>  // b.none
    4800951c:	d2819102 	mov	x2, #0xc88                 	// #3208
    48009520:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009524:	9134a001 	add	x1, x0, #0xd28
    48009528:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800952c:	91276000 	add	x0, x0, #0x9d8
    48009530:	94001ace 	bl	48010068 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
    48009534:	b94027e0 	ldr	w0, [sp, #36]
    48009538:	7100041f 	cmp	w0, #0x1
    4800953c:	54000541 	b.ne	480095e4 <rt_mq_control+0x114>  // b.any
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    48009540:	97ffebbb 	bl	4800442c <rt_hw_interrupt_disable>
    48009544:	f9001fe0 	str	x0, [sp, #56]

        /* resume all waiting thread */
        _ipc_list_resume_all(&mq->parent.suspend_thread);
    48009548:	f94017e0 	ldr	x0, [sp, #40]
    4800954c:	91008000 	add	x0, x0, #0x20
    48009550:	97fff1f1 	bl	48005d14 <_ipc_list_resume_all>
        /* also resume all message queue private suspended thread */
        _ipc_list_resume_all(&(mq->suspend_sender_thread));
    48009554:	f94017e0 	ldr	x0, [sp, #40]
    48009558:	91016000 	add	x0, x0, #0x58
    4800955c:	97fff1ee 	bl	48005d14 <_ipc_list_resume_all>

        /* release all message in the queue */
        while (mq->msg_queue_head != RT_NULL)
    48009560:	14000016 	b	480095b8 <rt_mq_control+0xe8>
        {
            /* get message from queue */
            msg = (struct rt_mq_message *)mq->msg_queue_head;
    48009564:	f94017e0 	ldr	x0, [sp, #40]
    48009568:	f9402000 	ldr	x0, [x0, #64]
    4800956c:	f9001be0 	str	x0, [sp, #48]

            /* move message queue head */
            mq->msg_queue_head = msg->next;
    48009570:	f9401be0 	ldr	x0, [sp, #48]
    48009574:	f9400001 	ldr	x1, [x0]
    48009578:	f94017e0 	ldr	x0, [sp, #40]
    4800957c:	f9002001 	str	x1, [x0, #64]
            /* reach queue tail, set to NULL */
            if (mq->msg_queue_tail == msg)
    48009580:	f94017e0 	ldr	x0, [sp, #40]
    48009584:	f9402400 	ldr	x0, [x0, #72]
    48009588:	f9401be1 	ldr	x1, [sp, #48]
    4800958c:	eb00003f 	cmp	x1, x0
    48009590:	54000061 	b.ne	4800959c <rt_mq_control+0xcc>  // b.any
                mq->msg_queue_tail = RT_NULL;
    48009594:	f94017e0 	ldr	x0, [sp, #40]
    48009598:	f900241f 	str	xzr, [x0, #72]

            /* put message to free list */
            msg->next = (struct rt_mq_message *)mq->msg_queue_free;
    4800959c:	f94017e0 	ldr	x0, [sp, #40]
    480095a0:	f9402801 	ldr	x1, [x0, #80]
    480095a4:	f9401be0 	ldr	x0, [sp, #48]
    480095a8:	f9000001 	str	x1, [x0]
            mq->msg_queue_free = msg;
    480095ac:	f94017e0 	ldr	x0, [sp, #40]
    480095b0:	f9401be1 	ldr	x1, [sp, #48]
    480095b4:	f9002801 	str	x1, [x0, #80]
        while (mq->msg_queue_head != RT_NULL)
    480095b8:	f94017e0 	ldr	x0, [sp, #40]
    480095bc:	f9402000 	ldr	x0, [x0, #64]
    480095c0:	f100001f 	cmp	x0, #0x0
    480095c4:	54fffd01 	b.ne	48009564 <rt_mq_control+0x94>  // b.any
        }

        /* clean entry */
        mq->entry = 0;
    480095c8:	f94017e0 	ldr	x0, [sp, #40]
    480095cc:	7900781f 	strh	wzr, [x0, #60]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    480095d0:	f9401fe0 	ldr	x0, [sp, #56]
    480095d4:	97ffeb9a 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    480095d8:	94000f6d 	bl	4800d38c <rt_schedule>

        return RT_EOK;
    480095dc:	d2800000 	mov	x0, #0x0                   	// #0
    480095e0:	14000002 	b	480095e8 <rt_mq_control+0x118>
    }

    return -RT_ERROR;
    480095e4:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
    480095e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480095ec:	d65f03c0 	ret

00000000480095f0 <rt_interrupt_enter_sethook>:
 * @note The hook function must be simple and never be blocked or suspend.
 *
 * @param hook the function point to be called
 */
void rt_interrupt_enter_sethook(void (*hook)(void))
{
    480095f0:	d10043ff 	sub	sp, sp, #0x10
    480095f4:	f90007e0 	str	x0, [sp, #8]
    rt_interrupt_enter_hook = hook;
    480095f8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480095fc:	91280000 	add	x0, x0, #0xa00
    48009600:	f94007e1 	ldr	x1, [sp, #8]
    48009604:	f9000001 	str	x1, [x0]
}
    48009608:	d503201f 	nop
    4800960c:	910043ff 	add	sp, sp, #0x10
    48009610:	d65f03c0 	ret

0000000048009614 <rt_interrupt_leave_sethook>:
 * @note The hook function must be simple and never be blocked or suspend.
 *
 * @param hook the function point to be called
 */
void rt_interrupt_leave_sethook(void (*hook)(void))
{
    48009614:	d10043ff 	sub	sp, sp, #0x10
    48009618:	f90007e0 	str	x0, [sp, #8]
    rt_interrupt_leave_hook = hook;
    4800961c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009620:	91282000 	add	x0, x0, #0xa08
    48009624:	f94007e1 	ldr	x1, [sp, #8]
    48009628:	f9000001 	str	x1, [x0]
}
    4800962c:	d503201f 	nop
    48009630:	910043ff 	add	sp, sp, #0x10
    48009634:	d65f03c0 	ret

0000000048009638 <rt_interrupt_enter>:
 * @note Please don't invoke this routine in application
 *
 * @see rt_interrupt_leave
 */
void rt_interrupt_enter(void)
{
    48009638:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800963c:	910003fd 	mov	x29, sp
    rt_base_t level;

    level = rt_hw_interrupt_disable();
    48009640:	97ffeb7b 	bl	4800442c <rt_hw_interrupt_disable>
    48009644:	f9000fe0 	str	x0, [sp, #24]
    rt_interrupt_nest ++;
    48009648:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800964c:	9127e000 	add	x0, x0, #0x9f8
    48009650:	39400000 	ldrb	w0, [x0]
    48009654:	12001c00 	and	w0, w0, #0xff
    48009658:	11000400 	add	w0, w0, #0x1
    4800965c:	12001c01 	and	w1, w0, #0xff
    48009660:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009664:	9127e000 	add	x0, x0, #0x9f8
    48009668:	39000001 	strb	w1, [x0]
    RT_OBJECT_HOOK_CALL(rt_interrupt_enter_hook,());
    4800966c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009670:	91280000 	add	x0, x0, #0xa00
    48009674:	f9400000 	ldr	x0, [x0]
    48009678:	f100001f 	cmp	x0, #0x0
    4800967c:	540000a0 	b.eq	48009690 <rt_interrupt_enter+0x58>  // b.none
    48009680:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009684:	91280000 	add	x0, x0, #0xa00
    48009688:	f9400000 	ldr	x0, [x0]
    4800968c:	d63f0000 	blr	x0
    rt_hw_interrupt_enable(level);
    48009690:	f9400fe0 	ldr	x0, [sp, #24]
    48009694:	97ffeb6a 	bl	4800443c <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq has come..., irq current nest:%d\n",
                                rt_interrupt_nest));
}
    48009698:	d503201f 	nop
    4800969c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480096a0:	d65f03c0 	ret

00000000480096a4 <rt_interrupt_leave>:
 * @note Please don't invoke this routine in application
 *
 * @see rt_interrupt_enter
 */
void rt_interrupt_leave(void)
{
    480096a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480096a8:	910003fd 	mov	x29, sp
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq is going to leave, irq current nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
    480096ac:	97ffeb60 	bl	4800442c <rt_hw_interrupt_disable>
    480096b0:	f9000fe0 	str	x0, [sp, #24]
    RT_OBJECT_HOOK_CALL(rt_interrupt_leave_hook,());
    480096b4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480096b8:	91282000 	add	x0, x0, #0xa08
    480096bc:	f9400000 	ldr	x0, [x0]
    480096c0:	f100001f 	cmp	x0, #0x0
    480096c4:	540000a0 	b.eq	480096d8 <rt_interrupt_leave+0x34>  // b.none
    480096c8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480096cc:	91282000 	add	x0, x0, #0xa08
    480096d0:	f9400000 	ldr	x0, [x0]
    480096d4:	d63f0000 	blr	x0
    rt_interrupt_nest --;
    480096d8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480096dc:	9127e000 	add	x0, x0, #0x9f8
    480096e0:	39400000 	ldrb	w0, [x0]
    480096e4:	12001c00 	and	w0, w0, #0xff
    480096e8:	51000400 	sub	w0, w0, #0x1
    480096ec:	12001c01 	and	w1, w0, #0xff
    480096f0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480096f4:	9127e000 	add	x0, x0, #0x9f8
    480096f8:	39000001 	strb	w1, [x0]
    rt_hw_interrupt_enable(level);
    480096fc:	f9400fe0 	ldr	x0, [sp, #24]
    48009700:	97ffeb4f 	bl	4800443c <rt_hw_interrupt_enable>
}
    48009704:	d503201f 	nop
    48009708:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800970c:	d65f03c0 	ret

0000000048009710 <rt_interrupt_get_nest>:
 * context is interrupt context.
 *
 * @return the number of nested interrupts.
 */
RT_WEAK rt_uint8_t rt_interrupt_get_nest(void)
{
    48009710:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48009714:	910003fd 	mov	x29, sp
    rt_uint8_t ret;
    rt_base_t level;

    level = rt_hw_interrupt_disable();
    48009718:	97ffeb45 	bl	4800442c <rt_hw_interrupt_disable>
    4800971c:	f9000fe0 	str	x0, [sp, #24]
    ret = rt_interrupt_nest;
    48009720:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009724:	9127e000 	add	x0, x0, #0x9f8
    48009728:	39400000 	ldrb	w0, [x0]
    4800972c:	39005fe0 	strb	w0, [sp, #23]
    rt_hw_interrupt_enable(level);
    48009730:	f9400fe0 	ldr	x0, [sp, #24]
    48009734:	97ffeb42 	bl	4800443c <rt_hw_interrupt_enable>
    return ret;
    48009738:	39405fe0 	ldrb	w0, [sp, #23]
}
    4800973c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48009740:	d65f03c0 	ret

0000000048009744 <rt_malloc_sethook>:
 *        block is allocated from heap memory.
 *
 * @param hook the hook function.
 */
void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
{
    48009744:	d10043ff 	sub	sp, sp, #0x10
    48009748:	f90007e0 	str	x0, [sp, #8]
    rt_malloc_hook = hook;
    4800974c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009750:	91284000 	add	x0, x0, #0xa10
    48009754:	f94007e1 	ldr	x1, [sp, #8]
    48009758:	f9000001 	str	x1, [x0]
}
    4800975c:	d503201f 	nop
    48009760:	910043ff 	add	sp, sp, #0x10
    48009764:	d65f03c0 	ret

0000000048009768 <rt_free_sethook>:
 *        block is released to heap memory.
 *
 * @param hook the hook function
 */
void rt_free_sethook(void (*hook)(void *ptr))
{
    48009768:	d10043ff 	sub	sp, sp, #0x10
    4800976c:	f90007e0 	str	x0, [sp, #8]
    rt_free_hook = hook;
    48009770:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009774:	91286000 	add	x0, x0, #0xa18
    48009778:	f94007e1 	ldr	x1, [sp, #8]
    4800977c:	f9000001 	str	x1, [x0]
}
    48009780:	d503201f 	nop
    48009784:	910043ff 	add	sp, sp, #0x10
    48009788:	d65f03c0 	ret

000000004800978c <plug_holes>:
    }
}
#endif /* RT_USING_MEMTRACE */

static void plug_holes(struct heap_mem *mem)
{
    4800978c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48009790:	910003fd 	mov	x29, sp
    48009794:	f9000fe0 	str	x0, [sp, #24]
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
    48009798:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800979c:	91288000 	add	x0, x0, #0xa20
    480097a0:	f9400000 	ldr	x0, [x0]
    480097a4:	f9400fe1 	ldr	x1, [sp, #24]
    480097a8:	eb00003f 	cmp	x1, x0
    480097ac:	540000e2 	b.cs	480097c8 <plug_holes+0x3c>  // b.hs, b.nlast
    480097b0:	d2801422 	mov	x2, #0xa1                  	// #161
    480097b4:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480097b8:	91018001 	add	x1, x0, #0x60
    480097bc:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480097c0:	9134e000 	add	x0, x0, #0xd38
    480097c4:	94001a29 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
    480097c8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480097cc:	9128a000 	add	x0, x0, #0xa28
    480097d0:	f9400000 	ldr	x0, [x0]
    480097d4:	f9400fe1 	ldr	x1, [sp, #24]
    480097d8:	eb00003f 	cmp	x1, x0
    480097dc:	540000e3 	b.cc	480097f8 <plug_holes+0x6c>  // b.lo, b.ul, b.last
    480097e0:	d2801442 	mov	x2, #0xa2                  	// #162
    480097e4:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480097e8:	91018001 	add	x1, x0, #0x60
    480097ec:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480097f0:	91356000 	add	x0, x0, #0xd58
    480097f4:	94001a1d 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(mem->used == 0);
    480097f8:	f9400fe0 	ldr	x0, [sp, #24]
    480097fc:	79400400 	ldrh	w0, [x0, #2]
    48009800:	7100001f 	cmp	w0, #0x0
    48009804:	540000e0 	b.eq	48009820 <plug_holes+0x94>  // b.none
    48009808:	d2801462 	mov	x2, #0xa3                  	// #163
    4800980c:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48009810:	91018001 	add	x1, x0, #0x60
    48009814:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009818:	91362000 	add	x0, x0, #0xd88
    4800981c:	94001a13 	bl	48010068 <rt_assert_handler>

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    48009820:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009824:	91288000 	add	x0, x0, #0xa20
    48009828:	f9400001 	ldr	x1, [x0]
    4800982c:	f9400fe0 	ldr	x0, [sp, #24]
    48009830:	f9400400 	ldr	x0, [x0, #8]
    48009834:	8b000020 	add	x0, x1, x0
    48009838:	f90017e0 	str	x0, [sp, #40]
    if (mem != nmem &&
    4800983c:	f9400fe1 	ldr	x1, [sp, #24]
    48009840:	f94017e0 	ldr	x0, [sp, #40]
    48009844:	eb00003f 	cmp	x1, x0
    48009848:	540004c0 	b.eq	480098e0 <plug_holes+0x154>  // b.none
        nmem->used == 0 &&
    4800984c:	f94017e0 	ldr	x0, [sp, #40]
    48009850:	79400400 	ldrh	w0, [x0, #2]
    if (mem != nmem &&
    48009854:	7100001f 	cmp	w0, #0x0
    48009858:	54000441 	b.ne	480098e0 <plug_holes+0x154>  // b.any
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    4800985c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009860:	9128a000 	add	x0, x0, #0xa28
    48009864:	f9400000 	ldr	x0, [x0]
        nmem->used == 0 &&
    48009868:	f94017e1 	ldr	x1, [sp, #40]
    4800986c:	eb00003f 	cmp	x1, x0
    48009870:	54000380 	b.eq	480098e0 <plug_holes+0x154>  // b.none
    {
        /* if mem->next is unused and not end of heap_ptr,
         * combine mem and mem->next
         */
        if (lfree == nmem)
    48009874:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009878:	9128c000 	add	x0, x0, #0xa30
    4800987c:	f9400000 	ldr	x0, [x0]
    48009880:	f94017e1 	ldr	x1, [sp, #40]
    48009884:	eb00003f 	cmp	x1, x0
    48009888:	540000a1 	b.ne	4800989c <plug_holes+0x110>  // b.any
        {
            lfree = mem;
    4800988c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009890:	9128c000 	add	x0, x0, #0xa30
    48009894:	f9400fe1 	ldr	x1, [sp, #24]
    48009898:	f9000001 	str	x1, [x0]
        }
        mem->next = nmem->next;
    4800989c:	f94017e0 	ldr	x0, [sp, #40]
    480098a0:	f9400401 	ldr	x1, [x0, #8]
    480098a4:	f9400fe0 	ldr	x0, [sp, #24]
    480098a8:	f9000401 	str	x1, [x0, #8]
        ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
    480098ac:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480098b0:	91288000 	add	x0, x0, #0xa20
    480098b4:	f9400000 	ldr	x0, [x0]
    480098b8:	f9400fe1 	ldr	x1, [sp, #24]
    480098bc:	cb000022 	sub	x2, x1, x0
    480098c0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480098c4:	91288000 	add	x0, x0, #0xa20
    480098c8:	f9400001 	ldr	x1, [x0]
    480098cc:	f94017e0 	ldr	x0, [sp, #40]
    480098d0:	f9400400 	ldr	x0, [x0, #8]
    480098d4:	8b000020 	add	x0, x1, x0
    480098d8:	aa0203e1 	mov	x1, x2
    480098dc:	f9000801 	str	x1, [x0, #16]
    }

    /* plug hole backward */
    pmem = (struct heap_mem *)&heap_ptr[mem->prev];
    480098e0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    480098e4:	91288000 	add	x0, x0, #0xa20
    480098e8:	f9400001 	ldr	x1, [x0]
    480098ec:	f9400fe0 	ldr	x0, [sp, #24]
    480098f0:	f9400800 	ldr	x0, [x0, #16]
    480098f4:	8b000020 	add	x0, x1, x0
    480098f8:	f90013e0 	str	x0, [sp, #32]
    if (pmem != mem && pmem->used == 0)
    480098fc:	f94013e1 	ldr	x1, [sp, #32]
    48009900:	f9400fe0 	ldr	x0, [sp, #24]
    48009904:	eb00003f 	cmp	x1, x0
    48009908:	54000400 	b.eq	48009988 <plug_holes+0x1fc>  // b.none
    4800990c:	f94013e0 	ldr	x0, [sp, #32]
    48009910:	79400400 	ldrh	w0, [x0, #2]
    48009914:	7100001f 	cmp	w0, #0x0
    48009918:	54000381 	b.ne	48009988 <plug_holes+0x1fc>  // b.any
    {
        /* if mem->prev is unused, combine mem and mem->prev */
        if (lfree == mem)
    4800991c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009920:	9128c000 	add	x0, x0, #0xa30
    48009924:	f9400000 	ldr	x0, [x0]
    48009928:	f9400fe1 	ldr	x1, [sp, #24]
    4800992c:	eb00003f 	cmp	x1, x0
    48009930:	540000a1 	b.ne	48009944 <plug_holes+0x1b8>  // b.any
        {
            lfree = pmem;
    48009934:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009938:	9128c000 	add	x0, x0, #0xa30
    4800993c:	f94013e1 	ldr	x1, [sp, #32]
    48009940:	f9000001 	str	x1, [x0]
        }
        pmem->next = mem->next;
    48009944:	f9400fe0 	ldr	x0, [sp, #24]
    48009948:	f9400401 	ldr	x1, [x0, #8]
    4800994c:	f94013e0 	ldr	x0, [sp, #32]
    48009950:	f9000401 	str	x1, [x0, #8]
        ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
    48009954:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009958:	91288000 	add	x0, x0, #0xa20
    4800995c:	f9400000 	ldr	x0, [x0]
    48009960:	f94013e1 	ldr	x1, [sp, #32]
    48009964:	cb000022 	sub	x2, x1, x0
    48009968:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800996c:	91288000 	add	x0, x0, #0xa20
    48009970:	f9400001 	ldr	x1, [x0]
    48009974:	f9400fe0 	ldr	x0, [sp, #24]
    48009978:	f9400400 	ldr	x0, [x0, #8]
    4800997c:	8b000020 	add	x0, x1, x0
    48009980:	aa0203e1 	mov	x1, x2
    48009984:	f9000801 	str	x1, [x0, #16]
    }
}
    48009988:	d503201f 	nop
    4800998c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48009990:	d65f03c0 	ret

0000000048009994 <rt_system_heap_init>:
 * @param begin_addr the beginning address of system heap memory.
 *
 * @param end_addr the end address of system heap memory.
 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
{
    48009994:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48009998:	910003fd 	mov	x29, sp
    4800999c:	f9000fe0 	str	x0, [sp, #24]
    480099a0:	f9000be1 	str	x1, [sp, #16]
    struct heap_mem *mem;
    rt_ubase_t begin_align = RT_ALIGN((rt_ubase_t)begin_addr, RT_ALIGN_SIZE);
    480099a4:	f9400fe0 	ldr	x0, [sp, #24]
    480099a8:	91000c00 	add	x0, x0, #0x3
    480099ac:	927ef400 	and	x0, x0, #0xfffffffffffffffc
    480099b0:	f9001fe0 	str	x0, [sp, #56]
    rt_ubase_t end_align   = RT_ALIGN_DOWN((rt_ubase_t)end_addr, RT_ALIGN_SIZE);
    480099b4:	f9400be0 	ldr	x0, [sp, #16]
    480099b8:	927ef400 	and	x0, x0, #0xfffffffffffffffc
    480099bc:	f9001be0 	str	x0, [sp, #48]

    RT_DEBUG_NOT_IN_INTERRUPT;
    480099c0:	97ffea9b 	bl	4800442c <rt_hw_interrupt_disable>
    480099c4:	f90017e0 	str	x0, [sp, #40]
    480099c8:	97ffff52 	bl	48009710 <rt_interrupt_get_nest>
    480099cc:	12001c00 	and	w0, w0, #0xff
    480099d0:	7100001f 	cmp	w0, #0x0
    480099d4:	54000180 	b.eq	48009a04 <rt_system_heap_init+0x70>  // b.none
    480099d8:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480099dc:	9101c001 	add	x1, x0, #0x70
    480099e0:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480099e4:	91366000 	add	x0, x0, #0xd98
    480099e8:	940018d2 	bl	4800fd30 <rt_kprintf>
    480099ec:	d2801a22 	mov	x2, #0xd1                  	// #209
    480099f0:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480099f4:	9101c001 	add	x1, x0, #0x70
    480099f8:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    480099fc:	91370000 	add	x0, x0, #0xdc0
    48009a00:	9400199a 	bl	48010068 <rt_assert_handler>
    48009a04:	f94017e0 	ldr	x0, [sp, #40]
    48009a08:	97ffea8d 	bl	4800443c <rt_hw_interrupt_enable>

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
    48009a0c:	f9401be0 	ldr	x0, [sp, #48]
    48009a10:	f100c01f 	cmp	x0, #0x30
    48009a14:	54000a69 	b.ls	48009b60 <rt_system_heap_init+0x1cc>  // b.plast
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
    48009a18:	f9401be0 	ldr	x0, [sp, #48]
    48009a1c:	d100c000 	sub	x0, x0, #0x30
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
    48009a20:	f9401fe1 	ldr	x1, [sp, #56]
    48009a24:	eb00003f 	cmp	x1, x0
    48009a28:	540009c8 	b.hi	48009b60 <rt_system_heap_init+0x1cc>  // b.pmore
    {
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    48009a2c:	f9401be1 	ldr	x1, [sp, #48]
    48009a30:	f9401fe0 	ldr	x0, [sp, #56]
    48009a34:	cb000020 	sub	x0, x1, x0
    48009a38:	d100c001 	sub	x1, x0, #0x30
    48009a3c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009a40:	9129c000 	add	x0, x0, #0xa70
    48009a44:	f9000001 	str	x1, [x0]

        return;
    }

    /* point to begin address of heap */
    heap_ptr = (rt_uint8_t *)begin_align;
    48009a48:	f9401fe1 	ldr	x1, [sp, #56]
    48009a4c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009a50:	91288000 	add	x0, x0, #0xa20
    48009a54:	f9000001 	str	x1, [x0]

    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
                                (rt_ubase_t)heap_ptr, mem_size_aligned));

    /* initialize the start of the heap */
    mem        = (struct heap_mem *)heap_ptr;
    48009a58:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009a5c:	91288000 	add	x0, x0, #0xa20
    48009a60:	f9400000 	ldr	x0, [x0]
    48009a64:	f90013e0 	str	x0, [sp, #32]
    mem->magic = HEAP_MAGIC;
    48009a68:	f94013e0 	ldr	x0, [sp, #32]
    48009a6c:	5283d401 	mov	w1, #0x1ea0                	// #7840
    48009a70:	79000001 	strh	w1, [x0]
    mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
    48009a74:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009a78:	9129c000 	add	x0, x0, #0xa70
    48009a7c:	f9400000 	ldr	x0, [x0]
    48009a80:	91006001 	add	x1, x0, #0x18
    48009a84:	f94013e0 	ldr	x0, [sp, #32]
    48009a88:	f9000401 	str	x1, [x0, #8]
    mem->prev  = 0;
    48009a8c:	f94013e0 	ldr	x0, [sp, #32]
    48009a90:	f900081f 	str	xzr, [x0, #16]
    mem->used  = 0;
    48009a94:	f94013e0 	ldr	x0, [sp, #32]
    48009a98:	7900041f 	strh	wzr, [x0, #2]
#ifdef RT_USING_MEMTRACE
    rt_mem_setname(mem, "INIT");
#endif /* RT_USING_MEMTRACE */

    /* initialize the end of the heap */
    heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
    48009a9c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009aa0:	91288000 	add	x0, x0, #0xa20
    48009aa4:	f9400001 	ldr	x1, [x0]
    48009aa8:	f94013e0 	ldr	x0, [sp, #32]
    48009aac:	f9400400 	ldr	x0, [x0, #8]
    48009ab0:	8b000021 	add	x1, x1, x0
    48009ab4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009ab8:	9128a000 	add	x0, x0, #0xa28
    48009abc:	f9000001 	str	x1, [x0]
    heap_end->magic = HEAP_MAGIC;
    48009ac0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009ac4:	9128a000 	add	x0, x0, #0xa28
    48009ac8:	f9400000 	ldr	x0, [x0]
    48009acc:	5283d401 	mov	w1, #0x1ea0                	// #7840
    48009ad0:	79000001 	strh	w1, [x0]
    heap_end->used  = 1;
    48009ad4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009ad8:	9128a000 	add	x0, x0, #0xa28
    48009adc:	f9400000 	ldr	x0, [x0]
    48009ae0:	52800021 	mov	w1, #0x1                   	// #1
    48009ae4:	79000401 	strh	w1, [x0, #2]
    heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
    48009ae8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009aec:	9129c000 	add	x0, x0, #0xa70
    48009af0:	f9400001 	ldr	x1, [x0]
    48009af4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009af8:	9128a000 	add	x0, x0, #0xa28
    48009afc:	f9400000 	ldr	x0, [x0]
    48009b00:	91006021 	add	x1, x1, #0x18
    48009b04:	f9000401 	str	x1, [x0, #8]
    heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
    48009b08:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009b0c:	9129c000 	add	x0, x0, #0xa70
    48009b10:	f9400001 	ldr	x1, [x0]
    48009b14:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009b18:	9128a000 	add	x0, x0, #0xa28
    48009b1c:	f9400000 	ldr	x0, [x0]
    48009b20:	91006021 	add	x1, x1, #0x18
    48009b24:	f9000801 	str	x1, [x0, #16]
#ifdef RT_USING_MEMTRACE
    rt_mem_setname(heap_end, "INIT");
#endif /* RT_USING_MEMTRACE */

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_PRIO);
    48009b28:	52800023 	mov	w3, #0x1                   	// #1
    48009b2c:	52800022 	mov	w2, #0x1                   	// #1
    48009b30:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009b34:	91382001 	add	x1, x0, #0xe08
    48009b38:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009b3c:	9128e000 	add	x0, x0, #0xa38
    48009b40:	97fff08f 	bl	48005d7c <rt_sem_init>

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
    48009b44:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009b48:	91288000 	add	x0, x0, #0xa20
    48009b4c:	f9400001 	ldr	x1, [x0]
    48009b50:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009b54:	9128c000 	add	x0, x0, #0xa30
    48009b58:	f9000001 	str	x1, [x0]
    48009b5c:	14000009 	b	48009b80 <rt_system_heap_init+0x1ec>
        rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
    48009b60:	f9400fe0 	ldr	x0, [sp, #24]
    48009b64:	f9400be1 	ldr	x1, [sp, #16]
    48009b68:	aa0103e2 	mov	x2, x1
    48009b6c:	aa0003e1 	mov	x1, x0
    48009b70:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009b74:	91372000 	add	x0, x0, #0xdc8
    48009b78:	9400186e 	bl	4800fd30 <rt_kprintf>
        return;
    48009b7c:	d503201f 	nop
}
    48009b80:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48009b84:	d65f03c0 	ret

0000000048009b88 <rt_malloc>:
 * @param size is the minimum size of the requested block in bytes.
 *
 * @return the pointer to allocated memory or NULL if no free memory was found.
 */
void *rt_malloc(rt_size_t size)
{
    48009b88:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48009b8c:	910003fd 	mov	x29, sp
    48009b90:	f9000fe0 	str	x0, [sp, #24]
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    if (size == 0)
    48009b94:	f9400fe0 	ldr	x0, [sp, #24]
    48009b98:	f100001f 	cmp	x0, #0x0
    48009b9c:	54000061 	b.ne	48009ba8 <rt_malloc+0x20>  // b.any
        return RT_NULL;
    48009ba0:	d2800000 	mov	x0, #0x0                   	// #0
    48009ba4:	14000132 	b	4800a06c <rt_malloc+0x4e4>

    RT_DEBUG_NOT_IN_INTERRUPT;
    48009ba8:	97ffea21 	bl	4800442c <rt_hw_interrupt_disable>
    48009bac:	f90023e0 	str	x0, [sp, #64]
    48009bb0:	97fffed8 	bl	48009710 <rt_interrupt_get_nest>
    48009bb4:	12001c00 	and	w0, w0, #0xff
    48009bb8:	7100001f 	cmp	w0, #0x0
    48009bbc:	54000180 	b.eq	48009bec <rt_malloc+0x64>  // b.none
    48009bc0:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48009bc4:	91022001 	add	x1, x0, #0x88
    48009bc8:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009bcc:	91366000 	add	x0, x0, #0xd98
    48009bd0:	94001858 	bl	4800fd30 <rt_kprintf>
    48009bd4:	d28022e2 	mov	x2, #0x117                 	// #279
    48009bd8:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48009bdc:	91022001 	add	x1, x0, #0x88
    48009be0:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009be4:	91370000 	add	x0, x0, #0xdc0
    48009be8:	94001920 	bl	48010068 <rt_assert_handler>
    48009bec:	f94023e0 	ldr	x0, [sp, #64]
    48009bf0:	97ffea13 	bl	4800443c <rt_hw_interrupt_enable>
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));

    /* alignment size */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);
    48009bf4:	f9400fe0 	ldr	x0, [sp, #24]
    48009bf8:	91000c00 	add	x0, x0, #0x3
    48009bfc:	927ef400 	and	x0, x0, #0xfffffffffffffffc
    48009c00:	f9000fe0 	str	x0, [sp, #24]

    if (size > mem_size_aligned)
    48009c04:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009c08:	9129c000 	add	x0, x0, #0xa70
    48009c0c:	f9400000 	ldr	x0, [x0]
    48009c10:	f9400fe1 	ldr	x1, [sp, #24]
    48009c14:	eb00003f 	cmp	x1, x0
    48009c18:	54000069 	b.ls	48009c24 <rt_malloc+0x9c>  // b.plast
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));

        return RT_NULL;
    48009c1c:	d2800000 	mov	x0, #0x0                   	// #0
    48009c20:	14000113 	b	4800a06c <rt_malloc+0x4e4>
    }

    /* every data block must be at least MIN_SIZE_ALIGNED long */
    if (size < MIN_SIZE_ALIGNED)
    48009c24:	f9400fe0 	ldr	x0, [sp, #24]
    48009c28:	f1005c1f 	cmp	x0, #0x17
    48009c2c:	54000068 	b.hi	48009c38 <rt_malloc+0xb0>  // b.pmore
        size = MIN_SIZE_ALIGNED;
    48009c30:	d2800300 	mov	x0, #0x18                  	// #24
    48009c34:	f9000fe0 	str	x0, [sp, #24]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
    48009c38:	12800001 	mov	w1, #0xffffffff            	// #-1
    48009c3c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009c40:	9128e000 	add	x0, x0, #0xa38
    48009c44:	97fff12b 	bl	480060f0 <rt_sem_take>

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
    48009c48:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009c4c:	9128c000 	add	x0, x0, #0xa30
    48009c50:	f9400001 	ldr	x1, [x0]
    48009c54:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009c58:	91288000 	add	x0, x0, #0xa20
    48009c5c:	f9400000 	ldr	x0, [x0]
    48009c60:	cb000020 	sub	x0, x1, x0
    48009c64:	f90027e0 	str	x0, [sp, #72]
    48009c68:	140000f5 	b	4800a03c <rt_malloc+0x4b4>
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    {
        mem = (struct heap_mem *)&heap_ptr[ptr];
    48009c6c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009c70:	91288000 	add	x0, x0, #0xa20
    48009c74:	f9400001 	ldr	x1, [x0]
    48009c78:	f94027e0 	ldr	x0, [sp, #72]
    48009c7c:	8b000020 	add	x0, x1, x0
    48009c80:	f9001fe0 	str	x0, [sp, #56]

        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
    48009c84:	f9401fe0 	ldr	x0, [sp, #56]
    48009c88:	79400400 	ldrh	w0, [x0, #2]
    48009c8c:	7100001f 	cmp	w0, #0x0
    48009c90:	54001c81 	b.ne	4800a020 <rt_malloc+0x498>  // b.any
    48009c94:	f9401fe0 	ldr	x0, [sp, #56]
    48009c98:	f9400401 	ldr	x1, [x0, #8]
    48009c9c:	f94027e0 	ldr	x0, [sp, #72]
    48009ca0:	cb000020 	sub	x0, x1, x0
    48009ca4:	d1006000 	sub	x0, x0, #0x18
    48009ca8:	f9400fe1 	ldr	x1, [sp, #24]
    48009cac:	eb00003f 	cmp	x1, x0
    48009cb0:	54001b88 	b.hi	4800a020 <rt_malloc+0x498>  // b.pmore
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
    48009cb4:	f9401fe0 	ldr	x0, [sp, #56]
    48009cb8:	f9400401 	ldr	x1, [x0, #8]
    48009cbc:	f94027e0 	ldr	x0, [sp, #72]
    48009cc0:	cb000020 	sub	x0, x1, x0
    48009cc4:	d1006001 	sub	x1, x0, #0x18
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
    48009cc8:	f9400fe0 	ldr	x0, [sp, #24]
    48009ccc:	9100c000 	add	x0, x0, #0x30
            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
    48009cd0:	eb00003f 	cmp	x1, x0
    48009cd4:	540008c3 	b.cc	48009dec <rt_malloc+0x264>  // b.lo, b.ul, b.last
                 * struct heap_mem would fit in but no data between mem2 and mem2->next
                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
                 *       region that couldn't hold data, but when mem->next gets freed,
                 *       the 2 regions would be combined, resulting in more free memory
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    48009cd8:	f94027e1 	ldr	x1, [sp, #72]
    48009cdc:	f9400fe0 	ldr	x0, [sp, #24]
    48009ce0:	8b000020 	add	x0, x1, x0
    48009ce4:	91006000 	add	x0, x0, #0x18
    48009ce8:	f9001be0 	str	x0, [sp, #48]

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&heap_ptr[ptr2];
    48009cec:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009cf0:	91288000 	add	x0, x0, #0xa20
    48009cf4:	f9400001 	ldr	x1, [x0]
    48009cf8:	f9401be0 	ldr	x0, [sp, #48]
    48009cfc:	8b000020 	add	x0, x1, x0
    48009d00:	f90017e0 	str	x0, [sp, #40]
                mem2->magic = HEAP_MAGIC;
    48009d04:	f94017e0 	ldr	x0, [sp, #40]
    48009d08:	5283d401 	mov	w1, #0x1ea0                	// #7840
    48009d0c:	79000001 	strh	w1, [x0]
                mem2->used = 0;
    48009d10:	f94017e0 	ldr	x0, [sp, #40]
    48009d14:	7900041f 	strh	wzr, [x0, #2]
                mem2->next = mem->next;
    48009d18:	f9401fe0 	ldr	x0, [sp, #56]
    48009d1c:	f9400401 	ldr	x1, [x0, #8]
    48009d20:	f94017e0 	ldr	x0, [sp, #40]
    48009d24:	f9000401 	str	x1, [x0, #8]
                mem2->prev = ptr;
    48009d28:	f94017e0 	ldr	x0, [sp, #40]
    48009d2c:	f94027e1 	ldr	x1, [sp, #72]
    48009d30:	f9000801 	str	x1, [x0, #16]
#ifdef RT_USING_MEMTRACE
                rt_mem_setname(mem2, "    ");
#endif /* RT_USING_MEMTRACE */

                /* and insert it between mem and mem->next */
                mem->next = ptr2;
    48009d34:	f9401fe0 	ldr	x0, [sp, #56]
    48009d38:	f9401be1 	ldr	x1, [sp, #48]
    48009d3c:	f9000401 	str	x1, [x0, #8]
                mem->used = 1;
    48009d40:	f9401fe0 	ldr	x0, [sp, #56]
    48009d44:	52800021 	mov	w1, #0x1                   	// #1
    48009d48:	79000401 	strh	w1, [x0, #2]

                if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
    48009d4c:	f94017e0 	ldr	x0, [sp, #40]
    48009d50:	f9400401 	ldr	x1, [x0, #8]
    48009d54:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009d58:	9129c000 	add	x0, x0, #0xa70
    48009d5c:	f9400000 	ldr	x0, [x0]
    48009d60:	91006000 	add	x0, x0, #0x18
    48009d64:	eb00003f 	cmp	x1, x0
    48009d68:	54000120 	b.eq	48009d8c <rt_malloc+0x204>  // b.none
                {
                    ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
    48009d6c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009d70:	91288000 	add	x0, x0, #0xa20
    48009d74:	f9400001 	ldr	x1, [x0]
    48009d78:	f94017e0 	ldr	x0, [sp, #40]
    48009d7c:	f9400400 	ldr	x0, [x0, #8]
    48009d80:	8b000020 	add	x0, x1, x0
    48009d84:	f9401be1 	ldr	x1, [sp, #48]
    48009d88:	f9000801 	str	x1, [x0, #16]
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
    48009d8c:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009d90:	9129e000 	add	x0, x0, #0xa78
    48009d94:	f9400001 	ldr	x1, [x0]
    48009d98:	f9400fe0 	ldr	x0, [sp, #24]
    48009d9c:	8b000020 	add	x0, x1, x0
    48009da0:	91006001 	add	x1, x0, #0x18
    48009da4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009da8:	9129e000 	add	x0, x0, #0xa78
    48009dac:	f9000001 	str	x1, [x0]
                if (max_mem < used_mem)
    48009db0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009db4:	912a0000 	add	x0, x0, #0xa80
    48009db8:	f9400001 	ldr	x1, [x0]
    48009dbc:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009dc0:	9129e000 	add	x0, x0, #0xa78
    48009dc4:	f9400000 	ldr	x0, [x0]
    48009dc8:	eb00003f 	cmp	x1, x0
    48009dcc:	54000502 	b.cs	48009e6c <rt_malloc+0x2e4>  // b.hs, b.nlast
                    max_mem = used_mem;
    48009dd0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009dd4:	9129e000 	add	x0, x0, #0xa78
    48009dd8:	f9400001 	ldr	x1, [x0]
    48009ddc:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009de0:	912a0000 	add	x0, x0, #0xa80
    48009de4:	f9000001 	str	x1, [x0]
    48009de8:	14000021 	b	48009e6c <rt_malloc+0x2e4>
                 * take care of this).
                 * -> near fit or excact fit: do not split, no mem2 creation
                 * also can't move mem->next directly behind mem, since mem->next
                 * will always be used at this point!
                 */
                mem->used = 1;
    48009dec:	f9401fe0 	ldr	x0, [sp, #56]
    48009df0:	52800021 	mov	w1, #0x1                   	// #1
    48009df4:	79000401 	strh	w1, [x0, #2]
#ifdef RT_MEM_STATS
                used_mem += mem->next - ((rt_uint8_t *)mem - heap_ptr);
    48009df8:	f9401fe0 	ldr	x0, [sp, #56]
    48009dfc:	f9400400 	ldr	x0, [x0, #8]
    48009e00:	f0000161 	adrp	x1, 48038000 <isr_table+0x1fd8>
    48009e04:	91288021 	add	x1, x1, #0xa20
    48009e08:	f9400021 	ldr	x1, [x1]
    48009e0c:	f9401fe2 	ldr	x2, [sp, #56]
    48009e10:	cb010041 	sub	x1, x2, x1
    48009e14:	cb010001 	sub	x1, x0, x1
    48009e18:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e1c:	9129e000 	add	x0, x0, #0xa78
    48009e20:	f9400000 	ldr	x0, [x0]
    48009e24:	8b000021 	add	x1, x1, x0
    48009e28:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e2c:	9129e000 	add	x0, x0, #0xa78
    48009e30:	f9000001 	str	x1, [x0]
                if (max_mem < used_mem)
    48009e34:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e38:	912a0000 	add	x0, x0, #0xa80
    48009e3c:	f9400001 	ldr	x1, [x0]
    48009e40:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e44:	9129e000 	add	x0, x0, #0xa78
    48009e48:	f9400000 	ldr	x0, [x0]
    48009e4c:	eb00003f 	cmp	x1, x0
    48009e50:	540000e2 	b.cs	48009e6c <rt_malloc+0x2e4>  // b.hs, b.nlast
                    max_mem = used_mem;
    48009e54:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e58:	9129e000 	add	x0, x0, #0xa78
    48009e5c:	f9400001 	ldr	x1, [x0]
    48009e60:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e64:	912a0000 	add	x0, x0, #0xa80
    48009e68:	f9000001 	str	x1, [x0]
#endif /* RT_MEM_STATS */
            }
            /* set memory block magic */
            mem->magic = HEAP_MAGIC;
    48009e6c:	f9401fe0 	ldr	x0, [sp, #56]
    48009e70:	5283d401 	mov	w1, #0x1ea0                	// #7840
    48009e74:	79000001 	strh	w1, [x0]
                rt_mem_setname(mem, rt_thread_self()->name);
            else
                rt_mem_setname(mem, "NONE");
#endif /* RT_USING_MEMTRACE */

            if (mem == lfree)
    48009e78:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e7c:	9128c000 	add	x0, x0, #0xa30
    48009e80:	f9400000 	ldr	x0, [x0]
    48009e84:	f9401fe1 	ldr	x1, [sp, #56]
    48009e88:	eb00003f 	cmp	x1, x0
    48009e8c:	540005e1 	b.ne	48009f48 <rt_malloc+0x3c0>  // b.any
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
    48009e90:	1400000c 	b	48009ec0 <rt_malloc+0x338>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];
    48009e94:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009e98:	91288000 	add	x0, x0, #0xa20
    48009e9c:	f9400001 	ldr	x1, [x0]
    48009ea0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009ea4:	9128c000 	add	x0, x0, #0xa30
    48009ea8:	f9400000 	ldr	x0, [x0]
    48009eac:	f9400400 	ldr	x0, [x0, #8]
    48009eb0:	8b000021 	add	x1, x1, x0
    48009eb4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009eb8:	9128c000 	add	x0, x0, #0xa30
    48009ebc:	f9000001 	str	x1, [x0]
                while (lfree->used && lfree != heap_end)
    48009ec0:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009ec4:	9128c000 	add	x0, x0, #0xa30
    48009ec8:	f9400000 	ldr	x0, [x0]
    48009ecc:	79400400 	ldrh	w0, [x0, #2]
    48009ed0:	7100001f 	cmp	w0, #0x0
    48009ed4:	54000120 	b.eq	48009ef8 <rt_malloc+0x370>  // b.none
    48009ed8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009edc:	9128c000 	add	x0, x0, #0xa30
    48009ee0:	f9400001 	ldr	x1, [x0]
    48009ee4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009ee8:	9128a000 	add	x0, x0, #0xa28
    48009eec:	f9400000 	ldr	x0, [x0]
    48009ef0:	eb00003f 	cmp	x1, x0
    48009ef4:	54fffd01 	b.ne	48009e94 <rt_malloc+0x30c>  // b.any

                RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
    48009ef8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009efc:	9128c000 	add	x0, x0, #0xa30
    48009f00:	f9400001 	ldr	x1, [x0]
    48009f04:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009f08:	9128a000 	add	x0, x0, #0xa28
    48009f0c:	f9400000 	ldr	x0, [x0]
    48009f10:	eb00003f 	cmp	x1, x0
    48009f14:	540001a0 	b.eq	48009f48 <rt_malloc+0x3c0>  // b.none
    48009f18:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009f1c:	9128c000 	add	x0, x0, #0xa30
    48009f20:	f9400000 	ldr	x0, [x0]
    48009f24:	79400400 	ldrh	w0, [x0, #2]
    48009f28:	7100001f 	cmp	w0, #0x0
    48009f2c:	540000e0 	b.eq	48009f48 <rt_malloc+0x3c0>  // b.none
    48009f30:	d2803022 	mov	x2, #0x181                 	// #385
    48009f34:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48009f38:	91022001 	add	x1, x0, #0x88
    48009f3c:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009f40:	91384000 	add	x0, x0, #0xe10
    48009f44:	94001849 	bl	48010068 <rt_assert_handler>
            }

            rt_sem_release(&heap_sem);
    48009f48:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009f4c:	9128e000 	add	x0, x0, #0xa38
    48009f50:	97fff0fe 	bl	48006348 <rt_sem_release>
            RT_ASSERT((rt_ubase_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_ubase_t)heap_end);
    48009f54:	f9401fe1 	ldr	x1, [sp, #56]
    48009f58:	f9400fe0 	ldr	x0, [sp, #24]
    48009f5c:	8b000020 	add	x0, x1, x0
    48009f60:	91006000 	add	x0, x0, #0x18
    48009f64:	f0000161 	adrp	x1, 48038000 <isr_table+0x1fd8>
    48009f68:	9128a021 	add	x1, x1, #0xa28
    48009f6c:	f9400021 	ldr	x1, [x1]
    48009f70:	eb01001f 	cmp	x0, x1
    48009f74:	540000e9 	b.ls	48009f90 <rt_malloc+0x408>  // b.plast
    48009f78:	d28030a2 	mov	x2, #0x185                 	// #389
    48009f7c:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48009f80:	91022001 	add	x1, x0, #0x88
    48009f84:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009f88:	9138e000 	add	x0, x0, #0xe38
    48009f8c:	94001837 	bl	48010068 <rt_assert_handler>
            RT_ASSERT((rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
    48009f90:	f9401fe0 	ldr	x0, [sp, #56]
    48009f94:	91006000 	add	x0, x0, #0x18
    48009f98:	92400400 	and	x0, x0, #0x3
    48009f9c:	f100001f 	cmp	x0, #0x0
    48009fa0:	540000e0 	b.eq	48009fbc <rt_malloc+0x434>  // b.none
    48009fa4:	d28030c2 	mov	x2, #0x186                 	// #390
    48009fa8:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48009fac:	91022001 	add	x1, x0, #0x88
    48009fb0:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009fb4:	913a0000 	add	x0, x0, #0xe80
    48009fb8:	9400182c 	bl	48010068 <rt_assert_handler>
            RT_ASSERT((((rt_ubase_t)mem) & (RT_ALIGN_SIZE - 1)) == 0);
    48009fbc:	f9401fe0 	ldr	x0, [sp, #56]
    48009fc0:	92400400 	and	x0, x0, #0x3
    48009fc4:	f100001f 	cmp	x0, #0x0
    48009fc8:	540000e0 	b.eq	48009fe4 <rt_malloc+0x45c>  // b.none
    48009fcc:	d28030e2 	mov	x2, #0x187                 	// #391
    48009fd0:	d00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48009fd4:	91022001 	add	x1, x0, #0x88
    48009fd8:	b00000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    48009fdc:	913b4000 	add	x0, x0, #0xed0
    48009fe0:	94001822 	bl	48010068 <rt_assert_handler>
            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         ("allocate memory at 0x%x, size: %d\n",
                          (rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_ubase_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
    48009fe4:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009fe8:	91284000 	add	x0, x0, #0xa10
    48009fec:	f9400000 	ldr	x0, [x0]
    48009ff0:	f100001f 	cmp	x0, #0x0
    48009ff4:	54000100 	b.eq	4800a014 <rt_malloc+0x48c>  // b.none
    48009ff8:	f0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    48009ffc:	91284000 	add	x0, x0, #0xa10
    4800a000:	f9400002 	ldr	x2, [x0]
    4800a004:	f9401fe0 	ldr	x0, [sp, #56]
    4800a008:	91006000 	add	x0, x0, #0x18
    4800a00c:	f9400fe1 	ldr	x1, [sp, #24]
    4800a010:	d63f0040 	blr	x2
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
    4800a014:	f9401fe0 	ldr	x0, [sp, #56]
    4800a018:	91006000 	add	x0, x0, #0x18
    4800a01c:	14000014 	b	4800a06c <rt_malloc+0x4e4>
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    4800a020:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a024:	91288000 	add	x0, x0, #0xa20
    4800a028:	f9400001 	ldr	x1, [x0]
    4800a02c:	f94027e0 	ldr	x0, [sp, #72]
    4800a030:	8b000020 	add	x0, x1, x0
    4800a034:	f9400400 	ldr	x0, [x0, #8]
    4800a038:	f90027e0 	str	x0, [sp, #72]
         ptr < mem_size_aligned - size;
    4800a03c:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a040:	9129c000 	add	x0, x0, #0xa70
    4800a044:	f9400001 	ldr	x1, [x0]
    4800a048:	f9400fe0 	ldr	x0, [sp, #24]
    4800a04c:	cb000020 	sub	x0, x1, x0
    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
    4800a050:	f94027e1 	ldr	x1, [sp, #72]
    4800a054:	eb00003f 	cmp	x1, x0
    4800a058:	54ffe0a3 	b.cc	48009c6c <rt_malloc+0xe4>  // b.lo, b.ul, b.last
        }
    }

    rt_sem_release(&heap_sem);
    4800a05c:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a060:	9128e000 	add	x0, x0, #0xa38
    4800a064:	97fff0b9 	bl	48006348 <rt_sem_release>

    return RT_NULL;
    4800a068:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800a06c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800a070:	d65f03c0 	ret

000000004800a074 <rt_realloc>:
 * @param newsize is the required new size.
 *
 * @return the changed memory block address.
 */
void *rt_realloc(void *rmem, rt_size_t newsize)
{
    4800a074:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4800a078:	910003fd 	mov	x29, sp
    4800a07c:	f9000fe0 	str	x0, [sp, #24]
    4800a080:	f9000be1 	str	x1, [sp, #16]
    rt_size_t size;
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;
    void *nmem;

    RT_DEBUG_NOT_IN_INTERRUPT;
    4800a084:	97ffe8ea 	bl	4800442c <rt_hw_interrupt_disable>
    4800a088:	f9002fe0 	str	x0, [sp, #88]
    4800a08c:	97fffda1 	bl	48009710 <rt_interrupt_get_nest>
    4800a090:	12001c00 	and	w0, w0, #0xff
    4800a094:	7100001f 	cmp	w0, #0x0
    4800a098:	54000180 	b.eq	4800a0c8 <rt_realloc+0x54>  // b.none
    4800a09c:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a0a0:	91026001 	add	x1, x0, #0x98
    4800a0a4:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a0a8:	91366000 	add	x0, x0, #0xd98
    4800a0ac:	94001721 	bl	4800fd30 <rt_kprintf>
    4800a0b0:	d2803582 	mov	x2, #0x1ac                 	// #428
    4800a0b4:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a0b8:	91026001 	add	x1, x0, #0x98
    4800a0bc:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a0c0:	91370000 	add	x0, x0, #0xdc0
    4800a0c4:	940017e9 	bl	48010068 <rt_assert_handler>
    4800a0c8:	f9402fe0 	ldr	x0, [sp, #88]
    4800a0cc:	97ffe8dc 	bl	4800443c <rt_hw_interrupt_enable>

    /* alignment size */
    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
    4800a0d0:	f9400be0 	ldr	x0, [sp, #16]
    4800a0d4:	91000c00 	add	x0, x0, #0x3
    4800a0d8:	927ef400 	and	x0, x0, #0xfffffffffffffffc
    4800a0dc:	f9000be0 	str	x0, [sp, #16]
    if (newsize > mem_size_aligned)
    4800a0e0:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a0e4:	9129c000 	add	x0, x0, #0xa70
    4800a0e8:	f9400000 	ldr	x0, [x0]
    4800a0ec:	f9400be1 	ldr	x1, [sp, #16]
    4800a0f0:	eb00003f 	cmp	x1, x0
    4800a0f4:	54000069 	b.ls	4800a100 <rt_realloc+0x8c>  // b.plast
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));

        return RT_NULL;
    4800a0f8:	d2800000 	mov	x0, #0x0                   	// #0
    4800a0fc:	1400009a 	b	4800a364 <rt_realloc+0x2f0>
    }
    else if (newsize == 0)
    4800a100:	f9400be0 	ldr	x0, [sp, #16]
    4800a104:	f100001f 	cmp	x0, #0x0
    4800a108:	540000a1 	b.ne	4800a11c <rt_realloc+0xa8>  // b.any
    {
        rt_free(rmem);
    4800a10c:	f9400fe0 	ldr	x0, [sp, #24]
    4800a110:	940000ad 	bl	4800a3c4 <rt_free>
        return RT_NULL;
    4800a114:	d2800000 	mov	x0, #0x0                   	// #0
    4800a118:	14000093 	b	4800a364 <rt_realloc+0x2f0>
    }

    /* allocate a new memory block */
    if (rmem == RT_NULL)
    4800a11c:	f9400fe0 	ldr	x0, [sp, #24]
    4800a120:	f100001f 	cmp	x0, #0x0
    4800a124:	54000081 	b.ne	4800a134 <rt_realloc+0xc0>  // b.any
        return rt_malloc(newsize);
    4800a128:	f9400be0 	ldr	x0, [sp, #16]
    4800a12c:	97fffe97 	bl	48009b88 <rt_malloc>
    4800a130:	1400008d 	b	4800a364 <rt_realloc+0x2f0>

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
    4800a134:	12800001 	mov	w1, #0xffffffff            	// #-1
    4800a138:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a13c:	9128e000 	add	x0, x0, #0xa38
    4800a140:	97ffefec 	bl	480060f0 <rt_sem_take>

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
    4800a144:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a148:	91288000 	add	x0, x0, #0xa20
    4800a14c:	f9400000 	ldr	x0, [x0]
    4800a150:	f9400fe1 	ldr	x1, [sp, #24]
    4800a154:	eb00003f 	cmp	x1, x0
    4800a158:	540000e3 	b.cc	4800a174 <rt_realloc+0x100>  // b.lo, b.ul, b.last
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    4800a15c:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a160:	9128a000 	add	x0, x0, #0xa28
    4800a164:	f9400000 	ldr	x0, [x0]
    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
    4800a168:	f9400fe1 	ldr	x1, [sp, #24]
    4800a16c:	eb00003f 	cmp	x1, x0
    4800a170:	540000c3 	b.cc	4800a188 <rt_realloc+0x114>  // b.lo, b.ul, b.last
    {
        /* illegal memory */
        rt_sem_release(&heap_sem);
    4800a174:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a178:	9128e000 	add	x0, x0, #0xa38
    4800a17c:	97fff073 	bl	48006348 <rt_sem_release>

        return rmem;
    4800a180:	f9400fe0 	ldr	x0, [sp, #24]
    4800a184:	14000078 	b	4800a364 <rt_realloc+0x2f0>
    }

    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
    4800a188:	f9400fe0 	ldr	x0, [sp, #24]
    4800a18c:	d1006000 	sub	x0, x0, #0x18
    4800a190:	f9002be0 	str	x0, [sp, #80]

    ptr = (rt_uint8_t *)mem - heap_ptr;
    4800a194:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a198:	91288000 	add	x0, x0, #0xa20
    4800a19c:	f9400000 	ldr	x0, [x0]
    4800a1a0:	f9402be1 	ldr	x1, [sp, #80]
    4800a1a4:	cb000020 	sub	x0, x1, x0
    4800a1a8:	f90027e0 	str	x0, [sp, #72]
    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    4800a1ac:	f9402be0 	ldr	x0, [sp, #80]
    4800a1b0:	f9400401 	ldr	x1, [x0, #8]
    4800a1b4:	f94027e0 	ldr	x0, [sp, #72]
    4800a1b8:	cb000020 	sub	x0, x1, x0
    4800a1bc:	d1006000 	sub	x0, x0, #0x18
    4800a1c0:	f90023e0 	str	x0, [sp, #64]
    if (size == newsize)
    4800a1c4:	f94023e1 	ldr	x1, [sp, #64]
    4800a1c8:	f9400be0 	ldr	x0, [sp, #16]
    4800a1cc:	eb00003f 	cmp	x1, x0
    4800a1d0:	540000c1 	b.ne	4800a1e8 <rt_realloc+0x174>  // b.any
    {
        /* the size is the same as */
        rt_sem_release(&heap_sem);
    4800a1d4:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a1d8:	9128e000 	add	x0, x0, #0xa38
    4800a1dc:	97fff05b 	bl	48006348 <rt_sem_release>

        return rmem;
    4800a1e0:	f9400fe0 	ldr	x0, [sp, #24]
    4800a1e4:	14000060 	b	4800a364 <rt_realloc+0x2f0>
    }

    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
    4800a1e8:	f9400be0 	ldr	x0, [sp, #16]
    4800a1ec:	9100c000 	add	x0, x0, #0x30
    4800a1f0:	f94023e1 	ldr	x1, [sp, #64]
    4800a1f4:	eb00003f 	cmp	x1, x0
    4800a1f8:	540008c9 	b.ls	4800a310 <rt_realloc+0x29c>  // b.plast
    {
        /* split memory block */
#ifdef RT_MEM_STATS
        used_mem -= (size - newsize);
    4800a1fc:	f9400be1 	ldr	x1, [sp, #16]
    4800a200:	f94023e0 	ldr	x0, [sp, #64]
    4800a204:	cb000021 	sub	x1, x1, x0
    4800a208:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a20c:	9129e000 	add	x0, x0, #0xa78
    4800a210:	f9400000 	ldr	x0, [x0]
    4800a214:	8b000021 	add	x1, x1, x0
    4800a218:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a21c:	9129e000 	add	x0, x0, #0xa78
    4800a220:	f9000001 	str	x1, [x0]
#endif /* RT_MEM_STATS */

        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    4800a224:	f94027e1 	ldr	x1, [sp, #72]
    4800a228:	f9400be0 	ldr	x0, [sp, #16]
    4800a22c:	8b000020 	add	x0, x1, x0
    4800a230:	91006000 	add	x0, x0, #0x18
    4800a234:	f9001be0 	str	x0, [sp, #48]
        mem2 = (struct heap_mem *)&heap_ptr[ptr2];
    4800a238:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a23c:	91288000 	add	x0, x0, #0xa20
    4800a240:	f9400001 	ldr	x1, [x0]
    4800a244:	f9401be0 	ldr	x0, [sp, #48]
    4800a248:	8b000020 	add	x0, x1, x0
    4800a24c:	f90017e0 	str	x0, [sp, #40]
        mem2->magic = HEAP_MAGIC;
    4800a250:	f94017e0 	ldr	x0, [sp, #40]
    4800a254:	5283d401 	mov	w1, #0x1ea0                	// #7840
    4800a258:	79000001 	strh	w1, [x0]
        mem2->used = 0;
    4800a25c:	f94017e0 	ldr	x0, [sp, #40]
    4800a260:	7900041f 	strh	wzr, [x0, #2]
        mem2->next = mem->next;
    4800a264:	f9402be0 	ldr	x0, [sp, #80]
    4800a268:	f9400401 	ldr	x1, [x0, #8]
    4800a26c:	f94017e0 	ldr	x0, [sp, #40]
    4800a270:	f9000401 	str	x1, [x0, #8]
        mem2->prev = ptr;
    4800a274:	f94017e0 	ldr	x0, [sp, #40]
    4800a278:	f94027e1 	ldr	x1, [sp, #72]
    4800a27c:	f9000801 	str	x1, [x0, #16]
#ifdef RT_USING_MEMTRACE
        rt_mem_setname(mem2, "    ");
#endif /* RT_USING_MEMTRACE */
        mem->next = ptr2;
    4800a280:	f9402be0 	ldr	x0, [sp, #80]
    4800a284:	f9401be1 	ldr	x1, [sp, #48]
    4800a288:	f9000401 	str	x1, [x0, #8]
        if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
    4800a28c:	f94017e0 	ldr	x0, [sp, #40]
    4800a290:	f9400401 	ldr	x1, [x0, #8]
    4800a294:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a298:	9129c000 	add	x0, x0, #0xa70
    4800a29c:	f9400000 	ldr	x0, [x0]
    4800a2a0:	91006000 	add	x0, x0, #0x18
    4800a2a4:	eb00003f 	cmp	x1, x0
    4800a2a8:	54000120 	b.eq	4800a2cc <rt_realloc+0x258>  // b.none
        {
            ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
    4800a2ac:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a2b0:	91288000 	add	x0, x0, #0xa20
    4800a2b4:	f9400001 	ldr	x1, [x0]
    4800a2b8:	f94017e0 	ldr	x0, [sp, #40]
    4800a2bc:	f9400400 	ldr	x0, [x0, #8]
    4800a2c0:	8b000020 	add	x0, x1, x0
    4800a2c4:	f9401be1 	ldr	x1, [sp, #48]
    4800a2c8:	f9000801 	str	x1, [x0, #16]
        }

        if (mem2 < lfree)
    4800a2cc:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a2d0:	9128c000 	add	x0, x0, #0xa30
    4800a2d4:	f9400000 	ldr	x0, [x0]
    4800a2d8:	f94017e1 	ldr	x1, [sp, #40]
    4800a2dc:	eb00003f 	cmp	x1, x0
    4800a2e0:	540000a2 	b.cs	4800a2f4 <rt_realloc+0x280>  // b.hs, b.nlast
        {
            /* the splited struct is now the lowest */
            lfree = mem2;
    4800a2e4:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a2e8:	9128c000 	add	x0, x0, #0xa30
    4800a2ec:	f94017e1 	ldr	x1, [sp, #40]
    4800a2f0:	f9000001 	str	x1, [x0]
        }

        plug_holes(mem2);
    4800a2f4:	f94017e0 	ldr	x0, [sp, #40]
    4800a2f8:	97fffd25 	bl	4800978c <plug_holes>

        rt_sem_release(&heap_sem);
    4800a2fc:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a300:	9128e000 	add	x0, x0, #0xa38
    4800a304:	97fff011 	bl	48006348 <rt_sem_release>

        return rmem;
    4800a308:	f9400fe0 	ldr	x0, [sp, #24]
    4800a30c:	14000016 	b	4800a364 <rt_realloc+0x2f0>
    }
    rt_sem_release(&heap_sem);
    4800a310:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a314:	9128e000 	add	x0, x0, #0xa38
    4800a318:	97fff00c 	bl	48006348 <rt_sem_release>

    /* expand memory */
    nmem = rt_malloc(newsize);
    4800a31c:	f9400be0 	ldr	x0, [sp, #16]
    4800a320:	97fffe1a 	bl	48009b88 <rt_malloc>
    4800a324:	f9001fe0 	str	x0, [sp, #56]
    if (nmem != RT_NULL) /* check memory */
    4800a328:	f9401fe0 	ldr	x0, [sp, #56]
    4800a32c:	f100001f 	cmp	x0, #0x0
    4800a330:	54000180 	b.eq	4800a360 <rt_realloc+0x2ec>  // b.none
    {
        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
    4800a334:	f94023e0 	ldr	x0, [sp, #64]
    4800a338:	f9400be2 	ldr	x2, [sp, #16]
    4800a33c:	f9400be1 	ldr	x1, [sp, #16]
    4800a340:	eb00005f 	cmp	x2, x0
    4800a344:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
    4800a348:	aa0003e2 	mov	x2, x0
    4800a34c:	f9400fe1 	ldr	x1, [sp, #24]
    4800a350:	f9401fe0 	ldr	x0, [sp, #56]
    4800a354:	9400104e 	bl	4800e48c <rt_memcpy>
        rt_free(rmem);
    4800a358:	f9400fe0 	ldr	x0, [sp, #24]
    4800a35c:	9400001a 	bl	4800a3c4 <rt_free>
    }

    return nmem;
    4800a360:	f9401fe0 	ldr	x0, [sp, #56]
}
    4800a364:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4800a368:	d65f03c0 	ret

000000004800a36c <rt_calloc>:
 * @param  size is the size of one object to allocate.
 *
 * @return pointer to allocated memory / NULL pointer if there is an error.
 */
void *rt_calloc(rt_size_t count, rt_size_t size)
{
    4800a36c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800a370:	910003fd 	mov	x29, sp
    4800a374:	f9000fe0 	str	x0, [sp, #24]
    4800a378:	f9000be1 	str	x1, [sp, #16]
    void *p;

    /* allocate 'count' objects of size 'size' */
    p = rt_malloc(count * size);
    4800a37c:	f9400fe1 	ldr	x1, [sp, #24]
    4800a380:	f9400be0 	ldr	x0, [sp, #16]
    4800a384:	9b007c20 	mul	x0, x1, x0
    4800a388:	97fffe00 	bl	48009b88 <rt_malloc>
    4800a38c:	f90017e0 	str	x0, [sp, #40]

    /* zero the memory */
    if (p)
    4800a390:	f94017e0 	ldr	x0, [sp, #40]
    4800a394:	f100001f 	cmp	x0, #0x0
    4800a398:	54000100 	b.eq	4800a3b8 <rt_calloc+0x4c>  // b.none
        rt_memset(p, 0, count * size);
    4800a39c:	f9400fe1 	ldr	x1, [sp, #24]
    4800a3a0:	f9400be0 	ldr	x0, [sp, #16]
    4800a3a4:	9b007c20 	mul	x0, x1, x0
    4800a3a8:	aa0003e2 	mov	x2, x0
    4800a3ac:	52800001 	mov	w1, #0x0                   	// #0
    4800a3b0:	f94017e0 	ldr	x0, [sp, #40]
    4800a3b4:	94000fde 	bl	4800e32c <rt_memset>

    return p;
    4800a3b8:	f94017e0 	ldr	x0, [sp, #40]
}
    4800a3bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800a3c0:	d65f03c0 	ret

000000004800a3c4 <rt_free>:
 *        rt_malloc. The released memory block is taken back to system heap.
 *
 * @param rmem the address of memory which will be released.
 */
void rt_free(void *rmem)
{
    4800a3c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800a3c8:	910003fd 	mov	x29, sp
    4800a3cc:	f9000fe0 	str	x0, [sp, #24]
    struct heap_mem *mem;

    if (rmem == RT_NULL)
    4800a3d0:	f9400fe0 	ldr	x0, [sp, #24]
    4800a3d4:	f100001f 	cmp	x0, #0x0
    4800a3d8:	540013c0 	b.eq	4800a650 <rt_free+0x28c>  // b.none
        return;

    RT_DEBUG_NOT_IN_INTERRUPT;
    4800a3dc:	97ffe814 	bl	4800442c <rt_hw_interrupt_disable>
    4800a3e0:	f90017e0 	str	x0, [sp, #40]
    4800a3e4:	97fffccb 	bl	48009710 <rt_interrupt_get_nest>
    4800a3e8:	12001c00 	and	w0, w0, #0xff
    4800a3ec:	7100001f 	cmp	w0, #0x0
    4800a3f0:	54000180 	b.eq	4800a420 <rt_free+0x5c>  // b.none
    4800a3f4:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a3f8:	9102a001 	add	x1, x0, #0xa8
    4800a3fc:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a400:	91366000 	add	x0, x0, #0xd98
    4800a404:	9400164b 	bl	4800fd30 <rt_kprintf>
    4800a408:	d2804602 	mov	x2, #0x230                 	// #560
    4800a40c:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a410:	9102a001 	add	x1, x0, #0xa8
    4800a414:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a418:	91370000 	add	x0, x0, #0xdc0
    4800a41c:	94001713 	bl	48010068 <rt_assert_handler>
    4800a420:	f94017e0 	ldr	x0, [sp, #40]
    4800a424:	97ffe806 	bl	4800443c <rt_hw_interrupt_enable>

    RT_ASSERT((((rt_ubase_t)rmem) & (RT_ALIGN_SIZE - 1)) == 0);
    4800a428:	f9400fe0 	ldr	x0, [sp, #24]
    4800a42c:	92400400 	and	x0, x0, #0x3
    4800a430:	f100001f 	cmp	x0, #0x0
    4800a434:	540000e0 	b.eq	4800a450 <rt_free+0x8c>  // b.none
    4800a438:	d2804642 	mov	x2, #0x232                 	// #562
    4800a43c:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a440:	9102a001 	add	x1, x0, #0xa8
    4800a444:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a448:	913c0000 	add	x0, x0, #0xf00
    4800a44c:	94001707 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
    4800a450:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a454:	91288000 	add	x0, x0, #0xa20
    4800a458:	f9400000 	ldr	x0, [x0]
    4800a45c:	f9400fe1 	ldr	x1, [sp, #24]
    4800a460:	eb00003f 	cmp	x1, x0
    4800a464:	540000e3 	b.cc	4800a480 <rt_free+0xbc>  // b.lo, b.ul, b.last
    4800a468:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a46c:	9128a000 	add	x0, x0, #0xa28
    4800a470:	f9400000 	ldr	x0, [x0]
    4800a474:	f9400fe1 	ldr	x1, [sp, #24]
    4800a478:	eb00003f 	cmp	x1, x0
    4800a47c:	540000e3 	b.cc	4800a498 <rt_free+0xd4>  // b.lo, b.ul, b.last
    4800a480:	d2804662 	mov	x2, #0x233                 	// #563
    4800a484:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a488:	9102a001 	add	x1, x0, #0xa8
    4800a48c:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a490:	913cc000 	add	x0, x0, #0xf30
    4800a494:	940016f5 	bl	48010068 <rt_assert_handler>
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
    4800a498:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a49c:	91286000 	add	x0, x0, #0xa18
    4800a4a0:	f9400000 	ldr	x0, [x0]
    4800a4a4:	f100001f 	cmp	x0, #0x0
    4800a4a8:	540000c0 	b.eq	4800a4c0 <rt_free+0xfc>  // b.none
    4800a4ac:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a4b0:	91286000 	add	x0, x0, #0xa18
    4800a4b4:	f9400001 	ldr	x1, [x0]
    4800a4b8:	f9400fe0 	ldr	x0, [sp, #24]
    4800a4bc:	d63f0020 	blr	x1

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
    4800a4c0:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a4c4:	91288000 	add	x0, x0, #0xa20
    4800a4c8:	f9400000 	ldr	x0, [x0]
    4800a4cc:	f9400fe1 	ldr	x1, [sp, #24]
    4800a4d0:	eb00003f 	cmp	x1, x0
    4800a4d4:	54000c23 	b.cc	4800a658 <rt_free+0x294>  // b.lo, b.ul, b.last
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    4800a4d8:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a4dc:	9128a000 	add	x0, x0, #0xa28
    4800a4e0:	f9400000 	ldr	x0, [x0]
    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
    4800a4e4:	f9400fe1 	ldr	x1, [sp, #24]
    4800a4e8:	eb00003f 	cmp	x1, x0
    4800a4ec:	54000b62 	b.cs	4800a658 <rt_free+0x294>  // b.hs, b.nlast

        return;
    }

    /* Get the corresponding struct heap_mem ... */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
    4800a4f0:	f9400fe0 	ldr	x0, [sp, #24]
    4800a4f4:	d1006000 	sub	x0, x0, #0x18
    4800a4f8:	f90013e0 	str	x0, [sp, #32]
                  (rt_ubase_t)rmem,
                  (rt_ubase_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));


    /* protect the heap from concurrent access */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
    4800a4fc:	12800001 	mov	w1, #0xffffffff            	// #-1
    4800a500:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a504:	9128e000 	add	x0, x0, #0xa38
    4800a508:	97ffeefa 	bl	480060f0 <rt_sem_take>

    /* ... which has to be in a used state ... */
    if (!mem->used || mem->magic != HEAP_MAGIC)
    4800a50c:	f94013e0 	ldr	x0, [sp, #32]
    4800a510:	79400400 	ldrh	w0, [x0, #2]
    4800a514:	7100001f 	cmp	w0, #0x0
    4800a518:	540000c0 	b.eq	4800a530 <rt_free+0x16c>  // b.none
    4800a51c:	f94013e0 	ldr	x0, [sp, #32]
    4800a520:	79400001 	ldrh	w1, [x0]
    4800a524:	5283d400 	mov	w0, #0x1ea0                	// #7840
    4800a528:	6b00003f 	cmp	w1, w0
    4800a52c:	540001e0 	b.eq	4800a568 <rt_free+0x1a4>  // b.none
    {
        rt_kprintf("to free a bad data block:\n");
    4800a530:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a534:	913e4000 	add	x0, x0, #0xf90
    4800a538:	940015fe 	bl	4800fd30 <rt_kprintf>
        rt_kprintf("mem: 0x%08x, used flag: %d, magic code: 0x%04x\n", mem, mem->used, mem->magic);
    4800a53c:	f94013e0 	ldr	x0, [sp, #32]
    4800a540:	79400400 	ldrh	w0, [x0, #2]
    4800a544:	2a0003e1 	mov	w1, w0
    4800a548:	f94013e0 	ldr	x0, [sp, #32]
    4800a54c:	79400000 	ldrh	w0, [x0]
    4800a550:	2a0003e3 	mov	w3, w0
    4800a554:	2a0103e2 	mov	w2, w1
    4800a558:	f94013e1 	ldr	x1, [sp, #32]
    4800a55c:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a560:	913ec000 	add	x0, x0, #0xfb0
    4800a564:	940015f3 	bl	4800fd30 <rt_kprintf>
    }
    RT_ASSERT(mem->used);
    4800a568:	f94013e0 	ldr	x0, [sp, #32]
    4800a56c:	79400400 	ldrh	w0, [x0, #2]
    4800a570:	7100001f 	cmp	w0, #0x0
    4800a574:	540000e1 	b.ne	4800a590 <rt_free+0x1cc>  // b.any
    4800a578:	d2804a42 	mov	x2, #0x252                 	// #594
    4800a57c:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a580:	9102a001 	add	x1, x0, #0xa8
    4800a584:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a588:	913f8000 	add	x0, x0, #0xfe0
    4800a58c:	940016b7 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(mem->magic == HEAP_MAGIC);
    4800a590:	f94013e0 	ldr	x0, [sp, #32]
    4800a594:	79400001 	ldrh	w1, [x0]
    4800a598:	5283d400 	mov	w0, #0x1ea0                	// #7840
    4800a59c:	6b00003f 	cmp	w1, w0
    4800a5a0:	540000e0 	b.eq	4800a5bc <rt_free+0x1f8>  // b.none
    4800a5a4:	d2804a62 	mov	x2, #0x253                 	// #595
    4800a5a8:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a5ac:	9102a001 	add	x1, x0, #0xa8
    4800a5b0:	900000a0 	adrp	x0, 4801e000 <__FUNCTION__.14+0x10>
    4800a5b4:	913fc000 	add	x0, x0, #0xff0
    4800a5b8:	940016ac 	bl	48010068 <rt_assert_handler>
    /* ... and is now unused. */
    mem->used  = 0;
    4800a5bc:	f94013e0 	ldr	x0, [sp, #32]
    4800a5c0:	7900041f 	strh	wzr, [x0, #2]
    mem->magic = HEAP_MAGIC;
    4800a5c4:	f94013e0 	ldr	x0, [sp, #32]
    4800a5c8:	5283d401 	mov	w1, #0x1ea0                	// #7840
    4800a5cc:	79000001 	strh	w1, [x0]
#ifdef RT_USING_MEMTRACE
    rt_mem_setname(mem, "    ");
#endif /* RT_USING_MEMTRACE */

    if (mem < lfree)
    4800a5d0:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a5d4:	9128c000 	add	x0, x0, #0xa30
    4800a5d8:	f9400000 	ldr	x0, [x0]
    4800a5dc:	f94013e1 	ldr	x1, [sp, #32]
    4800a5e0:	eb00003f 	cmp	x1, x0
    4800a5e4:	540000a2 	b.cs	4800a5f8 <rt_free+0x234>  // b.hs, b.nlast
    {
        /* the newly freed struct is now the lowest */
        lfree = mem;
    4800a5e8:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a5ec:	9128c000 	add	x0, x0, #0xa30
    4800a5f0:	f94013e1 	ldr	x1, [sp, #32]
    4800a5f4:	f9000001 	str	x1, [x0]
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem->next - ((rt_uint8_t *)mem - heap_ptr));
    4800a5f8:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a5fc:	91288000 	add	x0, x0, #0xa20
    4800a600:	f9400000 	ldr	x0, [x0]
    4800a604:	f94013e1 	ldr	x1, [sp, #32]
    4800a608:	cb000020 	sub	x0, x1, x0
    4800a60c:	aa0003e1 	mov	x1, x0
    4800a610:	f94013e0 	ldr	x0, [sp, #32]
    4800a614:	f9400400 	ldr	x0, [x0, #8]
    4800a618:	cb000021 	sub	x1, x1, x0
    4800a61c:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a620:	9129e000 	add	x0, x0, #0xa78
    4800a624:	f9400000 	ldr	x0, [x0]
    4800a628:	8b000021 	add	x1, x1, x0
    4800a62c:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a630:	9129e000 	add	x0, x0, #0xa78
    4800a634:	f9000001 	str	x1, [x0]
#endif /* RT_MEM_STATS */

    /* finally, see if prev or next are free also */
    plug_holes(mem);
    4800a638:	f94013e0 	ldr	x0, [sp, #32]
    4800a63c:	97fffc54 	bl	4800978c <plug_holes>
    rt_sem_release(&heap_sem);
    4800a640:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a644:	9128e000 	add	x0, x0, #0xa38
    4800a648:	97ffef40 	bl	48006348 <rt_sem_release>
    4800a64c:	14000004 	b	4800a65c <rt_free+0x298>
        return;
    4800a650:	d503201f 	nop
    4800a654:	14000002 	b	4800a65c <rt_free+0x298>
        return;
    4800a658:	d503201f 	nop
}
    4800a65c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800a660:	d65f03c0 	ret

000000004800a664 <rt_memory_info>:
* @param max_used is a pointer to get the maximum memory used.
*/
void rt_memory_info(rt_uint32_t *total,
                    rt_uint32_t *used,
                    rt_uint32_t *max_used)
{
    4800a664:	d10083ff 	sub	sp, sp, #0x20
    4800a668:	f9000fe0 	str	x0, [sp, #24]
    4800a66c:	f9000be1 	str	x1, [sp, #16]
    4800a670:	f90007e2 	str	x2, [sp, #8]
    if (total != RT_NULL)
    4800a674:	f9400fe0 	ldr	x0, [sp, #24]
    4800a678:	f100001f 	cmp	x0, #0x0
    4800a67c:	540000e0 	b.eq	4800a698 <rt_memory_info+0x34>  // b.none
        *total = mem_size_aligned;
    4800a680:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a684:	9129c000 	add	x0, x0, #0xa70
    4800a688:	f9400000 	ldr	x0, [x0]
    4800a68c:	2a0003e1 	mov	w1, w0
    4800a690:	f9400fe0 	ldr	x0, [sp, #24]
    4800a694:	b9000001 	str	w1, [x0]
    if (used  != RT_NULL)
    4800a698:	f9400be0 	ldr	x0, [sp, #16]
    4800a69c:	f100001f 	cmp	x0, #0x0
    4800a6a0:	540000e0 	b.eq	4800a6bc <rt_memory_info+0x58>  // b.none
        *used = used_mem;
    4800a6a4:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a6a8:	9129e000 	add	x0, x0, #0xa78
    4800a6ac:	f9400000 	ldr	x0, [x0]
    4800a6b0:	2a0003e1 	mov	w1, w0
    4800a6b4:	f9400be0 	ldr	x0, [sp, #16]
    4800a6b8:	b9000001 	str	w1, [x0]
    if (max_used != RT_NULL)
    4800a6bc:	f94007e0 	ldr	x0, [sp, #8]
    4800a6c0:	f100001f 	cmp	x0, #0x0
    4800a6c4:	540000e0 	b.eq	4800a6e0 <rt_memory_info+0x7c>  // b.none
        *max_used = max_mem;
    4800a6c8:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a6cc:	912a0000 	add	x0, x0, #0xa80
    4800a6d0:	f9400000 	ldr	x0, [x0]
    4800a6d4:	2a0003e1 	mov	w1, w0
    4800a6d8:	f94007e0 	ldr	x0, [sp, #8]
    4800a6dc:	b9000001 	str	w1, [x0]
}
    4800a6e0:	d503201f 	nop
    4800a6e4:	910083ff 	add	sp, sp, #0x20
    4800a6e8:	d65f03c0 	ret

000000004800a6ec <list_mem>:

#ifdef RT_USING_FINSH
#include <finsh.h>

void list_mem(void)
{
    4800a6ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4800a6f0:	910003fd 	mov	x29, sp
    rt_kprintf("total memory: %d\n", mem_size_aligned);
    4800a6f4:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a6f8:	9129c000 	add	x0, x0, #0xa70
    4800a6fc:	f9400000 	ldr	x0, [x0]
    4800a700:	aa0003e1 	mov	x1, x0
    4800a704:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a708:	91004000 	add	x0, x0, #0x10
    4800a70c:	94001589 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("used memory : %d\n", used_mem);
    4800a710:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a714:	9129e000 	add	x0, x0, #0xa78
    4800a718:	f9400000 	ldr	x0, [x0]
    4800a71c:	aa0003e1 	mov	x1, x0
    4800a720:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a724:	9100a000 	add	x0, x0, #0x28
    4800a728:	94001582 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("maximum allocated memory: %d\n", max_mem);
    4800a72c:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800a730:	912a0000 	add	x0, x0, #0xa80
    4800a734:	f9400000 	ldr	x0, [x0]
    4800a738:	aa0003e1 	mov	x1, x0
    4800a73c:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800a740:	91010000 	add	x0, x0, #0x40
    4800a744:	9400157b 	bl	4800fd30 <rt_kprintf>
}
    4800a748:	d503201f 	nop
    4800a74c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4800a750:	d65f03c0 	ret

000000004800a754 <rt_list_init>:
{
    4800a754:	d10043ff 	sub	sp, sp, #0x10
    4800a758:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    4800a75c:	f94007e0 	ldr	x0, [sp, #8]
    4800a760:	f94007e1 	ldr	x1, [sp, #8]
    4800a764:	f9000401 	str	x1, [x0, #8]
    4800a768:	f94007e0 	ldr	x0, [sp, #8]
    4800a76c:	f9400401 	ldr	x1, [x0, #8]
    4800a770:	f94007e0 	ldr	x0, [sp, #8]
    4800a774:	f9000001 	str	x1, [x0]
}
    4800a778:	d503201f 	nop
    4800a77c:	910043ff 	add	sp, sp, #0x10
    4800a780:	d65f03c0 	ret

000000004800a784 <rt_list_insert_after>:
{
    4800a784:	d10043ff 	sub	sp, sp, #0x10
    4800a788:	f90007e0 	str	x0, [sp, #8]
    4800a78c:	f90003e1 	str	x1, [sp]
    l->next->prev = n;
    4800a790:	f94007e0 	ldr	x0, [sp, #8]
    4800a794:	f9400000 	ldr	x0, [x0]
    4800a798:	f94003e1 	ldr	x1, [sp]
    4800a79c:	f9000401 	str	x1, [x0, #8]
    n->next = l->next;
    4800a7a0:	f94007e0 	ldr	x0, [sp, #8]
    4800a7a4:	f9400001 	ldr	x1, [x0]
    4800a7a8:	f94003e0 	ldr	x0, [sp]
    4800a7ac:	f9000001 	str	x1, [x0]
    l->next = n;
    4800a7b0:	f94007e0 	ldr	x0, [sp, #8]
    4800a7b4:	f94003e1 	ldr	x1, [sp]
    4800a7b8:	f9000001 	str	x1, [x0]
    n->prev = l;
    4800a7bc:	f94003e0 	ldr	x0, [sp]
    4800a7c0:	f94007e1 	ldr	x1, [sp, #8]
    4800a7c4:	f9000401 	str	x1, [x0, #8]
}
    4800a7c8:	d503201f 	nop
    4800a7cc:	910043ff 	add	sp, sp, #0x10
    4800a7d0:	d65f03c0 	ret

000000004800a7d4 <rt_list_remove>:
{
    4800a7d4:	d10043ff 	sub	sp, sp, #0x10
    4800a7d8:	f90007e0 	str	x0, [sp, #8]
    n->next->prev = n->prev;
    4800a7dc:	f94007e0 	ldr	x0, [sp, #8]
    4800a7e0:	f9400000 	ldr	x0, [x0]
    4800a7e4:	f94007e1 	ldr	x1, [sp, #8]
    4800a7e8:	f9400421 	ldr	x1, [x1, #8]
    4800a7ec:	f9000401 	str	x1, [x0, #8]
    n->prev->next = n->next;
    4800a7f0:	f94007e0 	ldr	x0, [sp, #8]
    4800a7f4:	f9400400 	ldr	x0, [x0, #8]
    4800a7f8:	f94007e1 	ldr	x1, [sp, #8]
    4800a7fc:	f9400021 	ldr	x1, [x1]
    4800a800:	f9000001 	str	x1, [x0]
    n->next = n->prev = n;
    4800a804:	f94007e0 	ldr	x0, [sp, #8]
    4800a808:	f94007e1 	ldr	x1, [sp, #8]
    4800a80c:	f9000401 	str	x1, [x0, #8]
    4800a810:	f94007e0 	ldr	x0, [sp, #8]
    4800a814:	f9400401 	ldr	x1, [x0, #8]
    4800a818:	f94007e0 	ldr	x0, [sp, #8]
    4800a81c:	f9000001 	str	x1, [x0]
}
    4800a820:	d503201f 	nop
    4800a824:	910043ff 	add	sp, sp, #0x10
    4800a828:	d65f03c0 	ret

000000004800a82c <rt_list_isempty>:
{
    4800a82c:	d10043ff 	sub	sp, sp, #0x10
    4800a830:	f90007e0 	str	x0, [sp, #8]
    return l->next == l;
    4800a834:	f94007e0 	ldr	x0, [sp, #8]
    4800a838:	f9400000 	ldr	x0, [x0]
    4800a83c:	f94007e1 	ldr	x1, [sp, #8]
    4800a840:	eb00003f 	cmp	x1, x0
    4800a844:	1a9f17e0 	cset	w0, eq  // eq = none
    4800a848:	12001c00 	and	w0, w0, #0xff
}
    4800a84c:	910043ff 	add	sp, sp, #0x10
    4800a850:	d65f03c0 	ret

000000004800a854 <rt_timer_enter_sethook>:
 *        which will be invoked when enter timer timeout callback function.
 *
 * @param hook is the function point of timer
 */
void rt_timer_enter_sethook(void (*hook)(struct rt_timer *timer))
{
    4800a854:	d10043ff 	sub	sp, sp, #0x10
    4800a858:	f90007e0 	str	x0, [sp, #8]
    rt_timer_enter_hook = hook;
    4800a85c:	f0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800a860:	910e0000 	add	x0, x0, #0x380
    4800a864:	f94007e1 	ldr	x1, [sp, #8]
    4800a868:	f9000001 	str	x1, [x0]
}
    4800a86c:	d503201f 	nop
    4800a870:	910043ff 	add	sp, sp, #0x10
    4800a874:	d65f03c0 	ret

000000004800a878 <rt_timer_exit_sethook>:
 *        invoked when exit timer timeout callback function.
 *
 * @param hook is the function point of timer
 */
void rt_timer_exit_sethook(void (*hook)(struct rt_timer *timer))
{
    4800a878:	d10043ff 	sub	sp, sp, #0x10
    4800a87c:	f90007e0 	str	x0, [sp, #8]
    rt_timer_exit_hook = hook;
    4800a880:	f0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800a884:	910e2000 	add	x0, x0, #0x388
    4800a888:	f94007e1 	ldr	x1, [sp, #8]
    4800a88c:	f9000001 	str	x1, [x0]
}
    4800a890:	d503201f 	nop
    4800a894:	910043ff 	add	sp, sp, #0x10
    4800a898:	d65f03c0 	ret

000000004800a89c <_timer_init>:
static void _timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
    4800a89c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800a8a0:	910003fd 	mov	x29, sp
    4800a8a4:	f90017e0 	str	x0, [sp, #40]
    4800a8a8:	f90013e1 	str	x1, [sp, #32]
    4800a8ac:	f9000fe2 	str	x2, [sp, #24]
    4800a8b0:	b90017e3 	str	w3, [sp, #20]
    4800a8b4:	39004fe4 	strb	w4, [sp, #19]
    int i;

    /* set flag */
    timer->parent.flag  = flag;
    4800a8b8:	f94017e0 	ldr	x0, [sp, #40]
    4800a8bc:	39404fe1 	ldrb	w1, [sp, #19]
    4800a8c0:	39002401 	strb	w1, [x0, #9]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800a8c4:	f94017e0 	ldr	x0, [sp, #40]
    4800a8c8:	39402400 	ldrb	w0, [x0, #9]
    4800a8cc:	121f7800 	and	w0, w0, #0xfffffffe
    4800a8d0:	12001c01 	and	w1, w0, #0xff
    4800a8d4:	f94017e0 	ldr	x0, [sp, #40]
    4800a8d8:	39002401 	strb	w1, [x0, #9]

    timer->timeout_func = timeout;
    4800a8dc:	f94017e0 	ldr	x0, [sp, #40]
    4800a8e0:	f94013e1 	ldr	x1, [sp, #32]
    4800a8e4:	f9001801 	str	x1, [x0, #48]
    timer->parameter    = parameter;
    4800a8e8:	f94017e0 	ldr	x0, [sp, #40]
    4800a8ec:	f9400fe1 	ldr	x1, [sp, #24]
    4800a8f0:	f9001c01 	str	x1, [x0, #56]

    timer->timeout_tick = 0;
    4800a8f4:	f94017e0 	ldr	x0, [sp, #40]
    4800a8f8:	b900441f 	str	wzr, [x0, #68]
    timer->init_tick    = time;
    4800a8fc:	f94017e0 	ldr	x0, [sp, #40]
    4800a900:	b94017e1 	ldr	w1, [sp, #20]
    4800a904:	b9004001 	str	w1, [x0, #64]

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
    4800a908:	b9003fff 	str	wzr, [sp, #60]
    4800a90c:	1400000a 	b	4800a934 <_timer_init+0x98>
    {
        rt_list_init(&(timer->row[i]));
    4800a910:	b9803fe0 	ldrsw	x0, [sp, #60]
    4800a914:	91000800 	add	x0, x0, #0x2
    4800a918:	d37cec00 	lsl	x0, x0, #4
    4800a91c:	f94017e1 	ldr	x1, [sp, #40]
    4800a920:	8b000020 	add	x0, x1, x0
    4800a924:	97ffff8c 	bl	4800a754 <rt_list_init>
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
    4800a928:	b9403fe0 	ldr	w0, [sp, #60]
    4800a92c:	11000400 	add	w0, w0, #0x1
    4800a930:	b9003fe0 	str	w0, [sp, #60]
    4800a934:	b9403fe0 	ldr	w0, [sp, #60]
    4800a938:	7100001f 	cmp	w0, #0x0
    4800a93c:	54fffead 	b.le	4800a910 <_timer_init+0x74>
    }
}
    4800a940:	d503201f 	nop
    4800a944:	d503201f 	nop
    4800a948:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800a94c:	d65f03c0 	ret

000000004800a950 <_timer_list_next_timeout>:
 * @param timer_list is the array of time list
 *
 * @return the next timer's ticks
 */
static rt_tick_t _timer_list_next_timeout(rt_list_t timer_list[])
{
    4800a950:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800a954:	910003fd 	mov	x29, sp
    4800a958:	f9000bf3 	str	x19, [sp, #16]
    4800a95c:	f90017e0 	str	x0, [sp, #40]
    struct rt_timer *timer;
    register rt_base_t level;
    rt_tick_t timeout_tick = RT_TICK_MAX;
    4800a960:	12800000 	mov	w0, #0xffffffff            	// #-1
    4800a964:	b9003fe0 	str	w0, [sp, #60]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800a968:	97ffe6b1 	bl	4800442c <rt_hw_interrupt_disable>
    4800a96c:	aa0003f3 	mov	x19, x0

    if (!rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
    4800a970:	f94017e0 	ldr	x0, [sp, #40]
    4800a974:	97ffffae 	bl	4800a82c <rt_list_isempty>
    4800a978:	7100001f 	cmp	w0, #0x0
    4800a97c:	54000101 	b.ne	4800a99c <_timer_list_next_timeout+0x4c>  // b.any
    {
        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
    4800a980:	f94017e0 	ldr	x0, [sp, #40]
    4800a984:	f9400000 	ldr	x0, [x0]
    4800a988:	d1008000 	sub	x0, x0, #0x20
    4800a98c:	f9001be0 	str	x0, [sp, #48]
                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
        timeout_tick = timer->timeout_tick;
    4800a990:	f9401be0 	ldr	x0, [sp, #48]
    4800a994:	b9404400 	ldr	w0, [x0, #68]
    4800a998:	b9003fe0 	str	w0, [sp, #60]
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800a99c:	aa1303e0 	mov	x0, x19
    4800a9a0:	97ffe6a7 	bl	4800443c <rt_hw_interrupt_enable>

    return timeout_tick;
    4800a9a4:	b9403fe0 	ldr	w0, [sp, #60]
}
    4800a9a8:	f9400bf3 	ldr	x19, [sp, #16]
    4800a9ac:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800a9b0:	d65f03c0 	ret

000000004800a9b4 <_timer_remove>:
 * @brief Remove the timer
 *
 * @param timer the point of the timer
 */
rt_inline void _timer_remove(rt_timer_t timer)
{
    4800a9b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800a9b8:	910003fd 	mov	x29, sp
    4800a9bc:	f9000fe0 	str	x0, [sp, #24]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
    4800a9c0:	b9002fff 	str	wzr, [sp, #44]
    4800a9c4:	1400000a 	b	4800a9ec <_timer_remove+0x38>
    {
        rt_list_remove(&timer->row[i]);
    4800a9c8:	b9802fe0 	ldrsw	x0, [sp, #44]
    4800a9cc:	91000800 	add	x0, x0, #0x2
    4800a9d0:	d37cec00 	lsl	x0, x0, #4
    4800a9d4:	f9400fe1 	ldr	x1, [sp, #24]
    4800a9d8:	8b000020 	add	x0, x1, x0
    4800a9dc:	97ffff7e 	bl	4800a7d4 <rt_list_remove>
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
    4800a9e0:	b9402fe0 	ldr	w0, [sp, #44]
    4800a9e4:	11000400 	add	w0, w0, #0x1
    4800a9e8:	b9002fe0 	str	w0, [sp, #44]
    4800a9ec:	b9402fe0 	ldr	w0, [sp, #44]
    4800a9f0:	7100001f 	cmp	w0, #0x0
    4800a9f4:	54fffead 	b.le	4800a9c8 <_timer_remove+0x14>
    }
}
    4800a9f8:	d503201f 	nop
    4800a9fc:	d503201f 	nop
    4800aa00:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800aa04:	d65f03c0 	ret

000000004800aa08 <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
    4800aa08:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800aa0c:	910003fd 	mov	x29, sp
    4800aa10:	f9001fe0 	str	x0, [sp, #56]
    4800aa14:	f9001be1 	str	x1, [sp, #48]
    4800aa18:	f90017e2 	str	x2, [sp, #40]
    4800aa1c:	f90013e3 	str	x3, [sp, #32]
    4800aa20:	b9001fe4 	str	w4, [sp, #28]
    4800aa24:	39006fe5 	strb	w5, [sp, #27]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
    4800aa28:	f9401fe0 	ldr	x0, [sp, #56]
    4800aa2c:	f100001f 	cmp	x0, #0x0
    4800aa30:	540000e1 	b.ne	4800aa4c <rt_timer_init+0x44>  // b.any
    4800aa34:	d2801ee2 	mov	x2, #0xf7                  	// #247
    4800aa38:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aa3c:	91068001 	add	x1, x0, #0x1a0
    4800aa40:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aa44:	9102c000 	add	x0, x0, #0xb0
    4800aa48:	94001588 	bl	48010068 <rt_assert_handler>

    /* timer object initialization */
    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);
    4800aa4c:	f9401fe0 	ldr	x0, [sp, #56]
    4800aa50:	f9401be2 	ldr	x2, [sp, #48]
    4800aa54:	52800141 	mov	w1, #0xa                   	// #10
    4800aa58:	94000c81 	bl	4800dc5c <rt_object_init>

    _timer_init(timer, timeout, parameter, time, flag);
    4800aa5c:	39406fe4 	ldrb	w4, [sp, #27]
    4800aa60:	b9401fe3 	ldr	w3, [sp, #28]
    4800aa64:	f94013e2 	ldr	x2, [sp, #32]
    4800aa68:	f94017e1 	ldr	x1, [sp, #40]
    4800aa6c:	f9401fe0 	ldr	x0, [sp, #56]
    4800aa70:	97ffff8b 	bl	4800a89c <_timer_init>
}
    4800aa74:	d503201f 	nop
    4800aa78:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800aa7c:	d65f03c0 	ret

000000004800aa80 <rt_timer_detach>:
 * @param timer is the timer to be detached
 *
 * @return the status of detach
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
    4800aa80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800aa84:	910003fd 	mov	x29, sp
    4800aa88:	f9000bf3 	str	x19, [sp, #16]
    4800aa8c:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
    4800aa90:	f94017e0 	ldr	x0, [sp, #40]
    4800aa94:	f100001f 	cmp	x0, #0x0
    4800aa98:	540000e1 	b.ne	4800aab4 <rt_timer_detach+0x34>  // b.any
    4800aa9c:	d2802182 	mov	x2, #0x10c                 	// #268
    4800aaa0:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aaa4:	9106c001 	add	x1, x0, #0x1b0
    4800aaa8:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aaac:	9102c000 	add	x0, x0, #0xb0
    4800aab0:	9400156e 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
    4800aab4:	f94017e0 	ldr	x0, [sp, #40]
    4800aab8:	94000d7e 	bl	4800e0b0 <rt_object_get_type>
    4800aabc:	12001c00 	and	w0, w0, #0xff
    4800aac0:	7100281f 	cmp	w0, #0xa
    4800aac4:	540000e0 	b.eq	4800aae0 <rt_timer_detach+0x60>  // b.none
    4800aac8:	d28021a2 	mov	x2, #0x10d                 	// #269
    4800aacc:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aad0:	9106c001 	add	x1, x0, #0x1b0
    4800aad4:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aad8:	91032000 	add	x0, x0, #0xc8
    4800aadc:	94001563 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&timer->parent));
    4800aae0:	f94017e0 	ldr	x0, [sp, #40]
    4800aae4:	94000d5d 	bl	4800e058 <rt_object_is_systemobject>
    4800aae8:	7100001f 	cmp	w0, #0x0
    4800aaec:	540000e1 	b.ne	4800ab08 <rt_timer_detach+0x88>  // b.any
    4800aaf0:	d28021c2 	mov	x2, #0x10e                 	// #270
    4800aaf4:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aaf8:	9106c001 	add	x1, x0, #0x1b0
    4800aafc:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ab00:	91042000 	add	x0, x0, #0x108
    4800ab04:	94001559 	bl	48010068 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800ab08:	97ffe649 	bl	4800442c <rt_hw_interrupt_disable>
    4800ab0c:	aa0003f3 	mov	x19, x0

    _timer_remove(timer);
    4800ab10:	f94017e0 	ldr	x0, [sp, #40]
    4800ab14:	97ffffa8 	bl	4800a9b4 <_timer_remove>
    /* stop timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800ab18:	f94017e0 	ldr	x0, [sp, #40]
    4800ab1c:	39402400 	ldrb	w0, [x0, #9]
    4800ab20:	121f7800 	and	w0, w0, #0xfffffffe
    4800ab24:	12001c01 	and	w1, w0, #0xff
    4800ab28:	f94017e0 	ldr	x0, [sp, #40]
    4800ab2c:	39002401 	strb	w1, [x0, #9]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800ab30:	aa1303e0 	mov	x0, x19
    4800ab34:	97ffe642 	bl	4800443c <rt_hw_interrupt_enable>

    rt_object_detach(&(timer->parent));
    4800ab38:	f94017e0 	ldr	x0, [sp, #40]
    4800ab3c:	94000c9c 	bl	4800ddac <rt_object_detach>

    return RT_EOK;
    4800ab40:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800ab44:	f9400bf3 	ldr	x19, [sp, #16]
    4800ab48:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800ab4c:	d65f03c0 	ret

000000004800ab50 <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
    4800ab50:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800ab54:	910003fd 	mov	x29, sp
    4800ab58:	f90017e0 	str	x0, [sp, #40]
    4800ab5c:	f90013e1 	str	x1, [sp, #32]
    4800ab60:	f9000fe2 	str	x2, [sp, #24]
    4800ab64:	b90017e3 	str	w3, [sp, #20]
    4800ab68:	39004fe4 	strb	w4, [sp, #19]
    struct rt_timer *timer;

    /* allocate a object */
    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
    4800ab6c:	f94017e1 	ldr	x1, [sp, #40]
    4800ab70:	52800140 	mov	w0, #0xa                   	// #10
    4800ab74:	94000cb2 	bl	4800de3c <rt_object_allocate>
    4800ab78:	f9001fe0 	str	x0, [sp, #56]
    if (timer == RT_NULL)
    4800ab7c:	f9401fe0 	ldr	x0, [sp, #56]
    4800ab80:	f100001f 	cmp	x0, #0x0
    4800ab84:	54000061 	b.ne	4800ab90 <rt_timer_create+0x40>  // b.any
    {
        return RT_NULL;
    4800ab88:	d2800000 	mov	x0, #0x0                   	// #0
    4800ab8c:	14000008 	b	4800abac <rt_timer_create+0x5c>
    }

    _timer_init(timer, timeout, parameter, time, flag);
    4800ab90:	39404fe4 	ldrb	w4, [sp, #19]
    4800ab94:	b94017e3 	ldr	w3, [sp, #20]
    4800ab98:	f9400fe2 	ldr	x2, [sp, #24]
    4800ab9c:	f94013e1 	ldr	x1, [sp, #32]
    4800aba0:	f9401fe0 	ldr	x0, [sp, #56]
    4800aba4:	97ffff3e 	bl	4800a89c <_timer_init>

    return timer;
    4800aba8:	f9401fe0 	ldr	x0, [sp, #56]
}
    4800abac:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800abb0:	d65f03c0 	ret

000000004800abb4 <rt_timer_delete>:
 * @param timer the timer to be deleted
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_delete(rt_timer_t timer)
{
    4800abb4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800abb8:	910003fd 	mov	x29, sp
    4800abbc:	f9000bf3 	str	x19, [sp, #16]
    4800abc0:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
    4800abc4:	f94017e0 	ldr	x0, [sp, #40]
    4800abc8:	f100001f 	cmp	x0, #0x0
    4800abcc:	540000e1 	b.ne	4800abe8 <rt_timer_delete+0x34>  // b.any
    4800abd0:	d2802a22 	mov	x2, #0x151                 	// #337
    4800abd4:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800abd8:	91070001 	add	x1, x0, #0x1c0
    4800abdc:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800abe0:	9102c000 	add	x0, x0, #0xb0
    4800abe4:	94001521 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
    4800abe8:	f94017e0 	ldr	x0, [sp, #40]
    4800abec:	94000d31 	bl	4800e0b0 <rt_object_get_type>
    4800abf0:	12001c00 	and	w0, w0, #0xff
    4800abf4:	7100281f 	cmp	w0, #0xa
    4800abf8:	540000e0 	b.eq	4800ac14 <rt_timer_delete+0x60>  // b.none
    4800abfc:	d2802a42 	mov	x2, #0x152                 	// #338
    4800ac00:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ac04:	91070001 	add	x1, x0, #0x1c0
    4800ac08:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ac0c:	91032000 	add	x0, x0, #0xc8
    4800ac10:	94001516 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&timer->parent) == RT_FALSE);
    4800ac14:	f94017e0 	ldr	x0, [sp, #40]
    4800ac18:	94000d10 	bl	4800e058 <rt_object_is_systemobject>
    4800ac1c:	7100001f 	cmp	w0, #0x0
    4800ac20:	540000e0 	b.eq	4800ac3c <rt_timer_delete+0x88>  // b.none
    4800ac24:	d2802a62 	mov	x2, #0x153                 	// #339
    4800ac28:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ac2c:	91070001 	add	x1, x0, #0x1c0
    4800ac30:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ac34:	9104e000 	add	x0, x0, #0x138
    4800ac38:	9400150c 	bl	48010068 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800ac3c:	97ffe5fc 	bl	4800442c <rt_hw_interrupt_disable>
    4800ac40:	aa0003f3 	mov	x19, x0

    _timer_remove(timer);
    4800ac44:	f94017e0 	ldr	x0, [sp, #40]
    4800ac48:	97ffff5b 	bl	4800a9b4 <_timer_remove>
    /* stop timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800ac4c:	f94017e0 	ldr	x0, [sp, #40]
    4800ac50:	39402400 	ldrb	w0, [x0, #9]
    4800ac54:	121f7800 	and	w0, w0, #0xfffffffe
    4800ac58:	12001c01 	and	w1, w0, #0xff
    4800ac5c:	f94017e0 	ldr	x0, [sp, #40]
    4800ac60:	39002401 	strb	w1, [x0, #9]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800ac64:	aa1303e0 	mov	x0, x19
    4800ac68:	97ffe5f5 	bl	4800443c <rt_hw_interrupt_enable>

    rt_object_delete(&(timer->parent));
    4800ac6c:	f94017e0 	ldr	x0, [sp, #40]
    4800ac70:	94000cc9 	bl	4800df94 <rt_object_delete>

    return RT_EOK;
    4800ac74:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800ac78:	f9400bf3 	ldr	x19, [sp, #16]
    4800ac7c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800ac80:	d65f03c0 	ret

000000004800ac84 <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
    4800ac84:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4800ac88:	910003fd 	mov	x29, sp
    4800ac8c:	a90153f3 	stp	x19, x20, [sp, #16]
    4800ac90:	f90017e0 	str	x0, [sp, #40]
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
    4800ac94:	f94017e0 	ldr	x0, [sp, #40]
    4800ac98:	f100001f 	cmp	x0, #0x0
    4800ac9c:	540000e1 	b.ne	4800acb8 <rt_timer_start+0x34>  // b.any
    4800aca0:	d2802f02 	mov	x2, #0x178                 	// #376
    4800aca4:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800aca8:	91074001 	add	x1, x0, #0x1d0
    4800acac:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800acb0:	9102c000 	add	x0, x0, #0xb0
    4800acb4:	940014ed 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
    4800acb8:	f94017e0 	ldr	x0, [sp, #40]
    4800acbc:	94000cfd 	bl	4800e0b0 <rt_object_get_type>
    4800acc0:	12001c00 	and	w0, w0, #0xff
    4800acc4:	7100281f 	cmp	w0, #0xa
    4800acc8:	540000e0 	b.eq	4800ace4 <rt_timer_start+0x60>  // b.none
    4800accc:	d2802f22 	mov	x2, #0x179                 	// #377
    4800acd0:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800acd4:	91074001 	add	x1, x0, #0x1d0
    4800acd8:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800acdc:	91032000 	add	x0, x0, #0xc8
    4800ace0:	940014e2 	bl	48010068 <rt_assert_handler>

    need_schedule = RT_FALSE;
    4800ace4:	52800013 	mov	w19, #0x0                   	// #0

    /* stop timer firstly */
    level = rt_hw_interrupt_disable();
    4800ace8:	97ffe5d1 	bl	4800442c <rt_hw_interrupt_disable>
    4800acec:	aa0003f4 	mov	x20, x0
    /* remove timer from list */
    _timer_remove(timer);
    4800acf0:	f94017e0 	ldr	x0, [sp, #40]
    4800acf4:	97ffff30 	bl	4800a9b4 <_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800acf8:	f94017e0 	ldr	x0, [sp, #40]
    4800acfc:	39402400 	ldrb	w0, [x0, #9]
    4800ad00:	121f7800 	and	w0, w0, #0xfffffffe
    4800ad04:	12001c01 	and	w1, w0, #0xff
    4800ad08:	f94017e0 	ldr	x0, [sp, #40]
    4800ad0c:	39002401 	strb	w1, [x0, #9]

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
    4800ad10:	f0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800ad14:	91178000 	add	x0, x0, #0x5e0
    4800ad18:	f9400000 	ldr	x0, [x0]
    4800ad1c:	f100001f 	cmp	x0, #0x0
    4800ad20:	540000c0 	b.eq	4800ad38 <rt_timer_start+0xb4>  // b.none
    4800ad24:	f0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800ad28:	91178000 	add	x0, x0, #0x5e0
    4800ad2c:	f9400001 	ldr	x1, [x0]
    4800ad30:	f94017e0 	ldr	x0, [sp, #40]
    4800ad34:	d63f0020 	blr	x1

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
    4800ad38:	f94017e0 	ldr	x0, [sp, #40]
    4800ad3c:	b9404001 	ldr	w1, [x0, #64]
    4800ad40:	321f77e0 	mov	w0, #0x7ffffffe            	// #2147483646
    4800ad44:	6b00003f 	cmp	w1, w0
    4800ad48:	540000e9 	b.ls	4800ad64 <rt_timer_start+0xe0>  // b.plast
    4800ad4c:	d2803142 	mov	x2, #0x18a                 	// #394
    4800ad50:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ad54:	91074001 	add	x1, x0, #0x1d0
    4800ad58:	b00000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ad5c:	9105c000 	add	x0, x0, #0x170
    4800ad60:	940014c2 	bl	48010068 <rt_assert_handler>
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
    4800ad64:	940014e2 	bl	480100ec <rt_tick_get>
    4800ad68:	2a0003e1 	mov	w1, w0
    4800ad6c:	f94017e0 	ldr	x0, [sp, #40]
    4800ad70:	b9404000 	ldr	w0, [x0, #64]
    4800ad74:	0b000021 	add	w1, w1, w0
    4800ad78:	f94017e0 	ldr	x0, [sp, #40]
    4800ad7c:	b9004401 	str	w1, [x0, #68]

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
    4800ad80:	f94017e0 	ldr	x0, [sp, #40]
    4800ad84:	39402400 	ldrb	w0, [x0, #9]
    4800ad88:	121e0000 	and	w0, w0, #0x4
    4800ad8c:	7100001f 	cmp	w0, #0x0
    4800ad90:	540000a0 	b.eq	4800ada4 <rt_timer_start+0x120>  // b.none
    {
        /* insert timer to soft timer list */
        timer_list = _soft_timer_list;
    4800ad94:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800ad98:	912a6000 	add	x0, x0, #0xa98
    4800ad9c:	f9002be0 	str	x0, [sp, #80]
    4800ada0:	14000004 	b	4800adb0 <rt_timer_start+0x12c>
    }
    else
#endif /* RT_USING_TIMER_SOFT */
    {
        /* insert timer to system timer list */
        timer_list = _timer_list;
    4800ada4:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800ada8:	912a2000 	add	x0, x0, #0xa88
    4800adac:	f9002be0 	str	x0, [sp, #80]
    }

    row_head[0]  = &timer_list[0];
    4800adb0:	f9402be0 	ldr	x0, [sp, #80]
    4800adb4:	f9001be0 	str	x0, [sp, #48]
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    4800adb8:	b9005fff 	str	wzr, [sp, #92]
    4800adbc:	14000045 	b	4800aed0 <rt_timer_start+0x24c>
    {
        for (; row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
    4800adc0:	b9405fe0 	ldr	w0, [sp, #92]
    4800adc4:	d37df000 	lsl	x0, x0, #3
    4800adc8:	9100c3e1 	add	x1, sp, #0x30
    4800adcc:	f8606820 	ldr	x0, [x1, x0]
    4800add0:	f9400000 	ldr	x0, [x0]
    4800add4:	f90023e0 	str	x0, [sp, #64]

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
    4800add8:	b9405fe0 	ldr	w0, [sp, #92]
    4800addc:	d37cec00 	lsl	x0, x0, #4
    4800ade0:	91008000 	add	x0, x0, #0x20
    4800ade4:	cb0003e0 	neg	x0, x0
    4800ade8:	f94023e1 	ldr	x1, [sp, #64]
    4800adec:	8b000020 	add	x0, x1, x0
    4800adf0:	f9001fe0 	str	x0, [sp, #56]
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
    4800adf4:	f9401fe0 	ldr	x0, [sp, #56]
    4800adf8:	b9404401 	ldr	w1, [x0, #68]
    4800adfc:	f94017e0 	ldr	x0, [sp, #40]
    4800ae00:	b9404400 	ldr	w0, [x0, #68]
    4800ae04:	6b00003f 	cmp	w1, w0
    4800ae08:	54000140 	b.eq	4800ae30 <rt_timer_start+0x1ac>  // b.none
            {
                continue;
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
    4800ae0c:	f9401fe0 	ldr	x0, [sp, #56]
    4800ae10:	b9404401 	ldr	w1, [x0, #68]
    4800ae14:	f94017e0 	ldr	x0, [sp, #40]
    4800ae18:	b9404400 	ldr	w0, [x0, #68]
    4800ae1c:	4b000021 	sub	w1, w1, w0
    4800ae20:	321f77e0 	mov	w0, #0x7ffffffe            	// #2147483646
    4800ae24:	6b00003f 	cmp	w1, w0
    4800ae28:	54000309 	b.ls	4800ae88 <rt_timer_start+0x204>  // b.plast
    4800ae2c:	14000002 	b	4800ae34 <rt_timer_start+0x1b0>
                continue;
    4800ae30:	d503201f 	nop
             row_head[row_lvl]  = row_head[row_lvl]->next)
    4800ae34:	b9405fe0 	ldr	w0, [sp, #92]
    4800ae38:	d37df000 	lsl	x0, x0, #3
    4800ae3c:	9100c3e1 	add	x1, sp, #0x30
    4800ae40:	f8606820 	ldr	x0, [x1, x0]
    4800ae44:	f9400002 	ldr	x2, [x0]
    4800ae48:	b9405fe0 	ldr	w0, [sp, #92]
    4800ae4c:	d37df000 	lsl	x0, x0, #3
    4800ae50:	9100c3e1 	add	x1, sp, #0x30
    4800ae54:	f8206822 	str	x2, [x1, x0]
        for (; row_head[row_lvl] != timer_list[row_lvl].prev;
    4800ae58:	b9405fe0 	ldr	w0, [sp, #92]
    4800ae5c:	d37df000 	lsl	x0, x0, #3
    4800ae60:	9100c3e1 	add	x1, sp, #0x30
    4800ae64:	f8606821 	ldr	x1, [x1, x0]
    4800ae68:	b9405fe0 	ldr	w0, [sp, #92]
    4800ae6c:	d37cec00 	lsl	x0, x0, #4
    4800ae70:	f9402be2 	ldr	x2, [sp, #80]
    4800ae74:	8b000040 	add	x0, x2, x0
    4800ae78:	f9400400 	ldr	x0, [x0, #8]
    4800ae7c:	eb00003f 	cmp	x1, x0
    4800ae80:	54fffa01 	b.ne	4800adc0 <rt_timer_start+0x13c>  // b.any
    4800ae84:	14000002 	b	4800ae8c <rt_timer_start+0x208>
            {
                break;
    4800ae88:	d503201f 	nop
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
    4800ae8c:	b9405fe0 	ldr	w0, [sp, #92]
    4800ae90:	7100001f 	cmp	w0, #0x0
    4800ae94:	54000180 	b.eq	4800aec4 <rt_timer_start+0x240>  // b.none
            row_head[row_lvl + 1] = row_head[row_lvl] + 1;
    4800ae98:	b9405fe0 	ldr	w0, [sp, #92]
    4800ae9c:	d37df000 	lsl	x0, x0, #3
    4800aea0:	9100c3e1 	add	x1, sp, #0x30
    4800aea4:	f8606820 	ldr	x0, [x1, x0]
    4800aea8:	b9405fe1 	ldr	w1, [sp, #92]
    4800aeac:	11000421 	add	w1, w1, #0x1
    4800aeb0:	91004002 	add	x2, x0, #0x10
    4800aeb4:	2a0103e0 	mov	w0, w1
    4800aeb8:	d37df000 	lsl	x0, x0, #3
    4800aebc:	9100c3e1 	add	x1, sp, #0x30
    4800aec0:	f8206822 	str	x2, [x1, x0]
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    4800aec4:	b9405fe0 	ldr	w0, [sp, #92]
    4800aec8:	11000400 	add	w0, w0, #0x1
    4800aecc:	b9005fe0 	str	w0, [sp, #92]
    4800aed0:	b9405fe0 	ldr	w0, [sp, #92]
    4800aed4:	7100001f 	cmp	w0, #0x0
    4800aed8:	54fffc00 	b.eq	4800ae58 <rt_timer_start+0x1d4>  // b.none

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
    4800aedc:	f0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800aee0:	910e4000 	add	x0, x0, #0x390
    4800aee4:	b9400000 	ldr	w0, [x0]
    4800aee8:	11000401 	add	w1, w0, #0x1
    4800aeec:	f0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800aef0:	910e4000 	add	x0, x0, #0x390
    4800aef4:	b9000001 	str	w1, [x0]
    tst_nr = random_nr;
    4800aef8:	f0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800aefc:	910e4000 	add	x0, x0, #0x390
    4800af00:	b9400000 	ldr	w0, [x0]
    4800af04:	b9004fe0 	str	w0, [sp, #76]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - 1],
    4800af08:	f9401be2 	ldr	x2, [sp, #48]
    4800af0c:	f94017e0 	ldr	x0, [sp, #40]
    4800af10:	91008000 	add	x0, x0, #0x20
    4800af14:	aa0003e1 	mov	x1, x0
    4800af18:	aa0203e0 	mov	x0, x2
    4800af1c:	97fffe1a 	bl	4800a784 <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    4800af20:	52800040 	mov	w0, #0x2                   	// #2
    4800af24:	b9005fe0 	str	w0, [sp, #92]
    4800af28:	1400001d 	b	4800af9c <rt_timer_start+0x318>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
    4800af2c:	b9404fe0 	ldr	w0, [sp, #76]
    4800af30:	12000400 	and	w0, w0, #0x3
    4800af34:	7100001f 	cmp	w0, #0x0
    4800af38:	540003a1 	b.ne	4800afac <rt_timer_start+0x328>  // b.any
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
    4800af3c:	52800021 	mov	w1, #0x1                   	// #1
    4800af40:	b9405fe0 	ldr	w0, [sp, #92]
    4800af44:	4b000020 	sub	w0, w1, w0
    4800af48:	2a0003e0 	mov	w0, w0
    4800af4c:	d37df000 	lsl	x0, x0, #3
    4800af50:	9100c3e1 	add	x1, sp, #0x30
    4800af54:	f8606822 	ldr	x2, [x1, x0]
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
    4800af58:	52800021 	mov	w1, #0x1                   	// #1
    4800af5c:	b9405fe0 	ldr	w0, [sp, #92]
    4800af60:	4b000020 	sub	w0, w1, w0
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
    4800af64:	2a0003e0 	mov	w0, w0
    4800af68:	91000800 	add	x0, x0, #0x2
    4800af6c:	d37cec00 	lsl	x0, x0, #4
    4800af70:	f94017e1 	ldr	x1, [sp, #40]
    4800af74:	8b000020 	add	x0, x1, x0
    4800af78:	aa0003e1 	mov	x1, x0
    4800af7c:	aa0203e0 	mov	x0, x2
    4800af80:	97fffe01 	bl	4800a784 <rt_list_insert_after>
        else
            break;
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK + 1) >> 1;
    4800af84:	b9404fe0 	ldr	w0, [sp, #76]
    4800af88:	53027c00 	lsr	w0, w0, #2
    4800af8c:	b9004fe0 	str	w0, [sp, #76]
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    4800af90:	b9405fe0 	ldr	w0, [sp, #92]
    4800af94:	11000400 	add	w0, w0, #0x1
    4800af98:	b9005fe0 	str	w0, [sp, #92]
    4800af9c:	b9405fe0 	ldr	w0, [sp, #92]
    4800afa0:	7100041f 	cmp	w0, #0x1
    4800afa4:	54fffc49 	b.ls	4800af2c <rt_timer_start+0x2a8>  // b.plast
    4800afa8:	14000002 	b	4800afb0 <rt_timer_start+0x32c>
            break;
    4800afac:	d503201f 	nop
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
    4800afb0:	f94017e0 	ldr	x0, [sp, #40]
    4800afb4:	39402400 	ldrb	w0, [x0, #9]
    4800afb8:	32000000 	orr	w0, w0, #0x1
    4800afbc:	12001c01 	and	w1, w0, #0xff
    4800afc0:	f94017e0 	ldr	x0, [sp, #40]
    4800afc4:	39002401 	strb	w1, [x0, #9]

#ifdef RT_USING_TIMER_SOFT
    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
    4800afc8:	f94017e0 	ldr	x0, [sp, #40]
    4800afcc:	39402400 	ldrb	w0, [x0, #9]
    4800afd0:	121e0000 	and	w0, w0, #0x4
    4800afd4:	7100001f 	cmp	w0, #0x0
    4800afd8:	54000200 	b.eq	4800b018 <rt_timer_start+0x394>  // b.none
    {
        /* check whether timer thread is ready */
        if ((_soft_timer_status == RT_SOFT_TIMER_IDLE) &&
    4800afdc:	f00000a0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800afe0:	9115c000 	add	x0, x0, #0x570
    4800afe4:	39400000 	ldrb	w0, [x0]
    4800afe8:	7100041f 	cmp	w0, #0x1
    4800afec:	54000161 	b.ne	4800b018 <rt_timer_start+0x394>  // b.any
           ((_timer_thread.stat & RT_THREAD_STAT_MASK) == RT_THREAD_SUSPEND))
    4800aff0:	d0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800aff4:	912aa000 	add	x0, x0, #0xaa8
    4800aff8:	39418000 	ldrb	w0, [x0, #96]
    4800affc:	12000800 	and	w0, w0, #0x7
        if ((_soft_timer_status == RT_SOFT_TIMER_IDLE) &&
    4800b000:	7100081f 	cmp	w0, #0x2
    4800b004:	540000a1 	b.ne	4800b018 <rt_timer_start+0x394>  // b.any
        {
            /* resume timer thread to check soft timer */
            rt_thread_resume(&_timer_thread);
    4800b008:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b00c:	912aa000 	add	x0, x0, #0xaa8
    4800b010:	94000536 	bl	4800c4e8 <rt_thread_resume>
            need_schedule = RT_TRUE;
    4800b014:	52800033 	mov	w19, #0x1                   	// #1
        }
    }
#endif /* RT_USING_TIMER_SOFT */

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800b018:	aa1403e0 	mov	x0, x20
    4800b01c:	97ffe508 	bl	4800443c <rt_hw_interrupt_enable>

    if (need_schedule)
    4800b020:	7100027f 	cmp	w19, #0x0
    4800b024:	54000040 	b.eq	4800b02c <rt_timer_start+0x3a8>  // b.none
    {
        rt_schedule();
    4800b028:	940008d9 	bl	4800d38c <rt_schedule>
    }

    return RT_EOK;
    4800b02c:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800b030:	a94153f3 	ldp	x19, x20, [sp, #16]
    4800b034:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4800b038:	d65f03c0 	ret

000000004800b03c <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
    4800b03c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800b040:	910003fd 	mov	x29, sp
    4800b044:	f9000bf3 	str	x19, [sp, #16]
    4800b048:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
    4800b04c:	f94017e0 	ldr	x0, [sp, #40]
    4800b050:	f100001f 	cmp	x0, #0x0
    4800b054:	540000e1 	b.ne	4800b070 <rt_timer_stop+0x34>  // b.any
    4800b058:	d2803ea2 	mov	x2, #0x1f5                 	// #501
    4800b05c:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b060:	91078001 	add	x1, x0, #0x1e0
    4800b064:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b068:	9102c000 	add	x0, x0, #0xb0
    4800b06c:	940013ff 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
    4800b070:	f94017e0 	ldr	x0, [sp, #40]
    4800b074:	94000c0f 	bl	4800e0b0 <rt_object_get_type>
    4800b078:	12001c00 	and	w0, w0, #0xff
    4800b07c:	7100281f 	cmp	w0, #0xa
    4800b080:	540000e0 	b.eq	4800b09c <rt_timer_stop+0x60>  // b.none
    4800b084:	d2803ec2 	mov	x2, #0x1f6                 	// #502
    4800b088:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b08c:	91078001 	add	x1, x0, #0x1e0
    4800b090:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b094:	91032000 	add	x0, x0, #0xc8
    4800b098:	940013f4 	bl	48010068 <rt_assert_handler>

    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
    4800b09c:	f94017e0 	ldr	x0, [sp, #40]
    4800b0a0:	39402400 	ldrb	w0, [x0, #9]
    4800b0a4:	12000000 	and	w0, w0, #0x1
    4800b0a8:	7100001f 	cmp	w0, #0x0
    4800b0ac:	54000061 	b.ne	4800b0b8 <rt_timer_stop+0x7c>  // b.any
        return -RT_ERROR;
    4800b0b0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800b0b4:	14000018 	b	4800b114 <rt_timer_stop+0xd8>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
    4800b0b8:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b0bc:	9117a000 	add	x0, x0, #0x5e8
    4800b0c0:	f9400000 	ldr	x0, [x0]
    4800b0c4:	f100001f 	cmp	x0, #0x0
    4800b0c8:	540000c0 	b.eq	4800b0e0 <rt_timer_stop+0xa4>  // b.none
    4800b0cc:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b0d0:	9117a000 	add	x0, x0, #0x5e8
    4800b0d4:	f9400001 	ldr	x1, [x0]
    4800b0d8:	f94017e0 	ldr	x0, [sp, #40]
    4800b0dc:	d63f0020 	blr	x1

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800b0e0:	97ffe4d3 	bl	4800442c <rt_hw_interrupt_disable>
    4800b0e4:	aa0003f3 	mov	x19, x0

    _timer_remove(timer);
    4800b0e8:	f94017e0 	ldr	x0, [sp, #40]
    4800b0ec:	97fffe32 	bl	4800a9b4 <_timer_remove>
    /* change status */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800b0f0:	f94017e0 	ldr	x0, [sp, #40]
    4800b0f4:	39402400 	ldrb	w0, [x0, #9]
    4800b0f8:	121f7800 	and	w0, w0, #0xfffffffe
    4800b0fc:	12001c01 	and	w1, w0, #0xff
    4800b100:	f94017e0 	ldr	x0, [sp, #40]
    4800b104:	39002401 	strb	w1, [x0, #9]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800b108:	aa1303e0 	mov	x0, x19
    4800b10c:	97ffe4cc 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    4800b110:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800b114:	f9400bf3 	ldr	x19, [sp, #16]
    4800b118:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800b11c:	d65f03c0 	ret

000000004800b120 <rt_timer_control>:
 * @param arg the argument
 *
 * @return the statu of control
 */
rt_err_t rt_timer_control(rt_timer_t timer, int cmd, void *arg)
{
    4800b120:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800b124:	910003fd 	mov	x29, sp
    4800b128:	f9000bf3 	str	x19, [sp, #16]
    4800b12c:	f9001fe0 	str	x0, [sp, #56]
    4800b130:	b90037e1 	str	w1, [sp, #52]
    4800b134:	f90017e2 	str	x2, [sp, #40]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
    4800b138:	f9401fe0 	ldr	x0, [sp, #56]
    4800b13c:	f100001f 	cmp	x0, #0x0
    4800b140:	540000e1 	b.ne	4800b15c <rt_timer_control+0x3c>  // b.any
    4800b144:	d2804322 	mov	x2, #0x219                 	// #537
    4800b148:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b14c:	9107c001 	add	x1, x0, #0x1f0
    4800b150:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b154:	9102c000 	add	x0, x0, #0xb0
    4800b158:	940013c4 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
    4800b15c:	f9401fe0 	ldr	x0, [sp, #56]
    4800b160:	94000bd4 	bl	4800e0b0 <rt_object_get_type>
    4800b164:	12001c00 	and	w0, w0, #0xff
    4800b168:	7100281f 	cmp	w0, #0xa
    4800b16c:	540000e0 	b.eq	4800b188 <rt_timer_control+0x68>  // b.none
    4800b170:	d2804342 	mov	x2, #0x21a                 	// #538
    4800b174:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b178:	9107c001 	add	x1, x0, #0x1f0
    4800b17c:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b180:	91032000 	add	x0, x0, #0xc8
    4800b184:	940013b9 	bl	48010068 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
    4800b188:	97ffe4a9 	bl	4800442c <rt_hw_interrupt_disable>
    4800b18c:	aa0003f3 	mov	x19, x0
    switch (cmd)
    4800b190:	b94037e0 	ldr	w0, [sp, #52]
    4800b194:	7100101f 	cmp	w0, #0x4
    4800b198:	540005c0 	b.eq	4800b250 <rt_timer_control+0x130>  // b.none
    4800b19c:	b94037e0 	ldr	w0, [sp, #52]
    4800b1a0:	7100101f 	cmp	w0, #0x4
    4800b1a4:	540006ec 	b.gt	4800b280 <rt_timer_control+0x160>
    4800b1a8:	b94037e0 	ldr	w0, [sp, #52]
    4800b1ac:	71000c1f 	cmp	w0, #0x3
    4800b1b0:	54000420 	b.eq	4800b234 <rt_timer_control+0x114>  // b.none
    4800b1b4:	b94037e0 	ldr	w0, [sp, #52]
    4800b1b8:	71000c1f 	cmp	w0, #0x3
    4800b1bc:	5400062c 	b.gt	4800b280 <rt_timer_control+0x160>
    4800b1c0:	b94037e0 	ldr	w0, [sp, #52]
    4800b1c4:	7100081f 	cmp	w0, #0x2
    4800b1c8:	54000280 	b.eq	4800b218 <rt_timer_control+0xf8>  // b.none
    4800b1cc:	b94037e0 	ldr	w0, [sp, #52]
    4800b1d0:	7100081f 	cmp	w0, #0x2
    4800b1d4:	5400056c 	b.gt	4800b280 <rt_timer_control+0x160>
    4800b1d8:	b94037e0 	ldr	w0, [sp, #52]
    4800b1dc:	7100001f 	cmp	w0, #0x0
    4800b1e0:	54000120 	b.eq	4800b204 <rt_timer_control+0xe4>  // b.none
    4800b1e4:	b94037e0 	ldr	w0, [sp, #52]
    4800b1e8:	7100041f 	cmp	w0, #0x1
    4800b1ec:	540004a1 	b.ne	4800b280 <rt_timer_control+0x160>  // b.any
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
    4800b1f0:	f9401fe0 	ldr	x0, [sp, #56]
    4800b1f4:	b9404001 	ldr	w1, [x0, #64]
    4800b1f8:	f94017e0 	ldr	x0, [sp, #40]
    4800b1fc:	b9000001 	str	w1, [x0]
        break;
    4800b200:	14000021 	b	4800b284 <rt_timer_control+0x164>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
    4800b204:	f94017e0 	ldr	x0, [sp, #40]
    4800b208:	b9400001 	ldr	w1, [x0]
    4800b20c:	f9401fe0 	ldr	x0, [sp, #56]
    4800b210:	b9004001 	str	w1, [x0, #64]
        break;
    4800b214:	1400001c 	b	4800b284 <rt_timer_control+0x164>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
    4800b218:	f9401fe0 	ldr	x0, [sp, #56]
    4800b21c:	39402400 	ldrb	w0, [x0, #9]
    4800b220:	121e7800 	and	w0, w0, #0xfffffffd
    4800b224:	12001c01 	and	w1, w0, #0xff
    4800b228:	f9401fe0 	ldr	x0, [sp, #56]
    4800b22c:	39002401 	strb	w1, [x0, #9]
        break;
    4800b230:	14000015 	b	4800b284 <rt_timer_control+0x164>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
    4800b234:	f9401fe0 	ldr	x0, [sp, #56]
    4800b238:	39402400 	ldrb	w0, [x0, #9]
    4800b23c:	321f0000 	orr	w0, w0, #0x2
    4800b240:	12001c01 	and	w1, w0, #0xff
    4800b244:	f9401fe0 	ldr	x0, [sp, #56]
    4800b248:	39002401 	strb	w1, [x0, #9]
        break;
    4800b24c:	1400000e 	b	4800b284 <rt_timer_control+0x164>

    case RT_TIMER_CTRL_GET_STATE:
        if(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
    4800b250:	f9401fe0 	ldr	x0, [sp, #56]
    4800b254:	39402400 	ldrb	w0, [x0, #9]
    4800b258:	12000000 	and	w0, w0, #0x1
    4800b25c:	7100001f 	cmp	w0, #0x0
    4800b260:	540000a0 	b.eq	4800b274 <rt_timer_control+0x154>  // b.none
        {
            /*timer is start and run*/
            *(rt_tick_t *)arg = RT_TIMER_FLAG_ACTIVATED;
    4800b264:	f94017e0 	ldr	x0, [sp, #40]
    4800b268:	52800021 	mov	w1, #0x1                   	// #1
    4800b26c:	b9000001 	str	w1, [x0]
        else
        {
            /*timer is stop*/
            *(rt_tick_t *)arg = RT_TIMER_FLAG_DEACTIVATED;
        }
        break;
    4800b270:	14000005 	b	4800b284 <rt_timer_control+0x164>
            *(rt_tick_t *)arg = RT_TIMER_FLAG_DEACTIVATED;
    4800b274:	f94017e0 	ldr	x0, [sp, #40]
    4800b278:	b900001f 	str	wzr, [x0]
        break;
    4800b27c:	14000002 	b	4800b284 <rt_timer_control+0x164>

    default:
        break;
    4800b280:	d503201f 	nop
    }
    rt_hw_interrupt_enable(level);
    4800b284:	aa1303e0 	mov	x0, x19
    4800b288:	97ffe46d 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    4800b28c:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800b290:	f9400bf3 	ldr	x19, [sp, #16]
    4800b294:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800b298:	d65f03c0 	ret

000000004800b29c <rt_timer_check>:
 *        the corresponding timeout function will be invoked.
 *
 * @note This function shall be invoked in operating system timer interrupt.
 */
void rt_timer_check(void)
{
    4800b29c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800b2a0:	910003fd 	mov	x29, sp
    4800b2a4:	f9000bf3 	str	x19, [sp, #16]
    struct rt_timer *t;
    rt_tick_t current_tick;
    register rt_base_t level;
    rt_list_t list;

    rt_list_init(&list);
    4800b2a8:	910083e0 	add	x0, sp, #0x20
    4800b2ac:	97fffd2a 	bl	4800a754 <rt_list_init>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));

    current_tick = rt_tick_get();
    4800b2b0:	9400138f 	bl	480100ec <rt_tick_get>
    4800b2b4:	b9003fe0 	str	w0, [sp, #60]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800b2b8:	97ffe45d 	bl	4800442c <rt_hw_interrupt_disable>
    4800b2bc:	aa0003f3 	mov	x19, x0

    while (!rt_list_isempty(&_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
    4800b2c0:	14000053 	b	4800b40c <rt_timer_check+0x170>
    {
        t = rt_list_entry(_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
    4800b2c4:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b2c8:	912a2000 	add	x0, x0, #0xa88
    4800b2cc:	f9400000 	ldr	x0, [x0]
    4800b2d0:	d1008000 	sub	x0, x0, #0x20
    4800b2d4:	f9001be0 	str	x0, [sp, #48]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
    4800b2d8:	f9401be0 	ldr	x0, [sp, #48]
    4800b2dc:	b9404400 	ldr	w0, [x0, #68]
    4800b2e0:	b9403fe1 	ldr	w1, [sp, #60]
    4800b2e4:	4b000021 	sub	w1, w1, w0
    4800b2e8:	321f77e0 	mov	w0, #0x7ffffffe            	// #2147483646
    4800b2ec:	6b00003f 	cmp	w1, w0
    4800b2f0:	540009a8 	b.hi	4800b424 <rt_timer_check+0x188>  // b.pmore
        {
            RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t));
    4800b2f4:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b2f8:	910e0000 	add	x0, x0, #0x380
    4800b2fc:	f9400000 	ldr	x0, [x0]
    4800b300:	f100001f 	cmp	x0, #0x0
    4800b304:	540000c0 	b.eq	4800b31c <rt_timer_check+0x80>  // b.none
    4800b308:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b30c:	910e0000 	add	x0, x0, #0x380
    4800b310:	f9400001 	ldr	x1, [x0]
    4800b314:	f9401be0 	ldr	x0, [sp, #48]
    4800b318:	d63f0020 	blr	x1

            /* remove timer from timer list firstly */
            _timer_remove(t);
    4800b31c:	f9401be0 	ldr	x0, [sp, #48]
    4800b320:	97fffda5 	bl	4800a9b4 <_timer_remove>
            if (!(t->parent.flag & RT_TIMER_FLAG_PERIODIC))
    4800b324:	f9401be0 	ldr	x0, [sp, #48]
    4800b328:	39402400 	ldrb	w0, [x0, #9]
    4800b32c:	121f0000 	and	w0, w0, #0x2
    4800b330:	7100001f 	cmp	w0, #0x0
    4800b334:	540000e1 	b.ne	4800b350 <rt_timer_check+0xb4>  // b.any
            {
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800b338:	f9401be0 	ldr	x0, [sp, #48]
    4800b33c:	39402400 	ldrb	w0, [x0, #9]
    4800b340:	121f7800 	and	w0, w0, #0xfffffffe
    4800b344:	12001c01 	and	w1, w0, #0xff
    4800b348:	f9401be0 	ldr	x0, [sp, #48]
    4800b34c:	39002401 	strb	w1, [x0, #9]
            }
            /* add timer to temporary list  */
            rt_list_insert_after(&list, &(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
    4800b350:	f9401be0 	ldr	x0, [sp, #48]
    4800b354:	91008001 	add	x1, x0, #0x20
    4800b358:	910083e0 	add	x0, sp, #0x20
    4800b35c:	97fffd0a 	bl	4800a784 <rt_list_insert_after>
            /* call timeout function */
            t->timeout_func(t->parameter);
    4800b360:	f9401be0 	ldr	x0, [sp, #48]
    4800b364:	f9401801 	ldr	x1, [x0, #48]
    4800b368:	f9401be0 	ldr	x0, [sp, #48]
    4800b36c:	f9401c00 	ldr	x0, [x0, #56]
    4800b370:	d63f0020 	blr	x1

            /* re-get tick */
            current_tick = rt_tick_get();
    4800b374:	9400135e 	bl	480100ec <rt_tick_get>
    4800b378:	b9003fe0 	str	w0, [sp, #60]

            RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t));
    4800b37c:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b380:	910e2000 	add	x0, x0, #0x388
    4800b384:	f9400000 	ldr	x0, [x0]
    4800b388:	f100001f 	cmp	x0, #0x0
    4800b38c:	540000c0 	b.eq	4800b3a4 <rt_timer_check+0x108>  // b.none
    4800b390:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b394:	910e2000 	add	x0, x0, #0x388
    4800b398:	f9400001 	ldr	x1, [x0]
    4800b39c:	f9401be0 	ldr	x0, [sp, #48]
    4800b3a0:	d63f0020 	blr	x1
            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            /* Check whether the timer object is detached or started again */
            if (rt_list_isempty(&list))
    4800b3a4:	910083e0 	add	x0, sp, #0x20
    4800b3a8:	97fffd21 	bl	4800a82c <rt_list_isempty>
    4800b3ac:	7100001f 	cmp	w0, #0x0
    4800b3b0:	54000040 	b.eq	4800b3b8 <rt_timer_check+0x11c>  // b.none
            {
                continue;
    4800b3b4:	14000016 	b	4800b40c <rt_timer_check+0x170>
            }
            rt_list_remove(&(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
    4800b3b8:	f9401be0 	ldr	x0, [sp, #48]
    4800b3bc:	91008000 	add	x0, x0, #0x20
    4800b3c0:	97fffd05 	bl	4800a7d4 <rt_list_remove>
            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
    4800b3c4:	f9401be0 	ldr	x0, [sp, #48]
    4800b3c8:	39402400 	ldrb	w0, [x0, #9]
    4800b3cc:	121f0000 	and	w0, w0, #0x2
    4800b3d0:	7100001f 	cmp	w0, #0x0
    4800b3d4:	540001c0 	b.eq	4800b40c <rt_timer_check+0x170>  // b.none
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
    4800b3d8:	f9401be0 	ldr	x0, [sp, #48]
    4800b3dc:	39402400 	ldrb	w0, [x0, #9]
    4800b3e0:	12000000 	and	w0, w0, #0x1
            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
    4800b3e4:	7100001f 	cmp	w0, #0x0
    4800b3e8:	54000120 	b.eq	4800b40c <rt_timer_check+0x170>  // b.none
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800b3ec:	f9401be0 	ldr	x0, [sp, #48]
    4800b3f0:	39402400 	ldrb	w0, [x0, #9]
    4800b3f4:	121f7800 	and	w0, w0, #0xfffffffe
    4800b3f8:	12001c01 	and	w1, w0, #0xff
    4800b3fc:	f9401be0 	ldr	x0, [sp, #48]
    4800b400:	39002401 	strb	w1, [x0, #9]
                rt_timer_start(t);
    4800b404:	f9401be0 	ldr	x0, [sp, #48]
    4800b408:	97fffe1f 	bl	4800ac84 <rt_timer_start>
    while (!rt_list_isempty(&_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
    4800b40c:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b410:	912a2000 	add	x0, x0, #0xa88
    4800b414:	97fffd06 	bl	4800a82c <rt_list_isempty>
    4800b418:	7100001f 	cmp	w0, #0x0
    4800b41c:	54fff540 	b.eq	4800b2c4 <rt_timer_check+0x28>  // b.none
    4800b420:	14000002 	b	4800b428 <rt_timer_check+0x18c>
            }
        }
        else break;
    4800b424:	d503201f 	nop
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800b428:	aa1303e0 	mov	x0, x19
    4800b42c:	97ffe404 	bl	4800443c <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
}
    4800b430:	d503201f 	nop
    4800b434:	f9400bf3 	ldr	x19, [sp, #16]
    4800b438:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800b43c:	d65f03c0 	ret

000000004800b440 <rt_timer_next_timeout_tick>:
 * @brief This function will return the next timeout tick in the system.
 *
 * @return the next timeout tick in the system
 */
rt_tick_t rt_timer_next_timeout_tick(void)
{
    4800b440:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4800b444:	910003fd 	mov	x29, sp
    return _timer_list_next_timeout(_timer_list);
    4800b448:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b44c:	912a2000 	add	x0, x0, #0xa88
    4800b450:	97fffd40 	bl	4800a950 <_timer_list_next_timeout>
}
    4800b454:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4800b458:	d65f03c0 	ret

000000004800b45c <rt_soft_timer_check>:
/**
 * @brief This function will check software-timer list, if a timeout event happens, the
 *        corresponding timeout function will be invoked.
 */
void rt_soft_timer_check(void)
{
    4800b45c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800b460:	910003fd 	mov	x29, sp
    4800b464:	f9000bf3 	str	x19, [sp, #16]
    rt_tick_t current_tick;
    struct rt_timer *t;
    register rt_base_t level;
    rt_list_t list;

    rt_list_init(&list);
    4800b468:	910083e0 	add	x0, sp, #0x20
    4800b46c:	97fffcba 	bl	4800a754 <rt_list_init>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800b470:	97ffe3ef 	bl	4800442c <rt_hw_interrupt_disable>
    4800b474:	aa0003f3 	mov	x19, x0

    while (!rt_list_isempty(&_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
    4800b478:	1400005e 	b	4800b5f0 <rt_soft_timer_check+0x194>
    {
        t = rt_list_entry(_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
    4800b47c:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b480:	912a6000 	add	x0, x0, #0xa98
    4800b484:	f9400000 	ldr	x0, [x0]
    4800b488:	d1008000 	sub	x0, x0, #0x20
    4800b48c:	f9001fe0 	str	x0, [sp, #56]
                            struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

        current_tick = rt_tick_get();
    4800b490:	94001317 	bl	480100ec <rt_tick_get>
    4800b494:	b90037e0 	str	w0, [sp, #52]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
    4800b498:	f9401fe0 	ldr	x0, [sp, #56]
    4800b49c:	b9404400 	ldr	w0, [x0, #68]
    4800b4a0:	b94037e1 	ldr	w1, [sp, #52]
    4800b4a4:	4b000021 	sub	w1, w1, w0
    4800b4a8:	321f77e0 	mov	w0, #0x7ffffffe            	// #2147483646
    4800b4ac:	6b00003f 	cmp	w1, w0
    4800b4b0:	54000ac8 	b.hi	4800b608 <rt_soft_timer_check+0x1ac>  // b.pmore
        {
            RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t));
    4800b4b4:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b4b8:	910e0000 	add	x0, x0, #0x380
    4800b4bc:	f9400000 	ldr	x0, [x0]
    4800b4c0:	f100001f 	cmp	x0, #0x0
    4800b4c4:	540000c0 	b.eq	4800b4dc <rt_soft_timer_check+0x80>  // b.none
    4800b4c8:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b4cc:	910e0000 	add	x0, x0, #0x380
    4800b4d0:	f9400001 	ldr	x1, [x0]
    4800b4d4:	f9401fe0 	ldr	x0, [sp, #56]
    4800b4d8:	d63f0020 	blr	x1

            /* remove timer from timer list firstly */
            _timer_remove(t);
    4800b4dc:	f9401fe0 	ldr	x0, [sp, #56]
    4800b4e0:	97fffd35 	bl	4800a9b4 <_timer_remove>
            if (!(t->parent.flag & RT_TIMER_FLAG_PERIODIC))
    4800b4e4:	f9401fe0 	ldr	x0, [sp, #56]
    4800b4e8:	39402400 	ldrb	w0, [x0, #9]
    4800b4ec:	121f0000 	and	w0, w0, #0x2
    4800b4f0:	7100001f 	cmp	w0, #0x0
    4800b4f4:	540000e1 	b.ne	4800b510 <rt_soft_timer_check+0xb4>  // b.any
            {
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800b4f8:	f9401fe0 	ldr	x0, [sp, #56]
    4800b4fc:	39402400 	ldrb	w0, [x0, #9]
    4800b500:	121f7800 	and	w0, w0, #0xfffffffe
    4800b504:	12001c01 	and	w1, w0, #0xff
    4800b508:	f9401fe0 	ldr	x0, [sp, #56]
    4800b50c:	39002401 	strb	w1, [x0, #9]
            }
            /* add timer to temporary list  */
            rt_list_insert_after(&list, &(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
    4800b510:	f9401fe0 	ldr	x0, [sp, #56]
    4800b514:	91008001 	add	x1, x0, #0x20
    4800b518:	910083e0 	add	x0, sp, #0x20
    4800b51c:	97fffc9a 	bl	4800a784 <rt_list_insert_after>

            _soft_timer_status = RT_SOFT_TIMER_BUSY;
    4800b520:	d00000a0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800b524:	9115c000 	add	x0, x0, #0x570
    4800b528:	3900001f 	strb	wzr, [x0]
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
    4800b52c:	aa1303e0 	mov	x0, x19
    4800b530:	97ffe3c3 	bl	4800443c <rt_hw_interrupt_enable>

            /* call timeout function */
            t->timeout_func(t->parameter);
    4800b534:	f9401fe0 	ldr	x0, [sp, #56]
    4800b538:	f9401801 	ldr	x1, [x0, #48]
    4800b53c:	f9401fe0 	ldr	x0, [sp, #56]
    4800b540:	f9401c00 	ldr	x0, [x0, #56]
    4800b544:	d63f0020 	blr	x1

            RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t));
    4800b548:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b54c:	910e2000 	add	x0, x0, #0x388
    4800b550:	f9400000 	ldr	x0, [x0]
    4800b554:	f100001f 	cmp	x0, #0x0
    4800b558:	540000c0 	b.eq	4800b570 <rt_soft_timer_check+0x114>  // b.none
    4800b55c:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b560:	910e2000 	add	x0, x0, #0x388
    4800b564:	f9400001 	ldr	x1, [x0]
    4800b568:	f9401fe0 	ldr	x0, [sp, #56]
    4800b56c:	d63f0020 	blr	x1
            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            /* disable interrupt */
            level = rt_hw_interrupt_disable();
    4800b570:	97ffe3af 	bl	4800442c <rt_hw_interrupt_disable>
    4800b574:	aa0003f3 	mov	x19, x0

            _soft_timer_status = RT_SOFT_TIMER_IDLE;
    4800b578:	d00000a0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800b57c:	9115c000 	add	x0, x0, #0x570
    4800b580:	52800021 	mov	w1, #0x1                   	// #1
    4800b584:	39000001 	strb	w1, [x0]
            /* Check whether the timer object is detached or started again */
            if (rt_list_isempty(&list))
    4800b588:	910083e0 	add	x0, sp, #0x20
    4800b58c:	97fffca8 	bl	4800a82c <rt_list_isempty>
    4800b590:	7100001f 	cmp	w0, #0x0
    4800b594:	54000040 	b.eq	4800b59c <rt_soft_timer_check+0x140>  // b.none
            {
                continue;
    4800b598:	14000016 	b	4800b5f0 <rt_soft_timer_check+0x194>
            }
            rt_list_remove(&(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
    4800b59c:	f9401fe0 	ldr	x0, [sp, #56]
    4800b5a0:	91008000 	add	x0, x0, #0x20
    4800b5a4:	97fffc8c 	bl	4800a7d4 <rt_list_remove>
            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
    4800b5a8:	f9401fe0 	ldr	x0, [sp, #56]
    4800b5ac:	39402400 	ldrb	w0, [x0, #9]
    4800b5b0:	121f0000 	and	w0, w0, #0x2
    4800b5b4:	7100001f 	cmp	w0, #0x0
    4800b5b8:	540001c0 	b.eq	4800b5f0 <rt_soft_timer_check+0x194>  // b.none
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
    4800b5bc:	f9401fe0 	ldr	x0, [sp, #56]
    4800b5c0:	39402400 	ldrb	w0, [x0, #9]
    4800b5c4:	12000000 	and	w0, w0, #0x1
            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
    4800b5c8:	7100001f 	cmp	w0, #0x0
    4800b5cc:	54000120 	b.eq	4800b5f0 <rt_soft_timer_check+0x194>  // b.none
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
    4800b5d0:	f9401fe0 	ldr	x0, [sp, #56]
    4800b5d4:	39402400 	ldrb	w0, [x0, #9]
    4800b5d8:	121f7800 	and	w0, w0, #0xfffffffe
    4800b5dc:	12001c01 	and	w1, w0, #0xff
    4800b5e0:	f9401fe0 	ldr	x0, [sp, #56]
    4800b5e4:	39002401 	strb	w1, [x0, #9]
                rt_timer_start(t);
    4800b5e8:	f9401fe0 	ldr	x0, [sp, #56]
    4800b5ec:	97fffda6 	bl	4800ac84 <rt_timer_start>
    while (!rt_list_isempty(&_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
    4800b5f0:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b5f4:	912a6000 	add	x0, x0, #0xa98
    4800b5f8:	97fffc8d 	bl	4800a82c <rt_list_isempty>
    4800b5fc:	7100001f 	cmp	w0, #0x0
    4800b600:	54fff3e0 	b.eq	4800b47c <rt_soft_timer_check+0x20>  // b.none
    4800b604:	14000002 	b	4800b60c <rt_soft_timer_check+0x1b0>
            }
        }
        else break; /* not check anymore */
    4800b608:	d503201f 	nop
    }
    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800b60c:	aa1303e0 	mov	x0, x19
    4800b610:	97ffe38b 	bl	4800443c <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
}
    4800b614:	d503201f 	nop
    4800b618:	f9400bf3 	ldr	x19, [sp, #16]
    4800b61c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800b620:	d65f03c0 	ret

000000004800b624 <_timer_thread_entry>:
 * @brief System timer thread entry
 *
 * @param parameter is the arg of the thread
 */
static void _timer_thread_entry(void *parameter)
{
    4800b624:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800b628:	910003fd 	mov	x29, sp
    4800b62c:	f9000fe0 	str	x0, [sp, #24]
    rt_tick_t next_timeout;

    while (1)
    {
        /* get the next timeout tick */
        next_timeout = _timer_list_next_timeout(_soft_timer_list);
    4800b630:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b634:	912a6000 	add	x0, x0, #0xa98
    4800b638:	97fffcc6 	bl	4800a950 <_timer_list_next_timeout>
    4800b63c:	b9002fe0 	str	w0, [sp, #44]
        if (next_timeout == RT_TICK_MAX)
    4800b640:	b9402fe0 	ldr	w0, [sp, #44]
    4800b644:	3100041f 	cmn	w0, #0x1
    4800b648:	540000a1 	b.ne	4800b65c <_timer_thread_entry+0x38>  // b.any
        {
            /* no software timer exist, suspend self. */
            rt_thread_suspend(rt_thread_self());
    4800b64c:	94000154 	bl	4800bb9c <rt_thread_self>
    4800b650:	94000356 	bl	4800c3a8 <rt_thread_suspend>
            rt_schedule();
    4800b654:	9400074e 	bl	4800d38c <rt_schedule>
    4800b658:	1400000f 	b	4800b694 <_timer_thread_entry+0x70>
        else
        {
            rt_tick_t current_tick;

            /* get current tick */
            current_tick = rt_tick_get();
    4800b65c:	940012a4 	bl	480100ec <rt_tick_get>
    4800b660:	b9002be0 	str	w0, [sp, #40]

            if ((next_timeout - current_tick) < RT_TICK_MAX / 2)
    4800b664:	b9402fe1 	ldr	w1, [sp, #44]
    4800b668:	b9402be0 	ldr	w0, [sp, #40]
    4800b66c:	4b000021 	sub	w1, w1, w0
    4800b670:	321f77e0 	mov	w0, #0x7ffffffe            	// #2147483646
    4800b674:	6b00003f 	cmp	w1, w0
    4800b678:	540000e8 	b.hi	4800b694 <_timer_thread_entry+0x70>  // b.pmore
            {
                /* get the delta timeout tick */
                next_timeout = next_timeout - current_tick;
    4800b67c:	b9402fe1 	ldr	w1, [sp, #44]
    4800b680:	b9402be0 	ldr	w0, [sp, #40]
    4800b684:	4b000020 	sub	w0, w1, w0
    4800b688:	b9002fe0 	str	w0, [sp, #44]
                rt_thread_delay(next_timeout);
    4800b68c:	b9402fe0 	ldr	w0, [sp, #44]
    4800b690:	94000279 	bl	4800c074 <rt_thread_delay>
            }
        }

        /* check software timer */
        rt_soft_timer_check();
    4800b694:	97ffff72 	bl	4800b45c <rt_soft_timer_check>
        next_timeout = _timer_list_next_timeout(_soft_timer_list);
    4800b698:	17ffffe6 	b	4800b630 <_timer_thread_entry+0xc>

000000004800b69c <rt_system_timer_init>:
 * @ingroup SystemInit
 *
 * @brief This function will initialize system timer
 */
void rt_system_timer_init(void)
{
    4800b69c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800b6a0:	910003fd 	mov	x29, sp
    int i;

    for (i = 0; i < sizeof(_timer_list) / sizeof(_timer_list[0]); i++)
    4800b6a4:	b9001fff 	str	wzr, [sp, #28]
    4800b6a8:	1400000a 	b	4800b6d0 <rt_system_timer_init+0x34>
    {
        rt_list_init(_timer_list + i);
    4800b6ac:	b9801fe0 	ldrsw	x0, [sp, #28]
    4800b6b0:	d37cec01 	lsl	x1, x0, #4
    4800b6b4:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b6b8:	912a2000 	add	x0, x0, #0xa88
    4800b6bc:	8b000020 	add	x0, x1, x0
    4800b6c0:	97fffc25 	bl	4800a754 <rt_list_init>
    for (i = 0; i < sizeof(_timer_list) / sizeof(_timer_list[0]); i++)
    4800b6c4:	b9401fe0 	ldr	w0, [sp, #28]
    4800b6c8:	11000400 	add	w0, w0, #0x1
    4800b6cc:	b9001fe0 	str	w0, [sp, #28]
    4800b6d0:	b9401fe0 	ldr	w0, [sp, #28]
    4800b6d4:	7100001f 	cmp	w0, #0x0
    4800b6d8:	54fffea0 	b.eq	4800b6ac <rt_system_timer_init+0x10>  // b.none
    }
}
    4800b6dc:	d503201f 	nop
    4800b6e0:	d503201f 	nop
    4800b6e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800b6e8:	d65f03c0 	ret

000000004800b6ec <rt_system_timer_thread_init>:
 * @ingroup SystemInit
 *
 * @brief This function will initialize system timer thread
 */
void rt_system_timer_thread_init(void)
{
    4800b6ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800b6f0:	910003fd 	mov	x29, sp
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;
    4800b6f4:	b9001fff 	str	wzr, [sp, #28]
    4800b6f8:	1400000a 	b	4800b720 <rt_system_timer_thread_init+0x34>
         i < sizeof(_soft_timer_list) / sizeof(_soft_timer_list[0]);
         i++)
    {
        rt_list_init(_soft_timer_list + i);
    4800b6fc:	b9801fe0 	ldrsw	x0, [sp, #28]
    4800b700:	d37cec01 	lsl	x1, x0, #4
    4800b704:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b708:	912a6000 	add	x0, x0, #0xa98
    4800b70c:	8b000020 	add	x0, x1, x0
    4800b710:	97fffc11 	bl	4800a754 <rt_list_init>
         i++)
    4800b714:	b9401fe0 	ldr	w0, [sp, #28]
    4800b718:	11000400 	add	w0, w0, #0x1
    4800b71c:	b9001fe0 	str	w0, [sp, #28]
    for (i = 0;
    4800b720:	b9401fe0 	ldr	w0, [sp, #28]
    4800b724:	7100001f 	cmp	w0, #0x0
    4800b728:	54fffea0 	b.eq	4800b6fc <rt_system_timer_thread_init+0x10>  // b.none
    }

    /* start software timer thread */
    rt_thread_init(&_timer_thread,
    4800b72c:	52800147 	mov	w7, #0xa                   	// #10
    4800b730:	52800086 	mov	w6, #0x4                   	// #4
    4800b734:	52810005 	mov	w5, #0x800                 	// #2048
    4800b738:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b73c:	912e0004 	add	x4, x0, #0xb80
    4800b740:	d2800003 	mov	x3, #0x0                   	// #0
    4800b744:	90000000 	adrp	x0, 4800b000 <rt_timer_start+0x37c>
    4800b748:	91189002 	add	x2, x0, #0x624
    4800b74c:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800b750:	91066001 	add	x1, x0, #0x198
    4800b754:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b758:	912aa000 	add	x0, x0, #0xaa8
    4800b75c:	940000e5 	bl	4800baf0 <rt_thread_init>
                   sizeof(_timer_thread_stack),
                   RT_TIMER_THREAD_PRIO,
                   10);

    /* startup */
    rt_thread_startup(&_timer_thread);
    4800b760:	b0000160 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800b764:	912aa000 	add	x0, x0, #0xaa8
    4800b768:	94000111 	bl	4800bbac <rt_thread_startup>
#endif /* RT_USING_TIMER_SOFT */
}
    4800b76c:	d503201f 	nop
    4800b770:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800b774:	d65f03c0 	ret

000000004800b778 <rt_list_init>:
{
    4800b778:	d10043ff 	sub	sp, sp, #0x10
    4800b77c:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    4800b780:	f94007e0 	ldr	x0, [sp, #8]
    4800b784:	f94007e1 	ldr	x1, [sp, #8]
    4800b788:	f9000401 	str	x1, [x0, #8]
    4800b78c:	f94007e0 	ldr	x0, [sp, #8]
    4800b790:	f9400401 	ldr	x1, [x0, #8]
    4800b794:	f94007e0 	ldr	x0, [sp, #8]
    4800b798:	f9000001 	str	x1, [x0]
}
    4800b79c:	d503201f 	nop
    4800b7a0:	910043ff 	add	sp, sp, #0x10
    4800b7a4:	d65f03c0 	ret

000000004800b7a8 <rt_list_remove>:
{
    4800b7a8:	d10043ff 	sub	sp, sp, #0x10
    4800b7ac:	f90007e0 	str	x0, [sp, #8]
    n->next->prev = n->prev;
    4800b7b0:	f94007e0 	ldr	x0, [sp, #8]
    4800b7b4:	f9400000 	ldr	x0, [x0]
    4800b7b8:	f94007e1 	ldr	x1, [sp, #8]
    4800b7bc:	f9400421 	ldr	x1, [x1, #8]
    4800b7c0:	f9000401 	str	x1, [x0, #8]
    n->prev->next = n->next;
    4800b7c4:	f94007e0 	ldr	x0, [sp, #8]
    4800b7c8:	f9400400 	ldr	x0, [x0, #8]
    4800b7cc:	f94007e1 	ldr	x1, [sp, #8]
    4800b7d0:	f9400021 	ldr	x1, [x1]
    4800b7d4:	f9000001 	str	x1, [x0]
    n->next = n->prev = n;
    4800b7d8:	f94007e0 	ldr	x0, [sp, #8]
    4800b7dc:	f94007e1 	ldr	x1, [sp, #8]
    4800b7e0:	f9000401 	str	x1, [x0, #8]
    4800b7e4:	f94007e0 	ldr	x0, [sp, #8]
    4800b7e8:	f9400401 	ldr	x1, [x0, #8]
    4800b7ec:	f94007e0 	ldr	x0, [sp, #8]
    4800b7f0:	f9000001 	str	x1, [x0]
}
    4800b7f4:	d503201f 	nop
    4800b7f8:	910043ff 	add	sp, sp, #0x10
    4800b7fc:	d65f03c0 	ret

000000004800b800 <rt_thread_suspend_sethook>:
 * @note    The hook function must be simple and never be blocked or suspend.
 *
 * @param   hook is the specified hook function.
 */
void rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread))
{
    4800b800:	d10043ff 	sub	sp, sp, #0x10
    4800b804:	f90007e0 	str	x0, [sp, #8]
    rt_thread_suspend_hook = hook;
    4800b808:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b80c:	910e6000 	add	x0, x0, #0x398
    4800b810:	f94007e1 	ldr	x1, [sp, #8]
    4800b814:	f9000001 	str	x1, [x0]
}
    4800b818:	d503201f 	nop
    4800b81c:	910043ff 	add	sp, sp, #0x10
    4800b820:	d65f03c0 	ret

000000004800b824 <rt_thread_resume_sethook>:
 * @note    The hook function must be simple and never be blocked or suspend.
 *
 * @param   hook is the specified hook function.
 */
void rt_thread_resume_sethook(void (*hook)(rt_thread_t thread))
{
    4800b824:	d10043ff 	sub	sp, sp, #0x10
    4800b828:	f90007e0 	str	x0, [sp, #8]
    rt_thread_resume_hook = hook;
    4800b82c:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b830:	910e8000 	add	x0, x0, #0x3a0
    4800b834:	f94007e1 	ldr	x1, [sp, #8]
    4800b838:	f9000001 	str	x1, [x0]
}
    4800b83c:	d503201f 	nop
    4800b840:	910043ff 	add	sp, sp, #0x10
    4800b844:	d65f03c0 	ret

000000004800b848 <rt_thread_inited_sethook>:
 * @brief   This function sets a hook function when a thread is initialized.
 *
 * @param   hook is the specified hook function.
 */
void rt_thread_inited_sethook(void (*hook)(rt_thread_t thread))
{
    4800b848:	d10043ff 	sub	sp, sp, #0x10
    4800b84c:	f90007e0 	str	x0, [sp, #8]
    rt_thread_inited_hook = hook;
    4800b850:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800b854:	910ea000 	add	x0, x0, #0x3a8
    4800b858:	f94007e1 	ldr	x1, [sp, #8]
    4800b85c:	f9000001 	str	x1, [x0]
}
    4800b860:	d503201f 	nop
    4800b864:	910043ff 	add	sp, sp, #0x10
    4800b868:	d65f03c0 	ret

000000004800b86c <_thread_cleanup_execute>:

#endif /* RT_USING_HOOK */

static void _thread_cleanup_execute(rt_thread_t thread)
{
    4800b86c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800b870:	910003fd 	mov	x29, sp
    4800b874:	f9000bf3 	str	x19, [sp, #16]
    4800b878:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t level;
#ifdef RT_USING_MODULE
    struct rt_dlmodule *module = RT_NULL;
#endif /* RT_USING_MODULE */
    level = rt_hw_interrupt_disable();
    4800b87c:	97ffe2ec 	bl	4800442c <rt_hw_interrupt_disable>
    4800b880:	aa0003f3 	mov	x19, x0
    {
        dlmodule_destroy(module);
    }
#endif /* RT_USING_MODULE */
    /* invoke thread cleanup */
    if (thread->cleanup != RT_NULL)
    4800b884:	f94017e0 	ldr	x0, [sp, #40]
    4800b888:	f9406400 	ldr	x0, [x0, #200]
    4800b88c:	f100001f 	cmp	x0, #0x0
    4800b890:	540000a0 	b.eq	4800b8a4 <_thread_cleanup_execute+0x38>  // b.none
        thread->cleanup(thread);
    4800b894:	f94017e0 	ldr	x0, [sp, #40]
    4800b898:	f9406401 	ldr	x1, [x0, #200]
    4800b89c:	f94017e0 	ldr	x0, [sp, #40]
    4800b8a0:	d63f0020 	blr	x1

#ifdef RT_USING_SIGNALS
    rt_thread_free_sig(thread);
#endif /* RT_USING_SIGNALS */
    rt_hw_interrupt_enable(level);
    4800b8a4:	aa1303e0 	mov	x0, x19
    4800b8a8:	97ffe2e5 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800b8ac:	d503201f 	nop
    4800b8b0:	f9400bf3 	ldr	x19, [sp, #16]
    4800b8b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800b8b8:	d65f03c0 	ret

000000004800b8bc <_thread_exit>:

static void _thread_exit(void)
{
    4800b8bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800b8c0:	910003fd 	mov	x29, sp
    4800b8c4:	f9000bf3 	str	x19, [sp, #16]
    struct rt_thread *thread;
    register rt_base_t level;

    /* get current thread */
    thread = rt_thread_self();
    4800b8c8:	940000b5 	bl	4800bb9c <rt_thread_self>
    4800b8cc:	f90017e0 	str	x0, [sp, #40]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800b8d0:	97ffe2d7 	bl	4800442c <rt_hw_interrupt_disable>
    4800b8d4:	aa0003f3 	mov	x19, x0

    _thread_cleanup_execute(thread);
    4800b8d8:	f94017e0 	ldr	x0, [sp, #40]
    4800b8dc:	97ffffe4 	bl	4800b86c <_thread_cleanup_execute>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
    4800b8e0:	f94017e0 	ldr	x0, [sp, #40]
    4800b8e4:	940007a1 	bl	4800d768 <rt_schedule_remove_thread>
    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
    4800b8e8:	f94017e0 	ldr	x0, [sp, #40]
    4800b8ec:	52800081 	mov	w1, #0x4                   	// #4
    4800b8f0:	39018001 	strb	w1, [x0, #96]

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);
    4800b8f4:	f94017e0 	ldr	x0, [sp, #40]
    4800b8f8:	91020000 	add	x0, x0, #0x80
    4800b8fc:	97fffc61 	bl	4800aa80 <rt_timer_detach>

    if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
    4800b900:	f94017e0 	ldr	x0, [sp, #40]
    4800b904:	940009d5 	bl	4800e058 <rt_object_is_systemobject>
    4800b908:	7100041f 	cmp	w0, #0x1
    4800b90c:	54000081 	b.ne	4800b91c <_thread_exit+0x60>  // b.any
    {
        rt_object_detach((rt_object_t)thread);
    4800b910:	f94017e0 	ldr	x0, [sp, #40]
    4800b914:	94000926 	bl	4800ddac <rt_object_detach>
    4800b918:	14000003 	b	4800b924 <_thread_exit+0x68>
    }
    else
    {
        /* insert to defunct thread list */
        rt_thread_defunct_enqueue(thread);
    4800b91c:	f94017e0 	ldr	x0, [sp, #40]
    4800b920:	97ffe7c8 	bl	48005840 <rt_thread_defunct_enqueue>
    }

    /* switch to next task */
    rt_schedule();
    4800b924:	9400069a 	bl	4800d38c <rt_schedule>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800b928:	aa1303e0 	mov	x0, x19
    4800b92c:	97ffe2c4 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800b930:	d503201f 	nop
    4800b934:	f9400bf3 	ldr	x19, [sp, #16]
    4800b938:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800b93c:	d65f03c0 	ret

000000004800b940 <_thread_init>:
                             void             *parameter,
                             void             *stack_start,
                             rt_uint32_t       stack_size,
                             rt_uint8_t        priority,
                             rt_uint32_t       tick)
{
    4800b940:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4800b944:	910003fd 	mov	x29, sp
    4800b948:	f90027e0 	str	x0, [sp, #72]
    4800b94c:	f90023e1 	str	x1, [sp, #64]
    4800b950:	f9001fe2 	str	x2, [sp, #56]
    4800b954:	f9001be3 	str	x3, [sp, #48]
    4800b958:	f90017e4 	str	x4, [sp, #40]
    4800b95c:	b90027e5 	str	w5, [sp, #36]
    4800b960:	39008fe6 	strb	w6, [sp, #35]
    4800b964:	b9001fe7 	str	w7, [sp, #28]
    /* init thread list */
    rt_list_init(&(thread->tlist));
    4800b968:	f94027e0 	ldr	x0, [sp, #72]
    4800b96c:	91008000 	add	x0, x0, #0x20
    4800b970:	97ffff82 	bl	4800b778 <rt_list_init>

    thread->entry = (void *)entry;
    4800b974:	f94027e0 	ldr	x0, [sp, #72]
    4800b978:	f9401fe1 	ldr	x1, [sp, #56]
    4800b97c:	f9001c01 	str	x1, [x0, #56]
    thread->parameter = parameter;
    4800b980:	f94027e0 	ldr	x0, [sp, #72]
    4800b984:	f9401be1 	ldr	x1, [sp, #48]
    4800b988:	f9002001 	str	x1, [x0, #64]

    /* stack init */
    thread->stack_addr = stack_start;
    4800b98c:	f94027e0 	ldr	x0, [sp, #72]
    4800b990:	f94017e1 	ldr	x1, [sp, #40]
    4800b994:	f9002401 	str	x1, [x0, #72]
    thread->stack_size = stack_size;
    4800b998:	f94027e0 	ldr	x0, [sp, #72]
    4800b99c:	b94027e1 	ldr	w1, [sp, #36]
    4800b9a0:	b9005001 	str	w1, [x0, #80]

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
    4800b9a4:	f94027e0 	ldr	x0, [sp, #72]
    4800b9a8:	f9402403 	ldr	x3, [x0, #72]
    4800b9ac:	f94027e0 	ldr	x0, [sp, #72]
    4800b9b0:	b9405000 	ldr	w0, [x0, #80]
    4800b9b4:	2a0003e0 	mov	w0, w0
    4800b9b8:	aa0003e2 	mov	x2, x0
    4800b9bc:	52800461 	mov	w1, #0x23                  	// #35
    4800b9c0:	aa0303e0 	mov	x0, x3
    4800b9c4:	94000a5a 	bl	4800e32c <rt_memset>
#ifdef ARCH_CPU_STACK_GROWS_UPWARD
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
                                          (void *)((char *)thread->stack_addr),
                                          (void *)_thread_exit);
#else
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
    4800b9c8:	f94027e0 	ldr	x0, [sp, #72]
    4800b9cc:	f9401c04 	ldr	x4, [x0, #56]
    4800b9d0:	f94027e0 	ldr	x0, [sp, #72]
    4800b9d4:	f9402005 	ldr	x5, [x0, #64]
                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),
    4800b9d8:	f94027e0 	ldr	x0, [sp, #72]
    4800b9dc:	f9402401 	ldr	x1, [x0, #72]
    4800b9e0:	f94027e0 	ldr	x0, [sp, #72]
    4800b9e4:	b9405000 	ldr	w0, [x0, #80]
    4800b9e8:	2a0003e0 	mov	w0, w0
    4800b9ec:	d1002000 	sub	x0, x0, #0x8
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
    4800b9f0:	8b000021 	add	x1, x1, x0
    4800b9f4:	90000000 	adrp	x0, 4800b000 <rt_timer_start+0x37c>
    4800b9f8:	9122f003 	add	x3, x0, #0x8bc
    4800b9fc:	aa0103e2 	mov	x2, x1
    4800ba00:	aa0503e1 	mov	x1, x5
    4800ba04:	aa0403e0 	mov	x0, x4
    4800ba08:	97ffd77f 	bl	48001804 <rt_hw_stack_init>
    4800ba0c:	aa0003e1 	mov	x1, x0
    4800ba10:	f94027e0 	ldr	x0, [sp, #72]
    4800ba14:	f9001801 	str	x1, [x0, #48]
                                          (void *)_thread_exit);
#endif /* ARCH_CPU_STACK_GROWS_UPWARD */

    /* priority init */
    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
    4800ba18:	39408fe0 	ldrb	w0, [sp, #35]
    4800ba1c:	71007c1f 	cmp	w0, #0x1f
    4800ba20:	540000e9 	b.ls	4800ba3c <_thread_init+0xfc>  // b.plast
    4800ba24:	d2801542 	mov	x2, #0xaa                  	// #170
    4800ba28:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ba2c:	910f0001 	add	x1, x0, #0x3c0
    4800ba30:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ba34:	91082000 	add	x0, x0, #0x208
    4800ba38:	9400118c 	bl	48010068 <rt_assert_handler>
    thread->init_priority    = priority;
    4800ba3c:	f94027e0 	ldr	x0, [sp, #72]
    4800ba40:	39408fe1 	ldrb	w1, [sp, #35]
    4800ba44:	39018801 	strb	w1, [x0, #98]
    thread->current_priority = priority;
    4800ba48:	f94027e0 	ldr	x0, [sp, #72]
    4800ba4c:	39408fe1 	ldrb	w1, [sp, #35]
    4800ba50:	39018401 	strb	w1, [x0, #97]

    thread->number_mask = 0;
    4800ba54:	f94027e0 	ldr	x0, [sp, #72]
    4800ba58:	b900641f 	str	wzr, [x0, #100]
    thread->number = 0;
    thread->high_mask = 0;
#endif /* RT_THREAD_PRIORITY_MAX > 32 */

    /* tick init */
    thread->init_tick      = tick;
    4800ba5c:	b9401fe1 	ldr	w1, [sp, #28]
    4800ba60:	f94027e0 	ldr	x0, [sp, #72]
    4800ba64:	f9003801 	str	x1, [x0, #112]
    thread->remaining_tick = tick;
    4800ba68:	b9401fe1 	ldr	w1, [sp, #28]
    4800ba6c:	f94027e0 	ldr	x0, [sp, #72]
    4800ba70:	f9003c01 	str	x1, [x0, #120]

    /* error and flags */
    thread->error = RT_EOK;
    4800ba74:	f94027e0 	ldr	x0, [sp, #72]
    4800ba78:	f9002c1f 	str	xzr, [x0, #88]
    thread->stat  = RT_THREAD_INIT;
    4800ba7c:	f94027e0 	ldr	x0, [sp, #72]
    4800ba80:	3901801f 	strb	wzr, [x0, #96]
    thread->cpus_lock_nest = 0;
    thread->critical_lock_nest = 0;
#endif /* RT_USING_SMP */

    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
    4800ba84:	f94027e0 	ldr	x0, [sp, #72]
    4800ba88:	f900641f 	str	xzr, [x0, #200]
    thread->user_data = 0;
    4800ba8c:	f94027e0 	ldr	x0, [sp, #72]
    4800ba90:	f900681f 	str	xzr, [x0, #208]

    /* initialize thread timer */
    rt_timer_init(&(thread->thread_timer),
    4800ba94:	f94027e0 	ldr	x0, [sp, #72]
    4800ba98:	91020006 	add	x6, x0, #0x80
                  thread->name,
    4800ba9c:	f94027e1 	ldr	x1, [sp, #72]
    rt_timer_init(&(thread->thread_timer),
    4800baa0:	52800005 	mov	w5, #0x0                   	// #0
    4800baa4:	52800004 	mov	w4, #0x0                   	// #0
    4800baa8:	f94027e3 	ldr	x3, [sp, #72]
    4800baac:	b0000000 	adrp	x0, 4800c000 <rt_thread_sleep+0x5c>
    4800bab0:	91173002 	add	x2, x0, #0x5cc
    4800bab4:	aa0603e0 	mov	x0, x6
    4800bab8:	97fffbd4 	bl	4800aa08 <rt_timer_init>

#ifdef RT_USING_CPU_USAGE
    thread->duration_tick = 0;
#endif

    RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread));
    4800babc:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800bac0:	910ea000 	add	x0, x0, #0x3a8
    4800bac4:	f9400000 	ldr	x0, [x0]
    4800bac8:	f100001f 	cmp	x0, #0x0
    4800bacc:	540000c0 	b.eq	4800bae4 <_thread_init+0x1a4>  // b.none
    4800bad0:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800bad4:	910ea000 	add	x0, x0, #0x3a8
    4800bad8:	f9400001 	ldr	x1, [x0]
    4800badc:	f94027e0 	ldr	x0, [sp, #72]
    4800bae0:	d63f0020 	blr	x1

    return RT_EOK;
    4800bae4:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800bae8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800baec:	d65f03c0 	ret

000000004800baf0 <rt_thread_init>:
                        void             *parameter,
                        void             *stack_start,
                        rt_uint32_t       stack_size,
                        rt_uint8_t        priority,
                        rt_uint32_t       tick)
{
    4800baf0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4800baf4:	910003fd 	mov	x29, sp
    4800baf8:	f90027e0 	str	x0, [sp, #72]
    4800bafc:	f90023e1 	str	x1, [sp, #64]
    4800bb00:	f9001fe2 	str	x2, [sp, #56]
    4800bb04:	f9001be3 	str	x3, [sp, #48]
    4800bb08:	f90017e4 	str	x4, [sp, #40]
    4800bb0c:	b90027e5 	str	w5, [sp, #36]
    4800bb10:	39008fe6 	strb	w6, [sp, #35]
    4800bb14:	b9001fe7 	str	w7, [sp, #28]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800bb18:	f94027e0 	ldr	x0, [sp, #72]
    4800bb1c:	f100001f 	cmp	x0, #0x0
    4800bb20:	540000e1 	b.ne	4800bb3c <rt_thread_init+0x4c>  // b.any
    4800bb24:	d2802262 	mov	x2, #0x113                 	// #275
    4800bb28:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bb2c:	910f4001 	add	x1, x0, #0x3d0
    4800bb30:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bb34:	9108c000 	add	x0, x0, #0x230
    4800bb38:	9400114c 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(stack_start != RT_NULL);
    4800bb3c:	f94017e0 	ldr	x0, [sp, #40]
    4800bb40:	f100001f 	cmp	x0, #0x0
    4800bb44:	540000e1 	b.ne	4800bb60 <rt_thread_init+0x70>  // b.any
    4800bb48:	d2802282 	mov	x2, #0x114                 	// #276
    4800bb4c:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bb50:	910f4001 	add	x1, x0, #0x3d0
    4800bb54:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bb58:	91092000 	add	x0, x0, #0x248
    4800bb5c:	94001143 	bl	48010068 <rt_assert_handler>

    /* initialize thread object */
    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
    4800bb60:	f94023e2 	ldr	x2, [sp, #64]
    4800bb64:	52800021 	mov	w1, #0x1                   	// #1
    4800bb68:	f94027e0 	ldr	x0, [sp, #72]
    4800bb6c:	9400083c 	bl	4800dc5c <rt_object_init>

    return _thread_init(thread,
    4800bb70:	b9401fe7 	ldr	w7, [sp, #28]
    4800bb74:	39408fe6 	ldrb	w6, [sp, #35]
    4800bb78:	b94027e5 	ldr	w5, [sp, #36]
    4800bb7c:	f94017e4 	ldr	x4, [sp, #40]
    4800bb80:	f9401be3 	ldr	x3, [sp, #48]
    4800bb84:	f9401fe2 	ldr	x2, [sp, #56]
    4800bb88:	f94023e1 	ldr	x1, [sp, #64]
    4800bb8c:	f94027e0 	ldr	x0, [sp, #72]
    4800bb90:	97ffff6c 	bl	4800b940 <_thread_init>
                        parameter,
                        stack_start,
                        stack_size,
                        priority,
                        tick);
}
    4800bb94:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800bb98:	d65f03c0 	ret

000000004800bb9c <rt_thread_self>:
    rt_hw_local_irq_enable(lock);
    return self;
#else
    extern rt_thread_t rt_current_thread;

    return rt_current_thread;
    4800bb9c:	d0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800bba0:	9116e000 	add	x0, x0, #0x5b8
    4800bba4:	f9400000 	ldr	x0, [x0]
#endif /* RT_USING_SMP */
}
    4800bba8:	d65f03c0 	ret

000000004800bbac <rt_thread_startup>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_startup(rt_thread_t thread)
{
    4800bbac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800bbb0:	910003fd 	mov	x29, sp
    4800bbb4:	f9000fe0 	str	x0, [sp, #24]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800bbb8:	f9400fe0 	ldr	x0, [sp, #24]
    4800bbbc:	f100001f 	cmp	x0, #0x0
    4800bbc0:	540000e1 	b.ne	4800bbdc <rt_thread_startup+0x30>  // b.any
    4800bbc4:	d28028c2 	mov	x2, #0x146                 	// #326
    4800bbc8:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bbcc:	910f8001 	add	x1, x0, #0x3e0
    4800bbd0:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bbd4:	9108c000 	add	x0, x0, #0x230
    4800bbd8:	94001124 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_INIT);
    4800bbdc:	f9400fe0 	ldr	x0, [sp, #24]
    4800bbe0:	39418000 	ldrb	w0, [x0, #96]
    4800bbe4:	12000800 	and	w0, w0, #0x7
    4800bbe8:	7100001f 	cmp	w0, #0x0
    4800bbec:	540000e0 	b.eq	4800bc08 <rt_thread_startup+0x5c>  // b.none
    4800bbf0:	d28028e2 	mov	x2, #0x147                 	// #327
    4800bbf4:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bbf8:	910f8001 	add	x1, x0, #0x3e0
    4800bbfc:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bc00:	91098000 	add	x0, x0, #0x260
    4800bc04:	94001119 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800bc08:	f9400fe0 	ldr	x0, [sp, #24]
    4800bc0c:	94000929 	bl	4800e0b0 <rt_object_get_type>
    4800bc10:	12001c00 	and	w0, w0, #0xff
    4800bc14:	7100041f 	cmp	w0, #0x1
    4800bc18:	540000e0 	b.eq	4800bc34 <rt_thread_startup+0x88>  // b.none
    4800bc1c:	d2802902 	mov	x2, #0x148                 	// #328
    4800bc20:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bc24:	910f8001 	add	x1, x0, #0x3e0
    4800bc28:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bc2c:	910a6000 	add	x0, x0, #0x298
    4800bc30:	9400110e 	bl	48010068 <rt_assert_handler>

    /* set current priority to initialize priority */
    thread->current_priority = thread->init_priority;
    4800bc34:	f9400fe0 	ldr	x0, [sp, #24]
    4800bc38:	39418801 	ldrb	w1, [x0, #98]
    4800bc3c:	f9400fe0 	ldr	x0, [sp, #24]
    4800bc40:	39018401 	strb	w1, [x0, #97]
#if RT_THREAD_PRIORITY_MAX > 32
    thread->number      = thread->current_priority >> 3;            /* 5bit */
    thread->number_mask = 1L << thread->number;
    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
#else
    thread->number_mask = 1L << thread->current_priority;
    4800bc44:	f9400fe0 	ldr	x0, [sp, #24]
    4800bc48:	39418400 	ldrb	w0, [x0, #97]
    4800bc4c:	2a0003e1 	mov	w1, w0
    4800bc50:	d2800020 	mov	x0, #0x1                   	// #1
    4800bc54:	9ac12000 	lsl	x0, x0, x1
    4800bc58:	2a0003e1 	mov	w1, w0
    4800bc5c:	f9400fe0 	ldr	x0, [sp, #24]
    4800bc60:	b9006401 	str	w1, [x0, #100]
#endif /* RT_THREAD_PRIORITY_MAX > 32 */

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
                                   thread->name, thread->init_priority));
    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
    4800bc64:	f9400fe0 	ldr	x0, [sp, #24]
    4800bc68:	52800041 	mov	w1, #0x2                   	// #2
    4800bc6c:	39018001 	strb	w1, [x0, #96]
    /* then resume it */
    rt_thread_resume(thread);
    4800bc70:	f9400fe0 	ldr	x0, [sp, #24]
    4800bc74:	9400021d 	bl	4800c4e8 <rt_thread_resume>
    if (rt_thread_self() != RT_NULL)
    4800bc78:	97ffffc9 	bl	4800bb9c <rt_thread_self>
    4800bc7c:	f100001f 	cmp	x0, #0x0
    4800bc80:	54000040 	b.eq	4800bc88 <rt_thread_startup+0xdc>  // b.none
    {
        /* do a scheduling */
        rt_schedule();
    4800bc84:	940005c2 	bl	4800d38c <rt_schedule>
    }

    return RT_EOK;
    4800bc88:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800bc8c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800bc90:	d65f03c0 	ret

000000004800bc94 <rt_thread_detach>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_detach(rt_thread_t thread)
{
    4800bc94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800bc98:	910003fd 	mov	x29, sp
    4800bc9c:	f9000fe0 	str	x0, [sp, #24]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800bca0:	f9400fe0 	ldr	x0, [sp, #24]
    4800bca4:	f100001f 	cmp	x0, #0x0
    4800bca8:	540000e1 	b.ne	4800bcc4 <rt_thread_detach+0x30>  // b.any
    4800bcac:	d2802e82 	mov	x2, #0x174                 	// #372
    4800bcb0:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bcb4:	910fe001 	add	x1, x0, #0x3f8
    4800bcb8:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bcbc:	9108c000 	add	x0, x0, #0x230
    4800bcc0:	940010ea 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800bcc4:	f9400fe0 	ldr	x0, [sp, #24]
    4800bcc8:	940008fa 	bl	4800e0b0 <rt_object_get_type>
    4800bccc:	12001c00 	and	w0, w0, #0xff
    4800bcd0:	7100041f 	cmp	w0, #0x1
    4800bcd4:	540000e0 	b.eq	4800bcf0 <rt_thread_detach+0x5c>  // b.none
    4800bcd8:	d2802ea2 	mov	x2, #0x175                 	// #373
    4800bcdc:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bce0:	910fe001 	add	x1, x0, #0x3f8
    4800bce4:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bce8:	910a6000 	add	x0, x0, #0x298
    4800bcec:	940010df 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread));
    4800bcf0:	f9400fe0 	ldr	x0, [sp, #24]
    4800bcf4:	940008d9 	bl	4800e058 <rt_object_is_systemobject>
    4800bcf8:	7100001f 	cmp	w0, #0x0
    4800bcfc:	540000e1 	b.ne	4800bd18 <rt_thread_detach+0x84>  // b.any
    4800bd00:	d2802ec2 	mov	x2, #0x176                 	// #374
    4800bd04:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bd08:	910fe001 	add	x1, x0, #0x3f8
    4800bd0c:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bd10:	910b8000 	add	x0, x0, #0x2e0
    4800bd14:	940010d5 	bl	48010068 <rt_assert_handler>

    if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
    4800bd18:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd1c:	39418000 	ldrb	w0, [x0, #96]
    4800bd20:	12000800 	and	w0, w0, #0x7
    4800bd24:	7100101f 	cmp	w0, #0x4
    4800bd28:	54000061 	b.ne	4800bd34 <rt_thread_detach+0xa0>  // b.any
        return RT_EOK;
    4800bd2c:	d2800000 	mov	x0, #0x0                   	// #0
    4800bd30:	1400001e 	b	4800bda8 <rt_thread_detach+0x114>

    if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
    4800bd34:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd38:	39418000 	ldrb	w0, [x0, #96]
    4800bd3c:	12000800 	and	w0, w0, #0x7
    4800bd40:	7100001f 	cmp	w0, #0x0
    4800bd44:	54000060 	b.eq	4800bd50 <rt_thread_detach+0xbc>  // b.none
    {
        /* remove from schedule */
        rt_schedule_remove_thread(thread);
    4800bd48:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd4c:	94000687 	bl	4800d768 <rt_schedule_remove_thread>
    }

    _thread_cleanup_execute(thread);
    4800bd50:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd54:	97fffec6 	bl	4800b86c <_thread_cleanup_execute>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
    4800bd58:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd5c:	91020000 	add	x0, x0, #0x80
    4800bd60:	97fffb48 	bl	4800aa80 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
    4800bd64:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd68:	52800081 	mov	w1, #0x4                   	// #4
    4800bd6c:	39018001 	strb	w1, [x0, #96]

    if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
    4800bd70:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd74:	940008b9 	bl	4800e058 <rt_object_is_systemobject>
    4800bd78:	7100041f 	cmp	w0, #0x1
    4800bd7c:	54000081 	b.ne	4800bd8c <rt_thread_detach+0xf8>  // b.any
    {
        rt_object_detach((rt_object_t)thread);
    4800bd80:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd84:	9400080a 	bl	4800ddac <rt_object_detach>
    4800bd88:	14000007 	b	4800bda4 <rt_thread_detach+0x110>
    }
    else
    {
        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
    4800bd8c:	97ffe1a8 	bl	4800442c <rt_hw_interrupt_disable>
    4800bd90:	f90017e0 	str	x0, [sp, #40]
        /* insert to defunct thread list */
        rt_thread_defunct_enqueue(thread);
    4800bd94:	f9400fe0 	ldr	x0, [sp, #24]
    4800bd98:	97ffe6aa 	bl	48005840 <rt_thread_defunct_enqueue>
        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
    4800bd9c:	f94017e0 	ldr	x0, [sp, #40]
    4800bda0:	97ffe1a7 	bl	4800443c <rt_hw_interrupt_enable>
    }

    return RT_EOK;
    4800bda4:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800bda8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800bdac:	d65f03c0 	ret

000000004800bdb0 <rt_thread_create>:
                             void (*entry)(void *parameter),
                             void       *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t  priority,
                             rt_uint32_t tick)
{
    4800bdb0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4800bdb4:	910003fd 	mov	x29, sp
    4800bdb8:	f9001fe0 	str	x0, [sp, #56]
    4800bdbc:	f9001be1 	str	x1, [sp, #48]
    4800bdc0:	f90017e2 	str	x2, [sp, #40]
    4800bdc4:	b90027e3 	str	w3, [sp, #36]
    4800bdc8:	39008fe4 	strb	w4, [sp, #35]
    4800bdcc:	b9001fe5 	str	w5, [sp, #28]
    struct rt_thread *thread;
    void *stack_start;

    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
    4800bdd0:	f9401fe1 	ldr	x1, [sp, #56]
    4800bdd4:	52800020 	mov	w0, #0x1                   	// #1
    4800bdd8:	94000819 	bl	4800de3c <rt_object_allocate>
    4800bddc:	f90027e0 	str	x0, [sp, #72]
                                                    name);
    if (thread == RT_NULL)
    4800bde0:	f94027e0 	ldr	x0, [sp, #72]
    4800bde4:	f100001f 	cmp	x0, #0x0
    4800bde8:	54000061 	b.ne	4800bdf4 <rt_thread_create+0x44>  // b.any
        return RT_NULL;
    4800bdec:	d2800000 	mov	x0, #0x0                   	// #0
    4800bdf0:	14000015 	b	4800be44 <rt_thread_create+0x94>

    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
    4800bdf4:	b94027e0 	ldr	w0, [sp, #36]
    4800bdf8:	97fff764 	bl	48009b88 <rt_malloc>
    4800bdfc:	f90023e0 	str	x0, [sp, #64]
    if (stack_start == RT_NULL)
    4800be00:	f94023e0 	ldr	x0, [sp, #64]
    4800be04:	f100001f 	cmp	x0, #0x0
    4800be08:	540000a1 	b.ne	4800be1c <rt_thread_create+0x6c>  // b.any
    {
        /* allocate stack failure */
        rt_object_delete((rt_object_t)thread);
    4800be0c:	f94027e0 	ldr	x0, [sp, #72]
    4800be10:	94000861 	bl	4800df94 <rt_object_delete>

        return RT_NULL;
    4800be14:	d2800000 	mov	x0, #0x0                   	// #0
    4800be18:	1400000b 	b	4800be44 <rt_thread_create+0x94>
    }

    _thread_init(thread,
    4800be1c:	b9401fe7 	ldr	w7, [sp, #28]
    4800be20:	39408fe6 	ldrb	w6, [sp, #35]
    4800be24:	b94027e5 	ldr	w5, [sp, #36]
    4800be28:	f94023e4 	ldr	x4, [sp, #64]
    4800be2c:	f94017e3 	ldr	x3, [sp, #40]
    4800be30:	f9401be2 	ldr	x2, [sp, #48]
    4800be34:	f9401fe1 	ldr	x1, [sp, #56]
    4800be38:	f94027e0 	ldr	x0, [sp, #72]
    4800be3c:	97fffec1 	bl	4800b940 <_thread_init>
                    stack_start,
                    stack_size,
                    priority,
                    tick);

    return thread;
    4800be40:	f94027e0 	ldr	x0, [sp, #72]
}
    4800be44:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800be48:	d65f03c0 	ret

000000004800be4c <rt_thread_delete>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_delete(rt_thread_t thread)
{
    4800be4c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800be50:	910003fd 	mov	x29, sp
    4800be54:	f9000fe0 	str	x0, [sp, #24]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800be58:	f9400fe0 	ldr	x0, [sp, #24]
    4800be5c:	f100001f 	cmp	x0, #0x0
    4800be60:	540000e1 	b.ne	4800be7c <rt_thread_delete+0x30>  // b.any
    4800be64:	d2803c42 	mov	x2, #0x1e2                 	// #482
    4800be68:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800be6c:	91104001 	add	x1, x0, #0x410
    4800be70:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800be74:	9108c000 	add	x0, x0, #0x230
    4800be78:	9400107c 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800be7c:	f9400fe0 	ldr	x0, [sp, #24]
    4800be80:	9400088c 	bl	4800e0b0 <rt_object_get_type>
    4800be84:	12001c00 	and	w0, w0, #0xff
    4800be88:	7100041f 	cmp	w0, #0x1
    4800be8c:	540000e0 	b.eq	4800bea8 <rt_thread_delete+0x5c>  // b.none
    4800be90:	d2803c62 	mov	x2, #0x1e3                 	// #483
    4800be94:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800be98:	91104001 	add	x1, x0, #0x410
    4800be9c:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bea0:	910a6000 	add	x0, x0, #0x298
    4800bea4:	94001071 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread) == RT_FALSE);
    4800bea8:	f9400fe0 	ldr	x0, [sp, #24]
    4800beac:	9400086b 	bl	4800e058 <rt_object_is_systemobject>
    4800beb0:	7100001f 	cmp	w0, #0x0
    4800beb4:	540000e0 	b.eq	4800bed0 <rt_thread_delete+0x84>  // b.none
    4800beb8:	d2803c82 	mov	x2, #0x1e4                 	// #484
    4800bebc:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bec0:	91104001 	add	x1, x0, #0x410
    4800bec4:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bec8:	910c4000 	add	x0, x0, #0x310
    4800becc:	94001067 	bl	48010068 <rt_assert_handler>

    if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
    4800bed0:	f9400fe0 	ldr	x0, [sp, #24]
    4800bed4:	39418000 	ldrb	w0, [x0, #96]
    4800bed8:	12000800 	and	w0, w0, #0x7
    4800bedc:	7100101f 	cmp	w0, #0x4
    4800bee0:	54000061 	b.ne	4800beec <rt_thread_delete+0xa0>  // b.any
        return RT_EOK;
    4800bee4:	d2800000 	mov	x0, #0x0                   	// #0
    4800bee8:	14000017 	b	4800bf44 <rt_thread_delete+0xf8>

    if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
    4800beec:	f9400fe0 	ldr	x0, [sp, #24]
    4800bef0:	39418000 	ldrb	w0, [x0, #96]
    4800bef4:	12000800 	and	w0, w0, #0x7
    4800bef8:	7100001f 	cmp	w0, #0x0
    4800befc:	54000060 	b.eq	4800bf08 <rt_thread_delete+0xbc>  // b.none
    {
        /* remove from schedule */
        rt_schedule_remove_thread(thread);
    4800bf00:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf04:	94000619 	bl	4800d768 <rt_schedule_remove_thread>
    }

    _thread_cleanup_execute(thread);
    4800bf08:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf0c:	97fffe58 	bl	4800b86c <_thread_cleanup_execute>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
    4800bf10:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf14:	91020000 	add	x0, x0, #0x80
    4800bf18:	97fffada 	bl	4800aa80 <rt_timer_detach>

    /* disable interrupt */
    lock = rt_hw_interrupt_disable();
    4800bf1c:	97ffe144 	bl	4800442c <rt_hw_interrupt_disable>
    4800bf20:	f90017e0 	str	x0, [sp, #40]

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
    4800bf24:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf28:	52800081 	mov	w1, #0x4                   	// #4
    4800bf2c:	39018001 	strb	w1, [x0, #96]

    /* insert to defunct thread list */
    rt_thread_defunct_enqueue(thread);
    4800bf30:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf34:	97ffe643 	bl	48005840 <rt_thread_defunct_enqueue>

    /* enable interrupt */
    rt_hw_interrupt_enable(lock);
    4800bf38:	f94017e0 	ldr	x0, [sp, #40]
    4800bf3c:	97ffe140 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    4800bf40:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800bf44:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800bf48:	d65f03c0 	ret

000000004800bf4c <rt_thread_yield>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_yield(void)
{
    4800bf4c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800bf50:	910003fd 	mov	x29, sp
    struct rt_thread *thread;
    rt_base_t lock;

    thread = rt_thread_self();
    4800bf54:	97ffff12 	bl	4800bb9c <rt_thread_self>
    4800bf58:	f9000fe0 	str	x0, [sp, #24]
    lock = rt_hw_interrupt_disable();
    4800bf5c:	97ffe134 	bl	4800442c <rt_hw_interrupt_disable>
    4800bf60:	f9000be0 	str	x0, [sp, #16]
    thread->remaining_tick = thread->init_tick;
    4800bf64:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf68:	f9403801 	ldr	x1, [x0, #112]
    4800bf6c:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf70:	f9003c01 	str	x1, [x0, #120]
    thread->stat |= RT_THREAD_STAT_YIELD;
    4800bf74:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf78:	39418000 	ldrb	w0, [x0, #96]
    4800bf7c:	321d0000 	orr	w0, w0, #0x8
    4800bf80:	12001c01 	and	w1, w0, #0xff
    4800bf84:	f9400fe0 	ldr	x0, [sp, #24]
    4800bf88:	39018001 	strb	w1, [x0, #96]
    rt_schedule();
    4800bf8c:	94000500 	bl	4800d38c <rt_schedule>
    rt_hw_interrupt_enable(lock);
    4800bf90:	f9400be0 	ldr	x0, [sp, #16]
    4800bf94:	97ffe12a 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    4800bf98:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800bf9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800bfa0:	d65f03c0 	ret

000000004800bfa4 <rt_thread_sleep>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_sleep(rt_tick_t tick)
{
    4800bfa4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800bfa8:	910003fd 	mov	x29, sp
    4800bfac:	f9000bf3 	str	x19, [sp, #16]
    4800bfb0:	b9002fe0 	str	w0, [sp, #44]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* set to current thread */
    thread = rt_thread_self();
    4800bfb4:	97fffefa 	bl	4800bb9c <rt_thread_self>
    4800bfb8:	f9001fe0 	str	x0, [sp, #56]
    RT_ASSERT(thread != RT_NULL);
    4800bfbc:	f9401fe0 	ldr	x0, [sp, #56]
    4800bfc0:	f100001f 	cmp	x0, #0x0
    4800bfc4:	540000e1 	b.ne	4800bfe0 <rt_thread_sleep+0x3c>  // b.any
    4800bfc8:	d28045a2 	mov	x2, #0x22d                 	// #557
    4800bfcc:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bfd0:	9110a001 	add	x1, x0, #0x428
    4800bfd4:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bfd8:	9108c000 	add	x0, x0, #0x230
    4800bfdc:	94001023 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800bfe0:	f9401fe0 	ldr	x0, [sp, #56]
    4800bfe4:	94000833 	bl	4800e0b0 <rt_object_get_type>
    4800bfe8:	12001c00 	and	w0, w0, #0xff
    4800bfec:	7100041f 	cmp	w0, #0x1
    4800bff0:	540000e0 	b.eq	4800c00c <rt_thread_sleep+0x68>  // b.none
    4800bff4:	d28045c2 	mov	x2, #0x22e                 	// #558
    4800bff8:	900000a0 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800bffc:	9110a001 	add	x1, x0, #0x428
    4800c000:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c004:	910a6000 	add	x0, x0, #0x298
    4800c008:	94001018 	bl	48010068 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    4800c00c:	97ffe108 	bl	4800442c <rt_hw_interrupt_disable>
    4800c010:	aa0003f3 	mov	x19, x0

    /* suspend thread */
    rt_thread_suspend(thread);
    4800c014:	f9401fe0 	ldr	x0, [sp, #56]
    4800c018:	940000e4 	bl	4800c3a8 <rt_thread_suspend>

    /* reset the timeout of thread timer and start it */
    rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
    4800c01c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c020:	91020000 	add	x0, x0, #0x80
    4800c024:	9100b3e1 	add	x1, sp, #0x2c
    4800c028:	aa0103e2 	mov	x2, x1
    4800c02c:	52800001 	mov	w1, #0x0                   	// #0
    4800c030:	97fffc3c 	bl	4800b120 <rt_timer_control>
    rt_timer_start(&(thread->thread_timer));
    4800c034:	f9401fe0 	ldr	x0, [sp, #56]
    4800c038:	91020000 	add	x0, x0, #0x80
    4800c03c:	97fffb12 	bl	4800ac84 <rt_timer_start>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    4800c040:	aa1303e0 	mov	x0, x19
    4800c044:	97ffe0fe 	bl	4800443c <rt_hw_interrupt_enable>

    rt_schedule();
    4800c048:	940004d1 	bl	4800d38c <rt_schedule>

    /* clear error number of this thread to RT_EOK */
    if (thread->error == -RT_ETIMEOUT)
    4800c04c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c050:	f9402c00 	ldr	x0, [x0, #88]
    4800c054:	b100081f 	cmn	x0, #0x2
    4800c058:	54000061 	b.ne	4800c064 <rt_thread_sleep+0xc0>  // b.any
        thread->error = RT_EOK;
    4800c05c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c060:	f9002c1f 	str	xzr, [x0, #88]

    return RT_EOK;
    4800c064:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800c068:	f9400bf3 	ldr	x19, [sp, #16]
    4800c06c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800c070:	d65f03c0 	ret

000000004800c074 <rt_thread_delay>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_delay(rt_tick_t tick)
{
    4800c074:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800c078:	910003fd 	mov	x29, sp
    4800c07c:	b9001fe0 	str	w0, [sp, #28]
    return rt_thread_sleep(tick);
    4800c080:	b9401fe0 	ldr	w0, [sp, #28]
    4800c084:	97ffffc8 	bl	4800bfa4 <rt_thread_sleep>
}
    4800c088:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800c08c:	d65f03c0 	ret

000000004800c090 <rt_thread_delay_until>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_delay_until(rt_tick_t *tick, rt_tick_t inc_tick)
{
    4800c090:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800c094:	910003fd 	mov	x29, sp
    4800c098:	f9000bf3 	str	x19, [sp, #16]
    4800c09c:	f90017e0 	str	x0, [sp, #40]
    4800c0a0:	b90027e1 	str	w1, [sp, #36]
    register rt_base_t level;
    struct rt_thread *thread;
    rt_tick_t cur_tick;

    RT_ASSERT(tick != RT_NULL);
    4800c0a4:	f94017e0 	ldr	x0, [sp, #40]
    4800c0a8:	f100001f 	cmp	x0, #0x0
    4800c0ac:	540000e1 	b.ne	4800c0c8 <rt_thread_delay_until+0x38>  // b.any
    4800c0b0:	d2804c82 	mov	x2, #0x264                 	// #612
    4800c0b4:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c0b8:	9110e001 	add	x1, x0, #0x438
    4800c0bc:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c0c0:	910d4000 	add	x0, x0, #0x350
    4800c0c4:	94000fe9 	bl	48010068 <rt_assert_handler>

    /* set to current thread */
    thread = rt_thread_self();
    4800c0c8:	97fffeb5 	bl	4800bb9c <rt_thread_self>
    4800c0cc:	f9001fe0 	str	x0, [sp, #56]
    RT_ASSERT(thread != RT_NULL);
    4800c0d0:	f9401fe0 	ldr	x0, [sp, #56]
    4800c0d4:	f100001f 	cmp	x0, #0x0
    4800c0d8:	540000e1 	b.ne	4800c0f4 <rt_thread_delay_until+0x64>  // b.any
    4800c0dc:	d2804d02 	mov	x2, #0x268                 	// #616
    4800c0e0:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c0e4:	9110e001 	add	x1, x0, #0x438
    4800c0e8:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c0ec:	9108c000 	add	x0, x0, #0x230
    4800c0f0:	94000fde 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800c0f4:	f9401fe0 	ldr	x0, [sp, #56]
    4800c0f8:	940007ee 	bl	4800e0b0 <rt_object_get_type>
    4800c0fc:	12001c00 	and	w0, w0, #0xff
    4800c100:	7100041f 	cmp	w0, #0x1
    4800c104:	540000e0 	b.eq	4800c120 <rt_thread_delay_until+0x90>  // b.none
    4800c108:	d2804d22 	mov	x2, #0x269                 	// #617
    4800c10c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c110:	9110e001 	add	x1, x0, #0x438
    4800c114:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c118:	910a6000 	add	x0, x0, #0x298
    4800c11c:	94000fd3 	bl	48010068 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800c120:	97ffe0c3 	bl	4800442c <rt_hw_interrupt_disable>
    4800c124:	aa0003f3 	mov	x19, x0

    cur_tick = rt_tick_get();
    4800c128:	94000ff1 	bl	480100ec <rt_tick_get>
    4800c12c:	b90037e0 	str	w0, [sp, #52]
    if (cur_tick - *tick < inc_tick)
    4800c130:	f94017e0 	ldr	x0, [sp, #40]
    4800c134:	b9400000 	ldr	w0, [x0]
    4800c138:	b94037e1 	ldr	w1, [sp, #52]
    4800c13c:	4b000020 	sub	w0, w1, w0
    4800c140:	b94027e1 	ldr	w1, [sp, #36]
    4800c144:	6b00003f 	cmp	w1, w0
    4800c148:	54000429 	b.ls	4800c1cc <rt_thread_delay_until+0x13c>  // b.plast
    {
        rt_tick_t left_tick;

        *tick += inc_tick;
    4800c14c:	f94017e0 	ldr	x0, [sp, #40]
    4800c150:	b9400001 	ldr	w1, [x0]
    4800c154:	b94027e0 	ldr	w0, [sp, #36]
    4800c158:	0b000021 	add	w1, w1, w0
    4800c15c:	f94017e0 	ldr	x0, [sp, #40]
    4800c160:	b9000001 	str	w1, [x0]
        left_tick = *tick - cur_tick;
    4800c164:	f94017e0 	ldr	x0, [sp, #40]
    4800c168:	b9400001 	ldr	w1, [x0]
    4800c16c:	b94037e0 	ldr	w0, [sp, #52]
    4800c170:	4b000020 	sub	w0, w1, w0
    4800c174:	b90033e0 	str	w0, [sp, #48]

        /* suspend thread */
        rt_thread_suspend(thread);
    4800c178:	f9401fe0 	ldr	x0, [sp, #56]
    4800c17c:	9400008b 	bl	4800c3a8 <rt_thread_suspend>

        /* reset the timeout of thread timer and start it */
        rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &left_tick);
    4800c180:	f9401fe0 	ldr	x0, [sp, #56]
    4800c184:	91020000 	add	x0, x0, #0x80
    4800c188:	9100c3e1 	add	x1, sp, #0x30
    4800c18c:	aa0103e2 	mov	x2, x1
    4800c190:	52800001 	mov	w1, #0x0                   	// #0
    4800c194:	97fffbe3 	bl	4800b120 <rt_timer_control>
        rt_timer_start(&(thread->thread_timer));
    4800c198:	f9401fe0 	ldr	x0, [sp, #56]
    4800c19c:	91020000 	add	x0, x0, #0x80
    4800c1a0:	97fffab9 	bl	4800ac84 <rt_timer_start>

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    4800c1a4:	aa1303e0 	mov	x0, x19
    4800c1a8:	97ffe0a5 	bl	4800443c <rt_hw_interrupt_enable>

        rt_schedule();
    4800c1ac:	94000478 	bl	4800d38c <rt_schedule>

        /* clear error number of this thread to RT_EOK */
        if (thread->error == -RT_ETIMEOUT)
    4800c1b0:	f9401fe0 	ldr	x0, [sp, #56]
    4800c1b4:	f9402c00 	ldr	x0, [x0, #88]
    4800c1b8:	b100081f 	cmn	x0, #0x2
    4800c1bc:	54000121 	b.ne	4800c1e0 <rt_thread_delay_until+0x150>  // b.any
        {
            thread->error = RT_EOK;
    4800c1c0:	f9401fe0 	ldr	x0, [sp, #56]
    4800c1c4:	f9002c1f 	str	xzr, [x0, #88]
    4800c1c8:	14000006 	b	4800c1e0 <rt_thread_delay_until+0x150>
        }
    }
    else
    {
        *tick = cur_tick;
    4800c1cc:	f94017e0 	ldr	x0, [sp, #40]
    4800c1d0:	b94037e1 	ldr	w1, [sp, #52]
    4800c1d4:	b9000001 	str	w1, [x0]
        rt_hw_interrupt_enable(level);
    4800c1d8:	aa1303e0 	mov	x0, x19
    4800c1dc:	97ffe098 	bl	4800443c <rt_hw_interrupt_enable>
    }

    return RT_EOK;
    4800c1e0:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800c1e4:	f9400bf3 	ldr	x19, [sp, #16]
    4800c1e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800c1ec:	d65f03c0 	ret

000000004800c1f0 <rt_thread_mdelay>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_mdelay(rt_int32_t ms)
{
    4800c1f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800c1f4:	910003fd 	mov	x29, sp
    4800c1f8:	b9001fe0 	str	w0, [sp, #28]
    rt_tick_t tick;

    tick = rt_tick_from_millisecond(ms);
    4800c1fc:	b9401fe0 	ldr	w0, [sp, #28]
    4800c200:	94000ff7 	bl	480101dc <rt_tick_from_millisecond>
    4800c204:	b9002fe0 	str	w0, [sp, #44]

    return rt_thread_sleep(tick);
    4800c208:	b9402fe0 	ldr	w0, [sp, #44]
    4800c20c:	97ffff66 	bl	4800bfa4 <rt_thread_sleep>
}
    4800c210:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800c214:	d65f03c0 	ret

000000004800c218 <rt_thread_control>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_control(rt_thread_t thread, int cmd, void *arg)
{
    4800c218:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4800c21c:	910003fd 	mov	x29, sp
    4800c220:	f9000bf3 	str	x19, [sp, #16]
    4800c224:	f9001fe0 	str	x0, [sp, #56]
    4800c228:	b90037e1 	str	w1, [sp, #52]
    4800c22c:	f90017e2 	str	x2, [sp, #40]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800c230:	f9401fe0 	ldr	x0, [sp, #56]
    4800c234:	f100001f 	cmp	x0, #0x0
    4800c238:	540000e1 	b.ne	4800c254 <rt_thread_control+0x3c>  // b.any
    4800c23c:	d28057a2 	mov	x2, #0x2bd                 	// #701
    4800c240:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c244:	91114001 	add	x1, x0, #0x450
    4800c248:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c24c:	9108c000 	add	x0, x0, #0x230
    4800c250:	94000f86 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800c254:	f9401fe0 	ldr	x0, [sp, #56]
    4800c258:	94000796 	bl	4800e0b0 <rt_object_get_type>
    4800c25c:	12001c00 	and	w0, w0, #0xff
    4800c260:	7100041f 	cmp	w0, #0x1
    4800c264:	540000e0 	b.eq	4800c280 <rt_thread_control+0x68>  // b.none
    4800c268:	d28057c2 	mov	x2, #0x2be                 	// #702
    4800c26c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c270:	91114001 	add	x1, x0, #0x450
    4800c274:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c278:	910a6000 	add	x0, x0, #0x298
    4800c27c:	94000f7b 	bl	48010068 <rt_assert_handler>

    switch (cmd)
    4800c280:	b94037e0 	ldr	w0, [sp, #52]
    4800c284:	7100081f 	cmp	w0, #0x2
    4800c288:	54000160 	b.eq	4800c2b4 <rt_thread_control+0x9c>  // b.none
    4800c28c:	b94037e0 	ldr	w0, [sp, #52]
    4800c290:	7100081f 	cmp	w0, #0x2
    4800c294:	5400080c 	b.gt	4800c394 <rt_thread_control+0x17c>
    4800c298:	b94037e0 	ldr	w0, [sp, #52]
    4800c29c:	7100001f 	cmp	w0, #0x0
    4800c2a0:	54000580 	b.eq	4800c350 <rt_thread_control+0x138>  // b.none
    4800c2a4:	b94037e0 	ldr	w0, [sp, #52]
    4800c2a8:	7100041f 	cmp	w0, #0x1
    4800c2ac:	54000580 	b.eq	4800c35c <rt_thread_control+0x144>  // b.none
            break;
        }
    #endif /* RT_USING_SMP */

        default:
            break;
    4800c2b0:	14000039 	b	4800c394 <rt_thread_control+0x17c>
            temp = rt_hw_interrupt_disable();
    4800c2b4:	97ffe05e 	bl	4800442c <rt_hw_interrupt_disable>
    4800c2b8:	aa0003f3 	mov	x19, x0
            if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY)
    4800c2bc:	f9401fe0 	ldr	x0, [sp, #56]
    4800c2c0:	39418000 	ldrb	w0, [x0, #96]
    4800c2c4:	12000800 	and	w0, w0, #0x7
    4800c2c8:	7100041f 	cmp	w0, #0x1
    4800c2cc:	54000241 	b.ne	4800c314 <rt_thread_control+0xfc>  // b.any
                rt_schedule_remove_thread(thread);
    4800c2d0:	f9401fe0 	ldr	x0, [sp, #56]
    4800c2d4:	94000525 	bl	4800d768 <rt_schedule_remove_thread>
                thread->current_priority = *(rt_uint8_t *)arg;
    4800c2d8:	f94017e0 	ldr	x0, [sp, #40]
    4800c2dc:	39400001 	ldrb	w1, [x0]
    4800c2e0:	f9401fe0 	ldr	x0, [sp, #56]
    4800c2e4:	39018401 	strb	w1, [x0, #97]
                thread->number_mask = 1 << thread->current_priority;
    4800c2e8:	f9401fe0 	ldr	x0, [sp, #56]
    4800c2ec:	39418400 	ldrb	w0, [x0, #97]
    4800c2f0:	2a0003e1 	mov	w1, w0
    4800c2f4:	52800020 	mov	w0, #0x1                   	// #1
    4800c2f8:	1ac12000 	lsl	w0, w0, w1
    4800c2fc:	2a0003e1 	mov	w1, w0
    4800c300:	f9401fe0 	ldr	x0, [sp, #56]
    4800c304:	b9006401 	str	w1, [x0, #100]
                rt_schedule_insert_thread(thread);
    4800c308:	f9401fe0 	ldr	x0, [sp, #56]
    4800c30c:	940004d2 	bl	4800d654 <rt_schedule_insert_thread>
    4800c310:	1400000d 	b	4800c344 <rt_thread_control+0x12c>
                thread->current_priority = *(rt_uint8_t *)arg;
    4800c314:	f94017e0 	ldr	x0, [sp, #40]
    4800c318:	39400001 	ldrb	w1, [x0]
    4800c31c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c320:	39018401 	strb	w1, [x0, #97]
                thread->number_mask = 1 << thread->current_priority;
    4800c324:	f9401fe0 	ldr	x0, [sp, #56]
    4800c328:	39418400 	ldrb	w0, [x0, #97]
    4800c32c:	2a0003e1 	mov	w1, w0
    4800c330:	52800020 	mov	w0, #0x1                   	// #1
    4800c334:	1ac12000 	lsl	w0, w0, w1
    4800c338:	2a0003e1 	mov	w1, w0
    4800c33c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c340:	b9006401 	str	w1, [x0, #100]
            rt_hw_interrupt_enable(temp);
    4800c344:	aa1303e0 	mov	x0, x19
    4800c348:	97ffe03d 	bl	4800443c <rt_hw_interrupt_enable>
            break;
    4800c34c:	14000013 	b	4800c398 <rt_thread_control+0x180>
            return rt_thread_startup(thread);
    4800c350:	f9401fe0 	ldr	x0, [sp, #56]
    4800c354:	97fffe16 	bl	4800bbac <rt_thread_startup>
    4800c358:	14000011 	b	4800c39c <rt_thread_control+0x184>
            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
    4800c35c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c360:	9400073e 	bl	4800e058 <rt_object_is_systemobject>
    4800c364:	7100041f 	cmp	w0, #0x1
    4800c368:	540000a1 	b.ne	4800c37c <rt_thread_control+0x164>  // b.any
                rt_err = rt_thread_detach(thread);
    4800c36c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c370:	97fffe49 	bl	4800bc94 <rt_thread_detach>
    4800c374:	f90027e0 	str	x0, [sp, #72]
    4800c378:	14000004 	b	4800c388 <rt_thread_control+0x170>
                rt_err = rt_thread_delete(thread);
    4800c37c:	f9401fe0 	ldr	x0, [sp, #56]
    4800c380:	97fffeb3 	bl	4800be4c <rt_thread_delete>
    4800c384:	f90027e0 	str	x0, [sp, #72]
            rt_schedule();
    4800c388:	94000401 	bl	4800d38c <rt_schedule>
            return rt_err;
    4800c38c:	f94027e0 	ldr	x0, [sp, #72]
    4800c390:	14000003 	b	4800c39c <rt_thread_control+0x184>
            break;
    4800c394:	d503201f 	nop
    }

    return RT_EOK;
    4800c398:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800c39c:	f9400bf3 	ldr	x19, [sp, #16]
    4800c3a0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800c3a4:	d65f03c0 	ret

000000004800c3a8 <rt_thread_suspend>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_suspend(rt_thread_t thread)
{
    4800c3a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800c3ac:	910003fd 	mov	x29, sp
    4800c3b0:	a90153f3 	stp	x19, x20, [sp, #16]
    4800c3b4:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t stat;
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800c3b8:	f94017e0 	ldr	x0, [sp, #40]
    4800c3bc:	f100001f 	cmp	x0, #0x0
    4800c3c0:	540000e1 	b.ne	4800c3dc <rt_thread_suspend+0x34>  // b.any
    4800c3c4:	d2806602 	mov	x2, #0x330                 	// #816
    4800c3c8:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c3cc:	9111a001 	add	x1, x0, #0x468
    4800c3d0:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c3d4:	9108c000 	add	x0, x0, #0x230
    4800c3d8:	94000f24 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800c3dc:	f94017e0 	ldr	x0, [sp, #40]
    4800c3e0:	94000734 	bl	4800e0b0 <rt_object_get_type>
    4800c3e4:	12001c00 	and	w0, w0, #0xff
    4800c3e8:	7100041f 	cmp	w0, #0x1
    4800c3ec:	540000e0 	b.eq	4800c408 <rt_thread_suspend+0x60>  // b.none
    4800c3f0:	d2806622 	mov	x2, #0x331                 	// #817
    4800c3f4:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c3f8:	9111a001 	add	x1, x0, #0x468
    4800c3fc:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c400:	910a6000 	add	x0, x0, #0x298
    4800c404:	94000f19 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));

    stat = thread->stat & RT_THREAD_STAT_MASK;
    4800c408:	f94017e0 	ldr	x0, [sp, #40]
    4800c40c:	39418000 	ldrb	w0, [x0, #96]
    4800c410:	92401c00 	and	x0, x0, #0xff
    4800c414:	92400813 	and	x19, x0, #0x7
    if ((stat != RT_THREAD_READY) && (stat != RT_THREAD_RUNNING))
    4800c418:	f100067f 	cmp	x19, #0x1
    4800c41c:	540000a0 	b.eq	4800c430 <rt_thread_suspend+0x88>  // b.none
    4800c420:	f1000e7f 	cmp	x19, #0x3
    4800c424:	54000060 	b.eq	4800c430 <rt_thread_suspend+0x88>  // b.none
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, 0x%2x\n",
                                       thread->stat));
        return -RT_ERROR;
    4800c428:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800c42c:	1400002c 	b	4800c4dc <rt_thread_suspend+0x134>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    4800c430:	97ffdfff 	bl	4800442c <rt_hw_interrupt_disable>
    4800c434:	aa0003f4 	mov	x20, x0
    if (stat == RT_THREAD_RUNNING)
    4800c438:	f1000e7f 	cmp	x19, #0x3
    4800c43c:	54000181 	b.ne	4800c46c <rt_thread_suspend+0xc4>  // b.any
    {
        /* not suspend running status thread on other core */
        RT_ASSERT(thread == rt_thread_self());
    4800c440:	97fffdd7 	bl	4800bb9c <rt_thread_self>
    4800c444:	aa0003e1 	mov	x1, x0
    4800c448:	f94017e0 	ldr	x0, [sp, #40]
    4800c44c:	eb01001f 	cmp	x0, x1
    4800c450:	540000e0 	b.eq	4800c46c <rt_thread_suspend+0xc4>  // b.none
    4800c454:	d2806842 	mov	x2, #0x342                 	// #834
    4800c458:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c45c:	9111a001 	add	x1, x0, #0x468
    4800c460:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c464:	910d8000 	add	x0, x0, #0x360
    4800c468:	94000f00 	bl	48010068 <rt_assert_handler>
    }

    /* change thread stat */
    rt_schedule_remove_thread(thread);
    4800c46c:	f94017e0 	ldr	x0, [sp, #40]
    4800c470:	940004be 	bl	4800d768 <rt_schedule_remove_thread>
    thread->stat = RT_THREAD_SUSPEND | (thread->stat & ~RT_THREAD_STAT_MASK);
    4800c474:	f94017e0 	ldr	x0, [sp, #40]
    4800c478:	39418000 	ldrb	w0, [x0, #96]
    4800c47c:	13001c00 	sxtb	w0, w0
    4800c480:	121d7000 	and	w0, w0, #0xfffffff8
    4800c484:	13001c00 	sxtb	w0, w0
    4800c488:	321f0000 	orr	w0, w0, #0x2
    4800c48c:	13001c00 	sxtb	w0, w0
    4800c490:	12001c01 	and	w1, w0, #0xff
    4800c494:	f94017e0 	ldr	x0, [sp, #40]
    4800c498:	39018001 	strb	w1, [x0, #96]

    /* stop thread timer anyway */
    rt_timer_stop(&(thread->thread_timer));
    4800c49c:	f94017e0 	ldr	x0, [sp, #40]
    4800c4a0:	91020000 	add	x0, x0, #0x80
    4800c4a4:	97fffae6 	bl	4800b03c <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    4800c4a8:	aa1403e0 	mov	x0, x20
    4800c4ac:	97ffdfe4 	bl	4800443c <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook, (thread));
    4800c4b0:	b0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800c4b4:	910e6000 	add	x0, x0, #0x398
    4800c4b8:	f9400000 	ldr	x0, [x0]
    4800c4bc:	f100001f 	cmp	x0, #0x0
    4800c4c0:	540000c0 	b.eq	4800c4d8 <rt_thread_suspend+0x130>  // b.none
    4800c4c4:	b0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800c4c8:	910e6000 	add	x0, x0, #0x398
    4800c4cc:	f9400001 	ldr	x1, [x0]
    4800c4d0:	f94017e0 	ldr	x0, [sp, #40]
    4800c4d4:	d63f0020 	blr	x1
    return RT_EOK;
    4800c4d8:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800c4dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4800c4e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800c4e4:	d65f03c0 	ret

000000004800c4e8 <rt_thread_resume>:
 *
 * @return  Return the operation status. If the return value is RT_EOK, the function is successfully executed.
 *          If the return value is any other values, it means this operation failed.
 */
rt_err_t rt_thread_resume(rt_thread_t thread)
{
    4800c4e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800c4ec:	910003fd 	mov	x29, sp
    4800c4f0:	f9000bf3 	str	x19, [sp, #16]
    4800c4f4:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800c4f8:	f94017e0 	ldr	x0, [sp, #40]
    4800c4fc:	f100001f 	cmp	x0, #0x0
    4800c500:	540000e1 	b.ne	4800c51c <rt_thread_resume+0x34>  // b.any
    4800c504:	d2806c22 	mov	x2, #0x361                 	// #865
    4800c508:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c50c:	91120001 	add	x1, x0, #0x480
    4800c510:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c514:	9108c000 	add	x0, x0, #0x230
    4800c518:	94000ed4 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800c51c:	f94017e0 	ldr	x0, [sp, #40]
    4800c520:	940006e4 	bl	4800e0b0 <rt_object_get_type>
    4800c524:	12001c00 	and	w0, w0, #0xff
    4800c528:	7100041f 	cmp	w0, #0x1
    4800c52c:	540000e0 	b.eq	4800c548 <rt_thread_resume+0x60>  // b.none
    4800c530:	d2806c42 	mov	x2, #0x362                 	// #866
    4800c534:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c538:	91120001 	add	x1, x0, #0x480
    4800c53c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c540:	910a6000 	add	x0, x0, #0x298
    4800c544:	94000ec9 	bl	48010068 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));

    if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_SUSPEND)
    4800c548:	f94017e0 	ldr	x0, [sp, #40]
    4800c54c:	39418000 	ldrb	w0, [x0, #96]
    4800c550:	12000800 	and	w0, w0, #0x7
    4800c554:	7100081f 	cmp	w0, #0x2
    4800c558:	54000060 	b.eq	4800c564 <rt_thread_resume+0x7c>  // b.none
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
    4800c55c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800c560:	14000018 	b	4800c5c0 <rt_thread_resume+0xd8>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    4800c564:	97ffdfb2 	bl	4800442c <rt_hw_interrupt_disable>
    4800c568:	aa0003f3 	mov	x19, x0

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
    4800c56c:	f94017e0 	ldr	x0, [sp, #40]
    4800c570:	91008000 	add	x0, x0, #0x20
    4800c574:	97fffc8d 	bl	4800b7a8 <rt_list_remove>

    rt_timer_stop(&thread->thread_timer);
    4800c578:	f94017e0 	ldr	x0, [sp, #40]
    4800c57c:	91020000 	add	x0, x0, #0x80
    4800c580:	97fffaaf 	bl	4800b03c <rt_timer_stop>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
    4800c584:	f94017e0 	ldr	x0, [sp, #40]
    4800c588:	94000433 	bl	4800d654 <rt_schedule_insert_thread>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    4800c58c:	aa1303e0 	mov	x0, x19
    4800c590:	97ffdfab 	bl	4800443c <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));
    4800c594:	b0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800c598:	910e8000 	add	x0, x0, #0x3a0
    4800c59c:	f9400000 	ldr	x0, [x0]
    4800c5a0:	f100001f 	cmp	x0, #0x0
    4800c5a4:	540000c0 	b.eq	4800c5bc <rt_thread_resume+0xd4>  // b.none
    4800c5a8:	b0000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800c5ac:	910e8000 	add	x0, x0, #0x3a0
    4800c5b0:	f9400001 	ldr	x1, [x0]
    4800c5b4:	f94017e0 	ldr	x0, [sp, #40]
    4800c5b8:	d63f0020 	blr	x1
    return RT_EOK;
    4800c5bc:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800c5c0:	f9400bf3 	ldr	x19, [sp, #16]
    4800c5c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800c5c8:	d65f03c0 	ret

000000004800c5cc <rt_thread_timeout>:
 *          when thread is timeout to wait some resource.
 *
 * @param   parameter is the parameter of thread timeout function
 */
void rt_thread_timeout(void *parameter)
{
    4800c5cc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800c5d0:	910003fd 	mov	x29, sp
    4800c5d4:	f9000bf3 	str	x19, [sp, #16]
    4800c5d8:	f90017e0 	str	x0, [sp, #40]
    struct rt_thread *thread;
    register rt_base_t temp;

    thread = (struct rt_thread *)parameter;
    4800c5dc:	f94017e0 	ldr	x0, [sp, #40]
    4800c5e0:	f9001fe0 	str	x0, [sp, #56]

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
    4800c5e4:	f9401fe0 	ldr	x0, [sp, #56]
    4800c5e8:	f100001f 	cmp	x0, #0x0
    4800c5ec:	540000e1 	b.ne	4800c608 <rt_thread_timeout+0x3c>  // b.any
    4800c5f0:	d28071e2 	mov	x2, #0x38f                 	// #911
    4800c5f4:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c5f8:	91126001 	add	x1, x0, #0x498
    4800c5fc:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c600:	9108c000 	add	x0, x0, #0x230
    4800c604:	94000e99 	bl	48010068 <rt_assert_handler>
    RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_SUSPEND);
    4800c608:	f9401fe0 	ldr	x0, [sp, #56]
    4800c60c:	39418000 	ldrb	w0, [x0, #96]
    4800c610:	12000800 	and	w0, w0, #0x7
    4800c614:	7100081f 	cmp	w0, #0x2
    4800c618:	540000e0 	b.eq	4800c634 <rt_thread_timeout+0x68>  // b.none
    4800c61c:	d2807202 	mov	x2, #0x390                 	// #912
    4800c620:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c624:	91126001 	add	x1, x0, #0x498
    4800c628:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c62c:	910e0000 	add	x0, x0, #0x380
    4800c630:	94000e8e 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
    4800c634:	f9401fe0 	ldr	x0, [sp, #56]
    4800c638:	9400069e 	bl	4800e0b0 <rt_object_get_type>
    4800c63c:	12001c00 	and	w0, w0, #0xff
    4800c640:	7100041f 	cmp	w0, #0x1
    4800c644:	540000e0 	b.eq	4800c660 <rt_thread_timeout+0x94>  // b.none
    4800c648:	d2807222 	mov	x2, #0x391                 	// #913
    4800c64c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c650:	91126001 	add	x1, x0, #0x498
    4800c654:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c658:	910a6000 	add	x0, x0, #0x298
    4800c65c:	94000e83 	bl	48010068 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    4800c660:	97ffdf73 	bl	4800442c <rt_hw_interrupt_disable>
    4800c664:	aa0003f3 	mov	x19, x0

    /* set error number */
    thread->error = -RT_ETIMEOUT;
    4800c668:	f9401fe0 	ldr	x0, [sp, #56]
    4800c66c:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    4800c670:	f9002c01 	str	x1, [x0, #88]

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
    4800c674:	f9401fe0 	ldr	x0, [sp, #56]
    4800c678:	91008000 	add	x0, x0, #0x20
    4800c67c:	97fffc4b 	bl	4800b7a8 <rt_list_remove>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
    4800c680:	f9401fe0 	ldr	x0, [sp, #56]
    4800c684:	940003f4 	bl	4800d654 <rt_schedule_insert_thread>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    4800c688:	aa1303e0 	mov	x0, x19
    4800c68c:	97ffdf6c 	bl	4800443c <rt_hw_interrupt_enable>

    /* do schedule */
    rt_schedule();
    4800c690:	9400033f 	bl	4800d38c <rt_schedule>
}
    4800c694:	d503201f 	nop
    4800c698:	f9400bf3 	ldr	x19, [sp, #16]
    4800c69c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800c6a0:	d65f03c0 	ret

000000004800c6a4 <rt_thread_find>:
 *
 * @return  If the return value is a rt_thread structure pointer, the function is successfully executed.
 *          If the return value is RT_NULL, it means this operation failed.
 */
rt_thread_t rt_thread_find(char *name)
{
    4800c6a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800c6a8:	910003fd 	mov	x29, sp
    4800c6ac:	f9000fe0 	str	x0, [sp, #24]
    return (rt_thread_t)rt_object_find(name, RT_Object_Class_Thread);
    4800c6b0:	52800021 	mov	w1, #0x1                   	// #1
    4800c6b4:	f9400fe0 	ldr	x0, [sp, #24]
    4800c6b8:	94000690 	bl	4800e0f8 <rt_object_find>
}
    4800c6bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800c6c0:	d65f03c0 	ret

000000004800c6c4 <rt_list_init>:
{
    4800c6c4:	d10043ff 	sub	sp, sp, #0x10
    4800c6c8:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    4800c6cc:	f94007e0 	ldr	x0, [sp, #8]
    4800c6d0:	f94007e1 	ldr	x1, [sp, #8]
    4800c6d4:	f9000401 	str	x1, [x0, #8]
    4800c6d8:	f94007e0 	ldr	x0, [sp, #8]
    4800c6dc:	f9400401 	ldr	x1, [x0, #8]
    4800c6e0:	f94007e0 	ldr	x0, [sp, #8]
    4800c6e4:	f9000001 	str	x1, [x0]
}
    4800c6e8:	d503201f 	nop
    4800c6ec:	910043ff 	add	sp, sp, #0x10
    4800c6f0:	d65f03c0 	ret

000000004800c6f4 <rt_wqueue_init>:
typedef struct rt_wqueue_node rt_wqueue_node_t;

int __wqueue_default_wake(struct rt_wqueue_node *wait, void *key);

rt_inline void rt_wqueue_init(rt_wqueue_t *queue)
{
    4800c6f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800c6f8:	910003fd 	mov	x29, sp
    4800c6fc:	f9000fe0 	str	x0, [sp, #24]
    RT_ASSERT(queue != RT_NULL);
    4800c700:	f9400fe0 	ldr	x0, [sp, #24]
    4800c704:	f100001f 	cmp	x0, #0x0
    4800c708:	540000e1 	b.ne	4800c724 <rt_wqueue_init+0x30>  // b.any
    4800c70c:	d28004a2 	mov	x2, #0x25                  	// #37
    4800c710:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c714:	91172001 	add	x1, x0, #0x5c8
    4800c718:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c71c:	9112c000 	add	x0, x0, #0x4b0
    4800c720:	94000e52 	bl	48010068 <rt_assert_handler>

    queue->flag = RT_WQ_FLAG_CLEAN;
    4800c724:	f9400fe0 	ldr	x0, [sp, #24]
    4800c728:	b900001f 	str	wzr, [x0]
    rt_list_init(&(queue->waiting_list));
    4800c72c:	f9400fe0 	ldr	x0, [sp, #24]
    4800c730:	91002000 	add	x0, x0, #0x8
    4800c734:	97ffffe4 	bl	4800c6c4 <rt_list_init>
}
    4800c738:	d503201f 	nop
    4800c73c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800c740:	d65f03c0 	ret

000000004800c744 <rt_device_register>:
 * @return the error code, RT_EOK on initialization successfully.
 */
rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags)
{
    4800c744:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800c748:	910003fd 	mov	x29, sp
    4800c74c:	f90017e0 	str	x0, [sp, #40]
    4800c750:	f90013e1 	str	x1, [sp, #32]
    4800c754:	79003fe2 	strh	w2, [sp, #30]
    if (dev == RT_NULL)
    4800c758:	f94017e0 	ldr	x0, [sp, #40]
    4800c75c:	f100001f 	cmp	x0, #0x0
    4800c760:	54000061 	b.ne	4800c76c <rt_device_register+0x28>  // b.any
        return -RT_ERROR;
    4800c764:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800c768:	14000018 	b	4800c7c8 <rt_device_register+0x84>

    if (rt_device_find(name) != RT_NULL)
    4800c76c:	f94013e0 	ldr	x0, [sp, #32]
    4800c770:	9400003e 	bl	4800c868 <rt_device_find>
    4800c774:	f100001f 	cmp	x0, #0x0
    4800c778:	54000060 	b.eq	4800c784 <rt_device_register+0x40>  // b.none
        return -RT_ERROR;
    4800c77c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800c780:	14000012 	b	4800c7c8 <rt_device_register+0x84>

    rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
    4800c784:	f94017e0 	ldr	x0, [sp, #40]
    4800c788:	f94013e2 	ldr	x2, [sp, #32]
    4800c78c:	52800121 	mov	w1, #0x9                   	// #9
    4800c790:	94000533 	bl	4800dc5c <rt_object_init>
    dev->flag = flags;
    4800c794:	f94017e0 	ldr	x0, [sp, #40]
    4800c798:	79403fe1 	ldrh	w1, [sp, #30]
    4800c79c:	79004801 	strh	w1, [x0, #36]
    dev->ref_count = 0;
    4800c7a0:	f94017e0 	ldr	x0, [sp, #40]
    4800c7a4:	3900a01f 	strb	wzr, [x0, #40]
    dev->open_flag = 0;
    4800c7a8:	f94017e0 	ldr	x0, [sp, #40]
    4800c7ac:	79004c1f 	strh	wzr, [x0, #38]

#ifdef RT_USING_POSIX
    dev->fops = RT_NULL;
    4800c7b0:	f94017e0 	ldr	x0, [sp, #40]
    4800c7b4:	f900381f 	str	xzr, [x0, #112]
    rt_wqueue_init(&(dev->wait_queue));
    4800c7b8:	f94017e0 	ldr	x0, [sp, #40]
    4800c7bc:	9101e000 	add	x0, x0, #0x78
    4800c7c0:	97ffffcd 	bl	4800c6f4 <rt_wqueue_init>
#endif /* RT_USING_POSIX */

    return RT_EOK;
    4800c7c4:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800c7c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800c7cc:	d65f03c0 	ret

000000004800c7d0 <rt_device_unregister>:
 * @param dev is the pointer of device driver structure.
 *
 * @return the error code, RT_EOK on successfully.
 */
rt_err_t rt_device_unregister(rt_device_t dev)
{
    4800c7d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800c7d4:	910003fd 	mov	x29, sp
    4800c7d8:	f9000fe0 	str	x0, [sp, #24]
    RT_ASSERT(dev != RT_NULL);
    4800c7dc:	f9400fe0 	ldr	x0, [sp, #24]
    4800c7e0:	f100001f 	cmp	x0, #0x0
    4800c7e4:	540000e1 	b.ne	4800c800 <rt_device_unregister+0x30>  // b.any
    4800c7e8:	d2800aa2 	mov	x2, #0x55                  	// #85
    4800c7ec:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c7f0:	91176001 	add	x1, x0, #0x5d8
    4800c7f4:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c7f8:	91132000 	add	x0, x0, #0x4c8
    4800c7fc:	94000e1b 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800c800:	f9400fe0 	ldr	x0, [sp, #24]
    4800c804:	9400062b 	bl	4800e0b0 <rt_object_get_type>
    4800c808:	12001c00 	and	w0, w0, #0xff
    4800c80c:	7100241f 	cmp	w0, #0x9
    4800c810:	540000e0 	b.eq	4800c82c <rt_device_unregister+0x5c>  // b.none
    4800c814:	d2800ac2 	mov	x2, #0x56                  	// #86
    4800c818:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c81c:	91176001 	add	x1, x0, #0x5d8
    4800c820:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c824:	91136000 	add	x0, x0, #0x4d8
    4800c828:	94000e10 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&dev->parent));
    4800c82c:	f9400fe0 	ldr	x0, [sp, #24]
    4800c830:	9400060a 	bl	4800e058 <rt_object_is_systemobject>
    4800c834:	7100001f 	cmp	w0, #0x0
    4800c838:	540000e1 	b.ne	4800c854 <rt_device_unregister+0x84>  // b.any
    4800c83c:	d2800ae2 	mov	x2, #0x57                  	// #87
    4800c840:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c844:	91176001 	add	x1, x0, #0x5d8
    4800c848:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c84c:	91146000 	add	x0, x0, #0x518
    4800c850:	94000e06 	bl	48010068 <rt_assert_handler>

    rt_object_detach(&(dev->parent));
    4800c854:	f9400fe0 	ldr	x0, [sp, #24]
    4800c858:	94000555 	bl	4800ddac <rt_object_detach>

    return RT_EOK;
    4800c85c:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800c860:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800c864:	d65f03c0 	ret

000000004800c868 <rt_device_find>:
 * @param name is the device driver's name.
 *
 * @return the registered device driver on successful, or RT_NULL on failure.
 */
rt_device_t rt_device_find(const char *name)
{
    4800c868:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800c86c:	910003fd 	mov	x29, sp
    4800c870:	f9000fe0 	str	x0, [sp, #24]
    return (rt_device_t)rt_object_find(name, RT_Object_Class_Device);
    4800c874:	52800121 	mov	w1, #0x9                   	// #9
    4800c878:	f9400fe0 	ldr	x0, [sp, #24]
    4800c87c:	9400061f 	bl	4800e0f8 <rt_object_find>
}
    4800c880:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800c884:	d65f03c0 	ret

000000004800c888 <rt_device_create>:
 * @param attach_size is the size of user data.
 *
 * @return the allocated device object, or RT_NULL when failed.
 */
rt_device_t rt_device_create(int type, int attach_size)
{
    4800c888:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800c88c:	910003fd 	mov	x29, sp
    4800c890:	b9001fe0 	str	w0, [sp, #28]
    4800c894:	b9001be1 	str	w1, [sp, #24]
    int size;
    rt_device_t device;

    size = RT_ALIGN(sizeof(struct rt_device), RT_ALIGN_SIZE);
    4800c898:	52801300 	mov	w0, #0x98                  	// #152
    4800c89c:	b9002fe0 	str	w0, [sp, #44]
    attach_size = RT_ALIGN(attach_size, RT_ALIGN_SIZE);
    4800c8a0:	b9401be0 	ldr	w0, [sp, #24]
    4800c8a4:	11000c00 	add	w0, w0, #0x3
    4800c8a8:	121e7400 	and	w0, w0, #0xfffffffc
    4800c8ac:	b9001be0 	str	w0, [sp, #24]
    /* use the total size */
    size += attach_size;
    4800c8b0:	b9402fe1 	ldr	w1, [sp, #44]
    4800c8b4:	b9401be0 	ldr	w0, [sp, #24]
    4800c8b8:	0b000020 	add	w0, w1, w0
    4800c8bc:	b9002fe0 	str	w0, [sp, #44]

    device = (rt_device_t)rt_malloc(size);
    4800c8c0:	b9802fe0 	ldrsw	x0, [sp, #44]
    4800c8c4:	97fff4b1 	bl	48009b88 <rt_malloc>
    4800c8c8:	f90013e0 	str	x0, [sp, #32]
    if (device)
    4800c8cc:	f94013e0 	ldr	x0, [sp, #32]
    4800c8d0:	f100001f 	cmp	x0, #0x0
    4800c8d4:	54000100 	b.eq	4800c8f4 <rt_device_create+0x6c>  // b.none
    {
        rt_memset(device, 0x0, sizeof(struct rt_device));
    4800c8d8:	d2801302 	mov	x2, #0x98                  	// #152
    4800c8dc:	52800001 	mov	w1, #0x0                   	// #0
    4800c8e0:	f94013e0 	ldr	x0, [sp, #32]
    4800c8e4:	94000692 	bl	4800e32c <rt_memset>
        device->type = (enum rt_device_class_type)type;
    4800c8e8:	b9401fe1 	ldr	w1, [sp, #28]
    4800c8ec:	f94013e0 	ldr	x0, [sp, #32]
    4800c8f0:	b9002001 	str	w1, [x0, #32]
    }

    return device;
    4800c8f4:	f94013e0 	ldr	x0, [sp, #32]
}
    4800c8f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800c8fc:	d65f03c0 	ret

000000004800c900 <rt_device_destroy>:
 * @brief This function destroy the specific device object.
 *
 * @param dev is a specific device object.
 */
void rt_device_destroy(rt_device_t dev)
{
    4800c900:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800c904:	910003fd 	mov	x29, sp
    4800c908:	f9000fe0 	str	x0, [sp, #24]
    RT_ASSERT(dev != RT_NULL);
    4800c90c:	f9400fe0 	ldr	x0, [sp, #24]
    4800c910:	f100001f 	cmp	x0, #0x0
    4800c914:	540000e1 	b.ne	4800c930 <rt_device_destroy+0x30>  // b.any
    4800c918:	d2801242 	mov	x2, #0x92                  	// #146
    4800c91c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c920:	9117c001 	add	x1, x0, #0x5f0
    4800c924:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c928:	91132000 	add	x0, x0, #0x4c8
    4800c92c:	94000dcf 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800c930:	f9400fe0 	ldr	x0, [sp, #24]
    4800c934:	940005df 	bl	4800e0b0 <rt_object_get_type>
    4800c938:	12001c00 	and	w0, w0, #0xff
    4800c93c:	7100241f 	cmp	w0, #0x9
    4800c940:	540000e0 	b.eq	4800c95c <rt_device_destroy+0x5c>  // b.none
    4800c944:	d2801262 	mov	x2, #0x93                  	// #147
    4800c948:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c94c:	9117c001 	add	x1, x0, #0x5f0
    4800c950:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c954:	91136000 	add	x0, x0, #0x4d8
    4800c958:	94000dc4 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_is_systemobject(&dev->parent) == RT_FALSE);
    4800c95c:	f9400fe0 	ldr	x0, [sp, #24]
    4800c960:	940005be 	bl	4800e058 <rt_object_is_systemobject>
    4800c964:	7100001f 	cmp	w0, #0x0
    4800c968:	540000e0 	b.eq	4800c984 <rt_device_destroy+0x84>  // b.none
    4800c96c:	d2801282 	mov	x2, #0x94                  	// #148
    4800c970:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c974:	9117c001 	add	x1, x0, #0x5f0
    4800c978:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c97c:	91150000 	add	x0, x0, #0x540
    4800c980:	94000dba 	bl	48010068 <rt_assert_handler>

    rt_object_detach(&(dev->parent));
    4800c984:	f9400fe0 	ldr	x0, [sp, #24]
    4800c988:	94000509 	bl	4800ddac <rt_object_detach>

    /* release this device object */
    rt_free(dev);
    4800c98c:	f9400fe0 	ldr	x0, [sp, #24]
    4800c990:	97fff68d 	bl	4800a3c4 <rt_free>
}
    4800c994:	d503201f 	nop
    4800c998:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800c99c:	d65f03c0 	ret

000000004800c9a0 <rt_device_init>:
 * @param dev is the pointer of device driver structure.
 *
 * @return the result, RT_EOK on successfully.
 */
rt_err_t rt_device_init(rt_device_t dev)
{
    4800c9a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800c9a4:	910003fd 	mov	x29, sp
    4800c9a8:	f9000fe0 	str	x0, [sp, #24]
    rt_err_t result = RT_EOK;
    4800c9ac:	f90017ff 	str	xzr, [sp, #40]

    RT_ASSERT(dev != RT_NULL);
    4800c9b0:	f9400fe0 	ldr	x0, [sp, #24]
    4800c9b4:	f100001f 	cmp	x0, #0x0
    4800c9b8:	540000e1 	b.ne	4800c9d4 <rt_device_init+0x34>  // b.any
    4800c9bc:	d2801522 	mov	x2, #0xa9                  	// #169
    4800c9c0:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c9c4:	91182001 	add	x1, x0, #0x608
    4800c9c8:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800c9cc:	91132000 	add	x0, x0, #0x4c8
    4800c9d0:	94000da6 	bl	48010068 <rt_assert_handler>

    /* get device_init handler */
    if (device_init != RT_NULL)
    4800c9d4:	f9400fe0 	ldr	x0, [sp, #24]
    4800c9d8:	f9402000 	ldr	x0, [x0, #64]
    4800c9dc:	f100001f 	cmp	x0, #0x0
    4800c9e0:	54000360 	b.eq	4800ca4c <rt_device_init+0xac>  // b.none
    {
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
    4800c9e4:	f9400fe0 	ldr	x0, [sp, #24]
    4800c9e8:	79404800 	ldrh	w0, [x0, #36]
    4800c9ec:	121c0000 	and	w0, w0, #0x10
    4800c9f0:	7100001f 	cmp	w0, #0x0
    4800c9f4:	540002c1 	b.ne	4800ca4c <rt_device_init+0xac>  // b.any
        {
            result = device_init(dev);
    4800c9f8:	f9400fe0 	ldr	x0, [sp, #24]
    4800c9fc:	f9402001 	ldr	x1, [x0, #64]
    4800ca00:	f9400fe0 	ldr	x0, [sp, #24]
    4800ca04:	d63f0020 	blr	x1
    4800ca08:	f90017e0 	str	x0, [sp, #40]
            if (result != RT_EOK)
    4800ca0c:	f94017e0 	ldr	x0, [sp, #40]
    4800ca10:	f100001f 	cmp	x0, #0x0
    4800ca14:	54000100 	b.eq	4800ca34 <rt_device_init+0x94>  // b.none
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
    4800ca18:	f9400fe0 	ldr	x0, [sp, #24]
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
    4800ca1c:	f94017e2 	ldr	x2, [sp, #40]
    4800ca20:	aa0003e1 	mov	x1, x0
    4800ca24:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ca28:	9115e000 	add	x0, x0, #0x578
    4800ca2c:	94000cc1 	bl	4800fd30 <rt_kprintf>
    4800ca30:	14000007 	b	4800ca4c <rt_device_init+0xac>
            }
            else
            {
                dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    4800ca34:	f9400fe0 	ldr	x0, [sp, #24]
    4800ca38:	79404800 	ldrh	w0, [x0, #36]
    4800ca3c:	321c0000 	orr	w0, w0, #0x10
    4800ca40:	12003c01 	and	w1, w0, #0xffff
    4800ca44:	f9400fe0 	ldr	x0, [sp, #24]
    4800ca48:	79004801 	strh	w1, [x0, #36]
            }
        }
    }

    return result;
    4800ca4c:	f94017e0 	ldr	x0, [sp, #40]
}
    4800ca50:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800ca54:	d65f03c0 	ret

000000004800ca58 <rt_device_open>:
 * @param oflag is the flags for device open.
 *
 * @return the result, RT_EOK on successfully.
 */
rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
    4800ca58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800ca5c:	910003fd 	mov	x29, sp
    4800ca60:	f9000fe0 	str	x0, [sp, #24]
    4800ca64:	79002fe1 	strh	w1, [sp, #22]
    rt_err_t result = RT_EOK;
    4800ca68:	f90017ff 	str	xzr, [sp, #40]

    RT_ASSERT(dev != RT_NULL);
    4800ca6c:	f9400fe0 	ldr	x0, [sp, #24]
    4800ca70:	f100001f 	cmp	x0, #0x0
    4800ca74:	540000e1 	b.ne	4800ca90 <rt_device_open+0x38>  // b.any
    4800ca78:	d28019a2 	mov	x2, #0xcd                  	// #205
    4800ca7c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ca80:	91186001 	add	x1, x0, #0x618
    4800ca84:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ca88:	91132000 	add	x0, x0, #0x4c8
    4800ca8c:	94000d77 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800ca90:	f9400fe0 	ldr	x0, [sp, #24]
    4800ca94:	94000587 	bl	4800e0b0 <rt_object_get_type>
    4800ca98:	12001c00 	and	w0, w0, #0xff
    4800ca9c:	7100241f 	cmp	w0, #0x9
    4800caa0:	540000e0 	b.eq	4800cabc <rt_device_open+0x64>  // b.none
    4800caa4:	d28019c2 	mov	x2, #0xce                  	// #206
    4800caa8:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800caac:	91186001 	add	x1, x0, #0x618
    4800cab0:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cab4:	91136000 	add	x0, x0, #0x4d8
    4800cab8:	94000d6c 	bl	48010068 <rt_assert_handler>

    /* if device is not initialized, initialize it. */
    if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
    4800cabc:	f9400fe0 	ldr	x0, [sp, #24]
    4800cac0:	79404800 	ldrh	w0, [x0, #36]
    4800cac4:	121c0000 	and	w0, w0, #0x10
    4800cac8:	7100001f 	cmp	w0, #0x0
    4800cacc:	54000361 	b.ne	4800cb38 <rt_device_open+0xe0>  // b.any
    {
        if (device_init != RT_NULL)
    4800cad0:	f9400fe0 	ldr	x0, [sp, #24]
    4800cad4:	f9402000 	ldr	x0, [x0, #64]
    4800cad8:	f100001f 	cmp	x0, #0x0
    4800cadc:	54000220 	b.eq	4800cb20 <rt_device_open+0xc8>  // b.none
        {
            result = device_init(dev);
    4800cae0:	f9400fe0 	ldr	x0, [sp, #24]
    4800cae4:	f9402001 	ldr	x1, [x0, #64]
    4800cae8:	f9400fe0 	ldr	x0, [sp, #24]
    4800caec:	d63f0020 	blr	x1
    4800caf0:	f90017e0 	str	x0, [sp, #40]
            if (result != RT_EOK)
    4800caf4:	f94017e0 	ldr	x0, [sp, #40]
    4800caf8:	f100001f 	cmp	x0, #0x0
    4800cafc:	54000120 	b.eq	4800cb20 <rt_device_open+0xc8>  // b.none
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
    4800cb00:	f9400fe0 	ldr	x0, [sp, #24]
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
    4800cb04:	f94017e2 	ldr	x2, [sp, #40]
    4800cb08:	aa0003e1 	mov	x1, x0
    4800cb0c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cb10:	9115e000 	add	x0, x0, #0x578
    4800cb14:	94000c87 	bl	4800fd30 <rt_kprintf>

                return result;
    4800cb18:	f94017e0 	ldr	x0, [sp, #40]
    4800cb1c:	14000041 	b	4800cc20 <rt_device_open+0x1c8>
            }
        }

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    4800cb20:	f9400fe0 	ldr	x0, [sp, #24]
    4800cb24:	79404800 	ldrh	w0, [x0, #36]
    4800cb28:	321c0000 	orr	w0, w0, #0x10
    4800cb2c:	12003c01 	and	w1, w0, #0xffff
    4800cb30:	f9400fe0 	ldr	x0, [sp, #24]
    4800cb34:	79004801 	strh	w1, [x0, #36]
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
    4800cb38:	f9400fe0 	ldr	x0, [sp, #24]
    4800cb3c:	79404800 	ldrh	w0, [x0, #36]
    4800cb40:	121d0000 	and	w0, w0, #0x8
    4800cb44:	7100001f 	cmp	w0, #0x0
    4800cb48:	54000100 	b.eq	4800cb68 <rt_device_open+0x110>  // b.none
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
    4800cb4c:	f9400fe0 	ldr	x0, [sp, #24]
    4800cb50:	79404c00 	ldrh	w0, [x0, #38]
    4800cb54:	121d0000 	and	w0, w0, #0x8
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
    4800cb58:	7100001f 	cmp	w0, #0x0
    4800cb5c:	54000060 	b.eq	4800cb68 <rt_device_open+0x110>  // b.none
    {
        return -RT_EBUSY;
    4800cb60:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
    4800cb64:	1400002f 	b	4800cc20 <rt_device_open+0x1c8>
    }

    /* call device_open interface */
    if (device_open != RT_NULL)
    4800cb68:	f9400fe0 	ldr	x0, [sp, #24]
    4800cb6c:	f9402400 	ldr	x0, [x0, #72]
    4800cb70:	f100001f 	cmp	x0, #0x0
    4800cb74:	54000100 	b.eq	4800cb94 <rt_device_open+0x13c>  // b.none
    {
        result = device_open(dev, oflag);
    4800cb78:	f9400fe0 	ldr	x0, [sp, #24]
    4800cb7c:	f9402402 	ldr	x2, [x0, #72]
    4800cb80:	79402fe1 	ldrh	w1, [sp, #22]
    4800cb84:	f9400fe0 	ldr	x0, [sp, #24]
    4800cb88:	d63f0040 	blr	x2
    4800cb8c:	f90017e0 	str	x0, [sp, #40]
    4800cb90:	14000007 	b	4800cbac <rt_device_open+0x154>
    }
    else
    {
        /* set open flag */
        dev->open_flag = (oflag & RT_DEVICE_OFLAG_MASK);
    4800cb94:	79402fe1 	ldrh	w1, [sp, #22]
    4800cb98:	5281e1e0 	mov	w0, #0xf0f                 	// #3855
    4800cb9c:	0a000020 	and	w0, w1, w0
    4800cba0:	12003c01 	and	w1, w0, #0xffff
    4800cba4:	f9400fe0 	ldr	x0, [sp, #24]
    4800cba8:	79004c01 	strh	w1, [x0, #38]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
    4800cbac:	f94017e0 	ldr	x0, [sp, #40]
    4800cbb0:	f100001f 	cmp	x0, #0x0
    4800cbb4:	54000080 	b.eq	4800cbc4 <rt_device_open+0x16c>  // b.none
    4800cbb8:	f94017e0 	ldr	x0, [sp, #40]
    4800cbbc:	b100181f 	cmn	x0, #0x6
    4800cbc0:	540002e1 	b.ne	4800cc1c <rt_device_open+0x1c4>  // b.any
    {
        dev->open_flag |= RT_DEVICE_OFLAG_OPEN;
    4800cbc4:	f9400fe0 	ldr	x0, [sp, #24]
    4800cbc8:	79404c00 	ldrh	w0, [x0, #38]
    4800cbcc:	321d0000 	orr	w0, w0, #0x8
    4800cbd0:	12003c01 	and	w1, w0, #0xffff
    4800cbd4:	f9400fe0 	ldr	x0, [sp, #24]
    4800cbd8:	79004c01 	strh	w1, [x0, #38]

        dev->ref_count++;
    4800cbdc:	f9400fe0 	ldr	x0, [sp, #24]
    4800cbe0:	3940a000 	ldrb	w0, [x0, #40]
    4800cbe4:	11000400 	add	w0, w0, #0x1
    4800cbe8:	12001c01 	and	w1, w0, #0xff
    4800cbec:	f9400fe0 	ldr	x0, [sp, #24]
    4800cbf0:	3900a001 	strb	w1, [x0, #40]
        /* don't let bad things happen silently. If you are bitten by this assert,
         * please set the ref_count to a bigger type. */
        RT_ASSERT(dev->ref_count != 0);
    4800cbf4:	f9400fe0 	ldr	x0, [sp, #24]
    4800cbf8:	3940a000 	ldrb	w0, [x0, #40]
    4800cbfc:	7100001f 	cmp	w0, #0x0
    4800cc00:	540000e1 	b.ne	4800cc1c <rt_device_open+0x1c4>  // b.any
    4800cc04:	d2801f82 	mov	x2, #0xfc                  	// #252
    4800cc08:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cc0c:	91186001 	add	x1, x0, #0x618
    4800cc10:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cc14:	9116c000 	add	x0, x0, #0x5b0
    4800cc18:	94000d14 	bl	48010068 <rt_assert_handler>
    }

    return result;
    4800cc1c:	f94017e0 	ldr	x0, [sp, #40]
}
    4800cc20:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800cc24:	d65f03c0 	ret

000000004800cc28 <rt_device_close>:
 * @param dev is the pointer of device driver structure.
 *
 * @return the result, RT_EOK on successfully.
 */
rt_err_t rt_device_close(rt_device_t dev)
{
    4800cc28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800cc2c:	910003fd 	mov	x29, sp
    4800cc30:	f9000fe0 	str	x0, [sp, #24]
    rt_err_t result = RT_EOK;
    4800cc34:	f90017ff 	str	xzr, [sp, #40]

    RT_ASSERT(dev != RT_NULL);
    4800cc38:	f9400fe0 	ldr	x0, [sp, #24]
    4800cc3c:	f100001f 	cmp	x0, #0x0
    4800cc40:	540000e1 	b.ne	4800cc5c <rt_device_close+0x34>  // b.any
    4800cc44:	d28021c2 	mov	x2, #0x10e                 	// #270
    4800cc48:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cc4c:	9118a001 	add	x1, x0, #0x628
    4800cc50:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cc54:	91132000 	add	x0, x0, #0x4c8
    4800cc58:	94000d04 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800cc5c:	f9400fe0 	ldr	x0, [sp, #24]
    4800cc60:	94000514 	bl	4800e0b0 <rt_object_get_type>
    4800cc64:	12001c00 	and	w0, w0, #0xff
    4800cc68:	7100241f 	cmp	w0, #0x9
    4800cc6c:	540000e0 	b.eq	4800cc88 <rt_device_close+0x60>  // b.none
    4800cc70:	d28021e2 	mov	x2, #0x10f                 	// #271
    4800cc74:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cc78:	9118a001 	add	x1, x0, #0x628
    4800cc7c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cc80:	91136000 	add	x0, x0, #0x4d8
    4800cc84:	94000cf9 	bl	48010068 <rt_assert_handler>

    if (dev->ref_count == 0)
    4800cc88:	f9400fe0 	ldr	x0, [sp, #24]
    4800cc8c:	3940a000 	ldrb	w0, [x0, #40]
    4800cc90:	7100001f 	cmp	w0, #0x0
    4800cc94:	54000061 	b.ne	4800cca0 <rt_device_close+0x78>  // b.any
        return -RT_ERROR;
    4800cc98:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800cc9c:	1400001f 	b	4800cd18 <rt_device_close+0xf0>

    dev->ref_count--;
    4800cca0:	f9400fe0 	ldr	x0, [sp, #24]
    4800cca4:	3940a000 	ldrb	w0, [x0, #40]
    4800cca8:	51000400 	sub	w0, w0, #0x1
    4800ccac:	12001c01 	and	w1, w0, #0xff
    4800ccb0:	f9400fe0 	ldr	x0, [sp, #24]
    4800ccb4:	3900a001 	strb	w1, [x0, #40]

    if (dev->ref_count != 0)
    4800ccb8:	f9400fe0 	ldr	x0, [sp, #24]
    4800ccbc:	3940a000 	ldrb	w0, [x0, #40]
    4800ccc0:	7100001f 	cmp	w0, #0x0
    4800ccc4:	54000060 	b.eq	4800ccd0 <rt_device_close+0xa8>  // b.none
        return RT_EOK;
    4800ccc8:	d2800000 	mov	x0, #0x0                   	// #0
    4800cccc:	14000013 	b	4800cd18 <rt_device_close+0xf0>

    /* call device_close interface */
    if (device_close != RT_NULL)
    4800ccd0:	f9400fe0 	ldr	x0, [sp, #24]
    4800ccd4:	f9402800 	ldr	x0, [x0, #80]
    4800ccd8:	f100001f 	cmp	x0, #0x0
    4800ccdc:	540000c0 	b.eq	4800ccf4 <rt_device_close+0xcc>  // b.none
    {
        result = device_close(dev);
    4800cce0:	f9400fe0 	ldr	x0, [sp, #24]
    4800cce4:	f9402801 	ldr	x1, [x0, #80]
    4800cce8:	f9400fe0 	ldr	x0, [sp, #24]
    4800ccec:	d63f0020 	blr	x1
    4800ccf0:	f90017e0 	str	x0, [sp, #40]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
    4800ccf4:	f94017e0 	ldr	x0, [sp, #40]
    4800ccf8:	f100001f 	cmp	x0, #0x0
    4800ccfc:	54000080 	b.eq	4800cd0c <rt_device_close+0xe4>  // b.none
    4800cd00:	f94017e0 	ldr	x0, [sp, #40]
    4800cd04:	b100181f 	cmn	x0, #0x6
    4800cd08:	54000061 	b.ne	4800cd14 <rt_device_close+0xec>  // b.any
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
    4800cd0c:	f9400fe0 	ldr	x0, [sp, #24]
    4800cd10:	79004c1f 	strh	wzr, [x0, #38]

    return result;
    4800cd14:	f94017e0 	ldr	x0, [sp, #40]
}
    4800cd18:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800cd1c:	d65f03c0 	ret

000000004800cd20 <rt_device_read>:
 */
rt_size_t rt_device_read(rt_device_t dev,
                         rt_off_t    pos,
                         void       *buffer,
                         rt_size_t   size)
{
    4800cd20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800cd24:	910003fd 	mov	x29, sp
    4800cd28:	f90017e0 	str	x0, [sp, #40]
    4800cd2c:	f90013e1 	str	x1, [sp, #32]
    4800cd30:	f9000fe2 	str	x2, [sp, #24]
    4800cd34:	f9000be3 	str	x3, [sp, #16]
    RT_ASSERT(dev != RT_NULL);
    4800cd38:	f94017e0 	ldr	x0, [sp, #40]
    4800cd3c:	f100001f 	cmp	x0, #0x0
    4800cd40:	540000e1 	b.ne	4800cd5c <rt_device_read+0x3c>  // b.any
    4800cd44:	d2802762 	mov	x2, #0x13b                 	// #315
    4800cd48:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cd4c:	9118e001 	add	x1, x0, #0x638
    4800cd50:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cd54:	91132000 	add	x0, x0, #0x4c8
    4800cd58:	94000cc4 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800cd5c:	f94017e0 	ldr	x0, [sp, #40]
    4800cd60:	940004d4 	bl	4800e0b0 <rt_object_get_type>
    4800cd64:	12001c00 	and	w0, w0, #0xff
    4800cd68:	7100241f 	cmp	w0, #0x9
    4800cd6c:	540000e0 	b.eq	4800cd88 <rt_device_read+0x68>  // b.none
    4800cd70:	d2802782 	mov	x2, #0x13c                 	// #316
    4800cd74:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cd78:	9118e001 	add	x1, x0, #0x638
    4800cd7c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cd80:	91136000 	add	x0, x0, #0x4d8
    4800cd84:	94000cb9 	bl	48010068 <rt_assert_handler>

    if (dev->ref_count == 0)
    4800cd88:	f94017e0 	ldr	x0, [sp, #40]
    4800cd8c:	3940a000 	ldrb	w0, [x0, #40]
    4800cd90:	7100001f 	cmp	w0, #0x0
    4800cd94:	540000a1 	b.ne	4800cda8 <rt_device_read+0x88>  // b.any
    {
        rt_set_errno(-RT_ERROR);
    4800cd98:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800cd9c:	94000532 	bl	4800e264 <rt_set_errno>
        return 0;
    4800cda0:	d2800000 	mov	x0, #0x0                   	// #0
    4800cda4:	14000010 	b	4800cde4 <rt_device_read+0xc4>
    }

    /* call device_read interface */
    if (device_read != RT_NULL)
    4800cda8:	f94017e0 	ldr	x0, [sp, #40]
    4800cdac:	f9402c00 	ldr	x0, [x0, #88]
    4800cdb0:	f100001f 	cmp	x0, #0x0
    4800cdb4:	54000120 	b.eq	4800cdd8 <rt_device_read+0xb8>  // b.none
    {
        return device_read(dev, pos, buffer, size);
    4800cdb8:	f94017e0 	ldr	x0, [sp, #40]
    4800cdbc:	f9402c04 	ldr	x4, [x0, #88]
    4800cdc0:	f9400be3 	ldr	x3, [sp, #16]
    4800cdc4:	f9400fe2 	ldr	x2, [sp, #24]
    4800cdc8:	f94013e1 	ldr	x1, [sp, #32]
    4800cdcc:	f94017e0 	ldr	x0, [sp, #40]
    4800cdd0:	d63f0080 	blr	x4
    4800cdd4:	14000004 	b	4800cde4 <rt_device_read+0xc4>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
    4800cdd8:	928000a0 	mov	x0, #0xfffffffffffffffa    	// #-6
    4800cddc:	94000522 	bl	4800e264 <rt_set_errno>

    return 0;
    4800cde0:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800cde4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800cde8:	d65f03c0 	ret

000000004800cdec <rt_device_write>:
 */
rt_size_t rt_device_write(rt_device_t dev,
                          rt_off_t    pos,
                          const void *buffer,
                          rt_size_t   size)
{
    4800cdec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800cdf0:	910003fd 	mov	x29, sp
    4800cdf4:	f90017e0 	str	x0, [sp, #40]
    4800cdf8:	f90013e1 	str	x1, [sp, #32]
    4800cdfc:	f9000fe2 	str	x2, [sp, #24]
    4800ce00:	f9000be3 	str	x3, [sp, #16]
    RT_ASSERT(dev != RT_NULL);
    4800ce04:	f94017e0 	ldr	x0, [sp, #40]
    4800ce08:	f100001f 	cmp	x0, #0x0
    4800ce0c:	540000e1 	b.ne	4800ce28 <rt_device_write+0x3c>  // b.any
    4800ce10:	d2802ca2 	mov	x2, #0x165                 	// #357
    4800ce14:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ce18:	91192001 	add	x1, x0, #0x648
    4800ce1c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ce20:	91132000 	add	x0, x0, #0x4c8
    4800ce24:	94000c91 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800ce28:	f94017e0 	ldr	x0, [sp, #40]
    4800ce2c:	940004a1 	bl	4800e0b0 <rt_object_get_type>
    4800ce30:	12001c00 	and	w0, w0, #0xff
    4800ce34:	7100241f 	cmp	w0, #0x9
    4800ce38:	540000e0 	b.eq	4800ce54 <rt_device_write+0x68>  // b.none
    4800ce3c:	d2802cc2 	mov	x2, #0x166                 	// #358
    4800ce40:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ce44:	91192001 	add	x1, x0, #0x648
    4800ce48:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ce4c:	91136000 	add	x0, x0, #0x4d8
    4800ce50:	94000c86 	bl	48010068 <rt_assert_handler>

    if (dev->ref_count == 0)
    4800ce54:	f94017e0 	ldr	x0, [sp, #40]
    4800ce58:	3940a000 	ldrb	w0, [x0, #40]
    4800ce5c:	7100001f 	cmp	w0, #0x0
    4800ce60:	540000a1 	b.ne	4800ce74 <rt_device_write+0x88>  // b.any
    {
        rt_set_errno(-RT_ERROR);
    4800ce64:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800ce68:	940004ff 	bl	4800e264 <rt_set_errno>
        return 0;
    4800ce6c:	d2800000 	mov	x0, #0x0                   	// #0
    4800ce70:	14000010 	b	4800ceb0 <rt_device_write+0xc4>
    }

    /* call device_write interface */
    if (device_write != RT_NULL)
    4800ce74:	f94017e0 	ldr	x0, [sp, #40]
    4800ce78:	f9403000 	ldr	x0, [x0, #96]
    4800ce7c:	f100001f 	cmp	x0, #0x0
    4800ce80:	54000120 	b.eq	4800cea4 <rt_device_write+0xb8>  // b.none
    {
        return device_write(dev, pos, buffer, size);
    4800ce84:	f94017e0 	ldr	x0, [sp, #40]
    4800ce88:	f9403004 	ldr	x4, [x0, #96]
    4800ce8c:	f9400be3 	ldr	x3, [sp, #16]
    4800ce90:	f9400fe2 	ldr	x2, [sp, #24]
    4800ce94:	f94013e1 	ldr	x1, [sp, #32]
    4800ce98:	f94017e0 	ldr	x0, [sp, #40]
    4800ce9c:	d63f0080 	blr	x4
    4800cea0:	14000004 	b	4800ceb0 <rt_device_write+0xc4>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
    4800cea4:	928000a0 	mov	x0, #0xfffffffffffffffa    	// #-6
    4800cea8:	940004ef 	bl	4800e264 <rt_set_errno>

    return 0;
    4800ceac:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800ceb0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800ceb4:	d65f03c0 	ret

000000004800ceb8 <rt_device_control>:
 * @param arg is the argument of command.
 *
 * @return the result, -RT_ENOSYS for failed.
 */
rt_err_t rt_device_control(rt_device_t dev, int cmd, void *arg)
{
    4800ceb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800cebc:	910003fd 	mov	x29, sp
    4800cec0:	f90017e0 	str	x0, [sp, #40]
    4800cec4:	b90027e1 	str	w1, [sp, #36]
    4800cec8:	f9000fe2 	str	x2, [sp, #24]
    RT_ASSERT(dev != RT_NULL);
    4800cecc:	f94017e0 	ldr	x0, [sp, #40]
    4800ced0:	f100001f 	cmp	x0, #0x0
    4800ced4:	540000e1 	b.ne	4800cef0 <rt_device_control+0x38>  // b.any
    4800ced8:	d2803102 	mov	x2, #0x188                 	// #392
    4800cedc:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cee0:	91196001 	add	x1, x0, #0x658
    4800cee4:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cee8:	91132000 	add	x0, x0, #0x4c8
    4800ceec:	94000c5f 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800cef0:	f94017e0 	ldr	x0, [sp, #40]
    4800cef4:	9400046f 	bl	4800e0b0 <rt_object_get_type>
    4800cef8:	12001c00 	and	w0, w0, #0xff
    4800cefc:	7100241f 	cmp	w0, #0x9
    4800cf00:	540000e0 	b.eq	4800cf1c <rt_device_control+0x64>  // b.none
    4800cf04:	d2803122 	mov	x2, #0x189                 	// #393
    4800cf08:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cf0c:	91196001 	add	x1, x0, #0x658
    4800cf10:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cf14:	91136000 	add	x0, x0, #0x4d8
    4800cf18:	94000c54 	bl	48010068 <rt_assert_handler>

    /* call device_write interface */
    if (device_control != RT_NULL)
    4800cf1c:	f94017e0 	ldr	x0, [sp, #40]
    4800cf20:	f9403400 	ldr	x0, [x0, #104]
    4800cf24:	f100001f 	cmp	x0, #0x0
    4800cf28:	54000100 	b.eq	4800cf48 <rt_device_control+0x90>  // b.none
    {
        return device_control(dev, cmd, arg);
    4800cf2c:	f94017e0 	ldr	x0, [sp, #40]
    4800cf30:	f9403403 	ldr	x3, [x0, #104]
    4800cf34:	f9400fe2 	ldr	x2, [sp, #24]
    4800cf38:	b94027e1 	ldr	w1, [sp, #36]
    4800cf3c:	f94017e0 	ldr	x0, [sp, #40]
    4800cf40:	d63f0060 	blr	x3
    4800cf44:	14000002 	b	4800cf4c <rt_device_control+0x94>
    }

    return -RT_ENOSYS;
    4800cf48:	928000a0 	mov	x0, #0xfffffffffffffffa    	// #-6
}
    4800cf4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800cf50:	d65f03c0 	ret

000000004800cf54 <rt_device_set_rx_indicate>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
{
    4800cf54:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800cf58:	910003fd 	mov	x29, sp
    4800cf5c:	f9000fe0 	str	x0, [sp, #24]
    4800cf60:	f9000be1 	str	x1, [sp, #16]
    RT_ASSERT(dev != RT_NULL);
    4800cf64:	f9400fe0 	ldr	x0, [sp, #24]
    4800cf68:	f100001f 	cmp	x0, #0x0
    4800cf6c:	540000e1 	b.ne	4800cf88 <rt_device_set_rx_indicate+0x34>  // b.any
    4800cf70:	d2803462 	mov	x2, #0x1a3                 	// #419
    4800cf74:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cf78:	9119c001 	add	x1, x0, #0x670
    4800cf7c:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cf80:	91132000 	add	x0, x0, #0x4c8
    4800cf84:	94000c39 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800cf88:	f9400fe0 	ldr	x0, [sp, #24]
    4800cf8c:	94000449 	bl	4800e0b0 <rt_object_get_type>
    4800cf90:	12001c00 	and	w0, w0, #0xff
    4800cf94:	7100241f 	cmp	w0, #0x9
    4800cf98:	540000e0 	b.eq	4800cfb4 <rt_device_set_rx_indicate+0x60>  // b.none
    4800cf9c:	d2803482 	mov	x2, #0x1a4                 	// #420
    4800cfa0:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cfa4:	9119c001 	add	x1, x0, #0x670
    4800cfa8:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cfac:	91136000 	add	x0, x0, #0x4d8
    4800cfb0:	94000c2e 	bl	48010068 <rt_assert_handler>

    dev->rx_indicate = rx_ind;
    4800cfb4:	f9400fe0 	ldr	x0, [sp, #24]
    4800cfb8:	f9400be1 	ldr	x1, [sp, #16]
    4800cfbc:	f9001801 	str	x1, [x0, #48]

    return RT_EOK;
    4800cfc0:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800cfc4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800cfc8:	d65f03c0 	ret

000000004800cfcc <rt_device_set_tx_complete>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_tx_complete(rt_device_t dev,
                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer))
{
    4800cfcc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800cfd0:	910003fd 	mov	x29, sp
    4800cfd4:	f9000fe0 	str	x0, [sp, #24]
    4800cfd8:	f9000be1 	str	x1, [sp, #16]
    RT_ASSERT(dev != RT_NULL);
    4800cfdc:	f9400fe0 	ldr	x0, [sp, #24]
    4800cfe0:	f100001f 	cmp	x0, #0x0
    4800cfe4:	540000e1 	b.ne	4800d000 <rt_device_set_tx_complete+0x34>  // b.any
    4800cfe8:	d2803742 	mov	x2, #0x1ba                 	// #442
    4800cfec:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cff0:	911a4001 	add	x1, x0, #0x690
    4800cff4:	f0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800cff8:	91132000 	add	x0, x0, #0x4c8
    4800cffc:	94000c1b 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(rt_object_get_type(&dev->parent) == RT_Object_Class_Device);
    4800d000:	f9400fe0 	ldr	x0, [sp, #24]
    4800d004:	9400042b 	bl	4800e0b0 <rt_object_get_type>
    4800d008:	12001c00 	and	w0, w0, #0xff
    4800d00c:	7100241f 	cmp	w0, #0x9
    4800d010:	540000e0 	b.eq	4800d02c <rt_device_set_tx_complete+0x60>  // b.none
    4800d014:	d2803762 	mov	x2, #0x1bb                 	// #443
    4800d018:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d01c:	911a4001 	add	x1, x0, #0x690
    4800d020:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d024:	91136000 	add	x0, x0, #0x4d8
    4800d028:	94000c10 	bl	48010068 <rt_assert_handler>

    dev->tx_complete = tx_done;
    4800d02c:	f9400fe0 	ldr	x0, [sp, #24]
    4800d030:	f9400be1 	ldr	x1, [sp, #16]
    4800d034:	f9001c01 	str	x1, [x0, #56]

    return RT_EOK;
    4800d038:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800d03c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800d040:	d65f03c0 	ret

000000004800d044 <rt_list_init>:
{
    4800d044:	d10043ff 	sub	sp, sp, #0x10
    4800d048:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    4800d04c:	f94007e0 	ldr	x0, [sp, #8]
    4800d050:	f94007e1 	ldr	x1, [sp, #8]
    4800d054:	f9000401 	str	x1, [x0, #8]
    4800d058:	f94007e0 	ldr	x0, [sp, #8]
    4800d05c:	f9400401 	ldr	x1, [x0, #8]
    4800d060:	f94007e0 	ldr	x0, [sp, #8]
    4800d064:	f9000001 	str	x1, [x0]
}
    4800d068:	d503201f 	nop
    4800d06c:	910043ff 	add	sp, sp, #0x10
    4800d070:	d65f03c0 	ret

000000004800d074 <rt_list_insert_before>:
{
    4800d074:	d10043ff 	sub	sp, sp, #0x10
    4800d078:	f90007e0 	str	x0, [sp, #8]
    4800d07c:	f90003e1 	str	x1, [sp]
    l->prev->next = n;
    4800d080:	f94007e0 	ldr	x0, [sp, #8]
    4800d084:	f9400400 	ldr	x0, [x0, #8]
    4800d088:	f94003e1 	ldr	x1, [sp]
    4800d08c:	f9000001 	str	x1, [x0]
    n->prev = l->prev;
    4800d090:	f94007e0 	ldr	x0, [sp, #8]
    4800d094:	f9400401 	ldr	x1, [x0, #8]
    4800d098:	f94003e0 	ldr	x0, [sp]
    4800d09c:	f9000401 	str	x1, [x0, #8]
    l->prev = n;
    4800d0a0:	f94007e0 	ldr	x0, [sp, #8]
    4800d0a4:	f94003e1 	ldr	x1, [sp]
    4800d0a8:	f9000401 	str	x1, [x0, #8]
    n->next = l;
    4800d0ac:	f94003e0 	ldr	x0, [sp]
    4800d0b0:	f94007e1 	ldr	x1, [sp, #8]
    4800d0b4:	f9000001 	str	x1, [x0]
}
    4800d0b8:	d503201f 	nop
    4800d0bc:	910043ff 	add	sp, sp, #0x10
    4800d0c0:	d65f03c0 	ret

000000004800d0c4 <rt_list_remove>:
{
    4800d0c4:	d10043ff 	sub	sp, sp, #0x10
    4800d0c8:	f90007e0 	str	x0, [sp, #8]
    n->next->prev = n->prev;
    4800d0cc:	f94007e0 	ldr	x0, [sp, #8]
    4800d0d0:	f9400000 	ldr	x0, [x0]
    4800d0d4:	f94007e1 	ldr	x1, [sp, #8]
    4800d0d8:	f9400421 	ldr	x1, [x1, #8]
    4800d0dc:	f9000401 	str	x1, [x0, #8]
    n->prev->next = n->next;
    4800d0e0:	f94007e0 	ldr	x0, [sp, #8]
    4800d0e4:	f9400400 	ldr	x0, [x0, #8]
    4800d0e8:	f94007e1 	ldr	x1, [sp, #8]
    4800d0ec:	f9400021 	ldr	x1, [x1]
    4800d0f0:	f9000001 	str	x1, [x0]
    n->next = n->prev = n;
    4800d0f4:	f94007e0 	ldr	x0, [sp, #8]
    4800d0f8:	f94007e1 	ldr	x1, [sp, #8]
    4800d0fc:	f9000401 	str	x1, [x0, #8]
    4800d100:	f94007e0 	ldr	x0, [sp, #8]
    4800d104:	f9400401 	ldr	x1, [x0, #8]
    4800d108:	f94007e0 	ldr	x0, [sp, #8]
    4800d10c:	f9000001 	str	x1, [x0]
}
    4800d110:	d503201f 	nop
    4800d114:	910043ff 	add	sp, sp, #0x10
    4800d118:	d65f03c0 	ret

000000004800d11c <rt_list_isempty>:
{
    4800d11c:	d10043ff 	sub	sp, sp, #0x10
    4800d120:	f90007e0 	str	x0, [sp, #8]
    return l->next == l;
    4800d124:	f94007e0 	ldr	x0, [sp, #8]
    4800d128:	f9400000 	ldr	x0, [x0]
    4800d12c:	f94007e1 	ldr	x1, [sp, #8]
    4800d130:	eb00003f 	cmp	x1, x0
    4800d134:	1a9f17e0 	cset	w0, eq  // eq = none
    4800d138:	12001c00 	and	w0, w0, #0xff
}
    4800d13c:	910043ff 	add	sp, sp, #0x10
    4800d140:	d65f03c0 	ret

000000004800d144 <rt_scheduler_sethook>:
 *        switch happens.
 *
 * @param hook is the hook function.
 */
void rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
{
    4800d144:	d10043ff 	sub	sp, sp, #0x10
    4800d148:	f90007e0 	str	x0, [sp, #8]
    rt_scheduler_hook = hook;
    4800d14c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d150:	91172000 	add	x0, x0, #0x5c8
    4800d154:	f94007e1 	ldr	x1, [sp, #8]
    4800d158:	f9000001 	str	x1, [x0]
}
    4800d15c:	d503201f 	nop
    4800d160:	910043ff 	add	sp, sp, #0x10
    4800d164:	d65f03c0 	ret

000000004800d168 <rt_scheduler_switch_sethook>:
 *        switch happens.
 *
 * @param hook is the hook function.
 */
void rt_scheduler_switch_sethook(void (*hook)(struct rt_thread *tid))
{
    4800d168:	d10043ff 	sub	sp, sp, #0x10
    4800d16c:	f90007e0 	str	x0, [sp, #8]
    rt_scheduler_switch_hook = hook;
    4800d170:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d174:	91174000 	add	x0, x0, #0x5d0
    4800d178:	f94007e1 	ldr	x1, [sp, #8]
    4800d17c:	f9000001 	str	x1, [x0]
}
    4800d180:	d503201f 	nop
    4800d184:	910043ff 	add	sp, sp, #0x10
    4800d188:	d65f03c0 	ret

000000004800d18c <_rt_scheduler_stack_check>:
/**@}*/
#endif /* RT_USING_HOOK */

#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
    4800d18c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800d190:	910003fd 	mov	x29, sp
    4800d194:	f9000fe0 	str	x0, [sp, #24]
    RT_ASSERT(thread != RT_NULL);
    4800d198:	f9400fe0 	ldr	x0, [sp, #24]
    4800d19c:	f100001f 	cmp	x0, #0x0
    4800d1a0:	540000e1 	b.ne	4800d1bc <_rt_scheduler_stack_check+0x30>  // b.any
    4800d1a4:	d2800b02 	mov	x2, #0x58                  	// #88
    4800d1a8:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d1ac:	911c8001 	add	x1, x0, #0x720
    4800d1b0:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d1b4:	911ac000 	add	x0, x0, #0x6b0
    4800d1b8:	94000bac 	bl	48010068 <rt_assert_handler>

#ifdef ARCH_CPU_STACK_GROWS_UPWARD
    if (*((rt_uint8_t *)((rt_ubase_t)thread->stack_addr + thread->stack_size - 1)) != '#' ||
#else
    if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
    4800d1bc:	f9400fe0 	ldr	x0, [sp, #24]
    4800d1c0:	f9402400 	ldr	x0, [x0, #72]
    4800d1c4:	39400000 	ldrb	w0, [x0]
    4800d1c8:	71008c1f 	cmp	w0, #0x23
    4800d1cc:	54000281 	b.ne	4800d21c <_rt_scheduler_stack_check+0x90>  // b.any
#endif /* ARCH_CPU_STACK_GROWS_UPWARD */
        (rt_ubase_t)thread->sp <= (rt_ubase_t)thread->stack_addr ||
    4800d1d0:	f9400fe0 	ldr	x0, [sp, #24]
    4800d1d4:	f9401800 	ldr	x0, [x0, #48]
    4800d1d8:	aa0003e1 	mov	x1, x0
    4800d1dc:	f9400fe0 	ldr	x0, [sp, #24]
    4800d1e0:	f9402400 	ldr	x0, [x0, #72]
    if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
    4800d1e4:	eb00003f 	cmp	x1, x0
    4800d1e8:	540001a9 	b.ls	4800d21c <_rt_scheduler_stack_check+0x90>  // b.plast
        (rt_ubase_t)thread->sp >
    4800d1ec:	f9400fe0 	ldr	x0, [sp, #24]
    4800d1f0:	f9401800 	ldr	x0, [x0, #48]
    4800d1f4:	aa0003e1 	mov	x1, x0
        (rt_ubase_t)thread->stack_addr + (rt_ubase_t)thread->stack_size)
    4800d1f8:	f9400fe0 	ldr	x0, [sp, #24]
    4800d1fc:	f9402400 	ldr	x0, [x0, #72]
    4800d200:	aa0003e2 	mov	x2, x0
    4800d204:	f9400fe0 	ldr	x0, [sp, #24]
    4800d208:	b9405000 	ldr	w0, [x0, #80]
    4800d20c:	2a0003e0 	mov	w0, w0
    4800d210:	8b000040 	add	x0, x2, x0
        (rt_ubase_t)thread->sp <= (rt_ubase_t)thread->stack_addr ||
    4800d214:	eb00003f 	cmp	x1, x0
    4800d218:	54000189 	b.ls	4800d248 <_rt_scheduler_stack_check+0xbc>  // b.plast
    {
        rt_ubase_t level;

        rt_kprintf("thread:%s stack overflow\n", thread->name);
    4800d21c:	f9400fe0 	ldr	x0, [sp, #24]
    4800d220:	aa0003e1 	mov	x1, x0
    4800d224:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d228:	911b2000 	add	x0, x0, #0x6c8
    4800d22c:	94000ac1 	bl	4800fd30 <rt_kprintf>

        level = rt_hw_interrupt_disable();
    4800d230:	97ffdc7f 	bl	4800442c <rt_hw_interrupt_disable>
    4800d234:	f90017e0 	str	x0, [sp, #40]
        while (level);
    4800d238:	f94017e0 	ldr	x0, [sp, #40]
    4800d23c:	f100001f 	cmp	x0, #0x0
    4800d240:	54ffffc1 	b.ne	4800d238 <_rt_scheduler_stack_check+0xac>  // b.any
    {
    4800d244:	1400000f 	b	4800d280 <_rt_scheduler_stack_check+0xf4>
    {
        rt_kprintf("warning: %s stack is close to the top of stack address.\n",
                   thread->name);
    }
#else
    else if ((rt_ubase_t)thread->sp <= ((rt_ubase_t)thread->stack_addr + 32))
    4800d248:	f9400fe0 	ldr	x0, [sp, #24]
    4800d24c:	f9401800 	ldr	x0, [x0, #48]
    4800d250:	aa0003e1 	mov	x1, x0
    4800d254:	f9400fe0 	ldr	x0, [sp, #24]
    4800d258:	f9402400 	ldr	x0, [x0, #72]
    4800d25c:	91008000 	add	x0, x0, #0x20
    4800d260:	eb00003f 	cmp	x1, x0
    4800d264:	540000e8 	b.hi	4800d280 <_rt_scheduler_stack_check+0xf4>  // b.pmore
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
                   thread->name);
    4800d268:	f9400fe0 	ldr	x0, [sp, #24]
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
    4800d26c:	aa0003e1 	mov	x1, x0
    4800d270:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d274:	911ba000 	add	x0, x0, #0x6e8
    4800d278:	94000aae 	bl	4800fd30 <rt_kprintf>
    }
#endif /* ARCH_CPU_STACK_GROWS_UPWARD */
}
    4800d27c:	14000001 	b	4800d280 <_rt_scheduler_stack_check+0xf4>
    4800d280:	d503201f 	nop
    4800d284:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800d288:	d65f03c0 	ret

000000004800d28c <_scheduler_get_highest_priority_thread>:

    return highest_priority_thread;
}
#else
static struct rt_thread* _scheduler_get_highest_priority_thread(rt_ubase_t *highest_prio)
{
    4800d28c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800d290:	910003fd 	mov	x29, sp
    4800d294:	a90153f3 	stp	x19, x20, [sp, #16]
    4800d298:	f90017e0 	str	x0, [sp, #40]
    register rt_ubase_t number;

    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#else
    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
    4800d29c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d2a0:	9116c000 	add	x0, x0, #0x5b0
    4800d2a4:	b9400000 	ldr	w0, [x0]
    4800d2a8:	94000b31 	bl	4800ff6c <__rt_ffs>
    4800d2ac:	51000400 	sub	w0, w0, #0x1
    4800d2b0:	93407c13 	sxtw	x19, w0
#endif /* RT_THREAD_PRIORITY_MAX > 32 */

    /* get highest ready priority thread */
    highest_priority_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
    4800d2b4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d2b8:	910ec001 	add	x1, x0, #0x3b0
    4800d2bc:	d37cee60 	lsl	x0, x19, #4
    4800d2c0:	8b000020 	add	x0, x1, x0
    4800d2c4:	f9400000 	ldr	x0, [x0]
    4800d2c8:	d1008014 	sub	x20, x0, #0x20
                              struct rt_thread,
                              tlist);

    *highest_prio = highest_ready_priority;
    4800d2cc:	f94017e0 	ldr	x0, [sp, #40]
    4800d2d0:	f9000013 	str	x19, [x0]

    return highest_priority_thread;
    4800d2d4:	aa1403e0 	mov	x0, x20
}
    4800d2d8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4800d2dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800d2e0:	d65f03c0 	ret

000000004800d2e4 <rt_system_scheduler_init>:

/**
 * @brief This function will initialize the system scheduler.
 */
void rt_system_scheduler_init(void)
{
    4800d2e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800d2e8:	910003fd 	mov	x29, sp
    4800d2ec:	f9000bf3 	str	x19, [sp, #16]
    int cpu;
#endif /* RT_USING_SMP */
    register rt_base_t offset;

#ifndef RT_USING_SMP
    rt_scheduler_lock_nest = 0;
    4800d2f0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d2f4:	91170800 	add	x0, x0, #0x5c2
    4800d2f8:	7900001f 	strh	wzr, [x0]
#endif /* RT_USING_SMP */

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
    4800d2fc:	d2800013 	mov	x19, #0x0                   	// #0
    4800d300:	14000007 	b	4800d31c <rt_system_scheduler_init+0x38>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
    4800d304:	d37cee61 	lsl	x1, x19, #4
    4800d308:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d30c:	910ec000 	add	x0, x0, #0x3b0
    4800d310:	8b000020 	add	x0, x1, x0
    4800d314:	97ffff4c 	bl	4800d044 <rt_list_init>
    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
    4800d318:	91000673 	add	x19, x19, #0x1
    4800d31c:	f1007e7f 	cmp	x19, #0x1f
    4800d320:	54ffff2d 	b.le	4800d304 <rt_system_scheduler_init+0x20>
#endif /* RT_THREAD_PRIORITY_MAX > 32 */
    }
#endif /* RT_USING_SMP */

    /* initialize ready priority group */
    rt_thread_ready_priority_group = 0;
    4800d324:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d328:	9116c000 	add	x0, x0, #0x5b0
    4800d32c:	b900001f 	str	wzr, [x0]

#if RT_THREAD_PRIORITY_MAX > 32
    /* initialize ready table */
    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
#endif /* RT_THREAD_PRIORITY_MAX > 32 */
}
    4800d330:	d503201f 	nop
    4800d334:	f9400bf3 	ldr	x19, [sp, #16]
    4800d338:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800d33c:	d65f03c0 	ret

000000004800d340 <rt_system_scheduler_start>:
/**
 * @brief This function will startup the scheduler. It will select one thread
 *        with the highest priority level, then switch to it.
 */
void rt_system_scheduler_start(void)
{
    4800d340:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800d344:	910003fd 	mov	x29, sp
    4800d348:	f9000bf3 	str	x19, [sp, #16]
    register struct rt_thread *to_thread;
    rt_ubase_t highest_ready_priority;

    to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
    4800d34c:	9100a3e0 	add	x0, sp, #0x28
    4800d350:	97ffffcf 	bl	4800d28c <_scheduler_get_highest_priority_thread>
    4800d354:	aa0003f3 	mov	x19, x0

#ifdef RT_USING_SMP
    to_thread->oncpu = rt_hw_cpu_id();
#else
    rt_current_thread = to_thread;
    4800d358:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d35c:	9116e000 	add	x0, x0, #0x5b8
    4800d360:	f9000013 	str	x19, [x0]
#endif /* RT_USING_SMP */

    rt_schedule_remove_thread(to_thread);
    4800d364:	aa1303e0 	mov	x0, x19
    4800d368:	94000100 	bl	4800d768 <rt_schedule_remove_thread>
    to_thread->stat = RT_THREAD_RUNNING;
    4800d36c:	52800060 	mov	w0, #0x3                   	// #3
    4800d370:	39018260 	strb	w0, [x19, #96]

    /* switch to new thread */
#ifdef RT_USING_SMP
    rt_hw_context_switch_to((rt_ubase_t)&to_thread->sp, to_thread);
#else
    rt_hw_context_switch_to((rt_ubase_t)&to_thread->sp);
    4800d374:	9100c260 	add	x0, x19, #0x30
    4800d378:	97ffdc37 	bl	48004454 <rt_hw_context_switch_to>
#endif /* RT_USING_SMP */

    /* never come back */
}
    4800d37c:	d503201f 	nop
    4800d380:	f9400bf3 	ldr	x19, [sp, #16]
    4800d384:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800d388:	d65f03c0 	ret

000000004800d38c <rt_schedule>:
/**
 * @brief This function will perform scheduling once. It will select one thread
 *        with the highest priority, and switch to it immediately.
 */
void rt_schedule(void)
{
    4800d38c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800d390:	910003fd 	mov	x29, sp
    rt_base_t level;
    struct rt_thread *to_thread;
    struct rt_thread *from_thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800d394:	97ffdc26 	bl	4800442c <rt_hw_interrupt_disable>
    4800d398:	f90017e0 	str	x0, [sp, #40]

    /* check the scheduler is enabled or not */
    if (rt_scheduler_lock_nest == 0)
    4800d39c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d3a0:	91170800 	add	x0, x0, #0x5c2
    4800d3a4:	79c00000 	ldrsh	w0, [x0]
    4800d3a8:	7100001f 	cmp	w0, #0x0
    4800d3ac:	540014a1 	b.ne	4800d640 <rt_schedule+0x2b4>  // b.any
    {
        rt_ubase_t highest_ready_priority;

        if (rt_thread_ready_priority_group != 0)
    4800d3b0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d3b4:	9116c000 	add	x0, x0, #0x5b0
    4800d3b8:	b9400000 	ldr	w0, [x0]
    4800d3bc:	7100001f 	cmp	w0, #0x0
    4800d3c0:	54001400 	b.eq	4800d640 <rt_schedule+0x2b4>  // b.none
        {
            /* need_insert_from_thread: need to insert from_thread to ready queue */
            int need_insert_from_thread = 0;
    4800d3c4:	b90037ff 	str	wzr, [sp, #52]

            to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
    4800d3c8:	910063e0 	add	x0, sp, #0x18
    4800d3cc:	97ffffb0 	bl	4800d28c <_scheduler_get_highest_priority_thread>
    4800d3d0:	f9001fe0 	str	x0, [sp, #56]

            if ((rt_current_thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
    4800d3d4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d3d8:	9116e000 	add	x0, x0, #0x5b8
    4800d3dc:	f9400000 	ldr	x0, [x0]
    4800d3e0:	39418000 	ldrb	w0, [x0, #96]
    4800d3e4:	12000800 	and	w0, w0, #0x7
    4800d3e8:	71000c1f 	cmp	w0, #0x3
    4800d3ec:	540005c1 	b.ne	4800d4a4 <rt_schedule+0x118>  // b.any
            {
                if (rt_current_thread->current_priority < highest_ready_priority)
    4800d3f0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d3f4:	9116e000 	add	x0, x0, #0x5b8
    4800d3f8:	f9400000 	ldr	x0, [x0]
    4800d3fc:	39418400 	ldrb	w0, [x0, #97]
    4800d400:	92401c01 	and	x1, x0, #0xff
    4800d404:	f9400fe0 	ldr	x0, [sp, #24]
    4800d408:	eb00003f 	cmp	x1, x0
    4800d40c:	540000c2 	b.cs	4800d424 <rt_schedule+0x98>  // b.hs, b.nlast
                {
                    to_thread = rt_current_thread;
    4800d410:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d414:	9116e000 	add	x0, x0, #0x5b8
    4800d418:	f9400000 	ldr	x0, [x0]
    4800d41c:	f9001fe0 	str	x0, [sp, #56]
    4800d420:	14000017 	b	4800d47c <rt_schedule+0xf0>
                }
                else if (rt_current_thread->current_priority == highest_ready_priority && (rt_current_thread->stat & RT_THREAD_STAT_YIELD_MASK) == 0)
    4800d424:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d428:	9116e000 	add	x0, x0, #0x5b8
    4800d42c:	f9400000 	ldr	x0, [x0]
    4800d430:	39418400 	ldrb	w0, [x0, #97]
    4800d434:	92401c01 	and	x1, x0, #0xff
    4800d438:	f9400fe0 	ldr	x0, [sp, #24]
    4800d43c:	eb00003f 	cmp	x1, x0
    4800d440:	540001a1 	b.ne	4800d474 <rt_schedule+0xe8>  // b.any
    4800d444:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d448:	9116e000 	add	x0, x0, #0x5b8
    4800d44c:	f9400000 	ldr	x0, [x0]
    4800d450:	39418000 	ldrb	w0, [x0, #96]
    4800d454:	121d0000 	and	w0, w0, #0x8
    4800d458:	7100001f 	cmp	w0, #0x0
    4800d45c:	540000c1 	b.ne	4800d474 <rt_schedule+0xe8>  // b.any
                {
                    to_thread = rt_current_thread;
    4800d460:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d464:	9116e000 	add	x0, x0, #0x5b8
    4800d468:	f9400000 	ldr	x0, [x0]
    4800d46c:	f9001fe0 	str	x0, [sp, #56]
    4800d470:	14000003 	b	4800d47c <rt_schedule+0xf0>
                }
                else
                {
                    need_insert_from_thread = 1;
    4800d474:	52800020 	mov	w0, #0x1                   	// #1
    4800d478:	b90037e0 	str	w0, [sp, #52]
                }
                rt_current_thread->stat &= ~RT_THREAD_STAT_YIELD_MASK;
    4800d47c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d480:	9116e000 	add	x0, x0, #0x5b8
    4800d484:	f9400000 	ldr	x0, [x0]
    4800d488:	39418001 	ldrb	w1, [x0, #96]
    4800d48c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d490:	9116e000 	add	x0, x0, #0x5b8
    4800d494:	f9400000 	ldr	x0, [x0]
    4800d498:	121c7821 	and	w1, w1, #0xfffffff7
    4800d49c:	12001c21 	and	w1, w1, #0xff
    4800d4a0:	39018001 	strb	w1, [x0, #96]
            }

            if (to_thread != rt_current_thread)
    4800d4a4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d4a8:	9116e000 	add	x0, x0, #0x5b8
    4800d4ac:	f9400000 	ldr	x0, [x0]
    4800d4b0:	f9401fe1 	ldr	x1, [sp, #56]
    4800d4b4:	eb00003f 	cmp	x1, x0
    4800d4b8:	54000a00 	b.eq	4800d5f8 <rt_schedule+0x26c>  // b.none
            {
                /* if the destination thread is not the same as current thread */
                rt_current_priority = (rt_uint8_t)highest_ready_priority;
    4800d4bc:	f9400fe0 	ldr	x0, [sp, #24]
    4800d4c0:	12001c01 	and	w1, w0, #0xff
    4800d4c4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d4c8:	91170000 	add	x0, x0, #0x5c0
    4800d4cc:	39000001 	strb	w1, [x0]
                from_thread         = rt_current_thread;
    4800d4d0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d4d4:	9116e000 	add	x0, x0, #0x5b8
    4800d4d8:	f9400000 	ldr	x0, [x0]
    4800d4dc:	f90013e0 	str	x0, [sp, #32]
                rt_current_thread   = to_thread;
    4800d4e0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d4e4:	9116e000 	add	x0, x0, #0x5b8
    4800d4e8:	f9401fe1 	ldr	x1, [sp, #56]
    4800d4ec:	f9000001 	str	x1, [x0]

                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
    4800d4f0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d4f4:	91172000 	add	x0, x0, #0x5c8
    4800d4f8:	f9400000 	ldr	x0, [x0]
    4800d4fc:	f100001f 	cmp	x0, #0x0
    4800d500:	540000e0 	b.eq	4800d51c <rt_schedule+0x190>  // b.none
    4800d504:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d508:	91172000 	add	x0, x0, #0x5c8
    4800d50c:	f9400002 	ldr	x2, [x0]
    4800d510:	f9401fe1 	ldr	x1, [sp, #56]
    4800d514:	f94013e0 	ldr	x0, [sp, #32]
    4800d518:	d63f0040 	blr	x2

                if (need_insert_from_thread)
    4800d51c:	b94037e0 	ldr	w0, [sp, #52]
    4800d520:	7100001f 	cmp	w0, #0x0
    4800d524:	54000060 	b.eq	4800d530 <rt_schedule+0x1a4>  // b.none
                {
                    rt_schedule_insert_thread(from_thread);
    4800d528:	f94013e0 	ldr	x0, [sp, #32]
    4800d52c:	9400004a 	bl	4800d654 <rt_schedule_insert_thread>
                }

                rt_schedule_remove_thread(to_thread);
    4800d530:	f9401fe0 	ldr	x0, [sp, #56]
    4800d534:	9400008d 	bl	4800d768 <rt_schedule_remove_thread>
                to_thread->stat = RT_THREAD_RUNNING | (to_thread->stat & ~RT_THREAD_STAT_MASK);
    4800d538:	f9401fe0 	ldr	x0, [sp, #56]
    4800d53c:	39418000 	ldrb	w0, [x0, #96]
    4800d540:	13001c00 	sxtb	w0, w0
    4800d544:	121d7000 	and	w0, w0, #0xfffffff8
    4800d548:	13001c00 	sxtb	w0, w0
    4800d54c:	32000400 	orr	w0, w0, #0x3
    4800d550:	13001c00 	sxtb	w0, w0
    4800d554:	12001c01 	and	w1, w0, #0xff
    4800d558:	f9401fe0 	ldr	x0, [sp, #56]
    4800d55c:	39018001 	strb	w1, [x0, #96]
                         rt_interrupt_nest, highest_ready_priority,
                         RT_NAME_MAX, to_thread->name, to_thread->sp,
                         RT_NAME_MAX, from_thread->name, from_thread->sp));

#ifdef RT_USING_OVERFLOW_CHECK
                _rt_scheduler_stack_check(to_thread);
    4800d560:	f9401fe0 	ldr	x0, [sp, #56]
    4800d564:	97ffff0a 	bl	4800d18c <_rt_scheduler_stack_check>
#endif /* RT_USING_OVERFLOW_CHECK */

                if (rt_interrupt_nest == 0)
    4800d568:	f0000140 	adrp	x0, 48038000 <isr_table+0x1fd8>
    4800d56c:	9127e000 	add	x0, x0, #0x9f8
    4800d570:	39400000 	ldrb	w0, [x0]
    4800d574:	12001c00 	and	w0, w0, #0xff
    4800d578:	7100001f 	cmp	w0, #0x0
    4800d57c:	540002c1 	b.ne	4800d5d4 <rt_schedule+0x248>  // b.any
                {
                    extern void rt_thread_handle_sig(rt_bool_t clean_state);

                    RT_OBJECT_HOOK_CALL(rt_scheduler_switch_hook, (from_thread));
    4800d580:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d584:	91174000 	add	x0, x0, #0x5d0
    4800d588:	f9400000 	ldr	x0, [x0]
    4800d58c:	f100001f 	cmp	x0, #0x0
    4800d590:	540000c0 	b.eq	4800d5a8 <rt_schedule+0x21c>  // b.none
    4800d594:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d598:	91174000 	add	x0, x0, #0x5d0
    4800d59c:	f9400001 	ldr	x1, [x0]
    4800d5a0:	f94013e0 	ldr	x0, [sp, #32]
    4800d5a4:	d63f0020 	blr	x1

                    rt_hw_context_switch((rt_ubase_t)&from_thread->sp,
    4800d5a8:	f94013e0 	ldr	x0, [sp, #32]
    4800d5ac:	9100c000 	add	x0, x0, #0x30
    4800d5b0:	aa0003e2 	mov	x2, x0
                            (rt_ubase_t)&to_thread->sp);
    4800d5b4:	f9401fe0 	ldr	x0, [sp, #56]
    4800d5b8:	9100c000 	add	x0, x0, #0x30
                    rt_hw_context_switch((rt_ubase_t)&from_thread->sp,
    4800d5bc:	aa0003e1 	mov	x1, x0
    4800d5c0:	aa0203e0 	mov	x0, x2
    4800d5c4:	97ffdbcb 	bl	480044f0 <rt_hw_context_switch>

                    /* enable interrupt */
                    rt_hw_interrupt_enable(level);
    4800d5c8:	f94017e0 	ldr	x0, [sp, #40]
    4800d5cc:	97ffdb9c 	bl	4800443c <rt_hw_interrupt_enable>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);

__exit:
    return;
    4800d5d0:	1400001f 	b	4800d64c <rt_schedule+0x2c0>
                    rt_hw_context_switch_interrupt((rt_ubase_t)&from_thread->sp,
    4800d5d4:	f94013e0 	ldr	x0, [sp, #32]
    4800d5d8:	9100c000 	add	x0, x0, #0x30
    4800d5dc:	aa0003e2 	mov	x2, x0
                            (rt_ubase_t)&to_thread->sp);
    4800d5e0:	f9401fe0 	ldr	x0, [sp, #56]
    4800d5e4:	9100c000 	add	x0, x0, #0x30
                    rt_hw_context_switch_interrupt((rt_ubase_t)&from_thread->sp,
    4800d5e8:	aa0003e1 	mov	x1, x0
    4800d5ec:	aa0203e0 	mov	x0, x2
    4800d5f0:	97ffdc0f 	bl	4800462c <rt_hw_context_switch_interrupt>
    4800d5f4:	14000013 	b	4800d640 <rt_schedule+0x2b4>
                rt_schedule_remove_thread(rt_current_thread);
    4800d5f8:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d5fc:	9116e000 	add	x0, x0, #0x5b8
    4800d600:	f9400000 	ldr	x0, [x0]
    4800d604:	94000059 	bl	4800d768 <rt_schedule_remove_thread>
                rt_current_thread->stat = RT_THREAD_RUNNING | (rt_current_thread->stat & ~RT_THREAD_STAT_MASK);
    4800d608:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d60c:	9116e000 	add	x0, x0, #0x5b8
    4800d610:	f9400000 	ldr	x0, [x0]
    4800d614:	39418000 	ldrb	w0, [x0, #96]
    4800d618:	13001c00 	sxtb	w0, w0
    4800d61c:	121d7000 	and	w0, w0, #0xfffffff8
    4800d620:	13001c00 	sxtb	w0, w0
    4800d624:	32000400 	orr	w0, w0, #0x3
    4800d628:	13001c01 	sxtb	w1, w0
    4800d62c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d630:	9116e000 	add	x0, x0, #0x5b8
    4800d634:	f9400000 	ldr	x0, [x0]
    4800d638:	12001c21 	and	w1, w1, #0xff
    4800d63c:	39018001 	strb	w1, [x0, #96]
    rt_hw_interrupt_enable(level);
    4800d640:	f94017e0 	ldr	x0, [sp, #40]
    4800d644:	97ffdb7e 	bl	4800443c <rt_hw_interrupt_enable>
    return;
    4800d648:	d503201f 	nop
}
    4800d64c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800d650:	d65f03c0 	ret

000000004800d654 <rt_schedule_insert_thread>:
    /* enable interrupt */
    rt_hw_interrupt_enable(level);
}
#else
void rt_schedule_insert_thread(struct rt_thread *thread)
{
    4800d654:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800d658:	910003fd 	mov	x29, sp
    4800d65c:	f9000bf3 	str	x19, [sp, #16]
    4800d660:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
    4800d664:	f94017e0 	ldr	x0, [sp, #40]
    4800d668:	f100001f 	cmp	x0, #0x0
    4800d66c:	540000e1 	b.ne	4800d688 <rt_schedule_insert_thread+0x34>  // b.any
    4800d670:	d2805962 	mov	x2, #0x2cb                 	// #715
    4800d674:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d678:	911d0001 	add	x1, x0, #0x740
    4800d67c:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d680:	911ac000 	add	x0, x0, #0x6b0
    4800d684:	94000a79 	bl	48010068 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
    4800d688:	97ffdb69 	bl	4800442c <rt_hw_interrupt_disable>
    4800d68c:	aa0003f3 	mov	x19, x0

    /* it's current thread, it should be RUNNING thread */
    if (thread == rt_current_thread)
    4800d690:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d694:	9116e000 	add	x0, x0, #0x5b8
    4800d698:	f9400000 	ldr	x0, [x0]
    4800d69c:	f94017e1 	ldr	x1, [sp, #40]
    4800d6a0:	eb00003f 	cmp	x1, x0
    4800d6a4:	54000181 	b.ne	4800d6d4 <rt_schedule_insert_thread+0x80>  // b.any
    {
        thread->stat = RT_THREAD_RUNNING | (thread->stat & ~RT_THREAD_STAT_MASK);
    4800d6a8:	f94017e0 	ldr	x0, [sp, #40]
    4800d6ac:	39418000 	ldrb	w0, [x0, #96]
    4800d6b0:	13001c00 	sxtb	w0, w0
    4800d6b4:	121d7000 	and	w0, w0, #0xfffffff8
    4800d6b8:	13001c00 	sxtb	w0, w0
    4800d6bc:	32000400 	orr	w0, w0, #0x3
    4800d6c0:	13001c00 	sxtb	w0, w0
    4800d6c4:	12001c01 	and	w1, w0, #0xff
    4800d6c8:	f94017e0 	ldr	x0, [sp, #40]
    4800d6cc:	39018001 	strb	w1, [x0, #96]
        goto __exit;
    4800d6d0:	14000020 	b	4800d750 <rt_schedule_insert_thread+0xfc>
    }

    /* READY thread, insert to ready queue */
    thread->stat = RT_THREAD_READY | (thread->stat & ~RT_THREAD_STAT_MASK);
    4800d6d4:	f94017e0 	ldr	x0, [sp, #40]
    4800d6d8:	39418000 	ldrb	w0, [x0, #96]
    4800d6dc:	13001c00 	sxtb	w0, w0
    4800d6e0:	121d7000 	and	w0, w0, #0xfffffff8
    4800d6e4:	13001c00 	sxtb	w0, w0
    4800d6e8:	32000000 	orr	w0, w0, #0x1
    4800d6ec:	13001c00 	sxtb	w0, w0
    4800d6f0:	12001c01 	and	w1, w0, #0xff
    4800d6f4:	f94017e0 	ldr	x0, [sp, #40]
    4800d6f8:	39018001 	strb	w1, [x0, #96]
    /* insert thread to ready list */
    rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
    4800d6fc:	f94017e0 	ldr	x0, [sp, #40]
    4800d700:	39418400 	ldrb	w0, [x0, #97]
    4800d704:	93407c00 	sxtw	x0, w0
    4800d708:	d37cec01 	lsl	x1, x0, #4
    4800d70c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d710:	910ec000 	add	x0, x0, #0x3b0
    4800d714:	8b000022 	add	x2, x1, x0
    4800d718:	f94017e0 	ldr	x0, [sp, #40]
    4800d71c:	91008000 	add	x0, x0, #0x20
    4800d720:	aa0003e1 	mov	x1, x0
    4800d724:	aa0203e0 	mov	x0, x2
    4800d728:	97fffe53 	bl	4800d074 <rt_list_insert_before>

    /* set priority mask */
#if RT_THREAD_PRIORITY_MAX > 32
    rt_thread_ready_table[thread->number] |= thread->high_mask;
#endif /* RT_THREAD_PRIORITY_MAX > 32 */
    rt_thread_ready_priority_group |= thread->number_mask;
    4800d72c:	f94017e0 	ldr	x0, [sp, #40]
    4800d730:	b9406401 	ldr	w1, [x0, #100]
    4800d734:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d738:	9116c000 	add	x0, x0, #0x5b0
    4800d73c:	b9400000 	ldr	w0, [x0]
    4800d740:	2a000021 	orr	w1, w1, w0
    4800d744:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d748:	9116c000 	add	x0, x0, #0x5b0
    4800d74c:	b9000001 	str	w1, [x0]

__exit:
    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
    4800d750:	aa1303e0 	mov	x0, x19
    4800d754:	97ffdb3a 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800d758:	d503201f 	nop
    4800d75c:	f9400bf3 	ldr	x19, [sp, #16]
    4800d760:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800d764:	d65f03c0 	ret

000000004800d768 <rt_schedule_remove_thread>:
    /* enable interrupt */
    rt_hw_interrupt_enable(level);
}
#else
void rt_schedule_remove_thread(struct rt_thread *thread)
{
    4800d768:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800d76c:	910003fd 	mov	x29, sp
    4800d770:	f9000bf3 	str	x19, [sp, #16]
    4800d774:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t level;

    RT_ASSERT(thread != RT_NULL);
    4800d778:	f94017e0 	ldr	x0, [sp, #40]
    4800d77c:	f100001f 	cmp	x0, #0x0
    4800d780:	540000e1 	b.ne	4800d79c <rt_schedule_remove_thread+0x34>  // b.any
    4800d784:	d2806582 	mov	x2, #0x32c                 	// #812
    4800d788:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d78c:	911d8001 	add	x1, x0, #0x760
    4800d790:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800d794:	911ac000 	add	x0, x0, #0x6b0
    4800d798:	94000a34 	bl	48010068 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800d79c:	97ffdb24 	bl	4800442c <rt_hw_interrupt_disable>
    4800d7a0:	aa0003f3 	mov	x19, x0
    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
                                      RT_NAME_MAX, thread->name,
                                      thread->current_priority));

    /* remove thread from ready list */
    rt_list_remove(&(thread->tlist));
    4800d7a4:	f94017e0 	ldr	x0, [sp, #40]
    4800d7a8:	91008000 	add	x0, x0, #0x20
    4800d7ac:	97fffe46 	bl	4800d0c4 <rt_list_remove>
    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
    4800d7b0:	f94017e0 	ldr	x0, [sp, #40]
    4800d7b4:	39418400 	ldrb	w0, [x0, #97]
    4800d7b8:	93407c00 	sxtw	x0, w0
    4800d7bc:	d37cec01 	lsl	x1, x0, #4
    4800d7c0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d7c4:	910ec000 	add	x0, x0, #0x3b0
    4800d7c8:	8b000020 	add	x0, x1, x0
    4800d7cc:	97fffe54 	bl	4800d11c <rt_list_isempty>
    4800d7d0:	7100001f 	cmp	w0, #0x0
    4800d7d4:	54000160 	b.eq	4800d800 <rt_schedule_remove_thread+0x98>  // b.none
        if (rt_thread_ready_table[thread->number] == 0)
        {
            rt_thread_ready_priority_group &= ~thread->number_mask;
        }
#else
        rt_thread_ready_priority_group &= ~thread->number_mask;
    4800d7d8:	f94017e0 	ldr	x0, [sp, #40]
    4800d7dc:	b9406400 	ldr	w0, [x0, #100]
    4800d7e0:	2a2003e1 	mvn	w1, w0
    4800d7e4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d7e8:	9116c000 	add	x0, x0, #0x5b0
    4800d7ec:	b9400000 	ldr	w0, [x0]
    4800d7f0:	0a000021 	and	w1, w1, w0
    4800d7f4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d7f8:	9116c000 	add	x0, x0, #0x5b0
    4800d7fc:	b9000001 	str	w1, [x0]
#endif /* RT_THREAD_PRIORITY_MAX > 32 */
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800d800:	aa1303e0 	mov	x0, x19
    4800d804:	97ffdb0e 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800d808:	d503201f 	nop
    4800d80c:	f9400bf3 	ldr	x19, [sp, #16]
    4800d810:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800d814:	d65f03c0 	ret

000000004800d818 <rt_enter_critical>:
    /* enable interrupt */
    rt_hw_local_irq_enable(level);
}
#else
void rt_enter_critical(void)
{
    4800d818:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800d81c:	910003fd 	mov	x29, sp
    4800d820:	f9000bf3 	str	x19, [sp, #16]
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800d824:	97ffdb02 	bl	4800442c <rt_hw_interrupt_disable>
    4800d828:	aa0003f3 	mov	x19, x0

    /*
     * the maximal number of nest is RT_UINT16_MAX, which is big
     * enough and does not check here
     */
    rt_scheduler_lock_nest ++;
    4800d82c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d830:	91170800 	add	x0, x0, #0x5c2
    4800d834:	79c00000 	ldrsh	w0, [x0]
    4800d838:	12003c00 	and	w0, w0, #0xffff
    4800d83c:	11000400 	add	w0, w0, #0x1
    4800d840:	12003c00 	and	w0, w0, #0xffff
    4800d844:	13003c01 	sxth	w1, w0
    4800d848:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d84c:	91170800 	add	x0, x0, #0x5c2
    4800d850:	79000001 	strh	w1, [x0]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
    4800d854:	aa1303e0 	mov	x0, x19
    4800d858:	97ffdaf9 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800d85c:	d503201f 	nop
    4800d860:	f9400bf3 	ldr	x19, [sp, #16]
    4800d864:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800d868:	d65f03c0 	ret

000000004800d86c <rt_exit_critical>:
        rt_hw_local_irq_enable(level);
    }
}
#else
void rt_exit_critical(void)
{
    4800d86c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800d870:	910003fd 	mov	x29, sp
    4800d874:	f9000bf3 	str	x19, [sp, #16]
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
    4800d878:	97ffdaed 	bl	4800442c <rt_hw_interrupt_disable>
    4800d87c:	aa0003f3 	mov	x19, x0

    rt_scheduler_lock_nest --;
    4800d880:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d884:	91170800 	add	x0, x0, #0x5c2
    4800d888:	79c00000 	ldrsh	w0, [x0]
    4800d88c:	12003c00 	and	w0, w0, #0xffff
    4800d890:	51000400 	sub	w0, w0, #0x1
    4800d894:	12003c00 	and	w0, w0, #0xffff
    4800d898:	13003c01 	sxth	w1, w0
    4800d89c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d8a0:	91170800 	add	x0, x0, #0x5c2
    4800d8a4:	79000001 	strh	w1, [x0]
    if (rt_scheduler_lock_nest <= 0)
    4800d8a8:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d8ac:	91170800 	add	x0, x0, #0x5c2
    4800d8b0:	79c00000 	ldrsh	w0, [x0]
    4800d8b4:	7100001f 	cmp	w0, #0x0
    4800d8b8:	540001ac 	b.gt	4800d8ec <rt_exit_critical+0x80>
    {
        rt_scheduler_lock_nest = 0;
    4800d8bc:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d8c0:	91170800 	add	x0, x0, #0x5c2
    4800d8c4:	7900001f 	strh	wzr, [x0]
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    4800d8c8:	aa1303e0 	mov	x0, x19
    4800d8cc:	97ffdadc 	bl	4800443c <rt_hw_interrupt_enable>

        if (rt_current_thread)
    4800d8d0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d8d4:	9116e000 	add	x0, x0, #0x5b8
    4800d8d8:	f9400000 	ldr	x0, [x0]
    4800d8dc:	f100001f 	cmp	x0, #0x0
    4800d8e0:	540000a0 	b.eq	4800d8f4 <rt_exit_critical+0x88>  // b.none
        {
            /* if scheduler is started, do a schedule */
            rt_schedule();
    4800d8e4:	97fffeaa 	bl	4800d38c <rt_schedule>
    else
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    }
}
    4800d8e8:	14000003 	b	4800d8f4 <rt_exit_critical+0x88>
        rt_hw_interrupt_enable(level);
    4800d8ec:	aa1303e0 	mov	x0, x19
    4800d8f0:	97ffdad3 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800d8f4:	d503201f 	nop
    4800d8f8:	f9400bf3 	ldr	x19, [sp, #16]
    4800d8fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800d900:	d65f03c0 	ret

000000004800d904 <rt_critical_level>:
#ifdef RT_USING_SMP
    struct rt_thread *current_thread = rt_cpu_self()->current_thread;

    return current_thread->critical_lock_nest;
#else
    return rt_scheduler_lock_nest;
    4800d904:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d908:	91170800 	add	x0, x0, #0x5c2
    4800d90c:	79c00000 	ldrsh	w0, [x0]
    4800d910:	12003c00 	and	w0, w0, #0xffff
#endif /* RT_USING_SMP */
}
    4800d914:	d65f03c0 	ret

000000004800d918 <rt_list_insert_after>:
{
    4800d918:	d10043ff 	sub	sp, sp, #0x10
    4800d91c:	f90007e0 	str	x0, [sp, #8]
    4800d920:	f90003e1 	str	x1, [sp]
    l->next->prev = n;
    4800d924:	f94007e0 	ldr	x0, [sp, #8]
    4800d928:	f9400000 	ldr	x0, [x0]
    4800d92c:	f94003e1 	ldr	x1, [sp]
    4800d930:	f9000401 	str	x1, [x0, #8]
    n->next = l->next;
    4800d934:	f94007e0 	ldr	x0, [sp, #8]
    4800d938:	f9400001 	ldr	x1, [x0]
    4800d93c:	f94003e0 	ldr	x0, [sp]
    4800d940:	f9000001 	str	x1, [x0]
    l->next = n;
    4800d944:	f94007e0 	ldr	x0, [sp, #8]
    4800d948:	f94003e1 	ldr	x1, [sp]
    4800d94c:	f9000001 	str	x1, [x0]
    n->prev = l;
    4800d950:	f94003e0 	ldr	x0, [sp]
    4800d954:	f94007e1 	ldr	x1, [sp, #8]
    4800d958:	f9000401 	str	x1, [x0, #8]
}
    4800d95c:	d503201f 	nop
    4800d960:	910043ff 	add	sp, sp, #0x10
    4800d964:	d65f03c0 	ret

000000004800d968 <rt_list_remove>:
{
    4800d968:	d10043ff 	sub	sp, sp, #0x10
    4800d96c:	f90007e0 	str	x0, [sp, #8]
    n->next->prev = n->prev;
    4800d970:	f94007e0 	ldr	x0, [sp, #8]
    4800d974:	f9400000 	ldr	x0, [x0]
    4800d978:	f94007e1 	ldr	x1, [sp, #8]
    4800d97c:	f9400421 	ldr	x1, [x1, #8]
    4800d980:	f9000401 	str	x1, [x0, #8]
    n->prev->next = n->next;
    4800d984:	f94007e0 	ldr	x0, [sp, #8]
    4800d988:	f9400400 	ldr	x0, [x0, #8]
    4800d98c:	f94007e1 	ldr	x1, [sp, #8]
    4800d990:	f9400021 	ldr	x1, [x1]
    4800d994:	f9000001 	str	x1, [x0]
    n->next = n->prev = n;
    4800d998:	f94007e0 	ldr	x0, [sp, #8]
    4800d99c:	f94007e1 	ldr	x1, [sp, #8]
    4800d9a0:	f9000401 	str	x1, [x0, #8]
    4800d9a4:	f94007e0 	ldr	x0, [sp, #8]
    4800d9a8:	f9400401 	ldr	x1, [x0, #8]
    4800d9ac:	f94007e0 	ldr	x0, [sp, #8]
    4800d9b0:	f9000001 	str	x1, [x0]
}
    4800d9b4:	d503201f 	nop
    4800d9b8:	910043ff 	add	sp, sp, #0x10
    4800d9bc:	d65f03c0 	ret

000000004800d9c0 <rt_object_attach_sethook>:
 *        attaches to kernel object system.
 *
 * @param hook is the hook function.
 */
void rt_object_attach_sethook(void (*hook)(struct rt_object *object))
{
    4800d9c0:	d10043ff 	sub	sp, sp, #0x10
    4800d9c4:	f90007e0 	str	x0, [sp, #8]
    rt_object_attach_hook = hook;
    4800d9c8:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d9cc:	9117c000 	add	x0, x0, #0x5f0
    4800d9d0:	f94007e1 	ldr	x1, [sp, #8]
    4800d9d4:	f9000001 	str	x1, [x0]
}
    4800d9d8:	d503201f 	nop
    4800d9dc:	910043ff 	add	sp, sp, #0x10
    4800d9e0:	d65f03c0 	ret

000000004800d9e4 <rt_object_detach_sethook>:
 *        detaches from kernel object system.
 *
 * @param hook is the hook function
 */
void rt_object_detach_sethook(void (*hook)(struct rt_object *object))
{
    4800d9e4:	d10043ff 	sub	sp, sp, #0x10
    4800d9e8:	f90007e0 	str	x0, [sp, #8]
    rt_object_detach_hook = hook;
    4800d9ec:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800d9f0:	9117e000 	add	x0, x0, #0x5f8
    4800d9f4:	f94007e1 	ldr	x1, [sp, #8]
    4800d9f8:	f9000001 	str	x1, [x0]
}
    4800d9fc:	d503201f 	nop
    4800da00:	910043ff 	add	sp, sp, #0x10
    4800da04:	d65f03c0 	ret

000000004800da08 <rt_object_trytake_sethook>:
 *            message queue - message is received by thread
 *
 * @param hook is the hook function.
 */
void rt_object_trytake_sethook(void (*hook)(struct rt_object *object))
{
    4800da08:	d10043ff 	sub	sp, sp, #0x10
    4800da0c:	f90007e0 	str	x0, [sp, #8]
    rt_object_trytake_hook = hook;
    4800da10:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800da14:	91176000 	add	x0, x0, #0x5d8
    4800da18:	f94007e1 	ldr	x1, [sp, #8]
    4800da1c:	f9000001 	str	x1, [x0]
}
    4800da20:	d503201f 	nop
    4800da24:	910043ff 	add	sp, sp, #0x10
    4800da28:	d65f03c0 	ret

000000004800da2c <rt_object_take_sethook>:
 *            timer - timer is started
 *
 * @param hook the hook function.
 */
void rt_object_take_sethook(void (*hook)(struct rt_object *object))
{
    4800da2c:	d10043ff 	sub	sp, sp, #0x10
    4800da30:	f90007e0 	str	x0, [sp, #8]
    rt_object_take_hook = hook;
    4800da34:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800da38:	91178000 	add	x0, x0, #0x5e0
    4800da3c:	f94007e1 	ldr	x1, [sp, #8]
    4800da40:	f9000001 	str	x1, [x0]
}
    4800da44:	d503201f 	nop
    4800da48:	910043ff 	add	sp, sp, #0x10
    4800da4c:	d65f03c0 	ret

000000004800da50 <rt_object_put_sethook>:
 *        is put to kernel object system.
 *
 * @param hook is the hook function
 */
void rt_object_put_sethook(void (*hook)(struct rt_object *object))
{
    4800da50:	d10043ff 	sub	sp, sp, #0x10
    4800da54:	f90007e0 	str	x0, [sp, #8]
    rt_object_put_hook = hook;
    4800da58:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800da5c:	9117a000 	add	x0, x0, #0x5e8
    4800da60:	f94007e1 	ldr	x1, [sp, #8]
    4800da64:	f9000001 	str	x1, [x0]
}
    4800da68:	d503201f 	nop
    4800da6c:	910043ff 	add	sp, sp, #0x10
    4800da70:	d65f03c0 	ret

000000004800da74 <rt_object_get_information>:
 *
 * @return the object type information or RT_NULL
 */
struct rt_object_information *
rt_object_get_information(enum rt_object_class_type type)
{
    4800da74:	d10083ff 	sub	sp, sp, #0x20
    4800da78:	b9000fe0 	str	w0, [sp, #12]
    int index;

    for (index = 0; index < RT_Object_Info_Unknown; index ++)
    4800da7c:	b9001fff 	str	wzr, [sp, #28]
    4800da80:	14000013 	b	4800dacc <rt_object_get_information+0x58>
        if (_object_container[index].type == type) return &_object_container[index];
    4800da84:	900000a0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800da88:	9115e001 	add	x1, x0, #0x578
    4800da8c:	b9801fe0 	ldrsw	x0, [sp, #28]
    4800da90:	d37be800 	lsl	x0, x0, #5
    4800da94:	8b000020 	add	x0, x1, x0
    4800da98:	b9400000 	ldr	w0, [x0]
    4800da9c:	b9400fe1 	ldr	w1, [sp, #12]
    4800daa0:	6b00003f 	cmp	w1, w0
    4800daa4:	540000e1 	b.ne	4800dac0 <rt_object_get_information+0x4c>  // b.any
    4800daa8:	b9801fe0 	ldrsw	x0, [sp, #28]
    4800daac:	d37be801 	lsl	x1, x0, #5
    4800dab0:	900000a0 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4800dab4:	9115e000 	add	x0, x0, #0x578
    4800dab8:	8b000020 	add	x0, x1, x0
    4800dabc:	14000008 	b	4800dadc <rt_object_get_information+0x68>
    for (index = 0; index < RT_Object_Info_Unknown; index ++)
    4800dac0:	b9401fe0 	ldr	w0, [sp, #28]
    4800dac4:	11000400 	add	w0, w0, #0x1
    4800dac8:	b9001fe0 	str	w0, [sp, #28]
    4800dacc:	b9401fe0 	ldr	w0, [sp, #28]
    4800dad0:	7100201f 	cmp	w0, #0x8
    4800dad4:	54fffd8d 	b.le	4800da84 <rt_object_get_information+0x10>

    return RT_NULL;
    4800dad8:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800dadc:	910083ff 	add	sp, sp, #0x20
    4800dae0:	d65f03c0 	ret

000000004800dae4 <rt_object_get_length>:
 *             RT_Object_Class_Thread/Semaphore/Mutex... etc
 *
 * @return the length of object list
 */
int rt_object_get_length(enum rt_object_class_type type)
{
    4800dae4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800dae8:	910003fd 	mov	x29, sp
    4800daec:	b9001fe0 	str	w0, [sp, #28]
    int count = 0;
    4800daf0:	b9003fff 	str	wzr, [sp, #60]
    rt_ubase_t level;
    struct rt_list_node *node = RT_NULL;
    4800daf4:	f9001bff 	str	xzr, [sp, #48]
    struct rt_object_information *information = RT_NULL;
    4800daf8:	f90017ff 	str	xzr, [sp, #40]

    information = rt_object_get_information((enum rt_object_class_type)type);
    4800dafc:	b9401fe0 	ldr	w0, [sp, #28]
    4800db00:	97ffffdd 	bl	4800da74 <rt_object_get_information>
    4800db04:	f90017e0 	str	x0, [sp, #40]
    if (information == RT_NULL) return 0;
    4800db08:	f94017e0 	ldr	x0, [sp, #40]
    4800db0c:	f100001f 	cmp	x0, #0x0
    4800db10:	54000061 	b.ne	4800db1c <rt_object_get_length+0x38>  // b.any
    4800db14:	52800000 	mov	w0, #0x0                   	// #0
    4800db18:	14000015 	b	4800db6c <rt_object_get_length+0x88>

    level = rt_hw_interrupt_disable();
    4800db1c:	97ffda44 	bl	4800442c <rt_hw_interrupt_disable>
    4800db20:	f90013e0 	str	x0, [sp, #32]
    /* get the count of objects */
    rt_list_for_each(node, &(information->object_list))
    4800db24:	f94017e0 	ldr	x0, [sp, #40]
    4800db28:	f9400400 	ldr	x0, [x0, #8]
    4800db2c:	f9001be0 	str	x0, [sp, #48]
    4800db30:	14000007 	b	4800db4c <rt_object_get_length+0x68>
    {
        count ++;
    4800db34:	b9403fe0 	ldr	w0, [sp, #60]
    4800db38:	11000400 	add	w0, w0, #0x1
    4800db3c:	b9003fe0 	str	w0, [sp, #60]
    rt_list_for_each(node, &(information->object_list))
    4800db40:	f9401be0 	ldr	x0, [sp, #48]
    4800db44:	f9400000 	ldr	x0, [x0]
    4800db48:	f9001be0 	str	x0, [sp, #48]
    4800db4c:	f94017e0 	ldr	x0, [sp, #40]
    4800db50:	91002000 	add	x0, x0, #0x8
    4800db54:	f9401be1 	ldr	x1, [sp, #48]
    4800db58:	eb00003f 	cmp	x1, x0
    4800db5c:	54fffec1 	b.ne	4800db34 <rt_object_get_length+0x50>  // b.any
    }
    rt_hw_interrupt_enable(level);
    4800db60:	f94013e0 	ldr	x0, [sp, #32]
    4800db64:	97ffda36 	bl	4800443c <rt_hw_interrupt_enable>

    return count;
    4800db68:	b9403fe0 	ldr	w0, [sp, #60]
}
    4800db6c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800db70:	d65f03c0 	ret

000000004800db74 <rt_object_get_pointers>:
 * @param maxlen is the maximum number of pointers can be saved.
 *
 * @return the copied number of object pointers.
 */
int rt_object_get_pointers(enum rt_object_class_type type, rt_object_t *pointers, int maxlen)
{
    4800db74:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4800db78:	910003fd 	mov	x29, sp
    4800db7c:	b9001fe0 	str	w0, [sp, #28]
    4800db80:	f9000be1 	str	x1, [sp, #16]
    4800db84:	b9001be2 	str	w2, [sp, #24]
    int index = 0;
    4800db88:	b9004fff 	str	wzr, [sp, #76]
    rt_ubase_t level;

    struct rt_object *object;
    struct rt_list_node *node = RT_NULL;
    4800db8c:	f90023ff 	str	xzr, [sp, #64]
    struct rt_object_information *information = RT_NULL;
    4800db90:	f9001fff 	str	xzr, [sp, #56]

    if (maxlen <= 0) return 0;
    4800db94:	b9401be0 	ldr	w0, [sp, #24]
    4800db98:	7100001f 	cmp	w0, #0x0
    4800db9c:	5400006c 	b.gt	4800dba8 <rt_object_get_pointers+0x34>
    4800dba0:	52800000 	mov	w0, #0x0                   	// #0
    4800dba4:	1400002c 	b	4800dc54 <rt_object_get_pointers+0xe0>

    information = rt_object_get_information((enum rt_object_class_type)type);
    4800dba8:	b9401fe0 	ldr	w0, [sp, #28]
    4800dbac:	97ffffb2 	bl	4800da74 <rt_object_get_information>
    4800dbb0:	f9001fe0 	str	x0, [sp, #56]
    if (information == RT_NULL) return 0;
    4800dbb4:	f9401fe0 	ldr	x0, [sp, #56]
    4800dbb8:	f100001f 	cmp	x0, #0x0
    4800dbbc:	54000061 	b.ne	4800dbc8 <rt_object_get_pointers+0x54>  // b.any
    4800dbc0:	52800000 	mov	w0, #0x0                   	// #0
    4800dbc4:	14000024 	b	4800dc54 <rt_object_get_pointers+0xe0>

    level = rt_hw_interrupt_disable();
    4800dbc8:	97ffda19 	bl	4800442c <rt_hw_interrupt_disable>
    4800dbcc:	f9001be0 	str	x0, [sp, #48]
    /* retrieve pointer of object */
    rt_list_for_each(node, &(information->object_list))
    4800dbd0:	f9401fe0 	ldr	x0, [sp, #56]
    4800dbd4:	f9400400 	ldr	x0, [x0, #8]
    4800dbd8:	f90023e0 	str	x0, [sp, #64]
    4800dbdc:	14000014 	b	4800dc2c <rt_object_get_pointers+0xb8>
    {
        object = rt_list_entry(node, struct rt_object, list);
    4800dbe0:	f94023e0 	ldr	x0, [sp, #64]
    4800dbe4:	d1004000 	sub	x0, x0, #0x10
    4800dbe8:	f90017e0 	str	x0, [sp, #40]

        pointers[index] = object;
    4800dbec:	b9804fe0 	ldrsw	x0, [sp, #76]
    4800dbf0:	d37df000 	lsl	x0, x0, #3
    4800dbf4:	f9400be1 	ldr	x1, [sp, #16]
    4800dbf8:	8b000020 	add	x0, x1, x0
    4800dbfc:	f94017e1 	ldr	x1, [sp, #40]
    4800dc00:	f9000001 	str	x1, [x0]
        index ++;
    4800dc04:	b9404fe0 	ldr	w0, [sp, #76]
    4800dc08:	11000400 	add	w0, w0, #0x1
    4800dc0c:	b9004fe0 	str	w0, [sp, #76]

        if (index >= maxlen) break;
    4800dc10:	b9404fe1 	ldr	w1, [sp, #76]
    4800dc14:	b9401be0 	ldr	w0, [sp, #24]
    4800dc18:	6b00003f 	cmp	w1, w0
    4800dc1c:	5400014a 	b.ge	4800dc44 <rt_object_get_pointers+0xd0>  // b.tcont
    rt_list_for_each(node, &(information->object_list))
    4800dc20:	f94023e0 	ldr	x0, [sp, #64]
    4800dc24:	f9400000 	ldr	x0, [x0]
    4800dc28:	f90023e0 	str	x0, [sp, #64]
    4800dc2c:	f9401fe0 	ldr	x0, [sp, #56]
    4800dc30:	91002000 	add	x0, x0, #0x8
    4800dc34:	f94023e1 	ldr	x1, [sp, #64]
    4800dc38:	eb00003f 	cmp	x1, x0
    4800dc3c:	54fffd21 	b.ne	4800dbe0 <rt_object_get_pointers+0x6c>  // b.any
    4800dc40:	14000002 	b	4800dc48 <rt_object_get_pointers+0xd4>
        if (index >= maxlen) break;
    4800dc44:	d503201f 	nop
    }
    rt_hw_interrupt_enable(level);
    4800dc48:	f9401be0 	ldr	x0, [sp, #48]
    4800dc4c:	97ffd9fc 	bl	4800443c <rt_hw_interrupt_enable>

    return index;
    4800dc50:	b9404fe0 	ldr	w0, [sp, #76]
}
    4800dc54:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800dc58:	d65f03c0 	ret

000000004800dc5c <rt_object_init>:
 * @param name is the object name. In system, the object's name must be unique.
 */
void rt_object_init(struct rt_object         *object,
                    enum rt_object_class_type type,
                    const char               *name)
{
    4800dc5c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4800dc60:	910003fd 	mov	x29, sp
    4800dc64:	f9000bf3 	str	x19, [sp, #16]
    4800dc68:	f9001fe0 	str	x0, [sp, #56]
    4800dc6c:	b90037e1 	str	w1, [sp, #52]
    4800dc70:	f90017e2 	str	x2, [sp, #40]
    register rt_base_t temp;
    struct rt_list_node *node = RT_NULL;
    4800dc74:	f9002fff 	str	xzr, [sp, #88]
#ifdef RT_USING_MODULE
    struct rt_dlmodule *module = dlmodule_self();
#endif /* RT_USING_MODULE */

    /* get object information */
    information = rt_object_get_information(type);
    4800dc78:	b94037e0 	ldr	w0, [sp, #52]
    4800dc7c:	97ffff7e 	bl	4800da74 <rt_object_get_information>
    4800dc80:	f9002be0 	str	x0, [sp, #80]
    RT_ASSERT(information != RT_NULL);
    4800dc84:	f9402be0 	ldr	x0, [sp, #80]
    4800dc88:	f100001f 	cmp	x0, #0x0
    4800dc8c:	540000e1 	b.ne	4800dca8 <rt_object_init+0x4c>  // b.any
    4800dc90:	d28027c2 	mov	x2, #0x13e                 	// #318
    4800dc94:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dc98:	91208001 	add	x1, x0, #0x820
    4800dc9c:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dca0:	911e0000 	add	x0, x0, #0x780
    4800dca4:	940008f1 	bl	48010068 <rt_assert_handler>

    /* check object type to avoid re-initialization */

    /* enter critical */
    rt_enter_critical();
    4800dca8:	97fffedc 	bl	4800d818 <rt_enter_critical>
    /* try to find object */
    for (node  = information->object_list.next;
    4800dcac:	f9402be0 	ldr	x0, [sp, #80]
    4800dcb0:	f9400400 	ldr	x0, [x0, #8]
    4800dcb4:	f9002fe0 	str	x0, [sp, #88]
    4800dcb8:	14000014 	b	4800dd08 <rt_object_init+0xac>
            node != &(information->object_list);
            node  = node->next)
    {
        struct rt_object *obj;

        obj = rt_list_entry(node, struct rt_object, list);
    4800dcbc:	f9402fe0 	ldr	x0, [sp, #88]
    4800dcc0:	d1004000 	sub	x0, x0, #0x10
    4800dcc4:	f90027e0 	str	x0, [sp, #72]
        if (obj) /* skip warning when disable debug */
    4800dcc8:	f94027e0 	ldr	x0, [sp, #72]
    4800dccc:	f100001f 	cmp	x0, #0x0
    4800dcd0:	54000160 	b.eq	4800dcfc <rt_object_init+0xa0>  // b.none
        {
            RT_ASSERT(obj != object);
    4800dcd4:	f94027e1 	ldr	x1, [sp, #72]
    4800dcd8:	f9401fe0 	ldr	x0, [sp, #56]
    4800dcdc:	eb00003f 	cmp	x1, x0
    4800dce0:	540000e1 	b.ne	4800dcfc <rt_object_init+0xa0>  // b.any
    4800dce4:	d28029c2 	mov	x2, #0x14e                 	// #334
    4800dce8:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dcec:	91208001 	add	x1, x0, #0x820
    4800dcf0:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dcf4:	911e6000 	add	x0, x0, #0x798
    4800dcf8:	940008dc 	bl	48010068 <rt_assert_handler>
            node  = node->next)
    4800dcfc:	f9402fe0 	ldr	x0, [sp, #88]
    4800dd00:	f9400000 	ldr	x0, [x0]
    4800dd04:	f9002fe0 	str	x0, [sp, #88]
            node != &(information->object_list);
    4800dd08:	f9402be0 	ldr	x0, [sp, #80]
    4800dd0c:	91002000 	add	x0, x0, #0x8
    for (node  = information->object_list.next;
    4800dd10:	f9402fe1 	ldr	x1, [sp, #88]
    4800dd14:	eb00003f 	cmp	x1, x0
    4800dd18:	54fffd21 	b.ne	4800dcbc <rt_object_init+0x60>  // b.any
        }
    }
    /* leave critical */
    rt_exit_critical();
    4800dd1c:	97fffed4 	bl	4800d86c <rt_exit_critical>

    /* initialize object's parameters */
    /* set object type to static */
    object->type = type | RT_Object_Class_Static;
    4800dd20:	b94037e0 	ldr	w0, [sp, #52]
    4800dd24:	12001c00 	and	w0, w0, #0xff
    4800dd28:	32196000 	orr	w0, w0, #0xffffff80
    4800dd2c:	12001c01 	and	w1, w0, #0xff
    4800dd30:	f9401fe0 	ldr	x0, [sp, #56]
    4800dd34:	39002001 	strb	w1, [x0, #8]
    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
    4800dd38:	f9401fe0 	ldr	x0, [sp, #56]
    4800dd3c:	d2800102 	mov	x2, #0x8                   	// #8
    4800dd40:	f94017e1 	ldr	x1, [sp, #40]
    4800dd44:	940002e5 	bl	4800e8d8 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
    4800dd48:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800dd4c:	9117c000 	add	x0, x0, #0x5f0
    4800dd50:	f9400000 	ldr	x0, [x0]
    4800dd54:	f100001f 	cmp	x0, #0x0
    4800dd58:	540000c0 	b.eq	4800dd70 <rt_object_init+0x114>  // b.none
    4800dd5c:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800dd60:	9117c000 	add	x0, x0, #0x5f0
    4800dd64:	f9400001 	ldr	x1, [x0]
    4800dd68:	f9401fe0 	ldr	x0, [sp, #56]
    4800dd6c:	d63f0020 	blr	x1

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
    4800dd70:	97ffd9af 	bl	4800442c <rt_hw_interrupt_disable>
    4800dd74:	aa0003f3 	mov	x19, x0
    }
    else
#endif /* RT_USING_MODULE */
    {
        /* insert object into information object list */
        rt_list_insert_after(&(information->object_list), &(object->list));
    4800dd78:	f9402be0 	ldr	x0, [sp, #80]
    4800dd7c:	91002002 	add	x2, x0, #0x8
    4800dd80:	f9401fe0 	ldr	x0, [sp, #56]
    4800dd84:	91004000 	add	x0, x0, #0x10
    4800dd88:	aa0003e1 	mov	x1, x0
    4800dd8c:	aa0203e0 	mov	x0, x2
    4800dd90:	97fffee2 	bl	4800d918 <rt_list_insert_after>
    }

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
    4800dd94:	aa1303e0 	mov	x0, x19
    4800dd98:	97ffd9a9 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800dd9c:	d503201f 	nop
    4800dda0:	f9400bf3 	ldr	x19, [sp, #16]
    4800dda4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4800dda8:	d65f03c0 	ret

000000004800ddac <rt_object_detach>:
 *        and the memory of static object is not freed.
 *
 * @param object the specified object to be detached.
 */
void rt_object_detach(rt_object_t object)
{
    4800ddac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800ddb0:	910003fd 	mov	x29, sp
    4800ddb4:	f9000bf3 	str	x19, [sp, #16]
    4800ddb8:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
    4800ddbc:	f94017e0 	ldr	x0, [sp, #40]
    4800ddc0:	f100001f 	cmp	x0, #0x0
    4800ddc4:	540000e1 	b.ne	4800dde0 <rt_object_detach+0x34>  // b.any
    4800ddc8:	d2802f62 	mov	x2, #0x17b                 	// #379
    4800ddcc:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ddd0:	9120c001 	add	x1, x0, #0x830
    4800ddd4:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ddd8:	911ea000 	add	x0, x0, #0x7a8
    4800dddc:	940008a3 	bl	48010068 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
    4800dde0:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800dde4:	9117e000 	add	x0, x0, #0x5f8
    4800dde8:	f9400000 	ldr	x0, [x0]
    4800ddec:	f100001f 	cmp	x0, #0x0
    4800ddf0:	540000c0 	b.eq	4800de08 <rt_object_detach+0x5c>  // b.none
    4800ddf4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800ddf8:	9117e000 	add	x0, x0, #0x5f8
    4800ddfc:	f9400001 	ldr	x1, [x0]
    4800de00:	f94017e0 	ldr	x0, [sp, #40]
    4800de04:	d63f0020 	blr	x1

    /* reset object type */
    object->type = 0;
    4800de08:	f94017e0 	ldr	x0, [sp, #40]
    4800de0c:	3900201f 	strb	wzr, [x0, #8]

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
    4800de10:	97ffd987 	bl	4800442c <rt_hw_interrupt_disable>
    4800de14:	aa0003f3 	mov	x19, x0

    /* remove from old list */
    rt_list_remove(&(object->list));
    4800de18:	f94017e0 	ldr	x0, [sp, #40]
    4800de1c:	91004000 	add	x0, x0, #0x10
    4800de20:	97fffed2 	bl	4800d968 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
    4800de24:	aa1303e0 	mov	x0, x19
    4800de28:	97ffd985 	bl	4800443c <rt_hw_interrupt_enable>
}
    4800de2c:	d503201f 	nop
    4800de30:	f9400bf3 	ldr	x19, [sp, #16]
    4800de34:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800de38:	d65f03c0 	ret

000000004800de3c <rt_object_allocate>:
 * @param name is the object name. In system, the object's name must be unique.
 *
 * @return object
 */
rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
{
    4800de3c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4800de40:	910003fd 	mov	x29, sp
    4800de44:	f9000bf3 	str	x19, [sp, #16]
    4800de48:	b9002fe0 	str	w0, [sp, #44]
    4800de4c:	f90013e1 	str	x1, [sp, #32]
    struct rt_object_information *information;
#ifdef RT_USING_MODULE
    struct rt_dlmodule *module = dlmodule_self();
#endif /* RT_USING_MODULE */

    RT_DEBUG_NOT_IN_INTERRUPT;
    4800de50:	97ffd977 	bl	4800442c <rt_hw_interrupt_disable>
    4800de54:	f90027e0 	str	x0, [sp, #72]
    4800de58:	97ffee2e 	bl	48009710 <rt_interrupt_get_nest>
    4800de5c:	12001c00 	and	w0, w0, #0xff
    4800de60:	7100001f 	cmp	w0, #0x0
    4800de64:	54000180 	b.eq	4800de94 <rt_object_allocate+0x58>  // b.none
    4800de68:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800de6c:	91212001 	add	x1, x0, #0x848
    4800de70:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800de74:	911f0000 	add	x0, x0, #0x7c0
    4800de78:	940007ae 	bl	4800fd30 <rt_kprintf>
    4800de7c:	d28033e2 	mov	x2, #0x19f                 	// #415
    4800de80:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800de84:	91212001 	add	x1, x0, #0x848
    4800de88:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800de8c:	911fa000 	add	x0, x0, #0x7e8
    4800de90:	94000876 	bl	48010068 <rt_assert_handler>
    4800de94:	f94027e0 	ldr	x0, [sp, #72]
    4800de98:	97ffd969 	bl	4800443c <rt_hw_interrupt_enable>

    /* get object information */
    information = rt_object_get_information(type);
    4800de9c:	b9402fe0 	ldr	w0, [sp, #44]
    4800dea0:	97fffef5 	bl	4800da74 <rt_object_get_information>
    4800dea4:	f90023e0 	str	x0, [sp, #64]
    RT_ASSERT(information != RT_NULL);
    4800dea8:	f94023e0 	ldr	x0, [sp, #64]
    4800deac:	f100001f 	cmp	x0, #0x0
    4800deb0:	540000e1 	b.ne	4800decc <rt_object_allocate+0x90>  // b.any
    4800deb4:	d2803462 	mov	x2, #0x1a3                 	// #419
    4800deb8:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800debc:	91212001 	add	x1, x0, #0x848
    4800dec0:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dec4:	911e0000 	add	x0, x0, #0x780
    4800dec8:	94000868 	bl	48010068 <rt_assert_handler>

    object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
    4800decc:	f94023e0 	ldr	x0, [sp, #64]
    4800ded0:	f9400c00 	ldr	x0, [x0, #24]
    4800ded4:	97ffef2d 	bl	48009b88 <rt_malloc>
    4800ded8:	f9001fe0 	str	x0, [sp, #56]
    if (object == RT_NULL)
    4800dedc:	f9401fe0 	ldr	x0, [sp, #56]
    4800dee0:	f100001f 	cmp	x0, #0x0
    4800dee4:	54000061 	b.ne	4800def0 <rt_object_allocate+0xb4>  // b.any
    {
        /* no memory can be allocated */
        return RT_NULL;
    4800dee8:	d2800000 	mov	x0, #0x0                   	// #0
    4800deec:	14000027 	b	4800df88 <rt_object_allocate+0x14c>
    }

    /* clean memory data of object */
    rt_memset(object, 0x0, information->object_size);
    4800def0:	f94023e0 	ldr	x0, [sp, #64]
    4800def4:	f9400c00 	ldr	x0, [x0, #24]
    4800def8:	aa0003e2 	mov	x2, x0
    4800defc:	52800001 	mov	w1, #0x0                   	// #0
    4800df00:	f9401fe0 	ldr	x0, [sp, #56]
    4800df04:	9400010a 	bl	4800e32c <rt_memset>

    /* initialize object's parameters */

    /* set object type */
    object->type = type;
    4800df08:	b9402fe0 	ldr	w0, [sp, #44]
    4800df0c:	12001c01 	and	w1, w0, #0xff
    4800df10:	f9401fe0 	ldr	x0, [sp, #56]
    4800df14:	39002001 	strb	w1, [x0, #8]

    /* set object flag */
    object->flag = 0;
    4800df18:	f9401fe0 	ldr	x0, [sp, #56]
    4800df1c:	3900241f 	strb	wzr, [x0, #9]

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
    4800df20:	f9401fe0 	ldr	x0, [sp, #56]
    4800df24:	d2800102 	mov	x2, #0x8                   	// #8
    4800df28:	f94013e1 	ldr	x1, [sp, #32]
    4800df2c:	9400026b 	bl	4800e8d8 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
    4800df30:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800df34:	9117c000 	add	x0, x0, #0x5f0
    4800df38:	f9400000 	ldr	x0, [x0]
    4800df3c:	f100001f 	cmp	x0, #0x0
    4800df40:	540000c0 	b.eq	4800df58 <rt_object_allocate+0x11c>  // b.none
    4800df44:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800df48:	9117c000 	add	x0, x0, #0x5f0
    4800df4c:	f9400001 	ldr	x1, [x0]
    4800df50:	f9401fe0 	ldr	x0, [sp, #56]
    4800df54:	d63f0020 	blr	x1

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
    4800df58:	97ffd935 	bl	4800442c <rt_hw_interrupt_disable>
    4800df5c:	aa0003f3 	mov	x19, x0
    }
    else
#endif /* RT_USING_MODULE */
    {
        /* insert object into information object list */
        rt_list_insert_after(&(information->object_list), &(object->list));
    4800df60:	f94023e0 	ldr	x0, [sp, #64]
    4800df64:	91002002 	add	x2, x0, #0x8
    4800df68:	f9401fe0 	ldr	x0, [sp, #56]
    4800df6c:	91004000 	add	x0, x0, #0x10
    4800df70:	aa0003e1 	mov	x1, x0
    4800df74:	aa0203e0 	mov	x0, x2
    4800df78:	97fffe68 	bl	4800d918 <rt_list_insert_after>
    }

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
    4800df7c:	aa1303e0 	mov	x0, x19
    4800df80:	97ffd92f 	bl	4800443c <rt_hw_interrupt_enable>

    /* return object */
    return object;
    4800df84:	f9401fe0 	ldr	x0, [sp, #56]
}
    4800df88:	f9400bf3 	ldr	x19, [sp, #16]
    4800df8c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800df90:	d65f03c0 	ret

000000004800df94 <rt_object_delete>:
 * @brief This function will delete an object and release object memory.
 *
 * @param object is the specified object to be deleted.
 */
void rt_object_delete(rt_object_t object)
{
    4800df94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800df98:	910003fd 	mov	x29, sp
    4800df9c:	f9000bf3 	str	x19, [sp, #16]
    4800dfa0:	f90017e0 	str	x0, [sp, #40]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
    4800dfa4:	f94017e0 	ldr	x0, [sp, #40]
    4800dfa8:	f100001f 	cmp	x0, #0x0
    4800dfac:	540000e1 	b.ne	4800dfc8 <rt_object_delete+0x34>  // b.any
    4800dfb0:	d2803ba2 	mov	x2, #0x1dd                 	// #477
    4800dfb4:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dfb8:	91218001 	add	x1, x0, #0x860
    4800dfbc:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dfc0:	911ea000 	add	x0, x0, #0x7a8
    4800dfc4:	94000829 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(!(object->type & RT_Object_Class_Static));
    4800dfc8:	f94017e0 	ldr	x0, [sp, #40]
    4800dfcc:	39402000 	ldrb	w0, [x0, #8]
    4800dfd0:	13001c00 	sxtb	w0, w0
    4800dfd4:	7100001f 	cmp	w0, #0x0
    4800dfd8:	540000ea 	b.ge	4800dff4 <rt_object_delete+0x60>  // b.tcont
    4800dfdc:	d2803bc2 	mov	x2, #0x1de                 	// #478
    4800dfe0:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dfe4:	91218001 	add	x1, x0, #0x860
    4800dfe8:	d0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800dfec:	911fc000 	add	x0, x0, #0x7f0
    4800dff0:	9400081e 	bl	48010068 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
    4800dff4:	90000160 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800dff8:	9117e000 	add	x0, x0, #0x5f8
    4800dffc:	f9400000 	ldr	x0, [x0]
    4800e000:	f100001f 	cmp	x0, #0x0
    4800e004:	540000c0 	b.eq	4800e01c <rt_object_delete+0x88>  // b.none
    4800e008:	f0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800e00c:	9117e000 	add	x0, x0, #0x5f8
    4800e010:	f9400001 	ldr	x1, [x0]
    4800e014:	f94017e0 	ldr	x0, [sp, #40]
    4800e018:	d63f0020 	blr	x1

    /* reset object type */
    object->type = RT_Object_Class_Null;
    4800e01c:	f94017e0 	ldr	x0, [sp, #40]
    4800e020:	3900201f 	strb	wzr, [x0, #8]

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
    4800e024:	97ffd902 	bl	4800442c <rt_hw_interrupt_disable>
    4800e028:	aa0003f3 	mov	x19, x0

    /* remove from old list */
    rt_list_remove(&(object->list));
    4800e02c:	f94017e0 	ldr	x0, [sp, #40]
    4800e030:	91004000 	add	x0, x0, #0x10
    4800e034:	97fffe4d 	bl	4800d968 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
    4800e038:	aa1303e0 	mov	x0, x19
    4800e03c:	97ffd900 	bl	4800443c <rt_hw_interrupt_enable>

    /* free the memory of object */
    RT_KERNEL_FREE(object);
    4800e040:	f94017e0 	ldr	x0, [sp, #40]
    4800e044:	97fff0e0 	bl	4800a3c4 <rt_free>
}
    4800e048:	d503201f 	nop
    4800e04c:	f9400bf3 	ldr	x19, [sp, #16]
    4800e050:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800e054:	d65f03c0 	ret

000000004800e058 <rt_object_is_systemobject>:
 * @param object is the specified object to be judged.
 *
 * @return RT_TRUE if a system object, RT_FALSE for others.
 */
rt_bool_t rt_object_is_systemobject(rt_object_t object)
{
    4800e058:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800e05c:	910003fd 	mov	x29, sp
    4800e060:	f9000fe0 	str	x0, [sp, #24]
    /* object check */
    RT_ASSERT(object != RT_NULL);
    4800e064:	f9400fe0 	ldr	x0, [sp, #24]
    4800e068:	f100001f 	cmp	x0, #0x0
    4800e06c:	540000e1 	b.ne	4800e088 <rt_object_is_systemobject+0x30>  // b.any
    4800e070:	d2804002 	mov	x2, #0x200                 	// #512
    4800e074:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e078:	9121e001 	add	x1, x0, #0x878
    4800e07c:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e080:	911ea000 	add	x0, x0, #0x7a8
    4800e084:	940007f9 	bl	48010068 <rt_assert_handler>

    if (object->type & RT_Object_Class_Static)
    4800e088:	f9400fe0 	ldr	x0, [sp, #24]
    4800e08c:	39402000 	ldrb	w0, [x0, #8]
    4800e090:	13001c00 	sxtb	w0, w0
    4800e094:	7100001f 	cmp	w0, #0x0
    4800e098:	5400006a 	b.ge	4800e0a4 <rt_object_is_systemobject+0x4c>  // b.tcont
        return RT_TRUE;
    4800e09c:	52800020 	mov	w0, #0x1                   	// #1
    4800e0a0:	14000002 	b	4800e0a8 <rt_object_is_systemobject+0x50>

    return RT_FALSE;
    4800e0a4:	52800000 	mov	w0, #0x0                   	// #0
}
    4800e0a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800e0ac:	d65f03c0 	ret

000000004800e0b0 <rt_object_get_type>:
 * @param object is the specified object to be get type.
 *
 * @return the type of object.
 */
rt_uint8_t rt_object_get_type(rt_object_t object)
{
    4800e0b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800e0b4:	910003fd 	mov	x29, sp
    4800e0b8:	f9000fe0 	str	x0, [sp, #24]
    /* object check */
    RT_ASSERT(object != RT_NULL);
    4800e0bc:	f9400fe0 	ldr	x0, [sp, #24]
    4800e0c0:	f100001f 	cmp	x0, #0x0
    4800e0c4:	540000e1 	b.ne	4800e0e0 <rt_object_get_type+0x30>  // b.any
    4800e0c8:	d2804262 	mov	x2, #0x213                 	// #531
    4800e0cc:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e0d0:	91226001 	add	x1, x0, #0x898
    4800e0d4:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e0d8:	911ea000 	add	x0, x0, #0x7a8
    4800e0dc:	940007e3 	bl	48010068 <rt_assert_handler>

    return object->type & ~RT_Object_Class_Static;
    4800e0e0:	f9400fe0 	ldr	x0, [sp, #24]
    4800e0e4:	39402000 	ldrb	w0, [x0, #8]
    4800e0e8:	12001800 	and	w0, w0, #0x7f
    4800e0ec:	12001c00 	and	w0, w0, #0xff
}
    4800e0f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800e0f4:	d65f03c0 	ret

000000004800e0f8 <rt_object_find>:
 * in object container.
 *
 * @note this function shall not be invoked in interrupt status.
 */
rt_object_t rt_object_find(const char *name, rt_uint8_t type)
{
    4800e0f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800e0fc:	910003fd 	mov	x29, sp
    4800e100:	f9000fe0 	str	x0, [sp, #24]
    4800e104:	39005fe1 	strb	w1, [sp, #23]
    struct rt_object *object = RT_NULL;
    4800e108:	f9001bff 	str	xzr, [sp, #48]
    struct rt_list_node *node = RT_NULL;
    4800e10c:	f9001fff 	str	xzr, [sp, #56]
    struct rt_object_information *information = RT_NULL;
    4800e110:	f90017ff 	str	xzr, [sp, #40]

    information = rt_object_get_information((enum rt_object_class_type)type);
    4800e114:	39405fe0 	ldrb	w0, [sp, #23]
    4800e118:	97fffe57 	bl	4800da74 <rt_object_get_information>
    4800e11c:	f90017e0 	str	x0, [sp, #40]

    /* parameter check */
    if ((name == RT_NULL) || (information == RT_NULL)) return RT_NULL;
    4800e120:	f9400fe0 	ldr	x0, [sp, #24]
    4800e124:	f100001f 	cmp	x0, #0x0
    4800e128:	54000080 	b.eq	4800e138 <rt_object_find+0x40>  // b.none
    4800e12c:	f94017e0 	ldr	x0, [sp, #40]
    4800e130:	f100001f 	cmp	x0, #0x0
    4800e134:	54000061 	b.ne	4800e140 <rt_object_find+0x48>  // b.any
    4800e138:	d2800000 	mov	x0, #0x0                   	// #0
    4800e13c:	1400002f 	b	4800e1f8 <rt_object_find+0x100>

    /* which is invoke in interrupt status */
    RT_DEBUG_NOT_IN_INTERRUPT;
    4800e140:	97ffd8bb 	bl	4800442c <rt_hw_interrupt_disable>
    4800e144:	f90013e0 	str	x0, [sp, #32]
    4800e148:	97ffed72 	bl	48009710 <rt_interrupt_get_nest>
    4800e14c:	12001c00 	and	w0, w0, #0xff
    4800e150:	7100001f 	cmp	w0, #0x0
    4800e154:	54000180 	b.eq	4800e184 <rt_object_find+0x8c>  // b.none
    4800e158:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e15c:	9122c001 	add	x1, x0, #0x8b0
    4800e160:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e164:	911f0000 	add	x0, x0, #0x7c0
    4800e168:	940006f2 	bl	4800fd30 <rt_kprintf>
    4800e16c:	d2804622 	mov	x2, #0x231                 	// #561
    4800e170:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e174:	9122c001 	add	x1, x0, #0x8b0
    4800e178:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800e17c:	911fa000 	add	x0, x0, #0x7e8
    4800e180:	940007ba 	bl	48010068 <rt_assert_handler>
    4800e184:	f94013e0 	ldr	x0, [sp, #32]
    4800e188:	97ffd8ad 	bl	4800443c <rt_hw_interrupt_enable>

    /* enter critical */
    rt_enter_critical();
    4800e18c:	97fffda3 	bl	4800d818 <rt_enter_critical>

    /* try to find object */
    rt_list_for_each(node, &(information->object_list))
    4800e190:	f94017e0 	ldr	x0, [sp, #40]
    4800e194:	f9400400 	ldr	x0, [x0, #8]
    4800e198:	f9001fe0 	str	x0, [sp, #56]
    4800e19c:	14000010 	b	4800e1dc <rt_object_find+0xe4>
    {
        object = rt_list_entry(node, struct rt_object, list);
    4800e1a0:	f9401fe0 	ldr	x0, [sp, #56]
    4800e1a4:	d1004000 	sub	x0, x0, #0x10
    4800e1a8:	f9001be0 	str	x0, [sp, #48]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
    4800e1ac:	f9401be0 	ldr	x0, [sp, #48]
    4800e1b0:	d2800102 	mov	x2, #0x8                   	// #8
    4800e1b4:	f9400fe1 	ldr	x1, [sp, #24]
    4800e1b8:	940001f3 	bl	4800e984 <rt_strncmp>
    4800e1bc:	7100001f 	cmp	w0, #0x0
    4800e1c0:	54000081 	b.ne	4800e1d0 <rt_object_find+0xd8>  // b.any
        {
            /* leave critical */
            rt_exit_critical();
    4800e1c4:	97fffdaa 	bl	4800d86c <rt_exit_critical>

            return object;
    4800e1c8:	f9401be0 	ldr	x0, [sp, #48]
    4800e1cc:	1400000b 	b	4800e1f8 <rt_object_find+0x100>
    rt_list_for_each(node, &(information->object_list))
    4800e1d0:	f9401fe0 	ldr	x0, [sp, #56]
    4800e1d4:	f9400000 	ldr	x0, [x0]
    4800e1d8:	f9001fe0 	str	x0, [sp, #56]
    4800e1dc:	f94017e0 	ldr	x0, [sp, #40]
    4800e1e0:	91002000 	add	x0, x0, #0x8
    4800e1e4:	f9401fe1 	ldr	x1, [sp, #56]
    4800e1e8:	eb00003f 	cmp	x1, x0
    4800e1ec:	54fffda1 	b.ne	4800e1a0 <rt_object_find+0xa8>  // b.any
        }
    }

    /* leave critical */
    rt_exit_critical();
    4800e1f0:	97fffd9f 	bl	4800d86c <rt_exit_critical>

    return RT_NULL;
    4800e1f4:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800e1f8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800e1fc:	d65f03c0 	ret

000000004800e200 <rt_get_errno>:
 * This function gets the global errno for the current thread.
 *
 * @return errno
 */
rt_err_t rt_get_errno(void)
{
    4800e200:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800e204:	910003fd 	mov	x29, sp
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
    4800e208:	97ffed42 	bl	48009710 <rt_interrupt_get_nest>
    4800e20c:	12001c00 	and	w0, w0, #0xff
    4800e210:	7100001f 	cmp	w0, #0x0
    4800e214:	540000c0 	b.eq	4800e22c <rt_get_errno+0x2c>  // b.none
    {
        /* it's in interrupt context */
        return __rt_errno;
    4800e218:	f0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800e21c:	91182000 	add	x0, x0, #0x608
    4800e220:	b9400000 	ldr	w0, [x0]
    4800e224:	93407c00 	sxtw	x0, w0
    4800e228:	1400000d 	b	4800e25c <rt_get_errno+0x5c>
    }

    tid = rt_thread_self();
    4800e22c:	97fff65c 	bl	4800bb9c <rt_thread_self>
    4800e230:	f9000fe0 	str	x0, [sp, #24]
    if (tid == RT_NULL)
    4800e234:	f9400fe0 	ldr	x0, [sp, #24]
    4800e238:	f100001f 	cmp	x0, #0x0
    4800e23c:	540000c1 	b.ne	4800e254 <rt_get_errno+0x54>  // b.any
        return __rt_errno;
    4800e240:	f0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800e244:	91182000 	add	x0, x0, #0x608
    4800e248:	b9400000 	ldr	w0, [x0]
    4800e24c:	93407c00 	sxtw	x0, w0
    4800e250:	14000003 	b	4800e25c <rt_get_errno+0x5c>

    return tid->error;
    4800e254:	f9400fe0 	ldr	x0, [sp, #24]
    4800e258:	f9402c00 	ldr	x0, [x0, #88]
}
    4800e25c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800e260:	d65f03c0 	ret

000000004800e264 <rt_set_errno>:
 * This function sets the global errno for the current thread.
 *
 * @param error is the errno shall be set.
 */
void rt_set_errno(rt_err_t error)
{
    4800e264:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800e268:	910003fd 	mov	x29, sp
    4800e26c:	f9000fe0 	str	x0, [sp, #24]
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
    4800e270:	97ffed28 	bl	48009710 <rt_interrupt_get_nest>
    4800e274:	12001c00 	and	w0, w0, #0xff
    4800e278:	7100001f 	cmp	w0, #0x0
    4800e27c:	540000e0 	b.eq	4800e298 <rt_set_errno+0x34>  // b.none
    {
        /* it's in interrupt context */
        __rt_errno = error;
    4800e280:	f9400fe0 	ldr	x0, [sp, #24]
    4800e284:	2a0003e1 	mov	w1, w0
    4800e288:	f0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800e28c:	91182000 	add	x0, x0, #0x608
    4800e290:	b9000001 	str	w1, [x0]

        return;
    4800e294:	1400000f 	b	4800e2d0 <rt_set_errno+0x6c>
    }

    tid = rt_thread_self();
    4800e298:	97fff641 	bl	4800bb9c <rt_thread_self>
    4800e29c:	f90017e0 	str	x0, [sp, #40]
    if (tid == RT_NULL)
    4800e2a0:	f94017e0 	ldr	x0, [sp, #40]
    4800e2a4:	f100001f 	cmp	x0, #0x0
    4800e2a8:	540000e1 	b.ne	4800e2c4 <rt_set_errno+0x60>  // b.any
    {
        __rt_errno = error;
    4800e2ac:	f9400fe0 	ldr	x0, [sp, #24]
    4800e2b0:	2a0003e1 	mov	w1, w0
    4800e2b4:	f0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800e2b8:	91182000 	add	x0, x0, #0x608
    4800e2bc:	b9000001 	str	w1, [x0]

        return;
    4800e2c0:	14000004 	b	4800e2d0 <rt_set_errno+0x6c>
    }

    tid->error = error;
    4800e2c4:	f94017e0 	ldr	x0, [sp, #40]
    4800e2c8:	f9400fe1 	ldr	x1, [sp, #24]
    4800e2cc:	f9002c01 	str	x1, [x0, #88]
}
    4800e2d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800e2d4:	d65f03c0 	ret

000000004800e2d8 <_rt_errno>:
 * This function returns the address of the current thread errno.
 *
 * @return The errno address.
 */
int *_rt_errno(void)
{
    4800e2d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4800e2dc:	910003fd 	mov	x29, sp
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
    4800e2e0:	97ffed0c 	bl	48009710 <rt_interrupt_get_nest>
    4800e2e4:	12001c00 	and	w0, w0, #0xff
    4800e2e8:	7100001f 	cmp	w0, #0x0
    4800e2ec:	54000080 	b.eq	4800e2fc <_rt_errno+0x24>  // b.none
        return (int *)&__rt_errno;
    4800e2f0:	f0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800e2f4:	91182000 	add	x0, x0, #0x608
    4800e2f8:	1400000b 	b	4800e324 <_rt_errno+0x4c>

    tid = rt_thread_self();
    4800e2fc:	97fff628 	bl	4800bb9c <rt_thread_self>
    4800e300:	f9000fe0 	str	x0, [sp, #24]
    if (tid != RT_NULL)
    4800e304:	f9400fe0 	ldr	x0, [sp, #24]
    4800e308:	f100001f 	cmp	x0, #0x0
    4800e30c:	54000080 	b.eq	4800e31c <_rt_errno+0x44>  // b.none
        return (int *) & (tid->error);
    4800e310:	f9400fe0 	ldr	x0, [sp, #24]
    4800e314:	91016000 	add	x0, x0, #0x58
    4800e318:	14000003 	b	4800e324 <_rt_errno+0x4c>

    return (int *)&__rt_errno;
    4800e31c:	f0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800e320:	91182000 	add	x0, x0, #0x608
}
    4800e324:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4800e328:	d65f03c0 	ret

000000004800e32c <rt_memset>:
 * @param  count number of bytes to be set.
 *
 * @return The address of source memory.
 */
RT_WEAK void *rt_memset(void *s, int c, rt_ubase_t count)
{
    4800e32c:	d10143ff 	sub	sp, sp, #0x50
    4800e330:	f9000fe0 	str	x0, [sp, #24]
    4800e334:	b90017e1 	str	w1, [sp, #20]
    4800e338:	f90007e2 	str	x2, [sp, #8]
#define LBLOCKSIZE      (sizeof(long))
#define UNALIGNED(X)    ((long)X & (LBLOCKSIZE - 1))
#define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)

    unsigned int i;
    char *m = (char *)s;
    4800e33c:	f9400fe0 	ldr	x0, [sp, #24]
    4800e340:	f90023e0 	str	x0, [sp, #64]
    unsigned long buffer;
    unsigned long *aligned_addr;
    unsigned int d = c & 0xff;  /* To avoid sign extension, copy C to an
    4800e344:	b94017e0 	ldr	w0, [sp, #20]
    4800e348:	12001c00 	and	w0, w0, #0xff
    4800e34c:	b9002fe0 	str	w0, [sp, #44]
                                unsigned variable.  */

    if (!TOO_SMALL(count) && !UNALIGNED(s))
    4800e350:	f94007e0 	ldr	x0, [sp, #8]
    4800e354:	f1001c1f 	cmp	x0, #0x7
    4800e358:	540008a9 	b.ls	4800e46c <rt_memset+0x140>  // b.plast
    4800e35c:	f9400fe0 	ldr	x0, [sp, #24]
    4800e360:	92400800 	and	x0, x0, #0x7
    4800e364:	f100001f 	cmp	x0, #0x0
    4800e368:	54000821 	b.ne	4800e46c <rt_memset+0x140>  // b.any
    {
        /* If we get this far, we know that count is large and s is word-aligned. */
        aligned_addr = (unsigned long *)s;
    4800e36c:	f9400fe0 	ldr	x0, [sp, #24]
    4800e370:	f9001be0 	str	x0, [sp, #48]
            buffer = (d << 8) | d;
            buffer |= (buffer << 16);
        }
        else
        {
            buffer = 0;
    4800e374:	f9001fff 	str	xzr, [sp, #56]
            for (i = 0; i < LBLOCKSIZE; i ++)
    4800e378:	b9004fff 	str	wzr, [sp, #76]
    4800e37c:	14000009 	b	4800e3a0 <rt_memset+0x74>
                buffer = (buffer << 8) | d;
    4800e380:	f9401fe0 	ldr	x0, [sp, #56]
    4800e384:	d378dc01 	lsl	x1, x0, #8
    4800e388:	b9402fe0 	ldr	w0, [sp, #44]
    4800e38c:	aa000020 	orr	x0, x1, x0
    4800e390:	f9001fe0 	str	x0, [sp, #56]
            for (i = 0; i < LBLOCKSIZE; i ++)
    4800e394:	b9404fe0 	ldr	w0, [sp, #76]
    4800e398:	11000400 	add	w0, w0, #0x1
    4800e39c:	b9004fe0 	str	w0, [sp, #76]
    4800e3a0:	b9404fe0 	ldr	w0, [sp, #76]
    4800e3a4:	71001c1f 	cmp	w0, #0x7
    4800e3a8:	54fffec9 	b.ls	4800e380 <rt_memset+0x54>  // b.plast
        }

        while (count >= LBLOCKSIZE * 4)
    4800e3ac:	14000018 	b	4800e40c <rt_memset+0xe0>
        {
            *aligned_addr++ = buffer;
    4800e3b0:	f9401be0 	ldr	x0, [sp, #48]
    4800e3b4:	91002001 	add	x1, x0, #0x8
    4800e3b8:	f9001be1 	str	x1, [sp, #48]
    4800e3bc:	f9401fe1 	ldr	x1, [sp, #56]
    4800e3c0:	f9000001 	str	x1, [x0]
            *aligned_addr++ = buffer;
    4800e3c4:	f9401be0 	ldr	x0, [sp, #48]
    4800e3c8:	91002001 	add	x1, x0, #0x8
    4800e3cc:	f9001be1 	str	x1, [sp, #48]
    4800e3d0:	f9401fe1 	ldr	x1, [sp, #56]
    4800e3d4:	f9000001 	str	x1, [x0]
            *aligned_addr++ = buffer;
    4800e3d8:	f9401be0 	ldr	x0, [sp, #48]
    4800e3dc:	91002001 	add	x1, x0, #0x8
    4800e3e0:	f9001be1 	str	x1, [sp, #48]
    4800e3e4:	f9401fe1 	ldr	x1, [sp, #56]
    4800e3e8:	f9000001 	str	x1, [x0]
            *aligned_addr++ = buffer;
    4800e3ec:	f9401be0 	ldr	x0, [sp, #48]
    4800e3f0:	91002001 	add	x1, x0, #0x8
    4800e3f4:	f9001be1 	str	x1, [sp, #48]
    4800e3f8:	f9401fe1 	ldr	x1, [sp, #56]
    4800e3fc:	f9000001 	str	x1, [x0]
            count -= 4 * LBLOCKSIZE;
    4800e400:	f94007e0 	ldr	x0, [sp, #8]
    4800e404:	d1008000 	sub	x0, x0, #0x20
    4800e408:	f90007e0 	str	x0, [sp, #8]
        while (count >= LBLOCKSIZE * 4)
    4800e40c:	f94007e0 	ldr	x0, [sp, #8]
    4800e410:	f1007c1f 	cmp	x0, #0x1f
    4800e414:	54fffce8 	b.hi	4800e3b0 <rt_memset+0x84>  // b.pmore
        }

        while (count >= LBLOCKSIZE)
    4800e418:	14000009 	b	4800e43c <rt_memset+0x110>
        {
            *aligned_addr++ = buffer;
    4800e41c:	f9401be0 	ldr	x0, [sp, #48]
    4800e420:	91002001 	add	x1, x0, #0x8
    4800e424:	f9001be1 	str	x1, [sp, #48]
    4800e428:	f9401fe1 	ldr	x1, [sp, #56]
    4800e42c:	f9000001 	str	x1, [x0]
            count -= LBLOCKSIZE;
    4800e430:	f94007e0 	ldr	x0, [sp, #8]
    4800e434:	d1002000 	sub	x0, x0, #0x8
    4800e438:	f90007e0 	str	x0, [sp, #8]
        while (count >= LBLOCKSIZE)
    4800e43c:	f94007e0 	ldr	x0, [sp, #8]
    4800e440:	f1001c1f 	cmp	x0, #0x7
    4800e444:	54fffec8 	b.hi	4800e41c <rt_memset+0xf0>  // b.pmore
        }

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
    4800e448:	f9401be0 	ldr	x0, [sp, #48]
    4800e44c:	f90023e0 	str	x0, [sp, #64]
    }

    while (count--)
    4800e450:	14000007 	b	4800e46c <rt_memset+0x140>
    {
        *m++ = (char)d;
    4800e454:	f94023e0 	ldr	x0, [sp, #64]
    4800e458:	91000401 	add	x1, x0, #0x1
    4800e45c:	f90023e1 	str	x1, [sp, #64]
    4800e460:	b9402fe1 	ldr	w1, [sp, #44]
    4800e464:	12001c21 	and	w1, w1, #0xff
    4800e468:	39000001 	strb	w1, [x0]
    while (count--)
    4800e46c:	f94007e0 	ldr	x0, [sp, #8]
    4800e470:	d1000401 	sub	x1, x0, #0x1
    4800e474:	f90007e1 	str	x1, [sp, #8]
    4800e478:	f100001f 	cmp	x0, #0x0
    4800e47c:	54fffec1 	b.ne	4800e454 <rt_memset+0x128>  // b.any
    }

    return s;
    4800e480:	f9400fe0 	ldr	x0, [sp, #24]

#undef LBLOCKSIZE
#undef UNALIGNED
#undef TOO_SMALL
#endif /* RT_KSERVICE_USING_TINY_SIZE */
}
    4800e484:	910143ff 	add	sp, sp, #0x50
    4800e488:	d65f03c0 	ret

000000004800e48c <rt_memcpy>:
 * @param  count is the copied length.
 *
 * @return The address of destination memory
 */
void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
{
    4800e48c:	d10143ff 	sub	sp, sp, #0x50
    4800e490:	f9000fe0 	str	x0, [sp, #24]
    4800e494:	f9000be1 	str	x1, [sp, #16]
    4800e498:	f90007e2 	str	x2, [sp, #8]
    (((long)X & (sizeof (long) - 1)) | ((long)Y & (sizeof (long) - 1)))
#define BIGBLOCKSIZE    (sizeof (long) << 2)
#define LITTLEBLOCKSIZE (sizeof (long))
#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)

    char *dst_ptr = (char *)dst;
    4800e49c:	f9400fe0 	ldr	x0, [sp, #24]
    4800e4a0:	f90027e0 	str	x0, [sp, #72]
    char *src_ptr = (char *)src;
    4800e4a4:	f9400be0 	ldr	x0, [sp, #16]
    4800e4a8:	f90023e0 	str	x0, [sp, #64]
    long *aligned_dst;
    long *aligned_src;
    int len = count;
    4800e4ac:	f94007e0 	ldr	x0, [sp, #8]
    4800e4b0:	b9002fe0 	str	w0, [sp, #44]

    /* If the size is small, or either SRC or DST is unaligned,
    then punt into the byte copy loop.  This should be rare. */
    if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
    4800e4b4:	b9402fe0 	ldr	w0, [sp, #44]
    4800e4b8:	71007c1f 	cmp	w0, #0x1f
    4800e4bc:	540009c9 	b.ls	4800e5f4 <rt_memcpy+0x168>  // b.plast
    4800e4c0:	f94023e1 	ldr	x1, [sp, #64]
    4800e4c4:	f94027e0 	ldr	x0, [sp, #72]
    4800e4c8:	aa000020 	orr	x0, x1, x0
    4800e4cc:	92400800 	and	x0, x0, #0x7
    4800e4d0:	f100001f 	cmp	x0, #0x0
    4800e4d4:	54000901 	b.ne	4800e5f4 <rt_memcpy+0x168>  // b.any
    {
        aligned_dst = (long *)dst_ptr;
    4800e4d8:	f94027e0 	ldr	x0, [sp, #72]
    4800e4dc:	f9001fe0 	str	x0, [sp, #56]
        aligned_src = (long *)src_ptr;
    4800e4e0:	f94023e0 	ldr	x0, [sp, #64]
    4800e4e4:	f9001be0 	str	x0, [sp, #48]

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
    4800e4e8:	14000024 	b	4800e578 <rt_memcpy+0xec>
        {
            *aligned_dst++ = *aligned_src++;
    4800e4ec:	f9401be1 	ldr	x1, [sp, #48]
    4800e4f0:	91002020 	add	x0, x1, #0x8
    4800e4f4:	f9001be0 	str	x0, [sp, #48]
    4800e4f8:	f9401fe0 	ldr	x0, [sp, #56]
    4800e4fc:	91002002 	add	x2, x0, #0x8
    4800e500:	f9001fe2 	str	x2, [sp, #56]
    4800e504:	f9400021 	ldr	x1, [x1]
    4800e508:	f9000001 	str	x1, [x0]
            *aligned_dst++ = *aligned_src++;
    4800e50c:	f9401be1 	ldr	x1, [sp, #48]
    4800e510:	91002020 	add	x0, x1, #0x8
    4800e514:	f9001be0 	str	x0, [sp, #48]
    4800e518:	f9401fe0 	ldr	x0, [sp, #56]
    4800e51c:	91002002 	add	x2, x0, #0x8
    4800e520:	f9001fe2 	str	x2, [sp, #56]
    4800e524:	f9400021 	ldr	x1, [x1]
    4800e528:	f9000001 	str	x1, [x0]
            *aligned_dst++ = *aligned_src++;
    4800e52c:	f9401be1 	ldr	x1, [sp, #48]
    4800e530:	91002020 	add	x0, x1, #0x8
    4800e534:	f9001be0 	str	x0, [sp, #48]
    4800e538:	f9401fe0 	ldr	x0, [sp, #56]
    4800e53c:	91002002 	add	x2, x0, #0x8
    4800e540:	f9001fe2 	str	x2, [sp, #56]
    4800e544:	f9400021 	ldr	x1, [x1]
    4800e548:	f9000001 	str	x1, [x0]
            *aligned_dst++ = *aligned_src++;
    4800e54c:	f9401be1 	ldr	x1, [sp, #48]
    4800e550:	91002020 	add	x0, x1, #0x8
    4800e554:	f9001be0 	str	x0, [sp, #48]
    4800e558:	f9401fe0 	ldr	x0, [sp, #56]
    4800e55c:	91002002 	add	x2, x0, #0x8
    4800e560:	f9001fe2 	str	x2, [sp, #56]
    4800e564:	f9400021 	ldr	x1, [x1]
    4800e568:	f9000001 	str	x1, [x0]
            len -= BIGBLOCKSIZE;
    4800e56c:	b9402fe0 	ldr	w0, [sp, #44]
    4800e570:	51008000 	sub	w0, w0, #0x20
    4800e574:	b9002fe0 	str	w0, [sp, #44]
        while (len >= BIGBLOCKSIZE)
    4800e578:	b9402fe0 	ldr	w0, [sp, #44]
    4800e57c:	71007c1f 	cmp	w0, #0x1f
    4800e580:	54fffb68 	b.hi	4800e4ec <rt_memcpy+0x60>  // b.pmore
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
    4800e584:	1400000c 	b	4800e5b4 <rt_memcpy+0x128>
        {
            *aligned_dst++ = *aligned_src++;
    4800e588:	f9401be1 	ldr	x1, [sp, #48]
    4800e58c:	91002020 	add	x0, x1, #0x8
    4800e590:	f9001be0 	str	x0, [sp, #48]
    4800e594:	f9401fe0 	ldr	x0, [sp, #56]
    4800e598:	91002002 	add	x2, x0, #0x8
    4800e59c:	f9001fe2 	str	x2, [sp, #56]
    4800e5a0:	f9400021 	ldr	x1, [x1]
    4800e5a4:	f9000001 	str	x1, [x0]
            len -= LITTLEBLOCKSIZE;
    4800e5a8:	b9402fe0 	ldr	w0, [sp, #44]
    4800e5ac:	51002000 	sub	w0, w0, #0x8
    4800e5b0:	b9002fe0 	str	w0, [sp, #44]
        while (len >= LITTLEBLOCKSIZE)
    4800e5b4:	b9402fe0 	ldr	w0, [sp, #44]
    4800e5b8:	71001c1f 	cmp	w0, #0x7
    4800e5bc:	54fffe68 	b.hi	4800e588 <rt_memcpy+0xfc>  // b.pmore
        }

        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
    4800e5c0:	f9401fe0 	ldr	x0, [sp, #56]
    4800e5c4:	f90027e0 	str	x0, [sp, #72]
        src_ptr = (char *)aligned_src;
    4800e5c8:	f9401be0 	ldr	x0, [sp, #48]
    4800e5cc:	f90023e0 	str	x0, [sp, #64]
    }

    while (len--)
    4800e5d0:	14000009 	b	4800e5f4 <rt_memcpy+0x168>
        *dst_ptr++ = *src_ptr++;
    4800e5d4:	f94023e1 	ldr	x1, [sp, #64]
    4800e5d8:	91000420 	add	x0, x1, #0x1
    4800e5dc:	f90023e0 	str	x0, [sp, #64]
    4800e5e0:	f94027e0 	ldr	x0, [sp, #72]
    4800e5e4:	91000402 	add	x2, x0, #0x1
    4800e5e8:	f90027e2 	str	x2, [sp, #72]
    4800e5ec:	39400021 	ldrb	w1, [x1]
    4800e5f0:	39000001 	strb	w1, [x0]
    while (len--)
    4800e5f4:	b9402fe0 	ldr	w0, [sp, #44]
    4800e5f8:	51000401 	sub	w1, w0, #0x1
    4800e5fc:	b9002fe1 	str	w1, [sp, #44]
    4800e600:	7100001f 	cmp	w0, #0x0
    4800e604:	54fffe81 	b.ne	4800e5d4 <rt_memcpy+0x148>  // b.any

    return dst;
    4800e608:	f9400fe0 	ldr	x0, [sp, #24]
#undef UNALIGNED
#undef BIGBLOCKSIZE
#undef LITTLEBLOCKSIZE
#undef TOO_SMALL
#endif /* RT_KSERVICE_USING_TINY_SIZE */
}
    4800e60c:	910143ff 	add	sp, sp, #0x50
    4800e610:	d65f03c0 	ret

000000004800e614 <rt_memmove>:
 * @param  n is the copied length.
 *
 * @return The address of destination memory.
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
    4800e614:	d100c3ff 	sub	sp, sp, #0x30
    4800e618:	f9000fe0 	str	x0, [sp, #24]
    4800e61c:	f9000be1 	str	x1, [sp, #16]
    4800e620:	f90007e2 	str	x2, [sp, #8]
    char *tmp = (char *)dest, *s = (char *)src;
    4800e624:	f9400fe0 	ldr	x0, [sp, #24]
    4800e628:	f90017e0 	str	x0, [sp, #40]
    4800e62c:	f9400be0 	ldr	x0, [sp, #16]
    4800e630:	f90013e0 	str	x0, [sp, #32]

    if (s < tmp && tmp < s + n)
    4800e634:	f94013e1 	ldr	x1, [sp, #32]
    4800e638:	f94017e0 	ldr	x0, [sp, #40]
    4800e63c:	eb00003f 	cmp	x1, x0
    4800e640:	54000502 	b.cs	4800e6e0 <rt_memmove+0xcc>  // b.hs, b.nlast
    4800e644:	f94013e1 	ldr	x1, [sp, #32]
    4800e648:	f94007e0 	ldr	x0, [sp, #8]
    4800e64c:	8b000020 	add	x0, x1, x0
    4800e650:	f94017e1 	ldr	x1, [sp, #40]
    4800e654:	eb00003f 	cmp	x1, x0
    4800e658:	54000442 	b.cs	4800e6e0 <rt_memmove+0xcc>  // b.hs, b.nlast
    {
        tmp += n;
    4800e65c:	f94017e1 	ldr	x1, [sp, #40]
    4800e660:	f94007e0 	ldr	x0, [sp, #8]
    4800e664:	8b000020 	add	x0, x1, x0
    4800e668:	f90017e0 	str	x0, [sp, #40]
        s += n;
    4800e66c:	f94013e1 	ldr	x1, [sp, #32]
    4800e670:	f94007e0 	ldr	x0, [sp, #8]
    4800e674:	8b000020 	add	x0, x1, x0
    4800e678:	f90013e0 	str	x0, [sp, #32]

        while (n--)
    4800e67c:	1400000b 	b	4800e6a8 <rt_memmove+0x94>
            *(--tmp) = *(--s);
    4800e680:	f94013e0 	ldr	x0, [sp, #32]
    4800e684:	d1000400 	sub	x0, x0, #0x1
    4800e688:	f90013e0 	str	x0, [sp, #32]
    4800e68c:	f94017e0 	ldr	x0, [sp, #40]
    4800e690:	d1000400 	sub	x0, x0, #0x1
    4800e694:	f90017e0 	str	x0, [sp, #40]
    4800e698:	f94013e0 	ldr	x0, [sp, #32]
    4800e69c:	39400001 	ldrb	w1, [x0]
    4800e6a0:	f94017e0 	ldr	x0, [sp, #40]
    4800e6a4:	39000001 	strb	w1, [x0]
        while (n--)
    4800e6a8:	f94007e0 	ldr	x0, [sp, #8]
    4800e6ac:	d1000401 	sub	x1, x0, #0x1
    4800e6b0:	f90007e1 	str	x1, [sp, #8]
    4800e6b4:	f100001f 	cmp	x0, #0x0
    4800e6b8:	54fffe41 	b.ne	4800e680 <rt_memmove+0x6c>  // b.any
    if (s < tmp && tmp < s + n)
    4800e6bc:	1400000e 	b	4800e6f4 <rt_memmove+0xe0>
    }
    else
    {
        while (n--)
            *tmp++ = *s++;
    4800e6c0:	f94013e1 	ldr	x1, [sp, #32]
    4800e6c4:	91000420 	add	x0, x1, #0x1
    4800e6c8:	f90013e0 	str	x0, [sp, #32]
    4800e6cc:	f94017e0 	ldr	x0, [sp, #40]
    4800e6d0:	91000402 	add	x2, x0, #0x1
    4800e6d4:	f90017e2 	str	x2, [sp, #40]
    4800e6d8:	39400021 	ldrb	w1, [x1]
    4800e6dc:	39000001 	strb	w1, [x0]
        while (n--)
    4800e6e0:	f94007e0 	ldr	x0, [sp, #8]
    4800e6e4:	d1000401 	sub	x1, x0, #0x1
    4800e6e8:	f90007e1 	str	x1, [sp, #8]
    4800e6ec:	f100001f 	cmp	x0, #0x0
    4800e6f0:	54fffe81 	b.ne	4800e6c0 <rt_memmove+0xac>  // b.any
    }

    return dest;
    4800e6f4:	f9400fe0 	ldr	x0, [sp, #24]
}
    4800e6f8:	9100c3ff 	add	sp, sp, #0x30
    4800e6fc:	d65f03c0 	ret

000000004800e700 <rt_memcmp>:
 *         If the result < 0, cs is smaller than ct.
 *         If the result > 0, cs is greater than ct.
 *         If the result = 0, cs is equal to ct.
 */
RT_WEAK rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
    4800e700:	d10103ff 	sub	sp, sp, #0x40
    4800e704:	f9000fe0 	str	x0, [sp, #24]
    4800e708:	f9000be1 	str	x1, [sp, #16]
    4800e70c:	f90007e2 	str	x2, [sp, #8]
    const unsigned char *su1, *su2;
    int res = 0;
    4800e710:	b9002fff 	str	wzr, [sp, #44]

    for (su1 = (const unsigned char *)cs, su2 = (const unsigned char *)ct; 0 < count; ++su1, ++su2, count--)
    4800e714:	f9400fe0 	ldr	x0, [sp, #24]
    4800e718:	f9001fe0 	str	x0, [sp, #56]
    4800e71c:	f9400be0 	ldr	x0, [sp, #16]
    4800e720:	f9001be0 	str	x0, [sp, #48]
    4800e724:	14000014 	b	4800e774 <rt_memcmp+0x74>
        if ((res = *su1 - *su2) != 0)
    4800e728:	f9401fe0 	ldr	x0, [sp, #56]
    4800e72c:	39400000 	ldrb	w0, [x0]
    4800e730:	2a0003e1 	mov	w1, w0
    4800e734:	f9401be0 	ldr	x0, [sp, #48]
    4800e738:	39400000 	ldrb	w0, [x0]
    4800e73c:	4b000020 	sub	w0, w1, w0
    4800e740:	b9002fe0 	str	w0, [sp, #44]
    4800e744:	b9402fe0 	ldr	w0, [sp, #44]
    4800e748:	7100001f 	cmp	w0, #0x0
    4800e74c:	540001c1 	b.ne	4800e784 <rt_memcmp+0x84>  // b.any
    for (su1 = (const unsigned char *)cs, su2 = (const unsigned char *)ct; 0 < count; ++su1, ++su2, count--)
    4800e750:	f9401fe0 	ldr	x0, [sp, #56]
    4800e754:	91000400 	add	x0, x0, #0x1
    4800e758:	f9001fe0 	str	x0, [sp, #56]
    4800e75c:	f9401be0 	ldr	x0, [sp, #48]
    4800e760:	91000400 	add	x0, x0, #0x1
    4800e764:	f9001be0 	str	x0, [sp, #48]
    4800e768:	f94007e0 	ldr	x0, [sp, #8]
    4800e76c:	d1000400 	sub	x0, x0, #0x1
    4800e770:	f90007e0 	str	x0, [sp, #8]
    4800e774:	f94007e0 	ldr	x0, [sp, #8]
    4800e778:	f100001f 	cmp	x0, #0x0
    4800e77c:	54fffd61 	b.ne	4800e728 <rt_memcmp+0x28>  // b.any
    4800e780:	14000002 	b	4800e788 <rt_memcmp+0x88>
            break;
    4800e784:	d503201f 	nop

    return res;
    4800e788:	b9402fe0 	ldr	w0, [sp, #44]
}
    4800e78c:	910103ff 	add	sp, sp, #0x40
    4800e790:	d65f03c0 	ret

000000004800e794 <rt_strstr>:
 * @param  s2 is the find string.
 *
 * @return The first occurrence of a s2 in s1, or RT_NULL if no found.
 */
char *rt_strstr(const char *s1, const char *s2)
{
    4800e794:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800e798:	910003fd 	mov	x29, sp
    4800e79c:	f9000fe0 	str	x0, [sp, #24]
    4800e7a0:	f9000be1 	str	x1, [sp, #16]
    int l1, l2;

    l2 = rt_strlen(s2);
    4800e7a4:	f9400be0 	ldr	x0, [sp, #16]
    4800e7a8:	940000b3 	bl	4800ea74 <rt_strlen>
    4800e7ac:	b9002be0 	str	w0, [sp, #40]
    if (!l2)
    4800e7b0:	b9402be0 	ldr	w0, [sp, #40]
    4800e7b4:	7100001f 	cmp	w0, #0x0
    4800e7b8:	54000061 	b.ne	4800e7c4 <rt_strstr+0x30>  // b.any
        return (char *)s1;
    4800e7bc:	f9400fe0 	ldr	x0, [sp, #24]
    4800e7c0:	14000019 	b	4800e824 <rt_strstr+0x90>
    l1 = rt_strlen(s1);
    4800e7c4:	f9400fe0 	ldr	x0, [sp, #24]
    4800e7c8:	940000ab 	bl	4800ea74 <rt_strlen>
    4800e7cc:	b9002fe0 	str	w0, [sp, #44]
    while (l1 >= l2)
    4800e7d0:	14000010 	b	4800e810 <rt_strstr+0x7c>
    {
        l1 --;
    4800e7d4:	b9402fe0 	ldr	w0, [sp, #44]
    4800e7d8:	51000400 	sub	w0, w0, #0x1
    4800e7dc:	b9002fe0 	str	w0, [sp, #44]
        if (!rt_memcmp(s1, s2, l2))
    4800e7e0:	b9802be0 	ldrsw	x0, [sp, #40]
    4800e7e4:	aa0003e2 	mov	x2, x0
    4800e7e8:	f9400be1 	ldr	x1, [sp, #16]
    4800e7ec:	f9400fe0 	ldr	x0, [sp, #24]
    4800e7f0:	97ffffc4 	bl	4800e700 <rt_memcmp>
    4800e7f4:	7100001f 	cmp	w0, #0x0
    4800e7f8:	54000061 	b.ne	4800e804 <rt_strstr+0x70>  // b.any
            return (char *)s1;
    4800e7fc:	f9400fe0 	ldr	x0, [sp, #24]
    4800e800:	14000009 	b	4800e824 <rt_strstr+0x90>
        s1 ++;
    4800e804:	f9400fe0 	ldr	x0, [sp, #24]
    4800e808:	91000400 	add	x0, x0, #0x1
    4800e80c:	f9000fe0 	str	x0, [sp, #24]
    while (l1 >= l2)
    4800e810:	b9402fe1 	ldr	w1, [sp, #44]
    4800e814:	b9402be0 	ldr	w0, [sp, #40]
    4800e818:	6b00003f 	cmp	w1, w0
    4800e81c:	54fffdca 	b.ge	4800e7d4 <rt_strstr+0x40>  // b.tcont
    }

    return RT_NULL;
    4800e820:	d2800000 	mov	x0, #0x0                   	// #0
}
    4800e824:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800e828:	d65f03c0 	ret

000000004800e82c <rt_strcasecmp>:
 *         If the result < 0, a is smaller than a.
 *         If the result > 0, a is greater than a.
 *         If the result = 0, a is equal to a.
 */
rt_int32_t rt_strcasecmp(const char *a, const char *b)
{
    4800e82c:	d10083ff 	sub	sp, sp, #0x20
    4800e830:	f90007e0 	str	x0, [sp, #8]
    4800e834:	f90003e1 	str	x1, [sp]
    int ca, cb;

    do
    {
        ca = *a++ & 0xff;
    4800e838:	f94007e0 	ldr	x0, [sp, #8]
    4800e83c:	91000401 	add	x1, x0, #0x1
    4800e840:	f90007e1 	str	x1, [sp, #8]
    4800e844:	39400000 	ldrb	w0, [x0]
    4800e848:	b9001fe0 	str	w0, [sp, #28]
        cb = *b++ & 0xff;
    4800e84c:	f94003e0 	ldr	x0, [sp]
    4800e850:	91000401 	add	x1, x0, #0x1
    4800e854:	f90003e1 	str	x1, [sp]
    4800e858:	39400000 	ldrb	w0, [x0]
    4800e85c:	b9001be0 	str	w0, [sp, #24]
        if (ca >= 'A' && ca <= 'Z')
    4800e860:	b9401fe0 	ldr	w0, [sp, #28]
    4800e864:	7101001f 	cmp	w0, #0x40
    4800e868:	540000ed 	b.le	4800e884 <rt_strcasecmp+0x58>
    4800e86c:	b9401fe0 	ldr	w0, [sp, #28]
    4800e870:	7101681f 	cmp	w0, #0x5a
    4800e874:	5400008c 	b.gt	4800e884 <rt_strcasecmp+0x58>
            ca += 'a' - 'A';
    4800e878:	b9401fe0 	ldr	w0, [sp, #28]
    4800e87c:	11008000 	add	w0, w0, #0x20
    4800e880:	b9001fe0 	str	w0, [sp, #28]
        if (cb >= 'A' && cb <= 'Z')
    4800e884:	b9401be0 	ldr	w0, [sp, #24]
    4800e888:	7101001f 	cmp	w0, #0x40
    4800e88c:	540000ed 	b.le	4800e8a8 <rt_strcasecmp+0x7c>
    4800e890:	b9401be0 	ldr	w0, [sp, #24]
    4800e894:	7101681f 	cmp	w0, #0x5a
    4800e898:	5400008c 	b.gt	4800e8a8 <rt_strcasecmp+0x7c>
            cb += 'a' - 'A';
    4800e89c:	b9401be0 	ldr	w0, [sp, #24]
    4800e8a0:	11008000 	add	w0, w0, #0x20
    4800e8a4:	b9001be0 	str	w0, [sp, #24]
    }
    while (ca == cb && ca != '\0');
    4800e8a8:	b9401fe1 	ldr	w1, [sp, #28]
    4800e8ac:	b9401be0 	ldr	w0, [sp, #24]
    4800e8b0:	6b00003f 	cmp	w1, w0
    4800e8b4:	54000081 	b.ne	4800e8c4 <rt_strcasecmp+0x98>  // b.any
    4800e8b8:	b9401fe0 	ldr	w0, [sp, #28]
    4800e8bc:	7100001f 	cmp	w0, #0x0
    4800e8c0:	54fffbc1 	b.ne	4800e838 <rt_strcasecmp+0xc>  // b.any

    return ca - cb;
    4800e8c4:	b9401fe1 	ldr	w1, [sp, #28]
    4800e8c8:	b9401be0 	ldr	w0, [sp, #24]
    4800e8cc:	4b000020 	sub	w0, w1, w0
}
    4800e8d0:	910083ff 	add	sp, sp, #0x20
    4800e8d4:	d65f03c0 	ret

000000004800e8d8 <rt_strncpy>:
 * @param  n is the maximum copied length.
 *
 * @return The address where the copied content is stored.
 */
char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
    4800e8d8:	d100c3ff 	sub	sp, sp, #0x30
    4800e8dc:	f9000fe0 	str	x0, [sp, #24]
    4800e8e0:	f9000be1 	str	x1, [sp, #16]
    4800e8e4:	f90007e2 	str	x2, [sp, #8]
    if (n != 0)
    4800e8e8:	f94007e0 	ldr	x0, [sp, #8]
    4800e8ec:	f100001f 	cmp	x0, #0x0
    4800e8f0:	54000440 	b.eq	4800e978 <rt_strncpy+0xa0>  // b.none
    {
        char *d = dst;
    4800e8f4:	f9400fe0 	ldr	x0, [sp, #24]
    4800e8f8:	f90017e0 	str	x0, [sp, #40]
        const char *s = src;
    4800e8fc:	f9400be0 	ldr	x0, [sp, #16]
    4800e900:	f90013e0 	str	x0, [sp, #32]

        do
        {
            if ((*d++ = *s++) == 0)
    4800e904:	f94013e1 	ldr	x1, [sp, #32]
    4800e908:	91000420 	add	x0, x1, #0x1
    4800e90c:	f90013e0 	str	x0, [sp, #32]
    4800e910:	f94017e0 	ldr	x0, [sp, #40]
    4800e914:	91000402 	add	x2, x0, #0x1
    4800e918:	f90017e2 	str	x2, [sp, #40]
    4800e91c:	39400021 	ldrb	w1, [x1]
    4800e920:	39000001 	strb	w1, [x0]
    4800e924:	39400000 	ldrb	w0, [x0]
    4800e928:	7100001f 	cmp	w0, #0x0
    4800e92c:	540001a1 	b.ne	4800e960 <rt_strncpy+0x88>  // b.any
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
    4800e930:	14000005 	b	4800e944 <rt_strncpy+0x6c>
                    *d++ = 0;
    4800e934:	f94017e0 	ldr	x0, [sp, #40]
    4800e938:	91000401 	add	x1, x0, #0x1
    4800e93c:	f90017e1 	str	x1, [sp, #40]
    4800e940:	3900001f 	strb	wzr, [x0]
                while (--n != 0)
    4800e944:	f94007e0 	ldr	x0, [sp, #8]
    4800e948:	d1000400 	sub	x0, x0, #0x1
    4800e94c:	f90007e0 	str	x0, [sp, #8]
    4800e950:	f94007e0 	ldr	x0, [sp, #8]
    4800e954:	f100001f 	cmp	x0, #0x0
    4800e958:	54fffee1 	b.ne	4800e934 <rt_strncpy+0x5c>  // b.any
                break;
    4800e95c:	14000007 	b	4800e978 <rt_strncpy+0xa0>
            }
        } while (--n != 0);
    4800e960:	f94007e0 	ldr	x0, [sp, #8]
    4800e964:	d1000400 	sub	x0, x0, #0x1
    4800e968:	f90007e0 	str	x0, [sp, #8]
    4800e96c:	f94007e0 	ldr	x0, [sp, #8]
    4800e970:	f100001f 	cmp	x0, #0x0
    4800e974:	54fffc81 	b.ne	4800e904 <rt_strncpy+0x2c>  // b.any
    }

    return (dst);
    4800e978:	f9400fe0 	ldr	x0, [sp, #24]
}
    4800e97c:	9100c3ff 	add	sp, sp, #0x30
    4800e980:	d65f03c0 	ret

000000004800e984 <rt_strncmp>:
 *         If the result < 0, cs is smaller than ct.
 *         If the result > 0, cs is greater than ct.
 *         If the result = 0, cs is equal to ct.
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
    4800e984:	f81d0ff3 	str	x19, [sp, #-48]!
    4800e988:	f90017e0 	str	x0, [sp, #40]
    4800e98c:	f90013e1 	str	x1, [sp, #32]
    4800e990:	f9000fe2 	str	x2, [sp, #24]
    register signed char __res = 0;
    4800e994:	52800013 	mov	w19, #0x0                   	// #0

    while (count)
    4800e998:	14000015 	b	4800e9ec <rt_strncmp+0x68>
    {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
    4800e99c:	f94017e0 	ldr	x0, [sp, #40]
    4800e9a0:	39400001 	ldrb	w1, [x0]
    4800e9a4:	f94013e0 	ldr	x0, [sp, #32]
    4800e9a8:	91000402 	add	x2, x0, #0x1
    4800e9ac:	f90013e2 	str	x2, [sp, #32]
    4800e9b0:	39400000 	ldrb	w0, [x0]
    4800e9b4:	4b000020 	sub	w0, w1, w0
    4800e9b8:	12001c00 	and	w0, w0, #0xff
    4800e9bc:	13001c13 	sxtb	w19, w0
    4800e9c0:	7100027f 	cmp	w19, #0x0
    4800e9c4:	540001a1 	b.ne	4800e9f8 <rt_strncmp+0x74>  // b.any
    4800e9c8:	f94017e0 	ldr	x0, [sp, #40]
    4800e9cc:	91000401 	add	x1, x0, #0x1
    4800e9d0:	f90017e1 	str	x1, [sp, #40]
    4800e9d4:	39400000 	ldrb	w0, [x0]
    4800e9d8:	7100001f 	cmp	w0, #0x0
    4800e9dc:	540000e0 	b.eq	4800e9f8 <rt_strncmp+0x74>  // b.none
            break;
        count --;
    4800e9e0:	f9400fe0 	ldr	x0, [sp, #24]
    4800e9e4:	d1000400 	sub	x0, x0, #0x1
    4800e9e8:	f9000fe0 	str	x0, [sp, #24]
    while (count)
    4800e9ec:	f9400fe0 	ldr	x0, [sp, #24]
    4800e9f0:	f100001f 	cmp	x0, #0x0
    4800e9f4:	54fffd41 	b.ne	4800e99c <rt_strncmp+0x18>  // b.any
    }

    return __res;
    4800e9f8:	2a1303e0 	mov	w0, w19
}
    4800e9fc:	f84307f3 	ldr	x19, [sp], #48
    4800ea00:	d65f03c0 	ret

000000004800ea04 <rt_strcmp>:
 *         If the result < 0, cs is smaller than ct.
 *         If the result > 0, cs is greater than ct.
 *         If the result = 0, cs is equal to ct.
 */
rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
    4800ea04:	d10043ff 	sub	sp, sp, #0x10
    4800ea08:	f90007e0 	str	x0, [sp, #8]
    4800ea0c:	f90003e1 	str	x1, [sp]
    while (*cs && *cs == *ct)
    4800ea10:	14000007 	b	4800ea2c <rt_strcmp+0x28>
    {
        cs++;
    4800ea14:	f94007e0 	ldr	x0, [sp, #8]
    4800ea18:	91000400 	add	x0, x0, #0x1
    4800ea1c:	f90007e0 	str	x0, [sp, #8]
        ct++;
    4800ea20:	f94003e0 	ldr	x0, [sp]
    4800ea24:	91000400 	add	x0, x0, #0x1
    4800ea28:	f90003e0 	str	x0, [sp]
    while (*cs && *cs == *ct)
    4800ea2c:	f94007e0 	ldr	x0, [sp, #8]
    4800ea30:	39400000 	ldrb	w0, [x0]
    4800ea34:	7100001f 	cmp	w0, #0x0
    4800ea38:	540000e0 	b.eq	4800ea54 <rt_strcmp+0x50>  // b.none
    4800ea3c:	f94007e0 	ldr	x0, [sp, #8]
    4800ea40:	39400001 	ldrb	w1, [x0]
    4800ea44:	f94003e0 	ldr	x0, [sp]
    4800ea48:	39400000 	ldrb	w0, [x0]
    4800ea4c:	6b00003f 	cmp	w1, w0
    4800ea50:	54fffe20 	b.eq	4800ea14 <rt_strcmp+0x10>  // b.none
    }

    return (*cs - *ct);
    4800ea54:	f94007e0 	ldr	x0, [sp, #8]
    4800ea58:	39400000 	ldrb	w0, [x0]
    4800ea5c:	2a0003e1 	mov	w1, w0
    4800ea60:	f94003e0 	ldr	x0, [sp]
    4800ea64:	39400000 	ldrb	w0, [x0]
    4800ea68:	4b000020 	sub	w0, w1, w0
}
    4800ea6c:	910043ff 	add	sp, sp, #0x10
    4800ea70:	d65f03c0 	ret

000000004800ea74 <rt_strlen>:
 * @param  s is the string
 *
 * @return The length of string.
 */
rt_size_t rt_strlen(const char *s)
{
    4800ea74:	d10083ff 	sub	sp, sp, #0x20
    4800ea78:	f90007e0 	str	x0, [sp, #8]
    const char *sc;

    for (sc = s; *sc != '\0'; ++sc) /* nothing */
    4800ea7c:	f94007e0 	ldr	x0, [sp, #8]
    4800ea80:	f9000fe0 	str	x0, [sp, #24]
    4800ea84:	14000004 	b	4800ea94 <rt_strlen+0x20>
    4800ea88:	f9400fe0 	ldr	x0, [sp, #24]
    4800ea8c:	91000400 	add	x0, x0, #0x1
    4800ea90:	f9000fe0 	str	x0, [sp, #24]
    4800ea94:	f9400fe0 	ldr	x0, [sp, #24]
    4800ea98:	39400000 	ldrb	w0, [x0]
    4800ea9c:	7100001f 	cmp	w0, #0x0
    4800eaa0:	54ffff41 	b.ne	4800ea88 <rt_strlen+0x14>  // b.any
        ;

    return sc - s;
    4800eaa4:	f9400fe1 	ldr	x1, [sp, #24]
    4800eaa8:	f94007e0 	ldr	x0, [sp, #8]
    4800eaac:	cb000020 	sub	x0, x1, x0
}
    4800eab0:	910083ff 	add	sp, sp, #0x20
    4800eab4:	d65f03c0 	ret

000000004800eab8 <rt_strnlen>:
 * @param  maxlen is the max size.
 *
 * @return The length of string.
 */
rt_size_t rt_strnlen(const char *s, rt_ubase_t maxlen)
{
    4800eab8:	d10083ff 	sub	sp, sp, #0x20
    4800eabc:	f90007e0 	str	x0, [sp, #8]
    4800eac0:	f90003e1 	str	x1, [sp]
    const char *sc;

    for (sc = s; *sc != '\0' && (rt_ubase_t)(sc - s) < maxlen; ++sc) /* nothing */
    4800eac4:	f94007e0 	ldr	x0, [sp, #8]
    4800eac8:	f9000fe0 	str	x0, [sp, #24]
    4800eacc:	14000004 	b	4800eadc <rt_strnlen+0x24>
    4800ead0:	f9400fe0 	ldr	x0, [sp, #24]
    4800ead4:	91000400 	add	x0, x0, #0x1
    4800ead8:	f9000fe0 	str	x0, [sp, #24]
    4800eadc:	f9400fe0 	ldr	x0, [sp, #24]
    4800eae0:	39400000 	ldrb	w0, [x0]
    4800eae4:	7100001f 	cmp	w0, #0x0
    4800eae8:	54000100 	b.eq	4800eb08 <rt_strnlen+0x50>  // b.none
    4800eaec:	f9400fe1 	ldr	x1, [sp, #24]
    4800eaf0:	f94007e0 	ldr	x0, [sp, #8]
    4800eaf4:	cb000020 	sub	x0, x1, x0
    4800eaf8:	aa0003e1 	mov	x1, x0
    4800eafc:	f94003e0 	ldr	x0, [sp]
    4800eb00:	eb01001f 	cmp	x0, x1
    4800eb04:	54fffe68 	b.hi	4800ead0 <rt_strnlen+0x18>  // b.pmore
        ;

    return sc - s;
    4800eb08:	f9400fe1 	ldr	x1, [sp, #24]
    4800eb0c:	f94007e0 	ldr	x0, [sp, #8]
    4800eb10:	cb000020 	sub	x0, x1, x0
}
    4800eb14:	910083ff 	add	sp, sp, #0x20
    4800eb18:	d65f03c0 	ret

000000004800eb1c <rt_strdup>:
 * @param  s is the string to be duplicated.
 *
 * @return The string address of the copy.
 */
char *rt_strdup(const char *s)
{
    4800eb1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800eb20:	910003fd 	mov	x29, sp
    4800eb24:	f9000fe0 	str	x0, [sp, #24]
    rt_size_t len = rt_strlen(s) + 1;
    4800eb28:	f9400fe0 	ldr	x0, [sp, #24]
    4800eb2c:	97ffffd2 	bl	4800ea74 <rt_strlen>
    4800eb30:	91000400 	add	x0, x0, #0x1
    4800eb34:	f90017e0 	str	x0, [sp, #40]
    char *tmp = (char *)rt_malloc(len);
    4800eb38:	f94017e0 	ldr	x0, [sp, #40]
    4800eb3c:	97ffec13 	bl	48009b88 <rt_malloc>
    4800eb40:	f90013e0 	str	x0, [sp, #32]

    if (!tmp)
    4800eb44:	f94013e0 	ldr	x0, [sp, #32]
    4800eb48:	f100001f 	cmp	x0, #0x0
    4800eb4c:	54000061 	b.ne	4800eb58 <rt_strdup+0x3c>  // b.any
        return RT_NULL;
    4800eb50:	d2800000 	mov	x0, #0x0                   	// #0
    4800eb54:	14000006 	b	4800eb6c <rt_strdup+0x50>

    rt_memcpy(tmp, s, len);
    4800eb58:	f94017e2 	ldr	x2, [sp, #40]
    4800eb5c:	f9400fe1 	ldr	x1, [sp, #24]
    4800eb60:	f94013e0 	ldr	x0, [sp, #32]
    4800eb64:	97fffe4a 	bl	4800e48c <rt_memcpy>

    return tmp;
    4800eb68:	f94013e0 	ldr	x0, [sp, #32]
}
    4800eb6c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800eb70:	d65f03c0 	ret

000000004800eb74 <rt_show_version>:

/**
 * This function will show the version of rt-thread rtos
 */
void rt_show_version(void)
{
    4800eb74:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4800eb78:	910003fd 	mov	x29, sp
    rt_kprintf("\n \\ | /\n");
    4800eb7c:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800eb80:	91230000 	add	x0, x0, #0x8c0
    4800eb84:	9400046b 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("- RT -     Thread Operating System\n");
    4800eb88:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800eb8c:	91234000 	add	x0, x0, #0x8d0
    4800eb90:	94000468 	bl	4800fd30 <rt_kprintf>
    rt_kprintf(" / | \\     %d.%d.%d build %s %s\n",
    4800eb94:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800eb98:	9123e005 	add	x5, x0, #0x8f8
    4800eb9c:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800eba0:	91242004 	add	x4, x0, #0x908
    4800eba4:	d2800083 	mov	x3, #0x4                   	// #4
    4800eba8:	d2800002 	mov	x2, #0x0                   	// #0
    4800ebac:	d2800081 	mov	x1, #0x4                   	// #4
    4800ebb0:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ebb4:	91246000 	add	x0, x0, #0x918
    4800ebb8:	9400045e 	bl	4800fd30 <rt_kprintf>
               RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__, __TIME__);
    rt_kprintf(" 2006 - 2021 Copyright by rt-thread team\n");
    4800ebbc:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ebc0:	91250000 	add	x0, x0, #0x940
    4800ebc4:	9400045b 	bl	4800fd30 <rt_kprintf>
}
    4800ebc8:	d503201f 	nop
    4800ebcc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4800ebd0:	d65f03c0 	ret

000000004800ebd4 <divide>:

    return res;
}
#else
rt_inline int divide(long *n, int base)
{
    4800ebd4:	d10083ff 	sub	sp, sp, #0x20
    4800ebd8:	f90007e0 	str	x0, [sp, #8]
    4800ebdc:	b90007e1 	str	w1, [sp, #4]
    int res;

    /* optimized for processor which does not support divide instructions. */
    if (base == 10)
    4800ebe0:	b94007e0 	ldr	w0, [sp, #4]
    4800ebe4:	7100281f 	cmp	w0, #0xa
    4800ebe8:	54000341 	b.ne	4800ec50 <divide+0x7c>  // b.any
    {
        res = (int)(((unsigned long)*n) % 10U);
    4800ebec:	f94007e0 	ldr	x0, [sp, #8]
    4800ebf0:	f9400000 	ldr	x0, [x0]
    4800ebf4:	aa0003e2 	mov	x2, x0
    4800ebf8:	b202e7e0 	mov	x0, #0xcccccccccccccccc    	// #-3689348814741910324
    4800ebfc:	f29999a0 	movk	x0, #0xcccd
    4800ec00:	9bc07c40 	umulh	x0, x2, x0
    4800ec04:	d343fc01 	lsr	x1, x0, #3
    4800ec08:	aa0103e0 	mov	x0, x1
    4800ec0c:	d37ef400 	lsl	x0, x0, #2
    4800ec10:	8b010000 	add	x0, x0, x1
    4800ec14:	8b000000 	add	x0, x0, x0
    4800ec18:	cb000041 	sub	x1, x2, x0
    4800ec1c:	2a0103e0 	mov	w0, w1
    4800ec20:	b9001fe0 	str	w0, [sp, #28]
        *n = (long)(((unsigned long)*n) / 10U);
    4800ec24:	f94007e0 	ldr	x0, [sp, #8]
    4800ec28:	f9400000 	ldr	x0, [x0]
    4800ec2c:	aa0003e1 	mov	x1, x0
    4800ec30:	b202e7e0 	mov	x0, #0xcccccccccccccccc    	// #-3689348814741910324
    4800ec34:	f29999a0 	movk	x0, #0xcccd
    4800ec38:	9bc07c20 	umulh	x0, x1, x0
    4800ec3c:	d343fc00 	lsr	x0, x0, #3
    4800ec40:	aa0003e1 	mov	x1, x0
    4800ec44:	f94007e0 	ldr	x0, [sp, #8]
    4800ec48:	f9000001 	str	x1, [x0]
    4800ec4c:	1400000b 	b	4800ec78 <divide+0xa4>
    }
    else
    {
        res = (int)(((unsigned long)*n) % 16U);
    4800ec50:	f94007e0 	ldr	x0, [sp, #8]
    4800ec54:	f9400000 	ldr	x0, [x0]
    4800ec58:	12000c00 	and	w0, w0, #0xf
    4800ec5c:	b9001fe0 	str	w0, [sp, #28]
        *n = (long)(((unsigned long)*n) / 16U);
    4800ec60:	f94007e0 	ldr	x0, [sp, #8]
    4800ec64:	f9400000 	ldr	x0, [x0]
    4800ec68:	d344fc00 	lsr	x0, x0, #4
    4800ec6c:	aa0003e1 	mov	x1, x0
    4800ec70:	f94007e0 	ldr	x0, [sp, #8]
    4800ec74:	f9000001 	str	x1, [x0]
    }

    return res;
    4800ec78:	b9401fe0 	ldr	w0, [sp, #28]
}
    4800ec7c:	910083ff 	add	sp, sp, #0x20
    4800ec80:	d65f03c0 	ret

000000004800ec84 <skip_atoi>:
#endif /* RT_PRINTF_LONGLONG */

rt_inline int skip_atoi(const char **s)
{
    4800ec84:	f81e0ff3 	str	x19, [sp, #-32]!
    4800ec88:	f9000fe0 	str	x0, [sp, #24]
    register int i = 0;
    4800ec8c:	52800013 	mov	w19, #0x0                   	// #0
    while (_ISDIGIT(**s))
    4800ec90:	1400000b 	b	4800ecbc <skip_atoi+0x38>
        i = i * 10 + *((*s)++) - '0';
    4800ec94:	52800140 	mov	w0, #0xa                   	// #10
    4800ec98:	1b007e61 	mul	w1, w19, w0
    4800ec9c:	f9400fe0 	ldr	x0, [sp, #24]
    4800eca0:	f9400000 	ldr	x0, [x0]
    4800eca4:	91000403 	add	x3, x0, #0x1
    4800eca8:	f9400fe2 	ldr	x2, [sp, #24]
    4800ecac:	f9000043 	str	x3, [x2]
    4800ecb0:	39400000 	ldrb	w0, [x0]
    4800ecb4:	0b000020 	add	w0, w1, w0
    4800ecb8:	5100c013 	sub	w19, w0, #0x30
    while (_ISDIGIT(**s))
    4800ecbc:	f9400fe0 	ldr	x0, [sp, #24]
    4800ecc0:	f9400000 	ldr	x0, [x0]
    4800ecc4:	39400000 	ldrb	w0, [x0]
    4800ecc8:	5100c000 	sub	w0, w0, #0x30
    4800eccc:	7100241f 	cmp	w0, #0x9
    4800ecd0:	54fffe29 	b.ls	4800ec94 <skip_atoi+0x10>  // b.plast

    return i;
    4800ecd4:	2a1303e0 	mov	w0, w19
}
    4800ecd8:	f84207f3 	ldr	x19, [sp], #32
    4800ecdc:	d65f03c0 	ret

000000004800ece0 <print_number>:
#endif /* RT_PRINTF_LONGLONG */
                          int   base,
                          int   s,
                          int   type)
#endif /* RT_PRINTF_PRECISION */
{
    4800ece0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    4800ece4:	910003fd 	mov	x29, sp
    4800ece8:	a90153f3 	stp	x19, x20, [sp, #16]
    4800ecec:	f90027e0 	str	x0, [sp, #72]
    4800ecf0:	f90023e1 	str	x1, [sp, #64]
    4800ecf4:	f9001fe2 	str	x2, [sp, #56]
    4800ecf8:	b90037e3 	str	w3, [sp, #52]
    4800ecfc:	b90033e4 	str	w4, [sp, #48]
    4800ed00:	b9002fe5 	str	w5, [sp, #44]
    4800ed04:	b9002be6 	str	w6, [sp, #40]
#ifdef RT_PRINTF_LONGLONG
    char tmp[32];
#else
    char tmp[16];
#endif /* RT_PRINTF_LONGLONG */
    int precision_bak = precision;
    4800ed08:	b9402fe0 	ldr	w0, [sp, #44]
    4800ed0c:	b9007be0 	str	w0, [sp, #120]
    static const char small_digits[] = "0123456789abcdef";
    static const char large_digits[] = "0123456789ABCDEF";
    register int i;
    register int size;

    size = s;
    4800ed10:	b94033f3 	ldr	w19, [sp, #48]

    digits = (type & LARGE) ? large_digits : small_digits;
    4800ed14:	b9402be0 	ldr	w0, [sp, #40]
    4800ed18:	121a0000 	and	w0, w0, #0x40
    4800ed1c:	7100001f 	cmp	w0, #0x0
    4800ed20:	54000080 	b.eq	4800ed30 <print_number+0x50>  // b.none
    4800ed24:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ed28:	912ac000 	add	x0, x0, #0xab0
    4800ed2c:	14000003 	b	4800ed38 <print_number+0x58>
    4800ed30:	b0000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ed34:	912b2000 	add	x0, x0, #0xac8
    4800ed38:	f9003be0 	str	x0, [sp, #112]
    if (type & LEFT)
    4800ed3c:	b9402be0 	ldr	w0, [sp, #40]
    4800ed40:	121c0000 	and	w0, w0, #0x10
    4800ed44:	7100001f 	cmp	w0, #0x0
    4800ed48:	54000080 	b.eq	4800ed58 <print_number+0x78>  // b.none
        type &= ~ZEROPAD;
    4800ed4c:	b9402be0 	ldr	w0, [sp, #40]
    4800ed50:	121f7800 	and	w0, w0, #0xfffffffe
    4800ed54:	b9002be0 	str	w0, [sp, #40]

    c = (type & ZEROPAD) ? '0' : ' ';
    4800ed58:	b9402be0 	ldr	w0, [sp, #40]
    4800ed5c:	12000000 	and	w0, w0, #0x1
    4800ed60:	7100001f 	cmp	w0, #0x0
    4800ed64:	54000060 	b.eq	4800ed70 <print_number+0x90>  // b.none
    4800ed68:	52800600 	mov	w0, #0x30                  	// #48
    4800ed6c:	14000002 	b	4800ed74 <print_number+0x94>
    4800ed70:	52800400 	mov	w0, #0x20                  	// #32
    4800ed74:	3901bfe0 	strb	w0, [sp, #111]

    /* get sign */
    sign = 0;
    4800ed78:	3901ffff 	strb	wzr, [sp, #127]
    if (type & SIGN)
    4800ed7c:	b9402be0 	ldr	w0, [sp, #40]
    4800ed80:	121f0000 	and	w0, w0, #0x2
    4800ed84:	7100001f 	cmp	w0, #0x0
    4800ed88:	540002e0 	b.eq	4800ede4 <print_number+0x104>  // b.none
    {
        if (num < 0)
    4800ed8c:	f9401fe0 	ldr	x0, [sp, #56]
    4800ed90:	f100001f 	cmp	x0, #0x0
    4800ed94:	540000ea 	b.ge	4800edb0 <print_number+0xd0>  // b.tcont
        {
            sign = '-';
    4800ed98:	528005a0 	mov	w0, #0x2d                  	// #45
    4800ed9c:	3901ffe0 	strb	w0, [sp, #127]
            num = -num;
    4800eda0:	f9401fe0 	ldr	x0, [sp, #56]
    4800eda4:	cb0003e0 	neg	x0, x0
    4800eda8:	f9001fe0 	str	x0, [sp, #56]
    4800edac:	1400000e 	b	4800ede4 <print_number+0x104>
        }
        else if (type & PLUS)
    4800edb0:	b9402be0 	ldr	w0, [sp, #40]
    4800edb4:	121e0000 	and	w0, w0, #0x4
    4800edb8:	7100001f 	cmp	w0, #0x0
    4800edbc:	54000080 	b.eq	4800edcc <print_number+0xec>  // b.none
            sign = '+';
    4800edc0:	52800560 	mov	w0, #0x2b                  	// #43
    4800edc4:	3901ffe0 	strb	w0, [sp, #127]
    4800edc8:	14000007 	b	4800ede4 <print_number+0x104>
        else if (type & SPACE)
    4800edcc:	b9402be0 	ldr	w0, [sp, #40]
    4800edd0:	121d0000 	and	w0, w0, #0x8
    4800edd4:	7100001f 	cmp	w0, #0x0
    4800edd8:	54000060 	b.eq	4800ede4 <print_number+0x104>  // b.none
            sign = ' ';
    4800eddc:	52800400 	mov	w0, #0x20                  	// #32
    4800ede0:	3901ffe0 	strb	w0, [sp, #127]
        else if (base == 8)
            size--;
    }
#endif /* RT_PRINTF_SPECIAL */

    i = 0;
    4800ede4:	52800014 	mov	w20, #0x0                   	// #0
    if (num == 0)
    4800ede8:	f9401fe0 	ldr	x0, [sp, #56]
    4800edec:	f100001f 	cmp	x0, #0x0
    4800edf0:	54000281 	b.ne	4800ee40 <print_number+0x160>  // b.any
        tmp[i++] = '0';
    4800edf4:	2a1403e0 	mov	w0, w20
    4800edf8:	11000414 	add	w20, w0, #0x1
    4800edfc:	93407c00 	sxtw	x0, w0
    4800ee00:	910163e1 	add	x1, sp, #0x58
    4800ee04:	52800602 	mov	w2, #0x30                  	// #48
    4800ee08:	38206822 	strb	w2, [x1, x0]
    4800ee0c:	14000010 	b	4800ee4c <print_number+0x16c>
    else
    {
        while (num != 0)
            tmp[i++] = digits[divide(&num, base)];
    4800ee10:	9100e3e0 	add	x0, sp, #0x38
    4800ee14:	b94037e1 	ldr	w1, [sp, #52]
    4800ee18:	97ffff6f 	bl	4800ebd4 <divide>
    4800ee1c:	93407c00 	sxtw	x0, w0
    4800ee20:	f9403be1 	ldr	x1, [sp, #112]
    4800ee24:	8b000020 	add	x0, x1, x0
    4800ee28:	2a1403e1 	mov	w1, w20
    4800ee2c:	11000434 	add	w20, w1, #0x1
    4800ee30:	39400002 	ldrb	w2, [x0]
    4800ee34:	93407c20 	sxtw	x0, w1
    4800ee38:	910163e1 	add	x1, sp, #0x58
    4800ee3c:	38206822 	strb	w2, [x1, x0]
        while (num != 0)
    4800ee40:	f9401fe0 	ldr	x0, [sp, #56]
    4800ee44:	f100001f 	cmp	x0, #0x0
    4800ee48:	54fffe41 	b.ne	4800ee10 <print_number+0x130>  // b.any
    }

#ifdef RT_PRINTF_PRECISION
    if (i > precision)
    4800ee4c:	b9402fe0 	ldr	w0, [sp, #44]
    4800ee50:	6b00029f 	cmp	w20, w0
    4800ee54:	5400004d 	b.le	4800ee5c <print_number+0x17c>
        precision = i;
    4800ee58:	b9002ff4 	str	w20, [sp, #44]
    size -= precision;
    4800ee5c:	b9402fe0 	ldr	w0, [sp, #44]
    4800ee60:	4b000273 	sub	w19, w19, w0
#else
    size -= i;
#endif /* RT_PRINTF_PRECISION */

    if (!(type & (ZEROPAD | LEFT)))
    4800ee64:	b9402be1 	ldr	w1, [sp, #40]
    4800ee68:	52800220 	mov	w0, #0x11                  	// #17
    4800ee6c:	0a000020 	and	w0, w1, w0
    4800ee70:	7100001f 	cmp	w0, #0x0
    4800ee74:	540002c1 	b.ne	4800eecc <print_number+0x1ec>  // b.any
    {
        if ((sign) && (size > 0))
    4800ee78:	3941ffe0 	ldrb	w0, [sp, #127]
    4800ee7c:	7100001f 	cmp	w0, #0x0
    4800ee80:	540001e0 	b.eq	4800eebc <print_number+0x1dc>  // b.none
    4800ee84:	7100027f 	cmp	w19, #0x0
    4800ee88:	540001ad 	b.le	4800eebc <print_number+0x1dc>
            size--;
    4800ee8c:	51000673 	sub	w19, w19, #0x1

        while (size-- > 0)
    4800ee90:	1400000b 	b	4800eebc <print_number+0x1dc>
        {
            if (buf < end)
    4800ee94:	f94027e1 	ldr	x1, [sp, #72]
    4800ee98:	f94023e0 	ldr	x0, [sp, #64]
    4800ee9c:	eb00003f 	cmp	x1, x0
    4800eea0:	54000082 	b.cs	4800eeb0 <print_number+0x1d0>  // b.hs, b.nlast
                *buf = ' ';
    4800eea4:	f94027e0 	ldr	x0, [sp, #72]
    4800eea8:	52800401 	mov	w1, #0x20                  	// #32
    4800eeac:	39000001 	strb	w1, [x0]
            ++ buf;
    4800eeb0:	f94027e0 	ldr	x0, [sp, #72]
    4800eeb4:	91000400 	add	x0, x0, #0x1
    4800eeb8:	f90027e0 	str	x0, [sp, #72]
        while (size-- > 0)
    4800eebc:	2a1303e0 	mov	w0, w19
    4800eec0:	51000413 	sub	w19, w0, #0x1
    4800eec4:	7100001f 	cmp	w0, #0x0
    4800eec8:	54fffe6c 	b.gt	4800ee94 <print_number+0x1b4>
        }
    }

    if (sign)
    4800eecc:	3941ffe0 	ldrb	w0, [sp, #127]
    4800eed0:	7100001f 	cmp	w0, #0x0
    4800eed4:	54000180 	b.eq	4800ef04 <print_number+0x224>  // b.none
    {
        if (buf < end)
    4800eed8:	f94027e1 	ldr	x1, [sp, #72]
    4800eedc:	f94023e0 	ldr	x0, [sp, #64]
    4800eee0:	eb00003f 	cmp	x1, x0
    4800eee4:	54000082 	b.cs	4800eef4 <print_number+0x214>  // b.hs, b.nlast
        {
            *buf = sign;
    4800eee8:	f94027e0 	ldr	x0, [sp, #72]
    4800eeec:	3941ffe1 	ldrb	w1, [sp, #127]
    4800eef0:	39000001 	strb	w1, [x0]
        }
        -- size;
    4800eef4:	51000673 	sub	w19, w19, #0x1
        ++ buf;
    4800eef8:	f94027e0 	ldr	x0, [sp, #72]
    4800eefc:	91000400 	add	x0, x0, #0x1
    4800ef00:	f90027e0 	str	x0, [sp, #72]
        }
    }
#endif /* RT_PRINTF_SPECIAL */

    /* no align to the left */
    if (!(type & LEFT))
    4800ef04:	b9402be0 	ldr	w0, [sp, #40]
    4800ef08:	121c0000 	and	w0, w0, #0x10
    4800ef0c:	7100001f 	cmp	w0, #0x0
    4800ef10:	54000361 	b.ne	4800ef7c <print_number+0x29c>  // b.any
    {
        while (size-- > 0)
    4800ef14:	1400000b 	b	4800ef40 <print_number+0x260>
        {
            if (buf < end)
    4800ef18:	f94027e1 	ldr	x1, [sp, #72]
    4800ef1c:	f94023e0 	ldr	x0, [sp, #64]
    4800ef20:	eb00003f 	cmp	x1, x0
    4800ef24:	54000082 	b.cs	4800ef34 <print_number+0x254>  // b.hs, b.nlast
                *buf = c;
    4800ef28:	f94027e0 	ldr	x0, [sp, #72]
    4800ef2c:	3941bfe1 	ldrb	w1, [sp, #111]
    4800ef30:	39000001 	strb	w1, [x0]
            ++ buf;
    4800ef34:	f94027e0 	ldr	x0, [sp, #72]
    4800ef38:	91000400 	add	x0, x0, #0x1
    4800ef3c:	f90027e0 	str	x0, [sp, #72]
        while (size-- > 0)
    4800ef40:	2a1303e0 	mov	w0, w19
    4800ef44:	51000413 	sub	w19, w0, #0x1
    4800ef48:	7100001f 	cmp	w0, #0x0
    4800ef4c:	54fffe6c 	b.gt	4800ef18 <print_number+0x238>
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
    4800ef50:	1400000b 	b	4800ef7c <print_number+0x29c>
    {
        if (buf < end)
    4800ef54:	f94027e1 	ldr	x1, [sp, #72]
    4800ef58:	f94023e0 	ldr	x0, [sp, #64]
    4800ef5c:	eb00003f 	cmp	x1, x0
    4800ef60:	54000082 	b.cs	4800ef70 <print_number+0x290>  // b.hs, b.nlast
            *buf = '0';
    4800ef64:	f94027e0 	ldr	x0, [sp, #72]
    4800ef68:	52800601 	mov	w1, #0x30                  	// #48
    4800ef6c:	39000001 	strb	w1, [x0]
        ++ buf;
    4800ef70:	f94027e0 	ldr	x0, [sp, #72]
    4800ef74:	91000400 	add	x0, x0, #0x1
    4800ef78:	f90027e0 	str	x0, [sp, #72]
    while (i < precision--)
    4800ef7c:	b9402fe0 	ldr	w0, [sp, #44]
    4800ef80:	51000401 	sub	w1, w0, #0x1
    4800ef84:	b9002fe1 	str	w1, [sp, #44]
    4800ef88:	6b00029f 	cmp	w20, w0
    4800ef8c:	54fffe4b 	b.lt	4800ef54 <print_number+0x274>  // b.tstop
    }
#endif /* RT_PRINTF_PRECISION */

    /* put number in the temporary buffer */
    while (i-- > 0 && (precision_bak != 0))
    4800ef90:	1400000d 	b	4800efc4 <print_number+0x2e4>
    {
        if (buf < end)
    4800ef94:	f94027e1 	ldr	x1, [sp, #72]
    4800ef98:	f94023e0 	ldr	x0, [sp, #64]
    4800ef9c:	eb00003f 	cmp	x1, x0
    4800efa0:	540000c2 	b.cs	4800efb8 <print_number+0x2d8>  // b.hs, b.nlast
            *buf = tmp[i];
    4800efa4:	93407e80 	sxtw	x0, w20
    4800efa8:	910163e1 	add	x1, sp, #0x58
    4800efac:	38606821 	ldrb	w1, [x1, x0]
    4800efb0:	f94027e0 	ldr	x0, [sp, #72]
    4800efb4:	39000001 	strb	w1, [x0]
        ++ buf;
    4800efb8:	f94027e0 	ldr	x0, [sp, #72]
    4800efbc:	91000400 	add	x0, x0, #0x1
    4800efc0:	f90027e0 	str	x0, [sp, #72]
    while (i-- > 0 && (precision_bak != 0))
    4800efc4:	2a1403e0 	mov	w0, w20
    4800efc8:	51000414 	sub	w20, w0, #0x1
    4800efcc:	7100001f 	cmp	w0, #0x0
    4800efd0:	540001ed 	b.le	4800f00c <print_number+0x32c>
    4800efd4:	b9407be0 	ldr	w0, [sp, #120]
    4800efd8:	7100001f 	cmp	w0, #0x0
    4800efdc:	54fffdc1 	b.ne	4800ef94 <print_number+0x2b4>  // b.any
    }

    while (size-- > 0)
    4800efe0:	1400000b 	b	4800f00c <print_number+0x32c>
    {
        if (buf < end)
    4800efe4:	f94027e1 	ldr	x1, [sp, #72]
    4800efe8:	f94023e0 	ldr	x0, [sp, #64]
    4800efec:	eb00003f 	cmp	x1, x0
    4800eff0:	54000082 	b.cs	4800f000 <print_number+0x320>  // b.hs, b.nlast
            *buf = ' ';
    4800eff4:	f94027e0 	ldr	x0, [sp, #72]
    4800eff8:	52800401 	mov	w1, #0x20                  	// #32
    4800effc:	39000001 	strb	w1, [x0]
        ++ buf;
    4800f000:	f94027e0 	ldr	x0, [sp, #72]
    4800f004:	91000400 	add	x0, x0, #0x1
    4800f008:	f90027e0 	str	x0, [sp, #72]
    while (size-- > 0)
    4800f00c:	2a1303e0 	mov	w0, w19
    4800f010:	51000413 	sub	w19, w0, #0x1
    4800f014:	7100001f 	cmp	w0, #0x0
    4800f018:	54fffe6c 	b.gt	4800efe4 <print_number+0x304>
    }

    return buf;
    4800f01c:	f94027e0 	ldr	x0, [sp, #72]
}
    4800f020:	a94153f3 	ldp	x19, x20, [sp, #16]
    4800f024:	a8c87bfd 	ldp	x29, x30, [sp], #128
    4800f028:	d65f03c0 	ret

000000004800f02c <rt_vsnprintf>:
 */
rt_int32_t rt_vsnprintf(char       *buf,
                        rt_size_t   size,
                        const char *fmt,
                        va_list     args)
{
    4800f02c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    4800f030:	910003fd 	mov	x29, sp
    4800f034:	f9000bf3 	str	x19, [sp, #16]
    4800f038:	f9001fe0 	str	x0, [sp, #56]
    4800f03c:	f9001be1 	str	x1, [sp, #48]
    4800f040:	f90017e2 	str	x2, [sp, #40]
    4800f044:	aa0303f3 	mov	x19, x3

#ifdef RT_PRINTF_PRECISION
    int precision;      /* min. # of digits for integers and max for a string */
#endif /* RT_PRINTF_PRECISION */

    str = buf;
    4800f048:	f9401fe0 	ldr	x0, [sp, #56]
    4800f04c:	f90037e0 	str	x0, [sp, #104]
    end = buf + size;
    4800f050:	f9401fe1 	ldr	x1, [sp, #56]
    4800f054:	f9401be0 	ldr	x0, [sp, #48]
    4800f058:	8b000020 	add	x0, x1, x0
    4800f05c:	f90033e0 	str	x0, [sp, #96]

    /* Make sure end is always >= buf */
    if (end < buf)
    4800f060:	f94033e1 	ldr	x1, [sp, #96]
    4800f064:	f9401fe0 	ldr	x0, [sp, #56]
    4800f068:	eb00003f 	cmp	x1, x0
    4800f06c:	54004c22 	b.cs	4800f9f0 <rt_vsnprintf+0x9c4>  // b.hs, b.nlast
    {
        end  = ((char *) - 1);
    4800f070:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4800f074:	f90033e0 	str	x0, [sp, #96]
        size = end - buf;
    4800f078:	f94033e1 	ldr	x1, [sp, #96]
    4800f07c:	f9401fe0 	ldr	x0, [sp, #56]
    4800f080:	cb000020 	sub	x0, x1, x0
    4800f084:	f9001be0 	str	x0, [sp, #48]
    }

    for (; *fmt ; ++fmt)
    4800f088:	1400025a 	b	4800f9f0 <rt_vsnprintf+0x9c4>
    {
        if (*fmt != '%')
    4800f08c:	f94017e0 	ldr	x0, [sp, #40]
    4800f090:	39400000 	ldrb	w0, [x0]
    4800f094:	7100941f 	cmp	w0, #0x25
    4800f098:	540001a0 	b.eq	4800f0cc <rt_vsnprintf+0xa0>  // b.none
        {
            if (str < end)
    4800f09c:	f94037e1 	ldr	x1, [sp, #104]
    4800f0a0:	f94033e0 	ldr	x0, [sp, #96]
    4800f0a4:	eb00003f 	cmp	x1, x0
    4800f0a8:	540000a2 	b.cs	4800f0bc <rt_vsnprintf+0x90>  // b.hs, b.nlast
                *str = *fmt;
    4800f0ac:	f94017e0 	ldr	x0, [sp, #40]
    4800f0b0:	39400001 	ldrb	w1, [x0]
    4800f0b4:	f94037e0 	ldr	x0, [sp, #104]
    4800f0b8:	39000001 	strb	w1, [x0]
            ++ str;
    4800f0bc:	f94037e0 	ldr	x0, [sp, #104]
    4800f0c0:	91000400 	add	x0, x0, #0x1
    4800f0c4:	f90037e0 	str	x0, [sp, #104]
            continue;
    4800f0c8:	14000247 	b	4800f9e4 <rt_vsnprintf+0x9b8>
        }

        /* process flags */
        flags = 0;
    4800f0cc:	39015bff 	strb	wzr, [sp, #86]

        while (1)
        {
            /* skips the first '%' also */
            ++ fmt;
    4800f0d0:	f94017e0 	ldr	x0, [sp, #40]
    4800f0d4:	91000400 	add	x0, x0, #0x1
    4800f0d8:	f90017e0 	str	x0, [sp, #40]
            if (*fmt == '-') flags |= LEFT;
    4800f0dc:	f94017e0 	ldr	x0, [sp, #40]
    4800f0e0:	39400000 	ldrb	w0, [x0]
    4800f0e4:	7100b41f 	cmp	w0, #0x2d
    4800f0e8:	540000a1 	b.ne	4800f0fc <rt_vsnprintf+0xd0>  // b.any
    4800f0ec:	39415be0 	ldrb	w0, [sp, #86]
    4800f0f0:	321c0000 	orr	w0, w0, #0x10
    4800f0f4:	39015be0 	strb	w0, [sp, #86]
    4800f0f8:	17fffff6 	b	4800f0d0 <rt_vsnprintf+0xa4>
            else if (*fmt == '+') flags |= PLUS;
    4800f0fc:	f94017e0 	ldr	x0, [sp, #40]
    4800f100:	39400000 	ldrb	w0, [x0]
    4800f104:	7100ac1f 	cmp	w0, #0x2b
    4800f108:	540000a1 	b.ne	4800f11c <rt_vsnprintf+0xf0>  // b.any
    4800f10c:	39415be0 	ldrb	w0, [sp, #86]
    4800f110:	321e0000 	orr	w0, w0, #0x4
    4800f114:	39015be0 	strb	w0, [sp, #86]
    4800f118:	17ffffee 	b	4800f0d0 <rt_vsnprintf+0xa4>
            else if (*fmt == ' ') flags |= SPACE;
    4800f11c:	f94017e0 	ldr	x0, [sp, #40]
    4800f120:	39400000 	ldrb	w0, [x0]
    4800f124:	7100801f 	cmp	w0, #0x20
    4800f128:	540000a1 	b.ne	4800f13c <rt_vsnprintf+0x110>  // b.any
    4800f12c:	39415be0 	ldrb	w0, [sp, #86]
    4800f130:	321d0000 	orr	w0, w0, #0x8
    4800f134:	39015be0 	strb	w0, [sp, #86]
    4800f138:	17ffffe6 	b	4800f0d0 <rt_vsnprintf+0xa4>
            else if (*fmt == '#') flags |= SPECIAL;
    4800f13c:	f94017e0 	ldr	x0, [sp, #40]
    4800f140:	39400000 	ldrb	w0, [x0]
    4800f144:	71008c1f 	cmp	w0, #0x23
    4800f148:	540000a1 	b.ne	4800f15c <rt_vsnprintf+0x130>  // b.any
    4800f14c:	39415be0 	ldrb	w0, [sp, #86]
    4800f150:	321b0000 	orr	w0, w0, #0x20
    4800f154:	39015be0 	strb	w0, [sp, #86]
    4800f158:	17ffffde 	b	4800f0d0 <rt_vsnprintf+0xa4>
            else if (*fmt == '0') flags |= ZEROPAD;
    4800f15c:	f94017e0 	ldr	x0, [sp, #40]
    4800f160:	39400000 	ldrb	w0, [x0]
    4800f164:	7100c01f 	cmp	w0, #0x30
    4800f168:	540000a1 	b.ne	4800f17c <rt_vsnprintf+0x150>  // b.any
    4800f16c:	39415be0 	ldrb	w0, [sp, #86]
    4800f170:	32000000 	orr	w0, w0, #0x1
    4800f174:	39015be0 	strb	w0, [sp, #86]
            ++ fmt;
    4800f178:	17ffffd6 	b	4800f0d0 <rt_vsnprintf+0xa4>
            else break;
    4800f17c:	d503201f 	nop
        }

        /* get field width */
        field_width = -1;
    4800f180:	12800000 	mov	w0, #0xffffffff            	// #-1
    4800f184:	b90053e0 	str	w0, [sp, #80]
        if (_ISDIGIT(*fmt)) field_width = skip_atoi(&fmt);
    4800f188:	f94017e0 	ldr	x0, [sp, #40]
    4800f18c:	39400000 	ldrb	w0, [x0]
    4800f190:	5100c000 	sub	w0, w0, #0x30
    4800f194:	7100241f 	cmp	w0, #0x9
    4800f198:	540000a8 	b.hi	4800f1ac <rt_vsnprintf+0x180>  // b.pmore
    4800f19c:	9100a3e0 	add	x0, sp, #0x28
    4800f1a0:	97fffeb9 	bl	4800ec84 <skip_atoi>
    4800f1a4:	b90053e0 	str	w0, [sp, #80]
    4800f1a8:	14000027 	b	4800f244 <rt_vsnprintf+0x218>
        else if (*fmt == '*')
    4800f1ac:	f94017e0 	ldr	x0, [sp, #40]
    4800f1b0:	39400000 	ldrb	w0, [x0]
    4800f1b4:	7100a81f 	cmp	w0, #0x2a
    4800f1b8:	54000461 	b.ne	4800f244 <rt_vsnprintf+0x218>  // b.any
        {
            ++ fmt;
    4800f1bc:	f94017e0 	ldr	x0, [sp, #40]
    4800f1c0:	91000400 	add	x0, x0, #0x1
    4800f1c4:	f90017e0 	str	x0, [sp, #40]
            /* it's the next argument */
            field_width = va_arg(args, int);
    4800f1c8:	b9401a61 	ldr	w1, [x19, #24]
    4800f1cc:	f9400260 	ldr	x0, [x19]
    4800f1d0:	7100003f 	cmp	w1, #0x0
    4800f1d4:	540000ab 	b.lt	4800f1e8 <rt_vsnprintf+0x1bc>  // b.tstop
    4800f1d8:	91002c01 	add	x1, x0, #0xb
    4800f1dc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f1e0:	f9000261 	str	x1, [x19]
    4800f1e4:	1400000d 	b	4800f218 <rt_vsnprintf+0x1ec>
    4800f1e8:	11002022 	add	w2, w1, #0x8
    4800f1ec:	b9001a62 	str	w2, [x19, #24]
    4800f1f0:	b9401a62 	ldr	w2, [x19, #24]
    4800f1f4:	7100005f 	cmp	w2, #0x0
    4800f1f8:	540000ad 	b.le	4800f20c <rt_vsnprintf+0x1e0>
    4800f1fc:	91002c01 	add	x1, x0, #0xb
    4800f200:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f204:	f9000261 	str	x1, [x19]
    4800f208:	14000004 	b	4800f218 <rt_vsnprintf+0x1ec>
    4800f20c:	f9400662 	ldr	x2, [x19, #8]
    4800f210:	93407c20 	sxtw	x0, w1
    4800f214:	8b000040 	add	x0, x2, x0
    4800f218:	b9400000 	ldr	w0, [x0]
    4800f21c:	b90053e0 	str	w0, [sp, #80]
            if (field_width < 0)
    4800f220:	b94053e0 	ldr	w0, [sp, #80]
    4800f224:	7100001f 	cmp	w0, #0x0
    4800f228:	540000ea 	b.ge	4800f244 <rt_vsnprintf+0x218>  // b.tcont
            {
                field_width = -field_width;
    4800f22c:	b94053e0 	ldr	w0, [sp, #80]
    4800f230:	4b0003e0 	neg	w0, w0
    4800f234:	b90053e0 	str	w0, [sp, #80]
                flags |= LEFT;
    4800f238:	39415be0 	ldrb	w0, [sp, #86]
    4800f23c:	321c0000 	orr	w0, w0, #0x10
    4800f240:	39015be0 	strb	w0, [sp, #86]
            }
        }

#ifdef RT_PRINTF_PRECISION
        /* get the precision */
        precision = -1;
    4800f244:	12800000 	mov	w0, #0xffffffff            	// #-1
    4800f248:	b9004fe0 	str	w0, [sp, #76]
        if (*fmt == '.')
    4800f24c:	f94017e0 	ldr	x0, [sp, #40]
    4800f250:	39400000 	ldrb	w0, [x0]
    4800f254:	7100b81f 	cmp	w0, #0x2e
    4800f258:	540005c1 	b.ne	4800f310 <rt_vsnprintf+0x2e4>  // b.any
        {
            ++ fmt;
    4800f25c:	f94017e0 	ldr	x0, [sp, #40]
    4800f260:	91000400 	add	x0, x0, #0x1
    4800f264:	f90017e0 	str	x0, [sp, #40]
            if (_ISDIGIT(*fmt)) precision = skip_atoi(&fmt);
    4800f268:	f94017e0 	ldr	x0, [sp, #40]
    4800f26c:	39400000 	ldrb	w0, [x0]
    4800f270:	5100c000 	sub	w0, w0, #0x30
    4800f274:	7100241f 	cmp	w0, #0x9
    4800f278:	540000a8 	b.hi	4800f28c <rt_vsnprintf+0x260>  // b.pmore
    4800f27c:	9100a3e0 	add	x0, sp, #0x28
    4800f280:	97fffe81 	bl	4800ec84 <skip_atoi>
    4800f284:	b9004fe0 	str	w0, [sp, #76]
    4800f288:	1400001e 	b	4800f300 <rt_vsnprintf+0x2d4>
            else if (*fmt == '*')
    4800f28c:	f94017e0 	ldr	x0, [sp, #40]
    4800f290:	39400000 	ldrb	w0, [x0]
    4800f294:	7100a81f 	cmp	w0, #0x2a
    4800f298:	54000341 	b.ne	4800f300 <rt_vsnprintf+0x2d4>  // b.any
            {
                ++ fmt;
    4800f29c:	f94017e0 	ldr	x0, [sp, #40]
    4800f2a0:	91000400 	add	x0, x0, #0x1
    4800f2a4:	f90017e0 	str	x0, [sp, #40]
                /* it's the next argument */
                precision = va_arg(args, int);
    4800f2a8:	b9401a61 	ldr	w1, [x19, #24]
    4800f2ac:	f9400260 	ldr	x0, [x19]
    4800f2b0:	7100003f 	cmp	w1, #0x0
    4800f2b4:	540000ab 	b.lt	4800f2c8 <rt_vsnprintf+0x29c>  // b.tstop
    4800f2b8:	91002c01 	add	x1, x0, #0xb
    4800f2bc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f2c0:	f9000261 	str	x1, [x19]
    4800f2c4:	1400000d 	b	4800f2f8 <rt_vsnprintf+0x2cc>
    4800f2c8:	11002022 	add	w2, w1, #0x8
    4800f2cc:	b9001a62 	str	w2, [x19, #24]
    4800f2d0:	b9401a62 	ldr	w2, [x19, #24]
    4800f2d4:	7100005f 	cmp	w2, #0x0
    4800f2d8:	540000ad 	b.le	4800f2ec <rt_vsnprintf+0x2c0>
    4800f2dc:	91002c01 	add	x1, x0, #0xb
    4800f2e0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f2e4:	f9000261 	str	x1, [x19]
    4800f2e8:	14000004 	b	4800f2f8 <rt_vsnprintf+0x2cc>
    4800f2ec:	f9400662 	ldr	x2, [x19, #8]
    4800f2f0:	93407c20 	sxtw	x0, w1
    4800f2f4:	8b000040 	add	x0, x2, x0
    4800f2f8:	b9400000 	ldr	w0, [x0]
    4800f2fc:	b9004fe0 	str	w0, [sp, #76]
            }
            if (precision < 0) precision = 0;
    4800f300:	b9404fe0 	ldr	w0, [sp, #76]
    4800f304:	7100001f 	cmp	w0, #0x0
    4800f308:	5400004a 	b.ge	4800f310 <rt_vsnprintf+0x2e4>  // b.tcont
    4800f30c:	b9004fff 	str	wzr, [sp, #76]
        }
#endif /* RT_PRINTF_PRECISION */
        /* get the conversion qualifier */
        qualifier = 0;
    4800f310:	390157ff 	strb	wzr, [sp, #85]
#ifdef RT_PRINTF_LONGLONG
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
#else
        if (*fmt == 'h' || *fmt == 'l')
    4800f314:	f94017e0 	ldr	x0, [sp, #40]
    4800f318:	39400000 	ldrb	w0, [x0]
    4800f31c:	7101a01f 	cmp	w0, #0x68
    4800f320:	540000a0 	b.eq	4800f334 <rt_vsnprintf+0x308>  // b.none
    4800f324:	f94017e0 	ldr	x0, [sp, #40]
    4800f328:	39400000 	ldrb	w0, [x0]
    4800f32c:	7101b01f 	cmp	w0, #0x6c
    4800f330:	540000e1 	b.ne	4800f34c <rt_vsnprintf+0x320>  // b.any
#endif /* RT_PRINTF_LONGLONG */
        {
            qualifier = *fmt;
    4800f334:	f94017e0 	ldr	x0, [sp, #40]
    4800f338:	39400000 	ldrb	w0, [x0]
    4800f33c:	390157e0 	strb	w0, [sp, #85]
            ++ fmt;
    4800f340:	f94017e0 	ldr	x0, [sp, #40]
    4800f344:	91000400 	add	x0, x0, #0x1
    4800f348:	f90017e0 	str	x0, [sp, #40]
            }
#endif /* RT_PRINTF_LONGLONG */
        }

        /* the default base */
        base = 10;
    4800f34c:	52800140 	mov	w0, #0xa                   	// #10
    4800f350:	39015fe0 	strb	w0, [sp, #87]

        switch (*fmt)
    4800f354:	f94017e0 	ldr	x0, [sp, #40]
    4800f358:	39400000 	ldrb	w0, [x0]
    4800f35c:	7101e01f 	cmp	w0, #0x78
    4800f360:	540022e0 	b.eq	4800f7bc <rt_vsnprintf+0x790>  // b.none
    4800f364:	7101e01f 	cmp	w0, #0x78
    4800f368:	5400238c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f36c:	7101d41f 	cmp	w0, #0x75
    4800f370:	54002700 	b.eq	4800f850 <rt_vsnprintf+0x824>  // b.none
    4800f374:	7101d41f 	cmp	w0, #0x75
    4800f378:	5400230c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f37c:	7101cc1f 	cmp	w0, #0x73
    4800f380:	54000c60 	b.eq	4800f50c <rt_vsnprintf+0x4e0>  // b.none
    4800f384:	7101cc1f 	cmp	w0, #0x73
    4800f388:	5400228c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f38c:	7101c01f 	cmp	w0, #0x70
    4800f390:	54001a20 	b.eq	4800f6d4 <rt_vsnprintf+0x6a8>  // b.none
    4800f394:	7101c01f 	cmp	w0, #0x70
    4800f398:	5400220c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f39c:	7101bc1f 	cmp	w0, #0x6f
    4800f3a0:	54002020 	b.eq	4800f7a4 <rt_vsnprintf+0x778>  // b.none
    4800f3a4:	7101bc1f 	cmp	w0, #0x6f
    4800f3a8:	5400218c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f3ac:	7101a41f 	cmp	w0, #0x69
    4800f3b0:	540020c0 	b.eq	4800f7c8 <rt_vsnprintf+0x79c>  // b.none
    4800f3b4:	7101a41f 	cmp	w0, #0x69
    4800f3b8:	5400210c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f3bc:	7101901f 	cmp	w0, #0x64
    4800f3c0:	54002040 	b.eq	4800f7c8 <rt_vsnprintf+0x79c>  // b.none
    4800f3c4:	7101901f 	cmp	w0, #0x64
    4800f3c8:	5400208c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f3cc:	71018c1f 	cmp	w0, #0x63
    4800f3d0:	54000100 	b.eq	4800f3f0 <rt_vsnprintf+0x3c4>  // b.none
    4800f3d4:	71018c1f 	cmp	w0, #0x63
    4800f3d8:	5400200c 	b.gt	4800f7d8 <rt_vsnprintf+0x7ac>
    4800f3dc:	7100941f 	cmp	w0, #0x25
    4800f3e0:	54001cc0 	b.eq	4800f778 <rt_vsnprintf+0x74c>  // b.none
    4800f3e4:	7101601f 	cmp	w0, #0x58
    4800f3e8:	54001e40 	b.eq	4800f7b0 <rt_vsnprintf+0x784>  // b.none
    4800f3ec:	140000fb 	b	4800f7d8 <rt_vsnprintf+0x7ac>
        {
        case 'c':
            if (!(flags & LEFT))
    4800f3f0:	39415be0 	ldrb	w0, [sp, #86]
    4800f3f4:	121c0000 	and	w0, w0, #0x10
    4800f3f8:	7100001f 	cmp	w0, #0x0
    4800f3fc:	54000241 	b.ne	4800f444 <rt_vsnprintf+0x418>  // b.any
            {
                while (--field_width > 0)
    4800f400:	1400000b 	b	4800f42c <rt_vsnprintf+0x400>
                {
                    if (str < end) *str = ' ';
    4800f404:	f94037e1 	ldr	x1, [sp, #104]
    4800f408:	f94033e0 	ldr	x0, [sp, #96]
    4800f40c:	eb00003f 	cmp	x1, x0
    4800f410:	54000082 	b.cs	4800f420 <rt_vsnprintf+0x3f4>  // b.hs, b.nlast
    4800f414:	f94037e0 	ldr	x0, [sp, #104]
    4800f418:	52800401 	mov	w1, #0x20                  	// #32
    4800f41c:	39000001 	strb	w1, [x0]
                    ++ str;
    4800f420:	f94037e0 	ldr	x0, [sp, #104]
    4800f424:	91000400 	add	x0, x0, #0x1
    4800f428:	f90037e0 	str	x0, [sp, #104]
                while (--field_width > 0)
    4800f42c:	b94053e0 	ldr	w0, [sp, #80]
    4800f430:	51000400 	sub	w0, w0, #0x1
    4800f434:	b90053e0 	str	w0, [sp, #80]
    4800f438:	b94053e0 	ldr	w0, [sp, #80]
    4800f43c:	7100001f 	cmp	w0, #0x0
    4800f440:	54fffe2c 	b.gt	4800f404 <rt_vsnprintf+0x3d8>
                }
            }

            /* get character */
            c = (rt_uint8_t)va_arg(args, int);
    4800f444:	b9401a61 	ldr	w1, [x19, #24]
    4800f448:	f9400260 	ldr	x0, [x19]
    4800f44c:	7100003f 	cmp	w1, #0x0
    4800f450:	540000ab 	b.lt	4800f464 <rt_vsnprintf+0x438>  // b.tstop
    4800f454:	91002c01 	add	x1, x0, #0xb
    4800f458:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f45c:	f9000261 	str	x1, [x19]
    4800f460:	1400000d 	b	4800f494 <rt_vsnprintf+0x468>
    4800f464:	11002022 	add	w2, w1, #0x8
    4800f468:	b9001a62 	str	w2, [x19, #24]
    4800f46c:	b9401a62 	ldr	w2, [x19, #24]
    4800f470:	7100005f 	cmp	w2, #0x0
    4800f474:	540000ad 	b.le	4800f488 <rt_vsnprintf+0x45c>
    4800f478:	91002c01 	add	x1, x0, #0xb
    4800f47c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f480:	f9000261 	str	x1, [x19]
    4800f484:	14000004 	b	4800f494 <rt_vsnprintf+0x468>
    4800f488:	f9400662 	ldr	x2, [x19, #8]
    4800f48c:	93407c20 	sxtw	x0, w1
    4800f490:	8b000040 	add	x0, x2, x0
    4800f494:	b9400000 	ldr	w0, [x0]
    4800f498:	39012fe0 	strb	w0, [sp, #75]
            if (str < end) *str = c;
    4800f49c:	f94037e1 	ldr	x1, [sp, #104]
    4800f4a0:	f94033e0 	ldr	x0, [sp, #96]
    4800f4a4:	eb00003f 	cmp	x1, x0
    4800f4a8:	54000082 	b.cs	4800f4b8 <rt_vsnprintf+0x48c>  // b.hs, b.nlast
    4800f4ac:	f94037e0 	ldr	x0, [sp, #104]
    4800f4b0:	39412fe1 	ldrb	w1, [sp, #75]
    4800f4b4:	39000001 	strb	w1, [x0]
            ++ str;
    4800f4b8:	f94037e0 	ldr	x0, [sp, #104]
    4800f4bc:	91000400 	add	x0, x0, #0x1
    4800f4c0:	f90037e0 	str	x0, [sp, #104]

            /* put width */
            while (--field_width > 0)
    4800f4c4:	1400000b 	b	4800f4f0 <rt_vsnprintf+0x4c4>
            {
                if (str < end) *str = ' ';
    4800f4c8:	f94037e1 	ldr	x1, [sp, #104]
    4800f4cc:	f94033e0 	ldr	x0, [sp, #96]
    4800f4d0:	eb00003f 	cmp	x1, x0
    4800f4d4:	54000082 	b.cs	4800f4e4 <rt_vsnprintf+0x4b8>  // b.hs, b.nlast
    4800f4d8:	f94037e0 	ldr	x0, [sp, #104]
    4800f4dc:	52800401 	mov	w1, #0x20                  	// #32
    4800f4e0:	39000001 	strb	w1, [x0]
                ++ str;
    4800f4e4:	f94037e0 	ldr	x0, [sp, #104]
    4800f4e8:	91000400 	add	x0, x0, #0x1
    4800f4ec:	f90037e0 	str	x0, [sp, #104]
            while (--field_width > 0)
    4800f4f0:	b94053e0 	ldr	w0, [sp, #80]
    4800f4f4:	51000400 	sub	w0, w0, #0x1
    4800f4f8:	b90053e0 	str	w0, [sp, #80]
    4800f4fc:	b94053e0 	ldr	w0, [sp, #80]
    4800f500:	7100001f 	cmp	w0, #0x0
    4800f504:	54fffe2c 	b.gt	4800f4c8 <rt_vsnprintf+0x49c>
            }
            continue;
    4800f508:	14000137 	b	4800f9e4 <rt_vsnprintf+0x9b8>

        case 's':
            s = va_arg(args, char *);
    4800f50c:	b9401a61 	ldr	w1, [x19, #24]
    4800f510:	f9400260 	ldr	x0, [x19]
    4800f514:	7100003f 	cmp	w1, #0x0
    4800f518:	540000ab 	b.lt	4800f52c <rt_vsnprintf+0x500>  // b.tstop
    4800f51c:	91003c01 	add	x1, x0, #0xf
    4800f520:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f524:	f9000261 	str	x1, [x19]
    4800f528:	1400000d 	b	4800f55c <rt_vsnprintf+0x530>
    4800f52c:	11002022 	add	w2, w1, #0x8
    4800f530:	b9001a62 	str	w2, [x19, #24]
    4800f534:	b9401a62 	ldr	w2, [x19, #24]
    4800f538:	7100005f 	cmp	w2, #0x0
    4800f53c:	540000ad 	b.le	4800f550 <rt_vsnprintf+0x524>
    4800f540:	91003c01 	add	x1, x0, #0xf
    4800f544:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f548:	f9000261 	str	x1, [x19]
    4800f54c:	14000004 	b	4800f55c <rt_vsnprintf+0x530>
    4800f550:	f9400662 	ldr	x2, [x19, #8]
    4800f554:	93407c20 	sxtw	x0, w1
    4800f558:	8b000040 	add	x0, x2, x0
    4800f55c:	f9400000 	ldr	x0, [x0]
    4800f560:	f9002fe0 	str	x0, [sp, #88]
            if (!s) s = "(NULL)";
    4800f564:	f9402fe0 	ldr	x0, [sp, #88]
    4800f568:	f100001f 	cmp	x0, #0x0
    4800f56c:	54000081 	b.ne	4800f57c <rt_vsnprintf+0x550>  // b.any
    4800f570:	90000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800f574:	9125c000 	add	x0, x0, #0x970
    4800f578:	f9002fe0 	str	x0, [sp, #88]

            for (len = 0; (len != field_width) && (s[len] != '\0'); len++);
    4800f57c:	b90077ff 	str	wzr, [sp, #116]
    4800f580:	14000004 	b	4800f590 <rt_vsnprintf+0x564>
    4800f584:	b94077e0 	ldr	w0, [sp, #116]
    4800f588:	11000400 	add	w0, w0, #0x1
    4800f58c:	b90077e0 	str	w0, [sp, #116]
    4800f590:	b94077e1 	ldr	w1, [sp, #116]
    4800f594:	b94053e0 	ldr	w0, [sp, #80]
    4800f598:	6b00003f 	cmp	w1, w0
    4800f59c:	540000e0 	b.eq	4800f5b8 <rt_vsnprintf+0x58c>  // b.none
    4800f5a0:	b98077e0 	ldrsw	x0, [sp, #116]
    4800f5a4:	f9402fe1 	ldr	x1, [sp, #88]
    4800f5a8:	8b000020 	add	x0, x1, x0
    4800f5ac:	39400000 	ldrb	w0, [x0]
    4800f5b0:	7100001f 	cmp	w0, #0x0
    4800f5b4:	54fffe81 	b.ne	4800f584 <rt_vsnprintf+0x558>  // b.any
#ifdef RT_PRINTF_PRECISION
            if (precision > 0 && len > precision) len = precision;
    4800f5b8:	b9404fe0 	ldr	w0, [sp, #76]
    4800f5bc:	7100001f 	cmp	w0, #0x0
    4800f5c0:	540000ed 	b.le	4800f5dc <rt_vsnprintf+0x5b0>
    4800f5c4:	b94077e1 	ldr	w1, [sp, #116]
    4800f5c8:	b9404fe0 	ldr	w0, [sp, #76]
    4800f5cc:	6b00003f 	cmp	w1, w0
    4800f5d0:	5400006d 	b.le	4800f5dc <rt_vsnprintf+0x5b0>
    4800f5d4:	b9404fe0 	ldr	w0, [sp, #76]
    4800f5d8:	b90077e0 	str	w0, [sp, #116]
#endif /* RT_PRINTF_PRECISION */

            if (!(flags & LEFT))
    4800f5dc:	39415be0 	ldrb	w0, [sp, #86]
    4800f5e0:	121c0000 	and	w0, w0, #0x10
    4800f5e4:	7100001f 	cmp	w0, #0x0
    4800f5e8:	54000241 	b.ne	4800f630 <rt_vsnprintf+0x604>  // b.any
            {
                while (len < field_width--)
    4800f5ec:	1400000b 	b	4800f618 <rt_vsnprintf+0x5ec>
                {
                    if (str < end) *str = ' ';
    4800f5f0:	f94037e1 	ldr	x1, [sp, #104]
    4800f5f4:	f94033e0 	ldr	x0, [sp, #96]
    4800f5f8:	eb00003f 	cmp	x1, x0
    4800f5fc:	54000082 	b.cs	4800f60c <rt_vsnprintf+0x5e0>  // b.hs, b.nlast
    4800f600:	f94037e0 	ldr	x0, [sp, #104]
    4800f604:	52800401 	mov	w1, #0x20                  	// #32
    4800f608:	39000001 	strb	w1, [x0]
                    ++ str;
    4800f60c:	f94037e0 	ldr	x0, [sp, #104]
    4800f610:	91000400 	add	x0, x0, #0x1
    4800f614:	f90037e0 	str	x0, [sp, #104]
                while (len < field_width--)
    4800f618:	b94053e0 	ldr	w0, [sp, #80]
    4800f61c:	51000401 	sub	w1, w0, #0x1
    4800f620:	b90053e1 	str	w1, [sp, #80]
    4800f624:	b94077e1 	ldr	w1, [sp, #116]
    4800f628:	6b00003f 	cmp	w1, w0
    4800f62c:	54fffe2b 	b.lt	4800f5f0 <rt_vsnprintf+0x5c4>  // b.tstop
                }
            }

            for (i = 0; i < len; ++i)
    4800f630:	b9007bff 	str	wzr, [sp, #120]
    4800f634:	14000012 	b	4800f67c <rt_vsnprintf+0x650>
            {
                if (str < end) *str = *s;
    4800f638:	f94037e1 	ldr	x1, [sp, #104]
    4800f63c:	f94033e0 	ldr	x0, [sp, #96]
    4800f640:	eb00003f 	cmp	x1, x0
    4800f644:	540000a2 	b.cs	4800f658 <rt_vsnprintf+0x62c>  // b.hs, b.nlast
    4800f648:	f9402fe0 	ldr	x0, [sp, #88]
    4800f64c:	39400001 	ldrb	w1, [x0]
    4800f650:	f94037e0 	ldr	x0, [sp, #104]
    4800f654:	39000001 	strb	w1, [x0]
                ++ str;
    4800f658:	f94037e0 	ldr	x0, [sp, #104]
    4800f65c:	91000400 	add	x0, x0, #0x1
    4800f660:	f90037e0 	str	x0, [sp, #104]
                ++ s;
    4800f664:	f9402fe0 	ldr	x0, [sp, #88]
    4800f668:	91000400 	add	x0, x0, #0x1
    4800f66c:	f9002fe0 	str	x0, [sp, #88]
            for (i = 0; i < len; ++i)
    4800f670:	b9407be0 	ldr	w0, [sp, #120]
    4800f674:	11000400 	add	w0, w0, #0x1
    4800f678:	b9007be0 	str	w0, [sp, #120]
    4800f67c:	b9407be1 	ldr	w1, [sp, #120]
    4800f680:	b94077e0 	ldr	w0, [sp, #116]
    4800f684:	6b00003f 	cmp	w1, w0
    4800f688:	54fffd8b 	b.lt	4800f638 <rt_vsnprintf+0x60c>  // b.tstop
            }

            while (len < field_width--)
    4800f68c:	1400000b 	b	4800f6b8 <rt_vsnprintf+0x68c>
            {
                if (str < end) *str = ' ';
    4800f690:	f94037e1 	ldr	x1, [sp, #104]
    4800f694:	f94033e0 	ldr	x0, [sp, #96]
    4800f698:	eb00003f 	cmp	x1, x0
    4800f69c:	54000082 	b.cs	4800f6ac <rt_vsnprintf+0x680>  // b.hs, b.nlast
    4800f6a0:	f94037e0 	ldr	x0, [sp, #104]
    4800f6a4:	52800401 	mov	w1, #0x20                  	// #32
    4800f6a8:	39000001 	strb	w1, [x0]
                ++ str;
    4800f6ac:	f94037e0 	ldr	x0, [sp, #104]
    4800f6b0:	91000400 	add	x0, x0, #0x1
    4800f6b4:	f90037e0 	str	x0, [sp, #104]
            while (len < field_width--)
    4800f6b8:	b94053e0 	ldr	w0, [sp, #80]
    4800f6bc:	51000401 	sub	w1, w0, #0x1
    4800f6c0:	b90053e1 	str	w1, [sp, #80]
    4800f6c4:	b94077e1 	ldr	w1, [sp, #116]
    4800f6c8:	6b00003f 	cmp	w1, w0
    4800f6cc:	54fffe2b 	b.lt	4800f690 <rt_vsnprintf+0x664>  // b.tstop
            }
            continue;
    4800f6d0:	140000c5 	b	4800f9e4 <rt_vsnprintf+0x9b8>

        case 'p':
            if (field_width == -1)
    4800f6d4:	b94053e0 	ldr	w0, [sp, #80]
    4800f6d8:	3100041f 	cmn	w0, #0x1
    4800f6dc:	540000c1 	b.ne	4800f6f4 <rt_vsnprintf+0x6c8>  // b.any
            {
                field_width = sizeof(void *) << 1;
    4800f6e0:	52800200 	mov	w0, #0x10                  	// #16
    4800f6e4:	b90053e0 	str	w0, [sp, #80]
                flags |= ZEROPAD;
    4800f6e8:	39415be0 	ldrb	w0, [sp, #86]
    4800f6ec:	32000000 	orr	w0, w0, #0x1
    4800f6f0:	39015be0 	strb	w0, [sp, #86]
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
                               (long)va_arg(args, void *),
    4800f6f4:	b9401a61 	ldr	w1, [x19, #24]
    4800f6f8:	f9400260 	ldr	x0, [x19]
    4800f6fc:	7100003f 	cmp	w1, #0x0
    4800f700:	540000ab 	b.lt	4800f714 <rt_vsnprintf+0x6e8>  // b.tstop
    4800f704:	91003c01 	add	x1, x0, #0xf
    4800f708:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f70c:	f9000261 	str	x1, [x19]
    4800f710:	1400000d 	b	4800f744 <rt_vsnprintf+0x718>
    4800f714:	11002022 	add	w2, w1, #0x8
    4800f718:	b9001a62 	str	w2, [x19, #24]
    4800f71c:	b9401a62 	ldr	w2, [x19, #24]
    4800f720:	7100005f 	cmp	w2, #0x0
    4800f724:	540000ad 	b.le	4800f738 <rt_vsnprintf+0x70c>
    4800f728:	91003c01 	add	x1, x0, #0xf
    4800f72c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f730:	f9000261 	str	x1, [x19]
    4800f734:	14000004 	b	4800f744 <rt_vsnprintf+0x718>
    4800f738:	f9400662 	ldr	x2, [x19, #8]
    4800f73c:	93407c20 	sxtw	x0, w1
    4800f740:	8b000040 	add	x0, x2, x0
    4800f744:	f9400000 	ldr	x0, [x0]
            str = print_number(str, end,
    4800f748:	aa0003e1 	mov	x1, x0
    4800f74c:	39415be0 	ldrb	w0, [sp, #86]
    4800f750:	2a0003e6 	mov	w6, w0
    4800f754:	b9404fe5 	ldr	w5, [sp, #76]
    4800f758:	b94053e4 	ldr	w4, [sp, #80]
    4800f75c:	52800203 	mov	w3, #0x10                  	// #16
    4800f760:	aa0103e2 	mov	x2, x1
    4800f764:	f94033e1 	ldr	x1, [sp, #96]
    4800f768:	f94037e0 	ldr	x0, [sp, #104]
    4800f76c:	97fffd5d 	bl	4800ece0 <print_number>
    4800f770:	f90037e0 	str	x0, [sp, #104]
#else
            str = print_number(str, end,
                               (long)va_arg(args, void *),
                               16, field_width, flags);
#endif /* RT_PRINTF_PRECISION */
            continue;
    4800f774:	1400009c 	b	4800f9e4 <rt_vsnprintf+0x9b8>

        case '%':
            if (str < end) *str = '%';
    4800f778:	f94037e1 	ldr	x1, [sp, #104]
    4800f77c:	f94033e0 	ldr	x0, [sp, #96]
    4800f780:	eb00003f 	cmp	x1, x0
    4800f784:	54000082 	b.cs	4800f794 <rt_vsnprintf+0x768>  // b.hs, b.nlast
    4800f788:	f94037e0 	ldr	x0, [sp, #104]
    4800f78c:	528004a1 	mov	w1, #0x25                  	// #37
    4800f790:	39000001 	strb	w1, [x0]
            ++ str;
    4800f794:	f94037e0 	ldr	x0, [sp, #104]
    4800f798:	91000400 	add	x0, x0, #0x1
    4800f79c:	f90037e0 	str	x0, [sp, #104]
            continue;
    4800f7a0:	14000091 	b	4800f9e4 <rt_vsnprintf+0x9b8>

        /* integer number formats - set up the flags and "break" */
        case 'o':
            base = 8;
    4800f7a4:	52800100 	mov	w0, #0x8                   	// #8
    4800f7a8:	39015fe0 	strb	w0, [sp, #87]
            break;
    4800f7ac:	1400002a 	b	4800f854 <rt_vsnprintf+0x828>

        case 'X':
            flags |= LARGE;
    4800f7b0:	39415be0 	ldrb	w0, [sp, #86]
    4800f7b4:	321a0000 	orr	w0, w0, #0x40
    4800f7b8:	39015be0 	strb	w0, [sp, #86]
        case 'x':
            base = 16;
    4800f7bc:	52800200 	mov	w0, #0x10                  	// #16
    4800f7c0:	39015fe0 	strb	w0, [sp, #87]
            break;
    4800f7c4:	14000024 	b	4800f854 <rt_vsnprintf+0x828>

        case 'd':
        case 'i':
            flags |= SIGN;
    4800f7c8:	39415be0 	ldrb	w0, [sp, #86]
    4800f7cc:	321f0000 	orr	w0, w0, #0x2
    4800f7d0:	39015be0 	strb	w0, [sp, #86]
        case 'u':
            break;
    4800f7d4:	1400001f 	b	4800f850 <rt_vsnprintf+0x824>

        default:
            if (str < end) *str = '%';
    4800f7d8:	f94037e1 	ldr	x1, [sp, #104]
    4800f7dc:	f94033e0 	ldr	x0, [sp, #96]
    4800f7e0:	eb00003f 	cmp	x1, x0
    4800f7e4:	54000082 	b.cs	4800f7f4 <rt_vsnprintf+0x7c8>  // b.hs, b.nlast
    4800f7e8:	f94037e0 	ldr	x0, [sp, #104]
    4800f7ec:	528004a1 	mov	w1, #0x25                  	// #37
    4800f7f0:	39000001 	strb	w1, [x0]
            ++ str;
    4800f7f4:	f94037e0 	ldr	x0, [sp, #104]
    4800f7f8:	91000400 	add	x0, x0, #0x1
    4800f7fc:	f90037e0 	str	x0, [sp, #104]

            if (*fmt)
    4800f800:	f94017e0 	ldr	x0, [sp, #40]
    4800f804:	39400000 	ldrb	w0, [x0]
    4800f808:	7100001f 	cmp	w0, #0x0
    4800f80c:	540001a0 	b.eq	4800f840 <rt_vsnprintf+0x814>  // b.none
            {
                if (str < end) *str = *fmt;
    4800f810:	f94037e1 	ldr	x1, [sp, #104]
    4800f814:	f94033e0 	ldr	x0, [sp, #96]
    4800f818:	eb00003f 	cmp	x1, x0
    4800f81c:	540000a2 	b.cs	4800f830 <rt_vsnprintf+0x804>  // b.hs, b.nlast
    4800f820:	f94017e0 	ldr	x0, [sp, #40]
    4800f824:	39400001 	ldrb	w1, [x0]
    4800f828:	f94037e0 	ldr	x0, [sp, #104]
    4800f82c:	39000001 	strb	w1, [x0]
                ++ str;
    4800f830:	f94037e0 	ldr	x0, [sp, #104]
    4800f834:	91000400 	add	x0, x0, #0x1
    4800f838:	f90037e0 	str	x0, [sp, #104]
            }
            else
            {
                -- fmt;
            }
            continue;
    4800f83c:	1400006a 	b	4800f9e4 <rt_vsnprintf+0x9b8>
                -- fmt;
    4800f840:	f94017e0 	ldr	x0, [sp, #40]
    4800f844:	d1000400 	sub	x0, x0, #0x1
    4800f848:	f90017e0 	str	x0, [sp, #40]
            continue;
    4800f84c:	14000066 	b	4800f9e4 <rt_vsnprintf+0x9b8>
            break;
    4800f850:	d503201f 	nop

#ifdef RT_PRINTF_LONGLONG
        if (qualifier == 'L') num = va_arg(args, long long);
        else if (qualifier == 'l')
#else
        if (qualifier == 'l')
    4800f854:	394157e0 	ldrb	w0, [sp, #85]
    4800f858:	7101b01f 	cmp	w0, #0x6c
    4800f85c:	54000361 	b.ne	4800f8c8 <rt_vsnprintf+0x89c>  // b.any
#endif /* RT_PRINTF_LONGLONG */
        {
            num = va_arg(args, rt_uint32_t);
    4800f860:	b9401a61 	ldr	w1, [x19, #24]
    4800f864:	f9400260 	ldr	x0, [x19]
    4800f868:	7100003f 	cmp	w1, #0x0
    4800f86c:	540000ab 	b.lt	4800f880 <rt_vsnprintf+0x854>  // b.tstop
    4800f870:	91002c01 	add	x1, x0, #0xb
    4800f874:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f878:	f9000261 	str	x1, [x19]
    4800f87c:	1400000d 	b	4800f8b0 <rt_vsnprintf+0x884>
    4800f880:	11002022 	add	w2, w1, #0x8
    4800f884:	b9001a62 	str	w2, [x19, #24]
    4800f888:	b9401a62 	ldr	w2, [x19, #24]
    4800f88c:	7100005f 	cmp	w2, #0x0
    4800f890:	540000ad 	b.le	4800f8a4 <rt_vsnprintf+0x878>
    4800f894:	91002c01 	add	x1, x0, #0xb
    4800f898:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f89c:	f9000261 	str	x1, [x19]
    4800f8a0:	14000004 	b	4800f8b0 <rt_vsnprintf+0x884>
    4800f8a4:	f9400662 	ldr	x2, [x19, #8]
    4800f8a8:	93407c20 	sxtw	x0, w1
    4800f8ac:	8b000040 	add	x0, x2, x0
    4800f8b0:	b9400000 	ldr	w0, [x0]
    4800f8b4:	b9007fe0 	str	w0, [sp, #124]
            if (flags & SIGN) num = (rt_int32_t)num;
    4800f8b8:	39415be0 	ldrb	w0, [sp, #86]
    4800f8bc:	121f0000 	and	w0, w0, #0x2
    4800f8c0:	7100001f 	cmp	w0, #0x0
    4800f8c4:	1400003c 	b	4800f9b4 <rt_vsnprintf+0x988>
        }
        else if (qualifier == 'h')
    4800f8c8:	394157e0 	ldrb	w0, [sp, #85]
    4800f8cc:	7101a01f 	cmp	w0, #0x68
    4800f8d0:	54000401 	b.ne	4800f950 <rt_vsnprintf+0x924>  // b.any
        {
            num = (rt_uint16_t)va_arg(args, rt_int32_t);
    4800f8d4:	b9401a61 	ldr	w1, [x19, #24]
    4800f8d8:	f9400260 	ldr	x0, [x19]
    4800f8dc:	7100003f 	cmp	w1, #0x0
    4800f8e0:	540000ab 	b.lt	4800f8f4 <rt_vsnprintf+0x8c8>  // b.tstop
    4800f8e4:	91002c01 	add	x1, x0, #0xb
    4800f8e8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f8ec:	f9000261 	str	x1, [x19]
    4800f8f0:	1400000d 	b	4800f924 <rt_vsnprintf+0x8f8>
    4800f8f4:	11002022 	add	w2, w1, #0x8
    4800f8f8:	b9001a62 	str	w2, [x19, #24]
    4800f8fc:	b9401a62 	ldr	w2, [x19, #24]
    4800f900:	7100005f 	cmp	w2, #0x0
    4800f904:	540000ad 	b.le	4800f918 <rt_vsnprintf+0x8ec>
    4800f908:	91002c01 	add	x1, x0, #0xb
    4800f90c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f910:	f9000261 	str	x1, [x19]
    4800f914:	14000004 	b	4800f924 <rt_vsnprintf+0x8f8>
    4800f918:	f9400662 	ldr	x2, [x19, #8]
    4800f91c:	93407c20 	sxtw	x0, w1
    4800f920:	8b000040 	add	x0, x2, x0
    4800f924:	b9400000 	ldr	w0, [x0]
    4800f928:	12003c00 	and	w0, w0, #0xffff
    4800f92c:	b9007fe0 	str	w0, [sp, #124]
            if (flags & SIGN) num = (rt_int16_t)num;
    4800f930:	39415be0 	ldrb	w0, [sp, #86]
    4800f934:	121f0000 	and	w0, w0, #0x2
    4800f938:	7100001f 	cmp	w0, #0x0
    4800f93c:	540003c0 	b.eq	4800f9b4 <rt_vsnprintf+0x988>  // b.none
    4800f940:	b9407fe0 	ldr	w0, [sp, #124]
    4800f944:	13003c00 	sxth	w0, w0
    4800f948:	b9007fe0 	str	w0, [sp, #124]
    4800f94c:	1400001a 	b	4800f9b4 <rt_vsnprintf+0x988>
        }
        else
        {
            num = va_arg(args, rt_uint32_t);
    4800f950:	b9401a61 	ldr	w1, [x19, #24]
    4800f954:	f9400260 	ldr	x0, [x19]
    4800f958:	7100003f 	cmp	w1, #0x0
    4800f95c:	540000ab 	b.lt	4800f970 <rt_vsnprintf+0x944>  // b.tstop
    4800f960:	91002c01 	add	x1, x0, #0xb
    4800f964:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f968:	f9000261 	str	x1, [x19]
    4800f96c:	1400000d 	b	4800f9a0 <rt_vsnprintf+0x974>
    4800f970:	11002022 	add	w2, w1, #0x8
    4800f974:	b9001a62 	str	w2, [x19, #24]
    4800f978:	b9401a62 	ldr	w2, [x19, #24]
    4800f97c:	7100005f 	cmp	w2, #0x0
    4800f980:	540000ad 	b.le	4800f994 <rt_vsnprintf+0x968>
    4800f984:	91002c01 	add	x1, x0, #0xb
    4800f988:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4800f98c:	f9000261 	str	x1, [x19]
    4800f990:	14000004 	b	4800f9a0 <rt_vsnprintf+0x974>
    4800f994:	f9400662 	ldr	x2, [x19, #8]
    4800f998:	93407c20 	sxtw	x0, w1
    4800f99c:	8b000040 	add	x0, x2, x0
    4800f9a0:	b9400000 	ldr	w0, [x0]
    4800f9a4:	b9007fe0 	str	w0, [sp, #124]
            if (flags & SIGN) num = (rt_int32_t)num;
    4800f9a8:	39415be0 	ldrb	w0, [sp, #86]
    4800f9ac:	121f0000 	and	w0, w0, #0x2
    4800f9b0:	7100001f 	cmp	w0, #0x0
        }
#ifdef RT_PRINTF_PRECISION
        str = print_number(str, end, num, base, field_width, precision, flags);
    4800f9b4:	b9407fe0 	ldr	w0, [sp, #124]
    4800f9b8:	39415fe1 	ldrb	w1, [sp, #87]
    4800f9bc:	39415be2 	ldrb	w2, [sp, #86]
    4800f9c0:	2a0203e6 	mov	w6, w2
    4800f9c4:	b9404fe5 	ldr	w5, [sp, #76]
    4800f9c8:	b94053e4 	ldr	w4, [sp, #80]
    4800f9cc:	2a0103e3 	mov	w3, w1
    4800f9d0:	aa0003e2 	mov	x2, x0
    4800f9d4:	f94033e1 	ldr	x1, [sp, #96]
    4800f9d8:	f94037e0 	ldr	x0, [sp, #104]
    4800f9dc:	97fffcc1 	bl	4800ece0 <print_number>
    4800f9e0:	f90037e0 	str	x0, [sp, #104]
    for (; *fmt ; ++fmt)
    4800f9e4:	f94017e0 	ldr	x0, [sp, #40]
    4800f9e8:	91000400 	add	x0, x0, #0x1
    4800f9ec:	f90017e0 	str	x0, [sp, #40]
    4800f9f0:	f94017e0 	ldr	x0, [sp, #40]
    4800f9f4:	39400000 	ldrb	w0, [x0]
    4800f9f8:	7100001f 	cmp	w0, #0x0
    4800f9fc:	54ffb481 	b.ne	4800f08c <rt_vsnprintf+0x60>  // b.any
#else
        str = print_number(str, end, num, base, field_width, flags);
#endif /* RT_PRINTF_PRECISION */
    }

    if (size > 0)
    4800fa00:	f9401be0 	ldr	x0, [sp, #48]
    4800fa04:	f100001f 	cmp	x0, #0x0
    4800fa08:	54000160 	b.eq	4800fa34 <rt_vsnprintf+0xa08>  // b.none
    {
        if (str < end) *str = '\0';
    4800fa0c:	f94037e1 	ldr	x1, [sp, #104]
    4800fa10:	f94033e0 	ldr	x0, [sp, #96]
    4800fa14:	eb00003f 	cmp	x1, x0
    4800fa18:	54000082 	b.cs	4800fa28 <rt_vsnprintf+0x9fc>  // b.hs, b.nlast
    4800fa1c:	f94037e0 	ldr	x0, [sp, #104]
    4800fa20:	3900001f 	strb	wzr, [x0]
    4800fa24:	14000004 	b	4800fa34 <rt_vsnprintf+0xa08>
        else
        {
            end[-1] = '\0';
    4800fa28:	f94033e0 	ldr	x0, [sp, #96]
    4800fa2c:	d1000400 	sub	x0, x0, #0x1
    4800fa30:	3900001f 	strb	wzr, [x0]
    }

    /* the trailing null byte doesn't count towards the total
    * ++str;
    */
    return str - buf;
    4800fa34:	f94037e1 	ldr	x1, [sp, #104]
    4800fa38:	f9401fe0 	ldr	x0, [sp, #56]
    4800fa3c:	cb000020 	sub	x0, x1, x0
}
    4800fa40:	f9400bf3 	ldr	x19, [sp, #16]
    4800fa44:	a8c87bfd 	ldp	x29, x30, [sp], #128
    4800fa48:	d65f03c0 	ret

000000004800fa4c <rt_snprintf>:
 * @param  fmt is the format parameters.
 *
 * @return The number of characters actually written to buffer.
 */
rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
{
    4800fa4c:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
    4800fa50:	910003fd 	mov	x29, sp
    4800fa54:	f90027e0 	str	x0, [sp, #72]
    4800fa58:	f90023e1 	str	x1, [sp, #64]
    4800fa5c:	f9001fe2 	str	x2, [sp, #56]
    4800fa60:	f90087e3 	str	x3, [sp, #264]
    4800fa64:	f9008be4 	str	x4, [sp, #272]
    4800fa68:	f9008fe5 	str	x5, [sp, #280]
    4800fa6c:	f90093e6 	str	x6, [sp, #288]
    4800fa70:	f90097e7 	str	x7, [sp, #296]
    4800fa74:	3d8023e0 	str	q0, [sp, #128]
    4800fa78:	3d8027e1 	str	q1, [sp, #144]
    4800fa7c:	3d802be2 	str	q2, [sp, #160]
    4800fa80:	3d802fe3 	str	q3, [sp, #176]
    4800fa84:	3d8033e4 	str	q4, [sp, #192]
    4800fa88:	3d8037e5 	str	q5, [sp, #208]
    4800fa8c:	3d803be6 	str	q6, [sp, #224]
    4800fa90:	3d803fe7 	str	q7, [sp, #240]
    rt_int32_t n;
    va_list args;

    va_start(args, fmt);
    4800fa94:	9104c3e0 	add	x0, sp, #0x130
    4800fa98:	f9002fe0 	str	x0, [sp, #88]
    4800fa9c:	9104c3e0 	add	x0, sp, #0x130
    4800faa0:	f90033e0 	str	x0, [sp, #96]
    4800faa4:	910403e0 	add	x0, sp, #0x100
    4800faa8:	f90037e0 	str	x0, [sp, #104]
    4800faac:	128004e0 	mov	w0, #0xffffffd8            	// #-40
    4800fab0:	b90073e0 	str	w0, [sp, #112]
    4800fab4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4800fab8:	b90077e0 	str	w0, [sp, #116]
    n = rt_vsnprintf(buf, size, fmt, args);
    4800fabc:	910043e2 	add	x2, sp, #0x10
    4800fac0:	910163e3 	add	x3, sp, #0x58
    4800fac4:	a9400460 	ldp	x0, x1, [x3]
    4800fac8:	a9000440 	stp	x0, x1, [x2]
    4800facc:	a9410460 	ldp	x0, x1, [x3, #16]
    4800fad0:	a9010440 	stp	x0, x1, [x2, #16]
    4800fad4:	910043e0 	add	x0, sp, #0x10
    4800fad8:	aa0003e3 	mov	x3, x0
    4800fadc:	f9401fe2 	ldr	x2, [sp, #56]
    4800fae0:	f94023e1 	ldr	x1, [sp, #64]
    4800fae4:	f94027e0 	ldr	x0, [sp, #72]
    4800fae8:	97fffd51 	bl	4800f02c <rt_vsnprintf>
    4800faec:	b9007fe0 	str	w0, [sp, #124]
    va_end(args);

    return n;
    4800faf0:	b9407fe0 	ldr	w0, [sp, #124]
}
    4800faf4:	a8d37bfd 	ldp	x29, x30, [sp], #304
    4800faf8:	d65f03c0 	ret

000000004800fafc <rt_vsprintf>:
 * @param  arg_ptr is a list of variable parameters.
 *
 * @return The number of characters actually written to buffer.
 */
rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
{
    4800fafc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4800fb00:	910003fd 	mov	x29, sp
    4800fb04:	f9000bf3 	str	x19, [sp, #16]
    4800fb08:	f90027e0 	str	x0, [sp, #72]
    4800fb0c:	f90023e1 	str	x1, [sp, #64]
    4800fb10:	aa0203f3 	mov	x19, x2
    return rt_vsnprintf(buf, (rt_size_t) - 1, format, arg_ptr);
    4800fb14:	910083e2 	add	x2, sp, #0x20
    4800fb18:	aa1303e3 	mov	x3, x19
    4800fb1c:	a9400460 	ldp	x0, x1, [x3]
    4800fb20:	a9000440 	stp	x0, x1, [x2]
    4800fb24:	a9410460 	ldp	x0, x1, [x3, #16]
    4800fb28:	a9010440 	stp	x0, x1, [x2, #16]
    4800fb2c:	910083e0 	add	x0, sp, #0x20
    4800fb30:	aa0003e3 	mov	x3, x0
    4800fb34:	f94023e2 	ldr	x2, [sp, #64]
    4800fb38:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    4800fb3c:	f94027e0 	ldr	x0, [sp, #72]
    4800fb40:	97fffd3b 	bl	4800f02c <rt_vsnprintf>
}
    4800fb44:	f9400bf3 	ldr	x19, [sp, #16]
    4800fb48:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4800fb4c:	d65f03c0 	ret

000000004800fb50 <rt_sprintf>:
 * @param  format is the format parameters.
 *
 * @return The number of characters actually written to buffer.
 */
rt_int32_t rt_sprintf(char *buf, const char *format, ...)
{
    4800fb50:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
    4800fb54:	910003fd 	mov	x29, sp
    4800fb58:	f9001fe0 	str	x0, [sp, #56]
    4800fb5c:	f9001be1 	str	x1, [sp, #48]
    4800fb60:	f9007be2 	str	x2, [sp, #240]
    4800fb64:	f9007fe3 	str	x3, [sp, #248]
    4800fb68:	f90083e4 	str	x4, [sp, #256]
    4800fb6c:	f90087e5 	str	x5, [sp, #264]
    4800fb70:	f9008be6 	str	x6, [sp, #272]
    4800fb74:	f9008fe7 	str	x7, [sp, #280]
    4800fb78:	3d801fe0 	str	q0, [sp, #112]
    4800fb7c:	3d8023e1 	str	q1, [sp, #128]
    4800fb80:	3d8027e2 	str	q2, [sp, #144]
    4800fb84:	3d802be3 	str	q3, [sp, #160]
    4800fb88:	3d802fe4 	str	q4, [sp, #176]
    4800fb8c:	3d8033e5 	str	q5, [sp, #192]
    4800fb90:	3d8037e6 	str	q6, [sp, #208]
    4800fb94:	3d803be7 	str	q7, [sp, #224]
    rt_int32_t n;
    va_list arg_ptr;

    va_start(arg_ptr, format);
    4800fb98:	910483e0 	add	x0, sp, #0x120
    4800fb9c:	f90027e0 	str	x0, [sp, #72]
    4800fba0:	910483e0 	add	x0, sp, #0x120
    4800fba4:	f9002be0 	str	x0, [sp, #80]
    4800fba8:	9103c3e0 	add	x0, sp, #0xf0
    4800fbac:	f9002fe0 	str	x0, [sp, #88]
    4800fbb0:	128005e0 	mov	w0, #0xffffffd0            	// #-48
    4800fbb4:	b90063e0 	str	w0, [sp, #96]
    4800fbb8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4800fbbc:	b90067e0 	str	w0, [sp, #100]
    n = rt_vsprintf(buf, format, arg_ptr);
    4800fbc0:	910043e2 	add	x2, sp, #0x10
    4800fbc4:	910123e3 	add	x3, sp, #0x48
    4800fbc8:	a9400460 	ldp	x0, x1, [x3]
    4800fbcc:	a9000440 	stp	x0, x1, [x2]
    4800fbd0:	a9410460 	ldp	x0, x1, [x3, #16]
    4800fbd4:	a9010440 	stp	x0, x1, [x2, #16]
    4800fbd8:	910043e0 	add	x0, sp, #0x10
    4800fbdc:	aa0003e2 	mov	x2, x0
    4800fbe0:	f9401be1 	ldr	x1, [sp, #48]
    4800fbe4:	f9401fe0 	ldr	x0, [sp, #56]
    4800fbe8:	97ffffc5 	bl	4800fafc <rt_vsprintf>
    4800fbec:	b9006fe0 	str	w0, [sp, #108]
    va_end(arg_ptr);

    return n;
    4800fbf0:	b9406fe0 	ldr	w0, [sp, #108]
}
    4800fbf4:	a8d27bfd 	ldp	x29, x30, [sp], #288
    4800fbf8:	d65f03c0 	ret

000000004800fbfc <rt_console_get_device>:
 *
 * @return Returns the console device pointer or RT_NULL.
 */
rt_device_t rt_console_get_device(void)
{
    return _console_device;
    4800fbfc:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fc00:	91184000 	add	x0, x0, #0x610
    4800fc04:	f9400000 	ldr	x0, [x0]
}
    4800fc08:	d65f03c0 	ret

000000004800fc0c <rt_console_set_device>:
 * @param  name is the name of new console device.
 *
 * @return the old console device handler on successful, or RT_NULL on failure.
 */
rt_device_t rt_console_set_device(const char *name)
{
    4800fc0c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800fc10:	910003fd 	mov	x29, sp
    4800fc14:	f9000fe0 	str	x0, [sp, #24]
    rt_device_t new_device, old_device;

    /* save old device */
    old_device = _console_device;
    4800fc18:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fc1c:	91184000 	add	x0, x0, #0x610
    4800fc20:	f9400000 	ldr	x0, [x0]
    4800fc24:	f90017e0 	str	x0, [sp, #40]

    /* find new console device */
    new_device = rt_device_find(name);
    4800fc28:	f9400fe0 	ldr	x0, [sp, #24]
    4800fc2c:	97fff30f 	bl	4800c868 <rt_device_find>
    4800fc30:	f90013e0 	str	x0, [sp, #32]

    /* check whether it's a same device */
    if (new_device == old_device) return RT_NULL;
    4800fc34:	f94013e1 	ldr	x1, [sp, #32]
    4800fc38:	f94017e0 	ldr	x0, [sp, #40]
    4800fc3c:	eb00003f 	cmp	x1, x0
    4800fc40:	54000061 	b.ne	4800fc4c <rt_console_set_device+0x40>  // b.any
    4800fc44:	d2800000 	mov	x0, #0x0                   	// #0
    4800fc48:	14000015 	b	4800fc9c <rt_console_set_device+0x90>

    if (new_device != RT_NULL)
    4800fc4c:	f94013e0 	ldr	x0, [sp, #32]
    4800fc50:	f100001f 	cmp	x0, #0x0
    4800fc54:	54000220 	b.eq	4800fc98 <rt_console_set_device+0x8c>  // b.none
    {
        if (_console_device != RT_NULL)
    4800fc58:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fc5c:	91184000 	add	x0, x0, #0x610
    4800fc60:	f9400000 	ldr	x0, [x0]
    4800fc64:	f100001f 	cmp	x0, #0x0
    4800fc68:	540000a0 	b.eq	4800fc7c <rt_console_set_device+0x70>  // b.none
        {
            /* close old console device */
            rt_device_close(_console_device);
    4800fc6c:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fc70:	91184000 	add	x0, x0, #0x610
    4800fc74:	f9400000 	ldr	x0, [x0]
    4800fc78:	97fff3ec 	bl	4800cc28 <rt_device_close>
        }

        /* set new console device */
        rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
    4800fc7c:	52800861 	mov	w1, #0x43                  	// #67
    4800fc80:	f94013e0 	ldr	x0, [sp, #32]
    4800fc84:	97fff375 	bl	4800ca58 <rt_device_open>
        _console_device = new_device;
    4800fc88:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fc8c:	91184000 	add	x0, x0, #0x610
    4800fc90:	f94013e1 	ldr	x1, [sp, #32]
    4800fc94:	f9000001 	str	x1, [x0]
    }

    return old_device;
    4800fc98:	f94017e0 	ldr	x0, [sp, #40]
}
    4800fc9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800fca0:	d65f03c0 	ret

000000004800fca4 <rt_hw_console_output>:
RTM_EXPORT(rt_console_set_device);
#endif /* RT_USING_DEVICE */

RT_WEAK void rt_hw_console_output(const char *str)
{
    4800fca4:	d10043ff 	sub	sp, sp, #0x10
    4800fca8:	f90007e0 	str	x0, [sp, #8]
    /* empty console output */
}
    4800fcac:	d503201f 	nop
    4800fcb0:	910043ff 	add	sp, sp, #0x10
    4800fcb4:	d65f03c0 	ret

000000004800fcb8 <rt_kputs>:
 * This function will put string to the console.
 *
 * @param str is the string output to the console.
 */
void rt_kputs(const char *str)
{
    4800fcb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800fcbc:	910003fd 	mov	x29, sp
    4800fcc0:	f9000bf3 	str	x19, [sp, #16]
    4800fcc4:	f90017e0 	str	x0, [sp, #40]
    if (!str) return;
    4800fcc8:	f94017e0 	ldr	x0, [sp, #40]
    4800fccc:	f100001f 	cmp	x0, #0x0
    4800fcd0:	54000280 	b.eq	4800fd20 <rt_kputs+0x68>  // b.none

#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
    4800fcd4:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fcd8:	91184000 	add	x0, x0, #0x610
    4800fcdc:	f9400000 	ldr	x0, [x0]
    4800fce0:	f100001f 	cmp	x0, #0x0
    4800fce4:	54000081 	b.ne	4800fcf4 <rt_kputs+0x3c>  // b.any
    {
        rt_hw_console_output(str);
    4800fce8:	f94017e0 	ldr	x0, [sp, #40]
    4800fcec:	97ffffee 	bl	4800fca4 <rt_hw_console_output>
    4800fcf0:	1400000d 	b	4800fd24 <rt_kputs+0x6c>
    }
    else
    {
        rt_device_write(_console_device, 0, str, rt_strlen(str));
    4800fcf4:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fcf8:	91184000 	add	x0, x0, #0x610
    4800fcfc:	f9400013 	ldr	x19, [x0]
    4800fd00:	f94017e0 	ldr	x0, [sp, #40]
    4800fd04:	97fffb5c 	bl	4800ea74 <rt_strlen>
    4800fd08:	aa0003e3 	mov	x3, x0
    4800fd0c:	f94017e2 	ldr	x2, [sp, #40]
    4800fd10:	d2800001 	mov	x1, #0x0                   	// #0
    4800fd14:	aa1303e0 	mov	x0, x19
    4800fd18:	97fff435 	bl	4800cdec <rt_device_write>
    4800fd1c:	14000002 	b	4800fd24 <rt_kputs+0x6c>
    if (!str) return;
    4800fd20:	d503201f 	nop
    }
#else
    rt_hw_console_output(str);
#endif /* RT_USING_DEVICE */
}
    4800fd24:	f9400bf3 	ldr	x19, [sp, #16]
    4800fd28:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800fd2c:	d65f03c0 	ret

000000004800fd30 <rt_kprintf>:
 * This function will print a formatted string on system console.
 *
 * @param fmt is the format parameters.
 */
RT_WEAK void rt_kprintf(const char *fmt, ...)
{
    4800fd30:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
    4800fd34:	910003fd 	mov	x29, sp
    4800fd38:	f9001fe0 	str	x0, [sp, #56]
    4800fd3c:	f9007fe1 	str	x1, [sp, #248]
    4800fd40:	f90083e2 	str	x2, [sp, #256]
    4800fd44:	f90087e3 	str	x3, [sp, #264]
    4800fd48:	f9008be4 	str	x4, [sp, #272]
    4800fd4c:	f9008fe5 	str	x5, [sp, #280]
    4800fd50:	f90093e6 	str	x6, [sp, #288]
    4800fd54:	f90097e7 	str	x7, [sp, #296]
    4800fd58:	3d801fe0 	str	q0, [sp, #112]
    4800fd5c:	3d8023e1 	str	q1, [sp, #128]
    4800fd60:	3d8027e2 	str	q2, [sp, #144]
    4800fd64:	3d802be3 	str	q3, [sp, #160]
    4800fd68:	3d802fe4 	str	q4, [sp, #176]
    4800fd6c:	3d8033e5 	str	q5, [sp, #192]
    4800fd70:	3d8037e6 	str	q6, [sp, #208]
    4800fd74:	3d803be7 	str	q7, [sp, #224]
    va_list args;
    rt_size_t length;
    static char rt_log_buf[RT_CONSOLEBUF_SIZE];

    va_start(args, fmt);
    4800fd78:	9104c3e0 	add	x0, sp, #0x130
    4800fd7c:	f90027e0 	str	x0, [sp, #72]
    4800fd80:	9104c3e0 	add	x0, sp, #0x130
    4800fd84:	f9002be0 	str	x0, [sp, #80]
    4800fd88:	9103c3e0 	add	x0, sp, #0xf0
    4800fd8c:	f9002fe0 	str	x0, [sp, #88]
    4800fd90:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    4800fd94:	b90063e0 	str	w0, [sp, #96]
    4800fd98:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4800fd9c:	b90067e0 	str	w0, [sp, #100]
    /* the return value of vsnprintf is the number of bytes that would be
     * written to buffer had if the size of the buffer been sufficiently
     * large excluding the terminating null byte. If the output string
     * would be larger than the rt_log_buf, we have to adjust the output
     * length. */
    length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
    4800fda0:	910043e2 	add	x2, sp, #0x10
    4800fda4:	910123e3 	add	x3, sp, #0x48
    4800fda8:	a9400460 	ldp	x0, x1, [x3]
    4800fdac:	a9000440 	stp	x0, x1, [x2]
    4800fdb0:	a9410460 	ldp	x0, x1, [x3, #16]
    4800fdb4:	a9010440 	stp	x0, x1, [x2, #16]
    4800fdb8:	910043e0 	add	x0, sp, #0x10
    4800fdbc:	aa0003e3 	mov	x3, x0
    4800fdc0:	f9401fe2 	ldr	x2, [sp, #56]
    4800fdc4:	d2800fe1 	mov	x1, #0x7f                  	// #127
    4800fdc8:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fdcc:	91186000 	add	x0, x0, #0x618
    4800fdd0:	97fffc97 	bl	4800f02c <rt_vsnprintf>
    4800fdd4:	93407c00 	sxtw	x0, w0
    4800fdd8:	f90037e0 	str	x0, [sp, #104]
    if (length > RT_CONSOLEBUF_SIZE - 1)
    4800fddc:	f94037e0 	ldr	x0, [sp, #104]
    4800fde0:	f101fc1f 	cmp	x0, #0x7f
    4800fde4:	54000069 	b.ls	4800fdf0 <rt_kprintf+0xc0>  // b.plast
        length = RT_CONSOLEBUF_SIZE - 1;
    4800fde8:	d2800fe0 	mov	x0, #0x7f                  	// #127
    4800fdec:	f90037e0 	str	x0, [sp, #104]
#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
    4800fdf0:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fdf4:	91184000 	add	x0, x0, #0x610
    4800fdf8:	f9400000 	ldr	x0, [x0]
    4800fdfc:	f100001f 	cmp	x0, #0x0
    4800fe00:	540000a1 	b.ne	4800fe14 <rt_kprintf+0xe4>  // b.any
    {
        rt_hw_console_output(rt_log_buf);
    4800fe04:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fe08:	91186000 	add	x0, x0, #0x618
    4800fe0c:	97ffffa6 	bl	4800fca4 <rt_hw_console_output>
    }
#else
    rt_hw_console_output(rt_log_buf);
#endif /* RT_USING_DEVICE */
    va_end(args);
}
    4800fe10:	1400000a 	b	4800fe38 <rt_kprintf+0x108>
        rt_device_write(_console_device, 0, rt_log_buf, length);
    4800fe14:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fe18:	91184000 	add	x0, x0, #0x610
    4800fe1c:	f9400004 	ldr	x4, [x0]
    4800fe20:	f94037e3 	ldr	x3, [sp, #104]
    4800fe24:	d0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4800fe28:	91186002 	add	x2, x0, #0x618
    4800fe2c:	d2800001 	mov	x1, #0x0                   	// #0
    4800fe30:	aa0403e0 	mov	x0, x4
    4800fe34:	97fff3ee 	bl	4800cdec <rt_device_write>
}
    4800fe38:	d503201f 	nop
    4800fe3c:	a8d37bfd 	ldp	x29, x30, [sp], #304
    4800fe40:	d65f03c0 	ret

000000004800fe44 <rt_malloc_align>:
 *
 * @return The memory block address was returned successfully, otherwise it was
 *         returned empty RT_NULL.
 */
RT_WEAK void *rt_malloc_align(rt_size_t size, rt_size_t align)
{
    4800fe44:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4800fe48:	910003fd 	mov	x29, sp
    4800fe4c:	f9000fe0 	str	x0, [sp, #24]
    4800fe50:	f9000be1 	str	x1, [sp, #16]
    void *align_ptr;
    int uintptr_size;
    rt_size_t align_size;

    /* sizeof pointer */
    uintptr_size = sizeof(void*);
    4800fe54:	52800100 	mov	w0, #0x8                   	// #8
    4800fe58:	b9002fe0 	str	w0, [sp, #44]
    uintptr_size -= 1;
    4800fe5c:	b9402fe0 	ldr	w0, [sp, #44]
    4800fe60:	51000400 	sub	w0, w0, #0x1
    4800fe64:	b9002fe0 	str	w0, [sp, #44]

    /* align the alignment size to uintptr size byte */
    align = ((align + uintptr_size) & ~uintptr_size);
    4800fe68:	b9802fe1 	ldrsw	x1, [sp, #44]
    4800fe6c:	f9400be0 	ldr	x0, [sp, #16]
    4800fe70:	8b000021 	add	x1, x1, x0
    4800fe74:	b9402fe0 	ldr	w0, [sp, #44]
    4800fe78:	2a2003e0 	mvn	w0, w0
    4800fe7c:	93407c00 	sxtw	x0, w0
    4800fe80:	8a000020 	and	x0, x1, x0
    4800fe84:	f9000be0 	str	x0, [sp, #16]

    /* get total aligned size */
    align_size = ((size + uintptr_size) & ~uintptr_size) + align;
    4800fe88:	b9802fe1 	ldrsw	x1, [sp, #44]
    4800fe8c:	f9400fe0 	ldr	x0, [sp, #24]
    4800fe90:	8b000021 	add	x1, x1, x0
    4800fe94:	b9402fe0 	ldr	w0, [sp, #44]
    4800fe98:	2a2003e0 	mvn	w0, w0
    4800fe9c:	93407c00 	sxtw	x0, w0
    4800fea0:	8a000020 	and	x0, x1, x0
    4800fea4:	f9400be1 	ldr	x1, [sp, #16]
    4800fea8:	8b000020 	add	x0, x1, x0
    4800feac:	f90013e0 	str	x0, [sp, #32]
    /* allocate memory block from heap */
    ptr = rt_malloc(align_size);
    4800feb0:	f94013e0 	ldr	x0, [sp, #32]
    4800feb4:	97ffe735 	bl	48009b88 <rt_malloc>
    4800feb8:	f9001fe0 	str	x0, [sp, #56]
    if (ptr != RT_NULL)
    4800febc:	f9401fe0 	ldr	x0, [sp, #56]
    4800fec0:	f100001f 	cmp	x0, #0x0
    4800fec4:	54000360 	b.eq	4800ff30 <rt_malloc_align+0xec>  // b.none
    {
        /* the allocated memory block is aligned */
        if (((rt_ubase_t)ptr & (align - 1)) == 0)
    4800fec8:	f9400be0 	ldr	x0, [sp, #16]
    4800fecc:	d1000401 	sub	x1, x0, #0x1
    4800fed0:	f9401fe0 	ldr	x0, [sp, #56]
    4800fed4:	8a000020 	and	x0, x1, x0
    4800fed8:	f100001f 	cmp	x0, #0x0
    4800fedc:	540000c1 	b.ne	4800fef4 <rt_malloc_align+0xb0>  // b.any
        {
            align_ptr = (void *)((rt_ubase_t)ptr + align);
    4800fee0:	f9401fe1 	ldr	x1, [sp, #56]
    4800fee4:	f9400be0 	ldr	x0, [sp, #16]
    4800fee8:	8b000020 	add	x0, x1, x0
    4800feec:	f9001be0 	str	x0, [sp, #48]
    4800fef0:	14000009 	b	4800ff14 <rt_malloc_align+0xd0>
        }
        else
        {
            align_ptr = (void *)(((rt_ubase_t)ptr + (align - 1)) & ~(align - 1));
    4800fef4:	f9401fe1 	ldr	x1, [sp, #56]
    4800fef8:	f9400be0 	ldr	x0, [sp, #16]
    4800fefc:	8b000020 	add	x0, x1, x0
    4800ff00:	d1000401 	sub	x1, x0, #0x1
    4800ff04:	f9400be0 	ldr	x0, [sp, #16]
    4800ff08:	cb0003e0 	neg	x0, x0
    4800ff0c:	8a000020 	and	x0, x1, x0
    4800ff10:	f9001be0 	str	x0, [sp, #48]
        }

        /* set the pointer before alignment pointer to the real pointer */
        *((rt_ubase_t *)((rt_ubase_t)align_ptr - sizeof(void *))) = (rt_ubase_t)ptr;
    4800ff14:	f9401be0 	ldr	x0, [sp, #48]
    4800ff18:	d1002000 	sub	x0, x0, #0x8
    4800ff1c:	aa0003e1 	mov	x1, x0
    4800ff20:	f9401fe0 	ldr	x0, [sp, #56]
    4800ff24:	f9000020 	str	x0, [x1]

        ptr = align_ptr;
    4800ff28:	f9401be0 	ldr	x0, [sp, #48]
    4800ff2c:	f9001fe0 	str	x0, [sp, #56]
    }

    return ptr;
    4800ff30:	f9401fe0 	ldr	x0, [sp, #56]
}
    4800ff34:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4800ff38:	d65f03c0 	ret

000000004800ff3c <rt_free_align>:
 * rt_malloc_align function and address is aligned.
 *
 * @param ptr is the memory block pointer.
 */
RT_WEAK void rt_free_align(void *ptr)
{
    4800ff3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4800ff40:	910003fd 	mov	x29, sp
    4800ff44:	f9000fe0 	str	x0, [sp, #24]
    void *real_ptr;

    real_ptr = (void *) * (rt_ubase_t *)((rt_ubase_t)ptr - sizeof(void *));
    4800ff48:	f9400fe0 	ldr	x0, [sp, #24]
    4800ff4c:	d1002000 	sub	x0, x0, #0x8
    4800ff50:	f9400000 	ldr	x0, [x0]
    4800ff54:	f90017e0 	str	x0, [sp, #40]
    rt_free(real_ptr);
    4800ff58:	f94017e0 	ldr	x0, [sp, #40]
    4800ff5c:	97ffe91a 	bl	4800a3c4 <rt_free>
}
    4800ff60:	d503201f 	nop
    4800ff64:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4800ff68:	d65f03c0 	ret

000000004800ff6c <__rt_ffs>:
 *
 * @return Return the index of the first bit set. If value is 0, then this function
 *         shall return 0.
 */
int __rt_ffs(int value)
{
    4800ff6c:	d10043ff 	sub	sp, sp, #0x10
    4800ff70:	b9000fe0 	str	w0, [sp, #12]
    if (value == 0) return 0;
    4800ff74:	b9400fe0 	ldr	w0, [sp, #12]
    4800ff78:	7100001f 	cmp	w0, #0x0
    4800ff7c:	54000061 	b.ne	4800ff88 <__rt_ffs+0x1c>  // b.any
    4800ff80:	52800000 	mov	w0, #0x0                   	// #0
    4800ff84:	1400002e 	b	4801003c <__rt_ffs+0xd0>

    if (value & 0xff)
    4800ff88:	b9400fe0 	ldr	w0, [sp, #12]
    4800ff8c:	12001c00 	and	w0, w0, #0xff
    4800ff90:	7100001f 	cmp	w0, #0x0
    4800ff94:	54000120 	b.eq	4800ffb8 <__rt_ffs+0x4c>  // b.none
        return __lowest_bit_bitmap[value & 0xff] + 1;
    4800ff98:	b9400fe0 	ldr	w0, [sp, #12]
    4800ff9c:	12001c02 	and	w2, w0, #0xff
    4800ffa0:	90000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ffa4:	9125e001 	add	x1, x0, #0x978
    4800ffa8:	93407c40 	sxtw	x0, w2
    4800ffac:	38606820 	ldrb	w0, [x1, x0]
    4800ffb0:	11000400 	add	w0, w0, #0x1
    4800ffb4:	14000022 	b	4801003c <__rt_ffs+0xd0>

    if (value & 0xff00)
    4800ffb8:	b9400fe0 	ldr	w0, [sp, #12]
    4800ffbc:	12181c00 	and	w0, w0, #0xff00
    4800ffc0:	7100001f 	cmp	w0, #0x0
    4800ffc4:	54000140 	b.eq	4800ffec <__rt_ffs+0x80>  // b.none
        return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
    4800ffc8:	b9400fe0 	ldr	w0, [sp, #12]
    4800ffcc:	13087c00 	asr	w0, w0, #8
    4800ffd0:	12001c02 	and	w2, w0, #0xff
    4800ffd4:	90000080 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4800ffd8:	9125e001 	add	x1, x0, #0x978
    4800ffdc:	93407c40 	sxtw	x0, w2
    4800ffe0:	38606820 	ldrb	w0, [x1, x0]
    4800ffe4:	11002400 	add	w0, w0, #0x9
    4800ffe8:	14000015 	b	4801003c <__rt_ffs+0xd0>

    if (value & 0xff0000)
    4800ffec:	b9400fe0 	ldr	w0, [sp, #12]
    4800fff0:	12101c00 	and	w0, w0, #0xff0000
    4800fff4:	7100001f 	cmp	w0, #0x0
    4800fff8:	54000140 	b.eq	48010020 <__rt_ffs+0xb4>  // b.none
        return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
    4800fffc:	b9400fe0 	ldr	w0, [sp, #12]
    48010000:	13107c00 	asr	w0, w0, #16
    48010004:	12001c02 	and	w2, w0, #0xff
    48010008:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801000c:	9125e001 	add	x1, x0, #0x978
    48010010:	93407c40 	sxtw	x0, w2
    48010014:	38606820 	ldrb	w0, [x1, x0]
    48010018:	11004400 	add	w0, w0, #0x11
    4801001c:	14000008 	b	4801003c <__rt_ffs+0xd0>

    return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
    48010020:	b9400fe0 	ldr	w0, [sp, #12]
    48010024:	53187c02 	lsr	w2, w0, #24
    48010028:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801002c:	9125e001 	add	x1, x0, #0x978
    48010030:	2a0203e0 	mov	w0, w2
    48010034:	38606820 	ldrb	w0, [x1, x0]
    48010038:	11006400 	add	w0, w0, #0x19
}
    4801003c:	910043ff 	add	sp, sp, #0x10
    48010040:	d65f03c0 	ret

0000000048010044 <rt_assert_set_hook>:
 * This function will set a hook function to RT_ASSERT(EX). It will run when the expression is false.
 *
 * @param hook is the hook function.
 */
void rt_assert_set_hook(void (*hook)(const char *ex, const char *func, rt_size_t line))
{
    48010044:	d10043ff 	sub	sp, sp, #0x10
    48010048:	f90007e0 	str	x0, [sp, #8]
    rt_assert_hook = hook;
    4801004c:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010050:	91180000 	add	x0, x0, #0x600
    48010054:	f94007e1 	ldr	x1, [sp, #8]
    48010058:	f9000001 	str	x1, [x0]
}
    4801005c:	d503201f 	nop
    48010060:	910043ff 	add	sp, sp, #0x10
    48010064:	d65f03c0 	ret

0000000048010068 <rt_assert_handler>:
 * @param func is the function name when assertion.
 *
 * @param line is the file line number when assertion.
 */
void rt_assert_handler(const char *ex_string, const char *func, rt_size_t line)
{
    48010068:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801006c:	910003fd 	mov	x29, sp
    48010070:	f90017e0 	str	x0, [sp, #40]
    48010074:	f90013e1 	str	x1, [sp, #32]
    48010078:	f9000fe2 	str	x2, [sp, #24]
    volatile char dummy = 0;
    4801007c:	3900ffff 	strb	wzr, [sp, #63]

    if (rt_assert_hook == RT_NULL)
    48010080:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010084:	91180000 	add	x0, x0, #0x600
    48010088:	f9400000 	ldr	x0, [x0]
    4801008c:	f100001f 	cmp	x0, #0x0
    48010090:	540001a1 	b.ne	480100c4 <rt_assert_handler+0x5c>  // b.any
            dlmodule_exit(-1);
        }
        else
#endif /*RT_USING_MODULE*/
        {
            rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
    48010094:	f9400fe3 	ldr	x3, [sp, #24]
    48010098:	f94013e2 	ldr	x2, [sp, #32]
    4801009c:	f94017e1 	ldr	x1, [sp, #40]
    480100a0:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480100a4:	9129e000 	add	x0, x0, #0xa78
    480100a8:	97ffff22 	bl	4800fd30 <rt_kprintf>
            while (dummy == 0);
    480100ac:	d503201f 	nop
    480100b0:	3940ffe0 	ldrb	w0, [sp, #63]
    480100b4:	12001c00 	and	w0, w0, #0xff
    480100b8:	7100001f 	cmp	w0, #0x0
    480100bc:	54ffffa0 	b.eq	480100b0 <rt_assert_handler+0x48>  // b.none
    }
    else
    {
        rt_assert_hook(ex_string, func, line);
    }
}
    480100c0:	14000008 	b	480100e0 <rt_assert_handler+0x78>
        rt_assert_hook(ex_string, func, line);
    480100c4:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480100c8:	91180000 	add	x0, x0, #0x600
    480100cc:	f9400003 	ldr	x3, [x0]
    480100d0:	f9400fe2 	ldr	x2, [sp, #24]
    480100d4:	f94013e1 	ldr	x1, [sp, #32]
    480100d8:	f94017e0 	ldr	x0, [sp, #40]
    480100dc:	d63f0060 	blr	x3
}
    480100e0:	d503201f 	nop
    480100e4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480100e8:	d65f03c0 	ret

00000000480100ec <rt_tick_get>:
 * @return   Return current tick.
 */
rt_tick_t rt_tick_get(void)
{
    /* return the global tick */
    return rt_tick;
    480100ec:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480100f0:	911a6000 	add	x0, x0, #0x698
    480100f4:	b9400000 	ldr	w0, [x0]
}
    480100f8:	d65f03c0 	ret

00000000480100fc <rt_tick_set>:
 * @brief    This function will set current tick.
 *
 * @param    tick is the value that you will set.
 */
void rt_tick_set(rt_tick_t tick)
{
    480100fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48010100:	910003fd 	mov	x29, sp
    48010104:	b9001fe0 	str	w0, [sp, #28]
    rt_base_t level;

    level = rt_hw_interrupt_disable();
    48010108:	97ffd0c9 	bl	4800442c <rt_hw_interrupt_disable>
    4801010c:	f90017e0 	str	x0, [sp, #40]
    rt_tick = tick;
    48010110:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010114:	911a6000 	add	x0, x0, #0x698
    48010118:	b9401fe1 	ldr	w1, [sp, #28]
    4801011c:	b9000001 	str	w1, [x0]
    rt_hw_interrupt_enable(level);
    48010120:	f94017e0 	ldr	x0, [sp, #40]
    48010124:	97ffd0c6 	bl	4800443c <rt_hw_interrupt_enable>
}
    48010128:	d503201f 	nop
    4801012c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48010130:	d65f03c0 	ret

0000000048010134 <rt_tick_increase>:
/**
 * @brief    This function will notify kernel there is one tick passed.
 *           Normally, this function is invoked by clock ISR.
 */
void rt_tick_increase(void)
{
    48010134:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48010138:	910003fd 	mov	x29, sp
    struct rt_thread *thread;
    rt_base_t level;

    level = rt_hw_interrupt_disable();
    4801013c:	97ffd0bc 	bl	4800442c <rt_hw_interrupt_disable>
    48010140:	f9000fe0 	str	x0, [sp, #24]

    /* increase the global tick */
#ifdef RT_USING_SMP
    rt_cpu_self()->tick ++;
#else
    ++ rt_tick;
    48010144:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010148:	911a6000 	add	x0, x0, #0x698
    4801014c:	b9400000 	ldr	w0, [x0]
    48010150:	11000401 	add	w1, w0, #0x1
    48010154:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010158:	911a6000 	add	x0, x0, #0x698
    4801015c:	b9000001 	str	w1, [x0]
#endif /* RT_USING_SMP */

    /* check time slice */
    thread = rt_thread_self();
    48010160:	97ffee8f 	bl	4800bb9c <rt_thread_self>
    48010164:	f9000be0 	str	x0, [sp, #16]

    -- thread->remaining_tick;
    48010168:	f9400be0 	ldr	x0, [sp, #16]
    4801016c:	f9403c00 	ldr	x0, [x0, #120]
    48010170:	d1000401 	sub	x1, x0, #0x1
    48010174:	f9400be0 	ldr	x0, [sp, #16]
    48010178:	f9003c01 	str	x1, [x0, #120]
    if (thread->remaining_tick == 0)
    4801017c:	f9400be0 	ldr	x0, [sp, #16]
    48010180:	f9403c00 	ldr	x0, [x0, #120]
    48010184:	f100001f 	cmp	x0, #0x0
    48010188:	540001e1 	b.ne	480101c4 <rt_tick_increase+0x90>  // b.any
    {
        /* change to initialized tick */
        thread->remaining_tick = thread->init_tick;
    4801018c:	f9400be0 	ldr	x0, [sp, #16]
    48010190:	f9403801 	ldr	x1, [x0, #112]
    48010194:	f9400be0 	ldr	x0, [sp, #16]
    48010198:	f9003c01 	str	x1, [x0, #120]
        thread->stat |= RT_THREAD_STAT_YIELD;
    4801019c:	f9400be0 	ldr	x0, [sp, #16]
    480101a0:	39418000 	ldrb	w0, [x0, #96]
    480101a4:	321d0000 	orr	w0, w0, #0x8
    480101a8:	12001c01 	and	w1, w0, #0xff
    480101ac:	f9400be0 	ldr	x0, [sp, #16]
    480101b0:	39018001 	strb	w1, [x0, #96]

        rt_hw_interrupt_enable(level);
    480101b4:	f9400fe0 	ldr	x0, [sp, #24]
    480101b8:	97ffd0a1 	bl	4800443c <rt_hw_interrupt_enable>
        rt_schedule();
    480101bc:	97fff474 	bl	4800d38c <rt_schedule>
    480101c0:	14000003 	b	480101cc <rt_tick_increase+0x98>
    }
    else
    {
        rt_hw_interrupt_enable(level);
    480101c4:	f9400fe0 	ldr	x0, [sp, #24]
    480101c8:	97ffd09d 	bl	4800443c <rt_hw_interrupt_enable>
    }

    /* check timer */
    rt_timer_check();
    480101cc:	97ffec34 	bl	4800b29c <rt_timer_check>
}
    480101d0:	d503201f 	nop
    480101d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480101d8:	d65f03c0 	ret

00000000480101dc <rt_tick_from_millisecond>:
 *              - Max 0x7fffffff
 *
 * @return   Return the calculated tick.
 */
rt_tick_t rt_tick_from_millisecond(rt_int32_t ms)
{
    480101dc:	d10083ff 	sub	sp, sp, #0x20
    480101e0:	b9000fe0 	str	w0, [sp, #12]
    rt_tick_t tick;

    if (ms < 0)
    480101e4:	b9400fe0 	ldr	w0, [sp, #12]
    480101e8:	7100001f 	cmp	w0, #0x0
    480101ec:	5400008a 	b.ge	480101fc <rt_tick_from_millisecond+0x20>  // b.tcont
    {
        tick = (rt_tick_t)RT_WAITING_FOREVER;
    480101f0:	12800000 	mov	w0, #0xffffffff            	// #-1
    480101f4:	b9001fe0 	str	w0, [sp, #28]
    480101f8:	14000025 	b	4801028c <rt_tick_from_millisecond+0xb0>
    }
    else
    {
        tick = RT_TICK_PER_SECOND * (ms / 1000);
    480101fc:	b9400fe0 	ldr	w0, [sp, #12]
    48010200:	5289ba61 	mov	w1, #0x4dd3                	// #19923
    48010204:	72a20c41 	movk	w1, #0x1062, lsl #16
    48010208:	9b217c01 	smull	x1, w0, w1
    4801020c:	d360fc21 	lsr	x1, x1, #32
    48010210:	13067c21 	asr	w1, w1, #6
    48010214:	131f7c00 	asr	w0, w0, #31
    48010218:	4b000021 	sub	w1, w1, w0
    4801021c:	52800c80 	mov	w0, #0x64                  	// #100
    48010220:	1b007c20 	mul	w0, w1, w0
    48010224:	b9001fe0 	str	w0, [sp, #28]
        tick += (RT_TICK_PER_SECOND * (ms % 1000) + 999) / 1000;
    48010228:	b9400fe1 	ldr	w1, [sp, #12]
    4801022c:	5289ba60 	mov	w0, #0x4dd3                	// #19923
    48010230:	72a20c40 	movk	w0, #0x1062, lsl #16
    48010234:	9b207c20 	smull	x0, w1, w0
    48010238:	d360fc00 	lsr	x0, x0, #32
    4801023c:	13067c02 	asr	w2, w0, #6
    48010240:	131f7c20 	asr	w0, w1, #31
    48010244:	4b000040 	sub	w0, w2, w0
    48010248:	52807d02 	mov	w2, #0x3e8                 	// #1000
    4801024c:	1b027c00 	mul	w0, w0, w2
    48010250:	4b000020 	sub	w0, w1, w0
    48010254:	52800c81 	mov	w1, #0x64                  	// #100
    48010258:	1b017c00 	mul	w0, w0, w1
    4801025c:	110f9c00 	add	w0, w0, #0x3e7
    48010260:	5289ba61 	mov	w1, #0x4dd3                	// #19923
    48010264:	72a20c41 	movk	w1, #0x1062, lsl #16
    48010268:	9b217c01 	smull	x1, w0, w1
    4801026c:	d360fc21 	lsr	x1, x1, #32
    48010270:	13067c21 	asr	w1, w1, #6
    48010274:	131f7c00 	asr	w0, w0, #31
    48010278:	4b000020 	sub	w0, w1, w0
    4801027c:	2a0003e1 	mov	w1, w0
    48010280:	b9401fe0 	ldr	w0, [sp, #28]
    48010284:	0b010000 	add	w0, w0, w1
    48010288:	b9001fe0 	str	w0, [sp, #28]
    }

    /* return the calculated tick */
    return tick;
    4801028c:	b9401fe0 	ldr	w0, [sp, #28]
}
    48010290:	910083ff 	add	sp, sp, #0x20
    48010294:	d65f03c0 	ret

0000000048010298 <rt_tick_get_millisecond>:
 *           provide the correct 1ms-based tick.
 *
 * @return   Return passed millisecond from boot.
 */
RT_WEAK rt_tick_t rt_tick_get_millisecond(void)
{
    48010298:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4801029c:	910003fd 	mov	x29, sp
#if 1000 % RT_TICK_PER_SECOND == 0u
    return rt_tick_get() * (1000u / RT_TICK_PER_SECOND);
    480102a0:	97ffff93 	bl	480100ec <rt_tick_get>
    480102a4:	2a0003e1 	mov	w1, w0
    480102a8:	52800140 	mov	w0, #0xa                   	// #10
    480102ac:	1b007c20 	mul	w0, w1, w0
#else
    #warning "rt-thread cannot provide a correct 1ms-based tick any longer,\
    please redefine this function in another file by using a high-precision hard-timer."
    return 0;
#endif /* 1000 % RT_TICK_PER_SECOND == 0u */
}
    480102b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    480102b4:	d65f03c0 	ret

00000000480102b8 <dfs_register>:
 * @param ops the file system instance to be registered.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_register(const struct dfs_filesystem_ops *ops)
{
    480102b8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480102bc:	910003fd 	mov	x29, sp
    480102c0:	f9000fe0 	str	x0, [sp, #24]
    int ret = RT_EOK;
    480102c4:	b9003fff 	str	wzr, [sp, #60]
    const struct dfs_filesystem_ops **empty = NULL;
    480102c8:	f9001bff 	str	xzr, [sp, #48]
    const struct dfs_filesystem_ops **iter;

    /* lock filesystem */
    dfs_lock();
    480102cc:	94000392 	bl	48011114 <dfs_lock>
    /* check if this filesystem was already registered */
    for (iter = &filesystem_operation_table[0];
    480102d0:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480102d4:	911a8000 	add	x0, x0, #0x6a0
    480102d8:	f90017e0 	str	x0, [sp, #40]
    480102dc:	1400001d 	b	48010350 <dfs_register+0x98>
            iter < &filesystem_operation_table[DFS_FILESYSTEM_TYPES_MAX]; iter ++)
    {
        /* find out an empty filesystem type entry */
        if (*iter == NULL)
    480102e0:	f94017e0 	ldr	x0, [sp, #40]
    480102e4:	f9400000 	ldr	x0, [x0]
    480102e8:	f100001f 	cmp	x0, #0x0
    480102ec:	540000e1 	b.ne	48010308 <dfs_register+0x50>  // b.any
            (empty == NULL) ? (empty = iter) : 0;
    480102f0:	f9401be0 	ldr	x0, [sp, #48]
    480102f4:	f100001f 	cmp	x0, #0x0
    480102f8:	54000261 	b.ne	48010344 <dfs_register+0x8c>  // b.any
    480102fc:	f94017e0 	ldr	x0, [sp, #40]
    48010300:	f9001be0 	str	x0, [sp, #48]
    48010304:	14000010 	b	48010344 <dfs_register+0x8c>
        else if (strcmp((*iter)->name, ops->name) == 0)
    48010308:	f94017e0 	ldr	x0, [sp, #40]
    4801030c:	f9400000 	ldr	x0, [x0]
    48010310:	f9400002 	ldr	x2, [x0]
    48010314:	f9400fe0 	ldr	x0, [sp, #24]
    48010318:	f9400000 	ldr	x0, [x0]
    4801031c:	aa0003e1 	mov	x1, x0
    48010320:	aa0203e0 	mov	x0, x2
    48010324:	94002ee7 	bl	4801bec0 <strcmp>
    48010328:	7100001f 	cmp	w0, #0x0
    4801032c:	540000c1 	b.ne	48010344 <dfs_register+0x8c>  // b.any
        {
            rt_set_errno(-EEXIST);
    48010330:	92800200 	mov	x0, #0xffffffffffffffef    	// #-17
    48010334:	97fff7cc 	bl	4800e264 <rt_set_errno>
            ret = -1;
    48010338:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801033c:	b9003fe0 	str	w0, [sp, #60]
            break;
    48010340:	14000009 	b	48010364 <dfs_register+0xac>
            iter < &filesystem_operation_table[DFS_FILESYSTEM_TYPES_MAX]; iter ++)
    48010344:	f94017e0 	ldr	x0, [sp, #40]
    48010348:	91002000 	add	x0, x0, #0x8
    4801034c:	f90017e0 	str	x0, [sp, #40]
    for (iter = &filesystem_operation_table[0];
    48010350:	f94017e1 	ldr	x1, [sp, #40]
    48010354:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010358:	911ac000 	add	x0, x0, #0x6b0
    4801035c:	eb00003f 	cmp	x1, x0
    48010360:	54fffc03 	b.cc	480102e0 <dfs_register+0x28>  // b.lo, b.ul, b.last
        }
    }

    /* save the filesystem's operations */
    if (empty == NULL)
    48010364:	f9401be0 	ldr	x0, [sp, #48]
    48010368:	f100001f 	cmp	x0, #0x0
    4801036c:	54000241 	b.ne	480103b4 <dfs_register+0xfc>  // b.any
    {
        rt_set_errno(-ENOSPC);
    48010370:	92800360 	mov	x0, #0xffffffffffffffe4    	// #-28
    48010374:	97fff7bc 	bl	4800e264 <rt_set_errno>
        LOG_E("There is no space to register this file system (%s).", ops->name);
    48010378:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801037c:	912be000 	add	x0, x0, #0xaf8
    48010380:	97fffe6c 	bl	4800fd30 <rt_kprintf>
    48010384:	f9400fe0 	ldr	x0, [sp, #24]
    48010388:	f9400000 	ldr	x0, [x0]
    4801038c:	aa0003e1 	mov	x1, x0
    48010390:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010394:	912c2000 	add	x0, x0, #0xb08
    48010398:	97fffe66 	bl	4800fd30 <rt_kprintf>
    4801039c:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480103a0:	912d0000 	add	x0, x0, #0xb40
    480103a4:	97fffe63 	bl	4800fd30 <rt_kprintf>
        ret = -1;
    480103a8:	12800000 	mov	w0, #0xffffffff            	// #-1
    480103ac:	b9003fe0 	str	w0, [sp, #60]
    480103b0:	14000007 	b	480103cc <dfs_register+0x114>
    }
    else if (ret == RT_EOK)
    480103b4:	b9403fe0 	ldr	w0, [sp, #60]
    480103b8:	7100001f 	cmp	w0, #0x0
    480103bc:	54000081 	b.ne	480103cc <dfs_register+0x114>  // b.any
    {
        *empty = ops;
    480103c0:	f9401be0 	ldr	x0, [sp, #48]
    480103c4:	f9400fe1 	ldr	x1, [sp, #24]
    480103c8:	f9000001 	str	x1, [x0]
    }

    dfs_unlock();
    480103cc:	9400036b 	bl	48011178 <dfs_unlock>
    return ret;
    480103d0:	b9403fe0 	ldr	w0, [sp, #60]
}
    480103d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480103d8:	d65f03c0 	ret

00000000480103dc <dfs_filesystem_lookup>:
 *
 * @return the found file system or NULL if no file system mounted on
 * specified path
 */
struct dfs_filesystem *dfs_filesystem_lookup(const char *path)
{
    480103dc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480103e0:	910003fd 	mov	x29, sp
    480103e4:	f9000fe0 	str	x0, [sp, #24]
    struct dfs_filesystem *iter;
    struct dfs_filesystem *fs = NULL;
    480103e8:	f9001bff 	str	xzr, [sp, #48]
    uint32_t fspath, prefixlen;

    prefixlen = 0;
    480103ec:	b9002fff 	str	wzr, [sp, #44]

    RT_ASSERT(path);
    480103f0:	f9400fe0 	ldr	x0, [sp, #24]
    480103f4:	f100001f 	cmp	x0, #0x0
    480103f8:	540000e1 	b.ne	48010414 <dfs_filesystem_lookup+0x38>  // b.any
    480103fc:	d2800ac2 	mov	x2, #0x56                  	// #86
    48010400:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010404:	9133a001 	add	x1, x0, #0xce8
    48010408:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801040c:	912d2000 	add	x0, x0, #0xb48
    48010410:	97ffff16 	bl	48010068 <rt_assert_handler>

    /* lock filesystem */
    dfs_lock();
    48010414:	94000340 	bl	48011114 <dfs_lock>

    /* lookup it in the filesystem table */
    for (iter = &filesystem_table[0];
    48010418:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801041c:	911ac000 	add	x0, x0, #0x6b0
    48010420:	f9001fe0 	str	x0, [sp, #56]
    48010424:	14000035 	b	480104f8 <dfs_filesystem_lookup+0x11c>
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    {
        if ((iter->path == NULL) || (iter->ops == NULL))
    48010428:	f9401fe0 	ldr	x0, [sp, #56]
    4801042c:	f9400400 	ldr	x0, [x0, #8]
    48010430:	f100001f 	cmp	x0, #0x0
    48010434:	54000520 	b.eq	480104d8 <dfs_filesystem_lookup+0xfc>  // b.none
    48010438:	f9401fe0 	ldr	x0, [sp, #56]
    4801043c:	f9400800 	ldr	x0, [x0, #16]
    48010440:	f100001f 	cmp	x0, #0x0
    48010444:	540004a0 	b.eq	480104d8 <dfs_filesystem_lookup+0xfc>  // b.none
            continue;

        fspath = strlen(iter->path);
    48010448:	f9401fe0 	ldr	x0, [sp, #56]
    4801044c:	f9400400 	ldr	x0, [x0, #8]
    48010450:	94002f4c 	bl	4801c180 <strlen>
    48010454:	b9002be0 	str	w0, [sp, #40]
        if ((fspath < prefixlen)
    48010458:	b9402be1 	ldr	w1, [sp, #40]
    4801045c:	b9402fe0 	ldr	w0, [sp, #44]
    48010460:	6b00003f 	cmp	w1, w0
    48010464:	540003e3 	b.cc	480104e0 <dfs_filesystem_lookup+0x104>  // b.lo, b.ul, b.last
            || (strncmp(iter->path, path, fspath) != 0))
    48010468:	f9401fe0 	ldr	x0, [sp, #56]
    4801046c:	f9400400 	ldr	x0, [x0, #8]
    48010470:	b9402be1 	ldr	w1, [sp, #40]
    48010474:	aa0103e2 	mov	x2, x1
    48010478:	f9400fe1 	ldr	x1, [sp, #24]
    4801047c:	94002f98 	bl	4801c2dc <strncmp>
    48010480:	7100001f 	cmp	w0, #0x0
    48010484:	540002e1 	b.ne	480104e0 <dfs_filesystem_lookup+0x104>  // b.any
            continue;

        /* check next path separator */
        if (fspath > 1 && (strlen(path) > fspath) && (path[fspath] != '/'))
    48010488:	b9402be0 	ldr	w0, [sp, #40]
    4801048c:	7100041f 	cmp	w0, #0x1
    48010490:	540001a9 	b.ls	480104c4 <dfs_filesystem_lookup+0xe8>  // b.plast
    48010494:	f9400fe0 	ldr	x0, [sp, #24]
    48010498:	94002f3a 	bl	4801c180 <strlen>
    4801049c:	aa0003e1 	mov	x1, x0
    480104a0:	b9402be0 	ldr	w0, [sp, #40]
    480104a4:	eb00003f 	cmp	x1, x0
    480104a8:	540000e9 	b.ls	480104c4 <dfs_filesystem_lookup+0xe8>  // b.plast
    480104ac:	b9402be0 	ldr	w0, [sp, #40]
    480104b0:	f9400fe1 	ldr	x1, [sp, #24]
    480104b4:	8b000020 	add	x0, x1, x0
    480104b8:	39400000 	ldrb	w0, [x0]
    480104bc:	7100bc1f 	cmp	w0, #0x2f
    480104c0:	54000141 	b.ne	480104e8 <dfs_filesystem_lookup+0x10c>  // b.any
            continue;

        fs = iter;
    480104c4:	f9401fe0 	ldr	x0, [sp, #56]
    480104c8:	f9001be0 	str	x0, [sp, #48]
        prefixlen = fspath;
    480104cc:	b9402be0 	ldr	w0, [sp, #40]
    480104d0:	b9002fe0 	str	w0, [sp, #44]
    480104d4:	14000006 	b	480104ec <dfs_filesystem_lookup+0x110>
            continue;
    480104d8:	d503201f 	nop
    480104dc:	14000004 	b	480104ec <dfs_filesystem_lookup+0x110>
            continue;
    480104e0:	d503201f 	nop
    480104e4:	14000002 	b	480104ec <dfs_filesystem_lookup+0x110>
            continue;
    480104e8:	d503201f 	nop
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    480104ec:	f9401fe0 	ldr	x0, [sp, #56]
    480104f0:	91008000 	add	x0, x0, #0x20
    480104f4:	f9001fe0 	str	x0, [sp, #56]
    for (iter = &filesystem_table[0];
    480104f8:	f9401fe1 	ldr	x1, [sp, #56]
    480104fc:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010500:	911bc000 	add	x0, x0, #0x6f0
    48010504:	eb00003f 	cmp	x1, x0
    48010508:	54fff903 	b.cc	48010428 <dfs_filesystem_lookup+0x4c>  // b.lo, b.ul, b.last
    }

    dfs_unlock();
    4801050c:	9400031b 	bl	48011178 <dfs_unlock>

    return fs;
    48010510:	f9401be0 	ldr	x0, [sp, #48]
}
    48010514:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48010518:	d65f03c0 	ret

000000004801051c <dfs_filesystem_get_mounted_path>:
 * @param device the device object which is mounted.
 *
 * @return the mounted path or NULL if none device mounted.
 */
const char *dfs_filesystem_get_mounted_path(struct rt_device *device)
{
    4801051c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48010520:	910003fd 	mov	x29, sp
    48010524:	f9000fe0 	str	x0, [sp, #24]
    const char *path = NULL;
    48010528:	f90017ff 	str	xzr, [sp, #40]
    struct dfs_filesystem *iter;

    dfs_lock();
    4801052c:	940002fa 	bl	48011114 <dfs_lock>
    for (iter = &filesystem_table[0];
    48010530:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010534:	911ac000 	add	x0, x0, #0x6b0
    48010538:	f90013e0 	str	x0, [sp, #32]
    4801053c:	14000012 	b	48010584 <dfs_filesystem_get_mounted_path+0x68>
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    {
        /* find the mounted device */
        if (iter->ops == NULL) continue;
    48010540:	f94013e0 	ldr	x0, [sp, #32]
    48010544:	f9400800 	ldr	x0, [x0, #16]
    48010548:	f100001f 	cmp	x0, #0x0
    4801054c:	54000140 	b.eq	48010574 <dfs_filesystem_get_mounted_path+0x58>  // b.none
        else if (iter->dev_id == device)
    48010550:	f94013e0 	ldr	x0, [sp, #32]
    48010554:	f9400000 	ldr	x0, [x0]
    48010558:	f9400fe1 	ldr	x1, [sp, #24]
    4801055c:	eb00003f 	cmp	x1, x0
    48010560:	540000c1 	b.ne	48010578 <dfs_filesystem_get_mounted_path+0x5c>  // b.any
        {
            path = iter->path;
    48010564:	f94013e0 	ldr	x0, [sp, #32]
    48010568:	f9400400 	ldr	x0, [x0, #8]
    4801056c:	f90017e0 	str	x0, [sp, #40]
            break;
    48010570:	1400000a 	b	48010598 <dfs_filesystem_get_mounted_path+0x7c>
        if (iter->ops == NULL) continue;
    48010574:	d503201f 	nop
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    48010578:	f94013e0 	ldr	x0, [sp, #32]
    4801057c:	91008000 	add	x0, x0, #0x20
    48010580:	f90013e0 	str	x0, [sp, #32]
    for (iter = &filesystem_table[0];
    48010584:	f94013e1 	ldr	x1, [sp, #32]
    48010588:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801058c:	911bc000 	add	x0, x0, #0x6f0
    48010590:	eb00003f 	cmp	x1, x0
    48010594:	54fffd63 	b.cc	48010540 <dfs_filesystem_get_mounted_path+0x24>  // b.lo, b.ul, b.last
        }
    }

    /* release filesystem_table lock */
    dfs_unlock();
    48010598:	940002f8 	bl	48011178 <dfs_unlock>

    return path;
    4801059c:	f94017e0 	ldr	x0, [sp, #40]
}
    480105a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480105a4:	d65f03c0 	ret

00000000480105a8 <dfs_filesystem_get_partition>:
 * @return RT_EOK on successful or -RT_ERROR on failed.
 */
int dfs_filesystem_get_partition(struct dfs_partition *part,
                                 uint8_t         *buf,
                                 uint32_t        pindex)
{
    480105a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480105ac:	910003fd 	mov	x29, sp
    480105b0:	f90017e0 	str	x0, [sp, #40]
    480105b4:	f90013e1 	str	x1, [sp, #32]
    480105b8:	b9001fe2 	str	w2, [sp, #28]
#define DPT_ITEM_SIZE   16          /* partition item size */

    uint8_t *dpt;
    uint8_t type;

    RT_ASSERT(part != NULL);
    480105bc:	f94017e0 	ldr	x0, [sp, #40]
    480105c0:	f100001f 	cmp	x0, #0x0
    480105c4:	540000e1 	b.ne	480105e0 <dfs_filesystem_get_partition+0x38>  // b.any
    480105c8:	d28014c2 	mov	x2, #0xa6                  	// #166
    480105cc:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480105d0:	91340001 	add	x1, x0, #0xd00
    480105d4:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480105d8:	912d4000 	add	x0, x0, #0xb50
    480105dc:	97fffea3 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(buf != NULL);
    480105e0:	f94013e0 	ldr	x0, [sp, #32]
    480105e4:	f100001f 	cmp	x0, #0x0
    480105e8:	540000e1 	b.ne	48010604 <dfs_filesystem_get_partition+0x5c>  // b.any
    480105ec:	d28014e2 	mov	x2, #0xa7                  	// #167
    480105f0:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480105f4:	91340001 	add	x1, x0, #0xd00
    480105f8:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480105fc:	912d8000 	add	x0, x0, #0xb60
    48010600:	97fffe9a 	bl	48010068 <rt_assert_handler>

    dpt = buf + DPT_ADDRESS + pindex * DPT_ITEM_SIZE;
    48010604:	b9401fe0 	ldr	w0, [sp, #28]
    48010608:	531c6c00 	lsl	w0, w0, #4
    4801060c:	2a0003e0 	mov	w0, w0
    48010610:	9106f800 	add	x0, x0, #0x1be
    48010614:	f94013e1 	ldr	x1, [sp, #32]
    48010618:	8b000020 	add	x0, x1, x0
    4801061c:	f9001fe0 	str	x0, [sp, #56]

    /* check if it is a valid partition table */
    if ((*dpt != 0x80) && (*dpt != 0x00))
    48010620:	f9401fe0 	ldr	x0, [sp, #56]
    48010624:	39400000 	ldrb	w0, [x0]
    48010628:	7102001f 	cmp	w0, #0x80
    4801062c:	540000e0 	b.eq	48010648 <dfs_filesystem_get_partition+0xa0>  // b.none
    48010630:	f9401fe0 	ldr	x0, [sp, #56]
    48010634:	39400000 	ldrb	w0, [x0]
    48010638:	7100001f 	cmp	w0, #0x0
    4801063c:	54000060 	b.eq	48010648 <dfs_filesystem_get_partition+0xa0>  // b.none
        return -EIO;
    48010640:	12800080 	mov	w0, #0xfffffffb            	// #-5
    48010644:	1400006c 	b	480107f4 <dfs_filesystem_get_partition+0x24c>

    /* get partition type */
    type = *(dpt + 4);
    48010648:	f9401fe0 	ldr	x0, [sp, #56]
    4801064c:	39401000 	ldrb	w0, [x0, #4]
    48010650:	3900dfe0 	strb	w0, [sp, #55]
    if (type == 0)
    48010654:	3940dfe0 	ldrb	w0, [sp, #55]
    48010658:	7100001f 	cmp	w0, #0x0
    4801065c:	54000061 	b.ne	48010668 <dfs_filesystem_get_partition+0xc0>  // b.any
        return -EIO;
    48010660:	12800080 	mov	w0, #0xfffffffb            	// #-5
    48010664:	14000064 	b	480107f4 <dfs_filesystem_get_partition+0x24c>

    /* set partition information
     *    size is the number of 512-Byte */
    part->type = type;
    48010668:	f94017e0 	ldr	x0, [sp, #40]
    4801066c:	3940dfe1 	ldrb	w1, [sp, #55]
    48010670:	39000001 	strb	w1, [x0]
    part->offset = *(dpt + 8) | *(dpt + 9) << 8 | *(dpt + 10) << 16 | *(dpt + 11) << 24;
    48010674:	f9401fe0 	ldr	x0, [sp, #56]
    48010678:	91002000 	add	x0, x0, #0x8
    4801067c:	39400000 	ldrb	w0, [x0]
    48010680:	2a0003e1 	mov	w1, w0
    48010684:	f9401fe0 	ldr	x0, [sp, #56]
    48010688:	91002400 	add	x0, x0, #0x9
    4801068c:	39400000 	ldrb	w0, [x0]
    48010690:	53185c00 	lsl	w0, w0, #8
    48010694:	2a000021 	orr	w1, w1, w0
    48010698:	f9401fe0 	ldr	x0, [sp, #56]
    4801069c:	91002800 	add	x0, x0, #0xa
    480106a0:	39400000 	ldrb	w0, [x0]
    480106a4:	53103c00 	lsl	w0, w0, #16
    480106a8:	2a000021 	orr	w1, w1, w0
    480106ac:	f9401fe0 	ldr	x0, [sp, #56]
    480106b0:	91002c00 	add	x0, x0, #0xb
    480106b4:	39400000 	ldrb	w0, [x0]
    480106b8:	53081c00 	lsl	w0, w0, #24
    480106bc:	2a000020 	orr	w0, w1, w0
    480106c0:	93407c01 	sxtw	x1, w0
    480106c4:	f94017e0 	ldr	x0, [sp, #40]
    480106c8:	f9000401 	str	x1, [x0, #8]
    part->size = *(dpt + 12) | *(dpt + 13) << 8 | *(dpt + 14) << 16 | *(dpt + 15) << 24;
    480106cc:	f9401fe0 	ldr	x0, [sp, #56]
    480106d0:	91003000 	add	x0, x0, #0xc
    480106d4:	39400000 	ldrb	w0, [x0]
    480106d8:	2a0003e1 	mov	w1, w0
    480106dc:	f9401fe0 	ldr	x0, [sp, #56]
    480106e0:	91003400 	add	x0, x0, #0xd
    480106e4:	39400000 	ldrb	w0, [x0]
    480106e8:	53185c00 	lsl	w0, w0, #8
    480106ec:	2a000021 	orr	w1, w1, w0
    480106f0:	f9401fe0 	ldr	x0, [sp, #56]
    480106f4:	91003800 	add	x0, x0, #0xe
    480106f8:	39400000 	ldrb	w0, [x0]
    480106fc:	53103c00 	lsl	w0, w0, #16
    48010700:	2a000021 	orr	w1, w1, w0
    48010704:	f9401fe0 	ldr	x0, [sp, #56]
    48010708:	91003c00 	add	x0, x0, #0xf
    4801070c:	39400000 	ldrb	w0, [x0]
    48010710:	53081c00 	lsl	w0, w0, #24
    48010714:	2a000020 	orr	w0, w1, w0
    48010718:	93407c01 	sxtw	x1, w0
    4801071c:	f94017e0 	ldr	x0, [sp, #40]
    48010720:	f9000801 	str	x1, [x0, #16]

    rt_kprintf("found part[%d], begin: %d, size: ",
               pindex, part->offset * 512);
    48010724:	f94017e0 	ldr	x0, [sp, #40]
    48010728:	f9400400 	ldr	x0, [x0, #8]
    rt_kprintf("found part[%d], begin: %d, size: ",
    4801072c:	d377d800 	lsl	x0, x0, #9
    48010730:	aa0003e2 	mov	x2, x0
    48010734:	b9401fe1 	ldr	w1, [sp, #28]
    48010738:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801073c:	912dc000 	add	x0, x0, #0xb70
    48010740:	97fffd7c 	bl	4800fd30 <rt_kprintf>
    if ((part->size >> 11) == 0)
    48010744:	f94017e0 	ldr	x0, [sp, #40]
    48010748:	f9400800 	ldr	x0, [x0, #16]
    4801074c:	d34bfc00 	lsr	x0, x0, #11
    48010750:	f100001f 	cmp	x0, #0x0
    48010754:	54000141 	b.ne	4801077c <dfs_filesystem_get_partition+0x1d4>  // b.any
        rt_kprintf("%d%s", part->size >> 1, "KB\n"); /* KB */
    48010758:	f94017e0 	ldr	x0, [sp, #40]
    4801075c:	f9400800 	ldr	x0, [x0, #16]
    48010760:	d341fc01 	lsr	x1, x0, #1
    48010764:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010768:	912e6002 	add	x2, x0, #0xb98
    4801076c:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010770:	912e8000 	add	x0, x0, #0xba0
    48010774:	97fffd6f 	bl	4800fd30 <rt_kprintf>
    48010778:	1400001e 	b	480107f0 <dfs_filesystem_get_partition+0x248>
    else
    {
        unsigned int part_size;
        part_size = part->size >> 11;                /* MB */
    4801077c:	f94017e0 	ldr	x0, [sp, #40]
    48010780:	f9400800 	ldr	x0, [x0, #16]
    48010784:	d34bfc00 	lsr	x0, x0, #11
    48010788:	b90033e0 	str	w0, [sp, #48]
        if ((part_size >> 10) == 0)
    4801078c:	b94033e0 	ldr	w0, [sp, #48]
    48010790:	530a7c00 	lsr	w0, w0, #10
    48010794:	7100001f 	cmp	w0, #0x0
    48010798:	540001a1 	b.ne	480107cc <dfs_filesystem_get_partition+0x224>  // b.any
            rt_kprintf("%d.%d%s", part_size, (part->size >> 1) & 0x3FF, "MB\n");
    4801079c:	f94017e0 	ldr	x0, [sp, #40]
    480107a0:	f9400800 	ldr	x0, [x0, #16]
    480107a4:	d341fc00 	lsr	x0, x0, #1
    480107a8:	92402401 	and	x1, x0, #0x3ff
    480107ac:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480107b0:	912ea003 	add	x3, x0, #0xba8
    480107b4:	aa0103e2 	mov	x2, x1
    480107b8:	b94033e1 	ldr	w1, [sp, #48]
    480107bc:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480107c0:	912ec000 	add	x0, x0, #0xbb0
    480107c4:	97fffd5b 	bl	4800fd30 <rt_kprintf>
    480107c8:	1400000a 	b	480107f0 <dfs_filesystem_get_partition+0x248>
        else
            rt_kprintf("%d.%d%s", part_size >> 10, part_size & 0x3FF, "GB\n");
    480107cc:	b94033e0 	ldr	w0, [sp, #48]
    480107d0:	530a7c01 	lsr	w1, w0, #10
    480107d4:	b94033e0 	ldr	w0, [sp, #48]
    480107d8:	12002402 	and	w2, w0, #0x3ff
    480107dc:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480107e0:	912ee003 	add	x3, x0, #0xbb8
    480107e4:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480107e8:	912ec000 	add	x0, x0, #0xbb0
    480107ec:	97fffd51 	bl	4800fd30 <rt_kprintf>
    }

    return RT_EOK;
    480107f0:	52800000 	mov	w0, #0x0                   	// #0
}
    480107f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480107f8:	d65f03c0 	ret

00000000480107fc <dfs_mount>:
int dfs_mount(const char   *device_name,
              const char   *path,
              const char   *filesystemtype,
              unsigned long rwflag,
              const void   *data)
{
    480107fc:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    48010800:	910003fd 	mov	x29, sp
    48010804:	f9001fe0 	str	x0, [sp, #56]
    48010808:	f9001be1 	str	x1, [sp, #48]
    4801080c:	f90017e2 	str	x2, [sp, #40]
    48010810:	f90013e3 	str	x3, [sp, #32]
    48010814:	f9000fe4 	str	x4, [sp, #24]
    const struct dfs_filesystem_ops **ops;
    struct dfs_filesystem *iter;
    struct dfs_filesystem *fs = NULL;
    48010818:	f9004fff 	str	xzr, [sp, #152]
    char *fullpath = NULL;
    4801081c:	f90047ff 	str	xzr, [sp, #136]
    rt_device_t dev_id;

    /* open specific device */
    if (device_name == NULL)
    48010820:	f9401fe0 	ldr	x0, [sp, #56]
    48010824:	f100001f 	cmp	x0, #0x0
    48010828:	54000061 	b.ne	48010834 <dfs_mount+0x38>  // b.any
    {
        /* which is a non-device filesystem mount */
        dev_id = NULL;
    4801082c:	f9004bff 	str	xzr, [sp, #144]
    48010830:	1400000b 	b	4801085c <dfs_mount+0x60>
    }
    else if ((dev_id = rt_device_find(device_name)) == NULL)
    48010834:	f9401fe0 	ldr	x0, [sp, #56]
    48010838:	97fff00c 	bl	4800c868 <rt_device_find>
    4801083c:	f9004be0 	str	x0, [sp, #144]
    48010840:	f9404be0 	ldr	x0, [sp, #144]
    48010844:	f100001f 	cmp	x0, #0x0
    48010848:	540000a1 	b.ne	4801085c <dfs_mount+0x60>  // b.any
    {
        /* no this device */
        rt_set_errno(-ENODEV);
    4801084c:	92800240 	mov	x0, #0xffffffffffffffed    	// #-19
    48010850:	97fff685 	bl	4800e264 <rt_set_errno>
        return -1;
    48010854:	12800000 	mov	w0, #0xffffffff            	// #-1
    48010858:	140000c1 	b	48010b5c <dfs_mount+0x360>
    }

    /* find out the specific filesystem */
    dfs_lock();
    4801085c:	9400022e 	bl	48011114 <dfs_lock>

    for (ops = &filesystem_operation_table[0];
    48010860:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010864:	911a8000 	add	x0, x0, #0x6a0
    48010868:	f90057e0 	str	x0, [sp, #168]
    4801086c:	1400000f 	b	480108a8 <dfs_mount+0xac>
            ops < &filesystem_operation_table[DFS_FILESYSTEM_TYPES_MAX]; ops++)
        if ((*ops != NULL) && (strcmp((*ops)->name, filesystemtype) == 0))
    48010870:	f94057e0 	ldr	x0, [sp, #168]
    48010874:	f9400000 	ldr	x0, [x0]
    48010878:	f100001f 	cmp	x0, #0x0
    4801087c:	54000100 	b.eq	4801089c <dfs_mount+0xa0>  // b.none
    48010880:	f94057e0 	ldr	x0, [sp, #168]
    48010884:	f9400000 	ldr	x0, [x0]
    48010888:	f9400000 	ldr	x0, [x0]
    4801088c:	f94017e1 	ldr	x1, [sp, #40]
    48010890:	94002d8c 	bl	4801bec0 <strcmp>
    48010894:	7100001f 	cmp	w0, #0x0
    48010898:	54000140 	b.eq	480108c0 <dfs_mount+0xc4>  // b.none
            ops < &filesystem_operation_table[DFS_FILESYSTEM_TYPES_MAX]; ops++)
    4801089c:	f94057e0 	ldr	x0, [sp, #168]
    480108a0:	91002000 	add	x0, x0, #0x8
    480108a4:	f90057e0 	str	x0, [sp, #168]
    for (ops = &filesystem_operation_table[0];
    480108a8:	f94057e1 	ldr	x1, [sp, #168]
    480108ac:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480108b0:	911ac000 	add	x0, x0, #0x6b0
    480108b4:	eb00003f 	cmp	x1, x0
    480108b8:	54fffdc3 	b.cc	48010870 <dfs_mount+0x74>  // b.lo, b.ul, b.last
    480108bc:	14000002 	b	480108c4 <dfs_mount+0xc8>
            break;
    480108c0:	d503201f 	nop

    dfs_unlock();
    480108c4:	9400022d 	bl	48011178 <dfs_unlock>

    if (ops == &filesystem_operation_table[DFS_FILESYSTEM_TYPES_MAX])
    480108c8:	f94057e1 	ldr	x1, [sp, #168]
    480108cc:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480108d0:	911ac000 	add	x0, x0, #0x6b0
    480108d4:	eb00003f 	cmp	x1, x0
    480108d8:	540000a1 	b.ne	480108ec <dfs_mount+0xf0>  // b.any
    {
        /* can't find filesystem */
        rt_set_errno(-ENODEV);
    480108dc:	92800240 	mov	x0, #0xffffffffffffffed    	// #-19
    480108e0:	97fff661 	bl	4800e264 <rt_set_errno>
        return -1;
    480108e4:	12800000 	mov	w0, #0xffffffff            	// #-1
    480108e8:	1400009d 	b	48010b5c <dfs_mount+0x360>
    }

    /* check if there is mount implementation */
    if ((*ops == NULL) || ((*ops)->mount == NULL))
    480108ec:	f94057e0 	ldr	x0, [sp, #168]
    480108f0:	f9400000 	ldr	x0, [x0]
    480108f4:	f100001f 	cmp	x0, #0x0
    480108f8:	540000c0 	b.eq	48010910 <dfs_mount+0x114>  // b.none
    480108fc:	f94057e0 	ldr	x0, [sp, #168]
    48010900:	f9400000 	ldr	x0, [x0]
    48010904:	f9400c00 	ldr	x0, [x0, #24]
    48010908:	f100001f 	cmp	x0, #0x0
    4801090c:	540000a1 	b.ne	48010920 <dfs_mount+0x124>  // b.any
    {
        rt_set_errno(-ENOSYS);
    48010910:	92800ae0 	mov	x0, #0xffffffffffffffa8    	// #-88
    48010914:	97fff654 	bl	4800e264 <rt_set_errno>
        return -1;
    48010918:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801091c:	14000090 	b	48010b5c <dfs_mount+0x360>
    }

    /* make full path for special file */
    fullpath = dfs_normalize_path(NULL, path);
    48010920:	f9401be1 	ldr	x1, [sp, #48]
    48010924:	d2800000 	mov	x0, #0x0                   	// #0
    48010928:	940003b6 	bl	48011800 <dfs_normalize_path>
    4801092c:	f90047e0 	str	x0, [sp, #136]
    if (fullpath == NULL) /* not an abstract path */
    48010930:	f94047e0 	ldr	x0, [sp, #136]
    48010934:	f100001f 	cmp	x0, #0x0
    48010938:	540000a1 	b.ne	4801094c <dfs_mount+0x150>  // b.any
    {
        rt_set_errno(-ENOTDIR);
    4801093c:	92800260 	mov	x0, #0xffffffffffffffec    	// #-20
    48010940:	97fff649 	bl	4800e264 <rt_set_errno>
        return -1;
    48010944:	12800000 	mov	w0, #0xffffffff            	// #-1
    48010948:	14000085 	b	48010b5c <dfs_mount+0x360>
    }

    /* Check if the path exists or not, raw APIs call, fixme */
    if ((strcmp(fullpath, "/") != 0) && (strcmp(fullpath, "/dev") != 0))
    4801094c:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010950:	912f0001 	add	x1, x0, #0xbc0
    48010954:	f94047e0 	ldr	x0, [sp, #136]
    48010958:	94002d5a 	bl	4801bec0 <strcmp>
    4801095c:	7100001f 	cmp	w0, #0x0
    48010960:	540002a0 	b.eq	480109b4 <dfs_mount+0x1b8>  // b.none
    48010964:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010968:	912f2001 	add	x1, x0, #0xbc8
    4801096c:	f94047e0 	ldr	x0, [sp, #136]
    48010970:	94002d54 	bl	4801bec0 <strcmp>
    48010974:	7100001f 	cmp	w0, #0x0
    48010978:	540001e0 	b.eq	480109b4 <dfs_mount+0x1b8>  // b.none
    {
        struct dfs_fd fd;

        if (dfs_file_open(&fd, fullpath, O_RDONLY | O_DIRECTORY) < 0)
    4801097c:	910103e0 	add	x0, sp, #0x40
    48010980:	52a00402 	mov	w2, #0x200000              	// #2097152
    48010984:	f94047e1 	ldr	x1, [sp, #136]
    48010988:	94000515 	bl	48011ddc <dfs_file_open>
    4801098c:	7100001f 	cmp	w0, #0x0
    48010990:	540000ea 	b.ge	480109ac <dfs_mount+0x1b0>  // b.tcont
        {
            rt_free(fullpath);
    48010994:	f94047e0 	ldr	x0, [sp, #136]
    48010998:	97ffe68b 	bl	4800a3c4 <rt_free>
            rt_set_errno(-ENOTDIR);
    4801099c:	92800260 	mov	x0, #0xffffffffffffffec    	// #-20
    480109a0:	97fff631 	bl	4800e264 <rt_set_errno>

            return -1;
    480109a4:	12800000 	mov	w0, #0xffffffff            	// #-1
    480109a8:	1400006d 	b	48010b5c <dfs_mount+0x360>
        }
        dfs_file_close(&fd);
    480109ac:	910103e0 	add	x0, sp, #0x40
    480109b0:	9400058d 	bl	48011fe4 <dfs_file_close>
    }

    /* check whether the file system mounted or not  in the filesystem table
     * if it is unmounted yet, find out an empty entry */
    dfs_lock();
    480109b4:	940001d8 	bl	48011114 <dfs_lock>

    for (iter = &filesystem_table[0];
    480109b8:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480109bc:	911ac000 	add	x0, x0, #0x6b0
    480109c0:	f90053e0 	str	x0, [sp, #160]
    480109c4:	14000017 	b	48010a20 <dfs_mount+0x224>
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    {
        /* check if it is an empty filesystem table entry? if it is, save fs */
        if (iter->ops == NULL)
    480109c8:	f94053e0 	ldr	x0, [sp, #160]
    480109cc:	f9400800 	ldr	x0, [x0, #16]
    480109d0:	f100001f 	cmp	x0, #0x0
    480109d4:	540000e1 	b.ne	480109f0 <dfs_mount+0x1f4>  // b.any
            (fs == NULL) ? (fs = iter) : 0;
    480109d8:	f9404fe0 	ldr	x0, [sp, #152]
    480109dc:	f100001f 	cmp	x0, #0x0
    480109e0:	540001a1 	b.ne	48010a14 <dfs_mount+0x218>  // b.any
    480109e4:	f94053e0 	ldr	x0, [sp, #160]
    480109e8:	f9004fe0 	str	x0, [sp, #152]
    480109ec:	1400000a 	b	48010a14 <dfs_mount+0x218>
        /* check if the PATH is mounted */
        else if (strcmp(iter->path, path) == 0)
    480109f0:	f94053e0 	ldr	x0, [sp, #160]
    480109f4:	f9400400 	ldr	x0, [x0, #8]
    480109f8:	f9401be1 	ldr	x1, [sp, #48]
    480109fc:	94002d31 	bl	4801bec0 <strcmp>
    48010a00:	7100001f 	cmp	w0, #0x0
    48010a04:	54000081 	b.ne	48010a14 <dfs_mount+0x218>  // b.any
        {
            rt_set_errno(-EINVAL);
    48010a08:	928002a0 	mov	x0, #0xffffffffffffffea    	// #-22
    48010a0c:	97fff616 	bl	4800e264 <rt_set_errno>
            goto err1;
    48010a10:	1400004f 	b	48010b4c <dfs_mount+0x350>
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    48010a14:	f94053e0 	ldr	x0, [sp, #160]
    48010a18:	91008000 	add	x0, x0, #0x20
    48010a1c:	f90053e0 	str	x0, [sp, #160]
    for (iter = &filesystem_table[0];
    48010a20:	f94053e1 	ldr	x1, [sp, #160]
    48010a24:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010a28:	911bc000 	add	x0, x0, #0x6f0
    48010a2c:	eb00003f 	cmp	x1, x0
    48010a30:	54fffcc3 	b.cc	480109c8 <dfs_mount+0x1cc>  // b.lo, b.ul, b.last
        }
    }

    if ((fs == NULL) && (iter == &filesystem_table[DFS_FILESYSTEMS_MAX]))
    48010a34:	f9404fe0 	ldr	x0, [sp, #152]
    48010a38:	f100001f 	cmp	x0, #0x0
    48010a3c:	54000261 	b.ne	48010a88 <dfs_mount+0x28c>  // b.any
    48010a40:	f94053e1 	ldr	x1, [sp, #160]
    48010a44:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010a48:	911bc000 	add	x0, x0, #0x6f0
    48010a4c:	eb00003f 	cmp	x1, x0
    48010a50:	540001c1 	b.ne	48010a88 <dfs_mount+0x28c>  // b.any
    {
        rt_set_errno(-ENOSPC);
    48010a54:	92800360 	mov	x0, #0xffffffffffffffe4    	// #-28
    48010a58:	97fff603 	bl	4800e264 <rt_set_errno>
        LOG_E("There is no space to mount this file system (%s).", filesystemtype);
    48010a5c:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010a60:	912be000 	add	x0, x0, #0xaf8
    48010a64:	97fffcb3 	bl	4800fd30 <rt_kprintf>
    48010a68:	f94017e1 	ldr	x1, [sp, #40]
    48010a6c:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010a70:	912f4000 	add	x0, x0, #0xbd0
    48010a74:	97fffcaf 	bl	4800fd30 <rt_kprintf>
    48010a78:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010a7c:	912d0000 	add	x0, x0, #0xb40
    48010a80:	97fffcac 	bl	4800fd30 <rt_kprintf>
        goto err1;
    48010a84:	14000032 	b	48010b4c <dfs_mount+0x350>
    }

    /* register file system */
    fs->path   = fullpath;
    48010a88:	f9404fe0 	ldr	x0, [sp, #152]
    48010a8c:	f94047e1 	ldr	x1, [sp, #136]
    48010a90:	f9000401 	str	x1, [x0, #8]
    fs->ops    = *ops;
    48010a94:	f94057e0 	ldr	x0, [sp, #168]
    48010a98:	f9400001 	ldr	x1, [x0]
    48010a9c:	f9404fe0 	ldr	x0, [sp, #152]
    48010aa0:	f9000801 	str	x1, [x0, #16]
    fs->dev_id = dev_id;
    48010aa4:	f9404fe0 	ldr	x0, [sp, #152]
    48010aa8:	f9404be1 	ldr	x1, [sp, #144]
    48010aac:	f9000001 	str	x1, [x0]
    /* release filesystem_table lock */
    dfs_unlock();
    48010ab0:	940001b2 	bl	48011178 <dfs_unlock>

    /* open device, but do not check the status of device */
    if (dev_id != NULL)
    48010ab4:	f9404be0 	ldr	x0, [sp, #144]
    48010ab8:	f100001f 	cmp	x0, #0x0
    48010abc:	540001a0 	b.eq	48010af0 <dfs_mount+0x2f4>  // b.none
    {
        if (rt_device_open(fs->dev_id,
    48010ac0:	f9404fe0 	ldr	x0, [sp, #152]
    48010ac4:	f9400000 	ldr	x0, [x0]
    48010ac8:	52800061 	mov	w1, #0x3                   	// #3
    48010acc:	97ffefe3 	bl	4800ca58 <rt_device_open>
    48010ad0:	f100001f 	cmp	x0, #0x0
    48010ad4:	540000e0 	b.eq	48010af0 <dfs_mount+0x2f4>  // b.none
                           RT_DEVICE_OFLAG_RDWR) != RT_EOK)
        {
            /* The underlying device has error, clear the entry. */
            dfs_lock();
    48010ad8:	9400018f 	bl	48011114 <dfs_lock>
            memset(fs, 0, sizeof(struct dfs_filesystem));
    48010adc:	d2800402 	mov	x2, #0x20                  	// #32
    48010ae0:	52800001 	mov	w1, #0x0                   	// #0
    48010ae4:	f9404fe0 	ldr	x0, [sp, #152]
    48010ae8:	94002c76 	bl	4801bcc0 <memset>

            goto err1;
    48010aec:	14000018 	b	48010b4c <dfs_mount+0x350>
        }
    }

    /* call mount of this filesystem */
    if ((*ops)->mount(fs, rwflag, data) < 0)
    48010af0:	f94057e0 	ldr	x0, [sp, #168]
    48010af4:	f9400000 	ldr	x0, [x0]
    48010af8:	f9400c03 	ldr	x3, [x0, #24]
    48010afc:	f9400fe2 	ldr	x2, [sp, #24]
    48010b00:	f94013e1 	ldr	x1, [sp, #32]
    48010b04:	f9404fe0 	ldr	x0, [sp, #152]
    48010b08:	d63f0060 	blr	x3
    48010b0c:	7100001f 	cmp	w0, #0x0
    48010b10:	540001aa 	b.ge	48010b44 <dfs_mount+0x348>  // b.tcont
    {
        /* close device */
        if (dev_id != NULL)
    48010b14:	f9404be0 	ldr	x0, [sp, #144]
    48010b18:	f100001f 	cmp	x0, #0x0
    48010b1c:	54000080 	b.eq	48010b2c <dfs_mount+0x330>  // b.none
            rt_device_close(fs->dev_id);
    48010b20:	f9404fe0 	ldr	x0, [sp, #152]
    48010b24:	f9400000 	ldr	x0, [x0]
    48010b28:	97fff040 	bl	4800cc28 <rt_device_close>

        /* mount failed */
        dfs_lock();
    48010b2c:	9400017a 	bl	48011114 <dfs_lock>
        /* clear filesystem table entry */
        memset(fs, 0, sizeof(struct dfs_filesystem));
    48010b30:	d2800402 	mov	x2, #0x20                  	// #32
    48010b34:	52800001 	mov	w1, #0x0                   	// #0
    48010b38:	f9404fe0 	ldr	x0, [sp, #152]
    48010b3c:	94002c61 	bl	4801bcc0 <memset>

        goto err1;
    48010b40:	14000003 	b	48010b4c <dfs_mount+0x350>
    }

    return 0;
    48010b44:	52800000 	mov	w0, #0x0                   	// #0
    48010b48:	14000005 	b	48010b5c <dfs_mount+0x360>

err1:
    dfs_unlock();
    48010b4c:	9400018b 	bl	48011178 <dfs_unlock>
    rt_free(fullpath);
    48010b50:	f94047e0 	ldr	x0, [sp, #136]
    48010b54:	97ffe61c 	bl	4800a3c4 <rt_free>

    return -1;
    48010b58:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    48010b5c:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    48010b60:	d65f03c0 	ret

0000000048010b64 <dfs_unmount>:
 * @param specialfile the specified path which mounted a file system.
 *
 * @return 0 on successful or -1 on failed.
 */
int dfs_unmount(const char *specialfile)
{
    48010b64:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48010b68:	910003fd 	mov	x29, sp
    48010b6c:	f9000fe0 	str	x0, [sp, #24]
    char *fullpath;
    struct dfs_filesystem *iter;
    struct dfs_filesystem *fs = NULL;
    48010b70:	f9001bff 	str	xzr, [sp, #48]

    fullpath = dfs_normalize_path(NULL, specialfile);
    48010b74:	f9400fe1 	ldr	x1, [sp, #24]
    48010b78:	d2800000 	mov	x0, #0x0                   	// #0
    48010b7c:	94000321 	bl	48011800 <dfs_normalize_path>
    48010b80:	f90017e0 	str	x0, [sp, #40]
    if (fullpath == NULL)
    48010b84:	f94017e0 	ldr	x0, [sp, #40]
    48010b88:	f100001f 	cmp	x0, #0x0
    48010b8c:	540000a1 	b.ne	48010ba0 <dfs_unmount+0x3c>  // b.any
    {
        rt_set_errno(-ENOTDIR);
    48010b90:	92800260 	mov	x0, #0xffffffffffffffec    	// #-20
    48010b94:	97fff5b4 	bl	4800e264 <rt_set_errno>

        return -1;
    48010b98:	12800000 	mov	w0, #0xffffffff            	// #-1
    48010b9c:	14000046 	b	48010cb4 <dfs_unmount+0x150>
    }

    /* lock filesystem */
    dfs_lock();
    48010ba0:	9400015d 	bl	48011114 <dfs_lock>

    for (iter = &filesystem_table[0];
    48010ba4:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010ba8:	911ac000 	add	x0, x0, #0x6b0
    48010bac:	f9001fe0 	str	x0, [sp, #56]
    48010bb0:	14000011 	b	48010bf4 <dfs_unmount+0x90>
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    {
        /* check if the PATH is mounted */
        if ((iter->path != NULL) && (strcmp(iter->path, fullpath) == 0))
    48010bb4:	f9401fe0 	ldr	x0, [sp, #56]
    48010bb8:	f9400400 	ldr	x0, [x0, #8]
    48010bbc:	f100001f 	cmp	x0, #0x0
    48010bc0:	54000140 	b.eq	48010be8 <dfs_unmount+0x84>  // b.none
    48010bc4:	f9401fe0 	ldr	x0, [sp, #56]
    48010bc8:	f9400400 	ldr	x0, [x0, #8]
    48010bcc:	f94017e1 	ldr	x1, [sp, #40]
    48010bd0:	94002cbc 	bl	4801bec0 <strcmp>
    48010bd4:	7100001f 	cmp	w0, #0x0
    48010bd8:	54000081 	b.ne	48010be8 <dfs_unmount+0x84>  // b.any
        {
            fs = iter;
    48010bdc:	f9401fe0 	ldr	x0, [sp, #56]
    48010be0:	f9001be0 	str	x0, [sp, #48]
            break;
    48010be4:	14000009 	b	48010c08 <dfs_unmount+0xa4>
            iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    48010be8:	f9401fe0 	ldr	x0, [sp, #56]
    48010bec:	91008000 	add	x0, x0, #0x20
    48010bf0:	f9001fe0 	str	x0, [sp, #56]
    for (iter = &filesystem_table[0];
    48010bf4:	f9401fe1 	ldr	x1, [sp, #56]
    48010bf8:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010bfc:	911bc000 	add	x0, x0, #0x6f0
    48010c00:	eb00003f 	cmp	x1, x0
    48010c04:	54fffd83 	b.cc	48010bb4 <dfs_unmount+0x50>  // b.lo, b.ul, b.last
        }
    }

    if (fs == NULL ||
    48010c08:	f9401be0 	ldr	x0, [sp, #48]
    48010c0c:	f100001f 	cmp	x0, #0x0
    48010c10:	54000480 	b.eq	48010ca0 <dfs_unmount+0x13c>  // b.none
        fs->ops->unmount == NULL ||
    48010c14:	f9401be0 	ldr	x0, [sp, #48]
    48010c18:	f9400800 	ldr	x0, [x0, #16]
    48010c1c:	f9401000 	ldr	x0, [x0, #32]
    if (fs == NULL ||
    48010c20:	f100001f 	cmp	x0, #0x0
    48010c24:	540003e0 	b.eq	48010ca0 <dfs_unmount+0x13c>  // b.none
        fs->ops->unmount(fs) < 0)
    48010c28:	f9401be0 	ldr	x0, [sp, #48]
    48010c2c:	f9400800 	ldr	x0, [x0, #16]
    48010c30:	f9401001 	ldr	x1, [x0, #32]
    48010c34:	f9401be0 	ldr	x0, [sp, #48]
    48010c38:	d63f0020 	blr	x1
        fs->ops->unmount == NULL ||
    48010c3c:	7100001f 	cmp	w0, #0x0
    48010c40:	5400030b 	b.lt	48010ca0 <dfs_unmount+0x13c>  // b.tstop
    {
        goto err1;
    }

    /* close device, but do not check the status of device */
    if (fs->dev_id != NULL)
    48010c44:	f9401be0 	ldr	x0, [sp, #48]
    48010c48:	f9400000 	ldr	x0, [x0]
    48010c4c:	f100001f 	cmp	x0, #0x0
    48010c50:	54000080 	b.eq	48010c60 <dfs_unmount+0xfc>  // b.none
        rt_device_close(fs->dev_id);
    48010c54:	f9401be0 	ldr	x0, [sp, #48]
    48010c58:	f9400000 	ldr	x0, [x0]
    48010c5c:	97ffeff3 	bl	4800cc28 <rt_device_close>

    if (fs->path != NULL)
    48010c60:	f9401be0 	ldr	x0, [sp, #48]
    48010c64:	f9400400 	ldr	x0, [x0, #8]
    48010c68:	f100001f 	cmp	x0, #0x0
    48010c6c:	54000080 	b.eq	48010c7c <dfs_unmount+0x118>  // b.none
        rt_free(fs->path);
    48010c70:	f9401be0 	ldr	x0, [sp, #48]
    48010c74:	f9400400 	ldr	x0, [x0, #8]
    48010c78:	97ffe5d3 	bl	4800a3c4 <rt_free>

    /* clear this filesystem table entry */
    memset(fs, 0, sizeof(struct dfs_filesystem));
    48010c7c:	d2800402 	mov	x2, #0x20                  	// #32
    48010c80:	52800001 	mov	w1, #0x0                   	// #0
    48010c84:	f9401be0 	ldr	x0, [sp, #48]
    48010c88:	94002c0e 	bl	4801bcc0 <memset>

    dfs_unlock();
    48010c8c:	9400013b 	bl	48011178 <dfs_unlock>
    rt_free(fullpath);
    48010c90:	f94017e0 	ldr	x0, [sp, #40]
    48010c94:	97ffe5cc 	bl	4800a3c4 <rt_free>

    return 0;
    48010c98:	52800000 	mov	w0, #0x0                   	// #0
    48010c9c:	14000006 	b	48010cb4 <dfs_unmount+0x150>
        goto err1;
    48010ca0:	d503201f 	nop

err1:
    dfs_unlock();
    48010ca4:	94000135 	bl	48011178 <dfs_unlock>
    rt_free(fullpath);
    48010ca8:	f94017e0 	ldr	x0, [sp, #40]
    48010cac:	97ffe5c6 	bl	4800a3c4 <rt_free>

    return -1;
    48010cb0:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    48010cb4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48010cb8:	d65f03c0 	ret

0000000048010cbc <dfs_mkfs>:
 * @param device_name the special device name
 *
 * @return 0 on successful, otherwise failed.
 */
int dfs_mkfs(const char *fs_name, const char *device_name)
{
    48010cbc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48010cc0:	910003fd 	mov	x29, sp
    48010cc4:	f9000fe0 	str	x0, [sp, #24]
    48010cc8:	f9000be1 	str	x1, [sp, #16]
    int index;
    rt_device_t dev_id = NULL;
    48010ccc:	f9001bff 	str	xzr, [sp, #48]

    /* check device name, and it should not be NULL */
    if (device_name != NULL)
    48010cd0:	f9400be0 	ldr	x0, [sp, #16]
    48010cd4:	f100001f 	cmp	x0, #0x0
    48010cd8:	54000080 	b.eq	48010ce8 <dfs_mkfs+0x2c>  // b.none
        dev_id = rt_device_find(device_name);
    48010cdc:	f9400be0 	ldr	x0, [sp, #16]
    48010ce0:	97ffeee2 	bl	4800c868 <rt_device_find>
    48010ce4:	f9001be0 	str	x0, [sp, #48]

    if (dev_id == NULL)
    48010ce8:	f9401be0 	ldr	x0, [sp, #48]
    48010cec:	f100001f 	cmp	x0, #0x0
    48010cf0:	540001e1 	b.ne	48010d2c <dfs_mkfs+0x70>  // b.any
    {
        rt_set_errno(-ENODEV);
    48010cf4:	92800240 	mov	x0, #0xffffffffffffffed    	// #-19
    48010cf8:	97fff55b 	bl	4800e264 <rt_set_errno>
        LOG_E("Device (%s) was not found", device_name);
    48010cfc:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010d00:	912be000 	add	x0, x0, #0xaf8
    48010d04:	97fffc0b 	bl	4800fd30 <rt_kprintf>
    48010d08:	f9400be1 	ldr	x1, [sp, #16]
    48010d0c:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010d10:	91302000 	add	x0, x0, #0xc08
    48010d14:	97fffc07 	bl	4800fd30 <rt_kprintf>
    48010d18:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010d1c:	912d0000 	add	x0, x0, #0xb40
    48010d20:	97fffc04 	bl	4800fd30 <rt_kprintf>
        return -1;
    48010d24:	12800000 	mov	w0, #0xffffffff            	// #-1
    48010d28:	14000046 	b	48010e40 <dfs_mkfs+0x184>
    }

    /* lock file system */
    dfs_lock();
    48010d2c:	940000fa 	bl	48011114 <dfs_lock>
    /* find the file system operations */
    for (index = 0; index < DFS_FILESYSTEM_TYPES_MAX; index ++)
    48010d30:	b9003fff 	str	wzr, [sp, #60]
    48010d34:	14000013 	b	48010d80 <dfs_mkfs+0xc4>
    {
        if (filesystem_operation_table[index] != NULL &&
    48010d38:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010d3c:	911a8000 	add	x0, x0, #0x6a0
    48010d40:	b9803fe1 	ldrsw	x1, [sp, #60]
    48010d44:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    48010d48:	f100001f 	cmp	x0, #0x0
    48010d4c:	54000140 	b.eq	48010d74 <dfs_mkfs+0xb8>  // b.none
            strcmp(filesystem_operation_table[index]->name, fs_name) == 0)
    48010d50:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010d54:	911a8000 	add	x0, x0, #0x6a0
    48010d58:	b9803fe1 	ldrsw	x1, [sp, #60]
    48010d5c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    48010d60:	f9400000 	ldr	x0, [x0]
    48010d64:	f9400fe1 	ldr	x1, [sp, #24]
    48010d68:	94002c56 	bl	4801bec0 <strcmp>
        if (filesystem_operation_table[index] != NULL &&
    48010d6c:	7100001f 	cmp	w0, #0x0
    48010d70:	54000100 	b.eq	48010d90 <dfs_mkfs+0xd4>  // b.none
    for (index = 0; index < DFS_FILESYSTEM_TYPES_MAX; index ++)
    48010d74:	b9403fe0 	ldr	w0, [sp, #60]
    48010d78:	11000400 	add	w0, w0, #0x1
    48010d7c:	b9003fe0 	str	w0, [sp, #60]
    48010d80:	b9403fe0 	ldr	w0, [sp, #60]
    48010d84:	7100041f 	cmp	w0, #0x1
    48010d88:	54fffd8d 	b.le	48010d38 <dfs_mkfs+0x7c>
    48010d8c:	14000002 	b	48010d94 <dfs_mkfs+0xd8>
            break;
    48010d90:	d503201f 	nop
    }
    dfs_unlock();
    48010d94:	940000f9 	bl	48011178 <dfs_unlock>

    if (index < DFS_FILESYSTEM_TYPES_MAX)
    48010d98:	b9403fe0 	ldr	w0, [sp, #60]
    48010d9c:	7100041f 	cmp	w0, #0x1
    48010da0:	540003ac 	b.gt	48010e14 <dfs_mkfs+0x158>
    {
        /* find file system operation */
        const struct dfs_filesystem_ops *ops = filesystem_operation_table[index];
    48010da4:	b0000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48010da8:	911a8000 	add	x0, x0, #0x6a0
    48010dac:	b9803fe1 	ldrsw	x1, [sp, #60]
    48010db0:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    48010db4:	f90017e0 	str	x0, [sp, #40]
        if (ops->mkfs == NULL)
    48010db8:	f94017e0 	ldr	x0, [sp, #40]
    48010dbc:	f9401400 	ldr	x0, [x0, #40]
    48010dc0:	f100001f 	cmp	x0, #0x0
    48010dc4:	540001e1 	b.ne	48010e00 <dfs_mkfs+0x144>  // b.any
        {
            LOG_E("The file system (%s) mkfs function was not implement", fs_name);
    48010dc8:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010dcc:	912be000 	add	x0, x0, #0xaf8
    48010dd0:	97fffbd8 	bl	4800fd30 <rt_kprintf>
    48010dd4:	f9400fe1 	ldr	x1, [sp, #24]
    48010dd8:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010ddc:	9130a000 	add	x0, x0, #0xc28
    48010de0:	97fffbd4 	bl	4800fd30 <rt_kprintf>
    48010de4:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010de8:	912d0000 	add	x0, x0, #0xb40
    48010dec:	97fffbd1 	bl	4800fd30 <rt_kprintf>
            rt_set_errno(-ENOSYS);
    48010df0:	92800ae0 	mov	x0, #0xffffffffffffffa8    	// #-88
    48010df4:	97fff51c 	bl	4800e264 <rt_set_errno>
            return -1;
    48010df8:	12800000 	mov	w0, #0xffffffff            	// #-1
    48010dfc:	14000011 	b	48010e40 <dfs_mkfs+0x184>
        }

        return ops->mkfs(dev_id);
    48010e00:	f94017e0 	ldr	x0, [sp, #40]
    48010e04:	f9401401 	ldr	x1, [x0, #40]
    48010e08:	f9401be0 	ldr	x0, [sp, #48]
    48010e0c:	d63f0020 	blr	x1
    48010e10:	1400000c 	b	48010e40 <dfs_mkfs+0x184>
    }

    LOG_E("File system (%s) was not found.", fs_name);
    48010e14:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010e18:	912be000 	add	x0, x0, #0xaf8
    48010e1c:	97fffbc5 	bl	4800fd30 <rt_kprintf>
    48010e20:	f9400fe1 	ldr	x1, [sp, #24]
    48010e24:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010e28:	91318000 	add	x0, x0, #0xc60
    48010e2c:	97fffbc1 	bl	4800fd30 <rt_kprintf>
    48010e30:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010e34:	912d0000 	add	x0, x0, #0xb40
    48010e38:	97fffbbe 	bl	4800fd30 <rt_kprintf>

    return -1;
    48010e3c:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    48010e40:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48010e44:	d65f03c0 	ret

0000000048010e48 <dfs_statfs>:
 * @param buffer the buffer to save the returned information.
 *
 * @return 0 on successful, others on failed.
 */
int dfs_statfs(const char *path, struct statfs *buffer)
{
    48010e48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48010e4c:	910003fd 	mov	x29, sp
    48010e50:	f9000fe0 	str	x0, [sp, #24]
    48010e54:	f9000be1 	str	x1, [sp, #16]
    struct dfs_filesystem *fs;

    fs = dfs_filesystem_lookup(path);
    48010e58:	f9400fe0 	ldr	x0, [sp, #24]
    48010e5c:	97fffd60 	bl	480103dc <dfs_filesystem_lookup>
    48010e60:	f90017e0 	str	x0, [sp, #40]
    if (fs != NULL)
    48010e64:	f94017e0 	ldr	x0, [sp, #40]
    48010e68:	f100001f 	cmp	x0, #0x0
    48010e6c:	540001a0 	b.eq	48010ea0 <dfs_statfs+0x58>  // b.none
    {
        if (fs->ops->statfs != NULL)
    48010e70:	f94017e0 	ldr	x0, [sp, #40]
    48010e74:	f9400800 	ldr	x0, [x0, #16]
    48010e78:	f9401800 	ldr	x0, [x0, #48]
    48010e7c:	f100001f 	cmp	x0, #0x0
    48010e80:	54000100 	b.eq	48010ea0 <dfs_statfs+0x58>  // b.none
            return fs->ops->statfs(fs, buffer);
    48010e84:	f94017e0 	ldr	x0, [sp, #40]
    48010e88:	f9400800 	ldr	x0, [x0, #16]
    48010e8c:	f9401802 	ldr	x2, [x0, #48]
    48010e90:	f9400be1 	ldr	x1, [sp, #16]
    48010e94:	f94017e0 	ldr	x0, [sp, #40]
    48010e98:	d63f0040 	blr	x2
    48010e9c:	14000002 	b	48010ea4 <dfs_statfs+0x5c>
    }

    return -1;
    48010ea0:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    48010ea4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48010ea8:	d65f03c0 	ret

0000000048010eac <mkfs>:
#endif

#ifdef RT_USING_FINSH
#include <finsh.h>
void mkfs(const char *fs_name, const char *device_name)
{
    48010eac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48010eb0:	910003fd 	mov	x29, sp
    48010eb4:	f9000fe0 	str	x0, [sp, #24]
    48010eb8:	f9000be1 	str	x1, [sp, #16]
    dfs_mkfs(fs_name, device_name);
    48010ebc:	f9400be1 	ldr	x1, [sp, #16]
    48010ec0:	f9400fe0 	ldr	x0, [sp, #24]
    48010ec4:	97ffff7e 	bl	48010cbc <dfs_mkfs>
}
    48010ec8:	d503201f 	nop
    48010ecc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48010ed0:	d65f03c0 	ret

0000000048010ed4 <df>:
FINSH_FUNCTION_EXPORT(mkfs, make a file system);

int df(const char *path)
{
    48010ed4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    48010ed8:	910003fd 	mov	x29, sp
    48010edc:	f9000fe0 	str	x0, [sp, #24]
    int result;
    int minor = 0;
    48010ee0:	b9006fff 	str	wzr, [sp, #108]
    long long cap;
    struct statfs buffer;

    int unit_index = 0;
    48010ee4:	b9005fff 	str	wzr, [sp, #92]
    char *unit_str[] = {"KB", "MB", "GB"};
    48010ee8:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010eec:	91334000 	add	x0, x0, #0xcd0
    48010ef0:	9100a3e2 	add	x2, sp, #0x28
    48010ef4:	aa0003e3 	mov	x3, x0
    48010ef8:	a9400460 	ldp	x0, x1, [x3]
    48010efc:	a9000440 	stp	x0, x1, [x2]
    48010f00:	f9400860 	ldr	x0, [x3, #16]
    48010f04:	f9000840 	str	x0, [x2, #16]

    result = dfs_statfs(path ? path : NULL, &buffer);
    48010f08:	910103e0 	add	x0, sp, #0x40
    48010f0c:	aa0003e1 	mov	x1, x0
    48010f10:	f9400fe0 	ldr	x0, [sp, #24]
    48010f14:	97ffffcd 	bl	48010e48 <dfs_statfs>
    48010f18:	b9005be0 	str	w0, [sp, #88]
    if (result != 0)
    48010f1c:	b9405be0 	ldr	w0, [sp, #88]
    48010f20:	7100001f 	cmp	w0, #0x0
    48010f24:	540000c0 	b.eq	48010f3c <df+0x68>  // b.none
    {
        rt_kprintf("dfs_statfs failed.\n");
    48010f28:	f0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48010f2c:	91320000 	add	x0, x0, #0xc80
    48010f30:	97fffb80 	bl	4800fd30 <rt_kprintf>
        return -1;
    48010f34:	12800000 	mov	w0, #0xffffffff            	// #-1
    48010f38:	1400003b 	b	48011024 <df+0x150>
    }

    cap = ((long long)buffer.f_bsize) * ((long long)buffer.f_bfree) / 1024LL;
    48010f3c:	f94023e0 	ldr	x0, [sp, #64]
    48010f40:	aa0003e1 	mov	x1, x0
    48010f44:	f9402be0 	ldr	x0, [sp, #80]
    48010f48:	9b007c20 	mul	x0, x1, x0
    48010f4c:	910ffc01 	add	x1, x0, #0x3ff
    48010f50:	f100001f 	cmp	x0, #0x0
    48010f54:	9a80b020 	csel	x0, x1, x0, lt  // lt = tstop
    48010f58:	934afc00 	asr	x0, x0, #10
    48010f5c:	f90033e0 	str	x0, [sp, #96]
    for (unit_index = 0; unit_index < 2; unit_index ++)
    48010f60:	b9005fff 	str	wzr, [sp, #92]
    48010f64:	1400001b 	b	48010fd0 <df+0xfc>
    {
        if (cap < 1024) break;
    48010f68:	f94033e0 	ldr	x0, [sp, #96]
    48010f6c:	f10ffc1f 	cmp	x0, #0x3ff
    48010f70:	5400038d 	b.le	48010fe0 <df+0x10c>

        minor = (cap % 1024) * 10 / 1024; /* only one decimal point */
    48010f74:	f94033e0 	ldr	x0, [sp, #96]
    48010f78:	eb0003e1 	negs	x1, x0
    48010f7c:	92402400 	and	x0, x0, #0x3ff
    48010f80:	92402421 	and	x1, x1, #0x3ff
    48010f84:	da814401 	csneg	x1, x0, x1, mi  // mi = first
    48010f88:	aa0103e0 	mov	x0, x1
    48010f8c:	d37ef400 	lsl	x0, x0, #2
    48010f90:	8b010000 	add	x0, x0, x1
    48010f94:	8b000000 	add	x0, x0, x0
    48010f98:	910ffc01 	add	x1, x0, #0x3ff
    48010f9c:	f100001f 	cmp	x0, #0x0
    48010fa0:	9a80b020 	csel	x0, x1, x0, lt  // lt = tstop
    48010fa4:	934afc00 	asr	x0, x0, #10
    48010fa8:	b9006fe0 	str	w0, [sp, #108]
        cap = cap / 1024;
    48010fac:	f94033e0 	ldr	x0, [sp, #96]
    48010fb0:	910ffc01 	add	x1, x0, #0x3ff
    48010fb4:	f100001f 	cmp	x0, #0x0
    48010fb8:	9a80b020 	csel	x0, x1, x0, lt  // lt = tstop
    48010fbc:	934afc00 	asr	x0, x0, #10
    48010fc0:	f90033e0 	str	x0, [sp, #96]
    for (unit_index = 0; unit_index < 2; unit_index ++)
    48010fc4:	b9405fe0 	ldr	w0, [sp, #92]
    48010fc8:	11000400 	add	w0, w0, #0x1
    48010fcc:	b9005fe0 	str	w0, [sp, #92]
    48010fd0:	b9405fe0 	ldr	w0, [sp, #92]
    48010fd4:	7100041f 	cmp	w0, #0x1
    48010fd8:	54fffc8d 	b.le	48010f68 <df+0x94>
    48010fdc:	14000002 	b	48010fe4 <df+0x110>
        if (cap < 1024) break;
    48010fe0:	d503201f 	nop
    }

    rt_kprintf("disk free: %d.%d %s [ %d block, %d bytes per block ]\n",
    48010fe4:	f94033e6 	ldr	x6, [sp, #96]
    48010fe8:	b9805fe0 	ldrsw	x0, [sp, #92]
    48010fec:	d37df000 	lsl	x0, x0, #3
    48010ff0:	9100a3e1 	add	x1, sp, #0x28
    48010ff4:	f8606820 	ldr	x0, [x1, x0]
    48010ff8:	f9402be1 	ldr	x1, [sp, #80]
    48010ffc:	f94023e2 	ldr	x2, [sp, #64]
    48011000:	aa0203e5 	mov	x5, x2
    48011004:	aa0103e4 	mov	x4, x1
    48011008:	aa0003e3 	mov	x3, x0
    4801100c:	b9406fe2 	ldr	w2, [sp, #108]
    48011010:	aa0603e1 	mov	x1, x6
    48011014:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011018:	91326000 	add	x0, x0, #0xc98
    4801101c:	97fffb45 	bl	4800fd30 <rt_kprintf>
               (unsigned long)cap, minor, unit_str[unit_index], buffer.f_bfree, buffer.f_bsize);
    return 0;
    48011020:	52800000 	mov	w0, #0x0                   	// #0
}
    48011024:	a8c77bfd 	ldp	x29, x30, [sp], #112
    48011028:	d65f03c0 	ret

000000004801102c <dfs_init>:

/**
 * this function will initialize device file system.
 */
int dfs_init(void)
{
    4801102c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48011030:	910003fd 	mov	x29, sp
    static rt_bool_t init_ok = RT_FALSE;

    if (init_ok)
    48011034:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48011038:	911d0000 	add	x0, x0, #0x740
    4801103c:	b9400000 	ldr	w0, [x0]
    48011040:	7100001f 	cmp	w0, #0x0
    48011044:	540000c0 	b.eq	4801105c <dfs_init+0x30>  // b.none
    {
        rt_kprintf("dfs already init.\n");
    48011048:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801104c:	91348000 	add	x0, x0, #0xd20
    48011050:	97fffb38 	bl	4800fd30 <rt_kprintf>
        return 0;
    48011054:	52800000 	mov	w0, #0x0                   	// #0
    48011058:	1400002d 	b	4801110c <dfs_init+0xe0>
    }

    /* clear filesystem operations table */
    memset((void *)filesystem_operation_table, 0, sizeof(filesystem_operation_table));
    4801105c:	d2800202 	mov	x2, #0x10                  	// #16
    48011060:	52800001 	mov	w1, #0x0                   	// #0
    48011064:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48011068:	911a8000 	add	x0, x0, #0x6a0
    4801106c:	94002b15 	bl	4801bcc0 <memset>
    /* clear filesystem table */
    memset(filesystem_table, 0, sizeof(filesystem_table));
    48011070:	d2800802 	mov	x2, #0x40                  	// #64
    48011074:	52800001 	mov	w1, #0x0                   	// #0
    48011078:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801107c:	911ac000 	add	x0, x0, #0x6b0
    48011080:	94002b10 	bl	4801bcc0 <memset>
    /* clean fd table */
    memset(&_fdtab, 0, sizeof(_fdtab));
    48011084:	d2800202 	mov	x2, #0x10                  	// #16
    48011088:	52800001 	mov	w1, #0x0                   	// #0
    4801108c:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48011090:	911cc000 	add	x0, x0, #0x730
    48011094:	94002b0b 	bl	4801bcc0 <memset>

    /* create device filesystem lock */
    rt_mutex_init(&fslock, "fslock", RT_IPC_FLAG_PRIO);
    48011098:	52800022 	mov	w2, #0x1                   	// #1
    4801109c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480110a0:	9134e001 	add	x1, x0, #0xd38
    480110a4:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480110a8:	911bc000 	add	x0, x0, #0x6f0
    480110ac:	97ffd51e 	bl	48006524 <rt_mutex_init>

#ifdef DFS_USING_WORKDIR
    /* set current working directory */
    memset(working_directory, 0, sizeof(working_directory));
    480110b0:	d2802002 	mov	x2, #0x100                 	// #256
    480110b4:	52800001 	mov	w1, #0x0                   	// #0
    480110b8:	90000080 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480110bc:	911a6000 	add	x0, x0, #0x698
    480110c0:	94002b00 	bl	4801bcc0 <memset>
    working_directory[0] = '/';
    480110c4:	90000080 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480110c8:	911a6000 	add	x0, x0, #0x698
    480110cc:	528005e1 	mov	w1, #0x2f                  	// #47
    480110d0:	39000001 	strb	w1, [x0]
#ifdef RT_USING_DFS_DEVFS
    {
        extern int devfs_init(void);

        /* if enable devfs, initialize and mount it as soon as possible */
        devfs_init();
    480110d4:	94000a24 	bl	48013964 <devfs_init>

        dfs_mount(NULL, "/dev", "devfs", 0, 0);
    480110d8:	d2800004 	mov	x4, #0x0                   	// #0
    480110dc:	d2800003 	mov	x3, #0x0                   	// #0
    480110e0:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480110e4:	91350002 	add	x2, x0, #0xd40
    480110e8:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480110ec:	91352001 	add	x1, x0, #0xd48
    480110f0:	d2800000 	mov	x0, #0x0                   	// #0
    480110f4:	97fffdc2 	bl	480107fc <dfs_mount>
    }
#endif

    init_ok = RT_TRUE;
    480110f8:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480110fc:	911d0000 	add	x0, x0, #0x740
    48011100:	52800021 	mov	w1, #0x1                   	// #1
    48011104:	b9000001 	str	w1, [x0]

    return 0;
    48011108:	52800000 	mov	w0, #0x0                   	// #0
}
    4801110c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48011110:	d65f03c0 	ret

0000000048011114 <dfs_lock>:
 * this function will lock device file system.
 *
 * @note please don't invoke it on ISR.
 */
void dfs_lock(void)
{
    48011114:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48011118:	910003fd 	mov	x29, sp
    rt_err_t result = -RT_EBUSY;
    4801111c:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
    48011120:	f9000fe0 	str	x0, [sp, #24]

    while (result == -RT_EBUSY)
    48011124:	14000006 	b	4801113c <dfs_lock+0x28>
    {
        result = rt_mutex_take(&fslock, RT_WAITING_FOREVER);
    48011128:	12800001 	mov	w1, #0xffffffff            	// #-1
    4801112c:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48011130:	911bc000 	add	x0, x0, #0x6f0
    48011134:	97ffd5b7 	bl	48006810 <rt_mutex_take>
    48011138:	f9000fe0 	str	x0, [sp, #24]
    while (result == -RT_EBUSY)
    4801113c:	f9400fe0 	ldr	x0, [sp, #24]
    48011140:	b1001c1f 	cmn	x0, #0x7
    48011144:	54ffff20 	b.eq	48011128 <dfs_lock+0x14>  // b.none
    }

    if (result != RT_EOK)
    48011148:	f9400fe0 	ldr	x0, [sp, #24]
    4801114c:	f100001f 	cmp	x0, #0x0
    48011150:	540000e0 	b.eq	4801116c <dfs_lock+0x58>  // b.none
    {
        RT_ASSERT(0);
    48011154:	d2800d62 	mov	x2, #0x6b                  	// #107
    48011158:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801115c:	913a0001 	add	x1, x0, #0xe80
    48011160:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011164:	91354000 	add	x0, x0, #0xd50
    48011168:	97fffbc0 	bl	48010068 <rt_assert_handler>
    }
}
    4801116c:	d503201f 	nop
    48011170:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48011174:	d65f03c0 	ret

0000000048011178 <dfs_unlock>:
 * this function will lock device file system.
 *
 * @note please don't invoke it on ISR.
 */
void dfs_unlock(void)
{
    48011178:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4801117c:	910003fd 	mov	x29, sp
    rt_mutex_release(&fslock);
    48011180:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48011184:	911bc000 	add	x0, x0, #0x6f0
    48011188:	97ffd675 	bl	48006b5c <rt_mutex_release>
}
    4801118c:	d503201f 	nop
    48011190:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48011194:	d65f03c0 	ret

0000000048011198 <fd_alloc>:

static int fd_alloc(struct dfs_fdtable *fdt, int startfd)
{
    48011198:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4801119c:	910003fd 	mov	x29, sp
    480111a0:	f9000bf3 	str	x19, [sp, #16]
    480111a4:	f90017e0 	str	x0, [sp, #40]
    480111a8:	b90027e1 	str	w1, [sp, #36]
    int idx;

    /* find an empty fd entry */
    for (idx = startfd; idx < (int)fdt->maxfd; idx++)
    480111ac:	b94027e0 	ldr	w0, [sp, #36]
    480111b0:	b9004fe0 	str	w0, [sp, #76]
    480111b4:	14000015 	b	48011208 <fd_alloc+0x70>
    {
        if (fdt->fds[idx] == RT_NULL)
    480111b8:	f94017e0 	ldr	x0, [sp, #40]
    480111bc:	f9400401 	ldr	x1, [x0, #8]
    480111c0:	b9804fe0 	ldrsw	x0, [sp, #76]
    480111c4:	d37df000 	lsl	x0, x0, #3
    480111c8:	8b000020 	add	x0, x1, x0
    480111cc:	f9400000 	ldr	x0, [x0]
    480111d0:	f100001f 	cmp	x0, #0x0
    480111d4:	54000280 	b.eq	48011224 <fd_alloc+0x8c>  // b.none
            break;
        if (fdt->fds[idx]->ref_count == 0)
    480111d8:	f94017e0 	ldr	x0, [sp, #40]
    480111dc:	f9400401 	ldr	x1, [x0, #8]
    480111e0:	b9804fe0 	ldrsw	x0, [sp, #76]
    480111e4:	d37df000 	lsl	x0, x0, #3
    480111e8:	8b000020 	add	x0, x1, x0
    480111ec:	f9400000 	ldr	x0, [x0]
    480111f0:	b9401000 	ldr	w0, [x0, #16]
    480111f4:	7100001f 	cmp	w0, #0x0
    480111f8:	540001a0 	b.eq	4801122c <fd_alloc+0x94>  // b.none
    for (idx = startfd; idx < (int)fdt->maxfd; idx++)
    480111fc:	b9404fe0 	ldr	w0, [sp, #76]
    48011200:	11000400 	add	w0, w0, #0x1
    48011204:	b9004fe0 	str	w0, [sp, #76]
    48011208:	f94017e0 	ldr	x0, [sp, #40]
    4801120c:	b9400000 	ldr	w0, [x0]
    48011210:	2a0003e1 	mov	w1, w0
    48011214:	b9404fe0 	ldr	w0, [sp, #76]
    48011218:	6b01001f 	cmp	w0, w1
    4801121c:	54fffceb 	b.lt	480111b8 <fd_alloc+0x20>  // b.tstop
    48011220:	14000004 	b	48011230 <fd_alloc+0x98>
            break;
    48011224:	d503201f 	nop
    48011228:	14000002 	b	48011230 <fd_alloc+0x98>
            break;
    4801122c:	d503201f 	nop
    }

    /* allocate a larger FD container */
    if (idx == fdt->maxfd && fdt->maxfd < DFS_FD_MAX)
    48011230:	f94017e0 	ldr	x0, [sp, #40]
    48011234:	b9400001 	ldr	w1, [x0]
    48011238:	b9404fe0 	ldr	w0, [sp, #76]
    4801123c:	6b00003f 	cmp	w1, w0
    48011240:	54000601 	b.ne	48011300 <fd_alloc+0x168>  // b.any
    48011244:	f94017e0 	ldr	x0, [sp, #40]
    48011248:	b9400000 	ldr	w0, [x0]
    4801124c:	71003c1f 	cmp	w0, #0xf
    48011250:	54000588 	b.hi	48011300 <fd_alloc+0x168>  // b.pmore
    {
        int cnt, index;
        struct dfs_fd **fds;

        /* increase the number of FD with 4 step length */
        cnt = fdt->maxfd + 4;
    48011254:	f94017e0 	ldr	x0, [sp, #40]
    48011258:	b9400000 	ldr	w0, [x0]
    4801125c:	11001000 	add	w0, w0, #0x4
    48011260:	b90047e0 	str	w0, [sp, #68]
        cnt = cnt > DFS_FD_MAX ? DFS_FD_MAX : cnt;
    48011264:	b94047e2 	ldr	w2, [sp, #68]
    48011268:	b94047e1 	ldr	w1, [sp, #68]
    4801126c:	52800200 	mov	w0, #0x10                  	// #16
    48011270:	7100405f 	cmp	w2, #0x10
    48011274:	1a80d020 	csel	w0, w1, w0, le
    48011278:	b90047e0 	str	w0, [sp, #68]

        fds = (struct dfs_fd **)rt_realloc(fdt->fds, cnt * sizeof(struct dfs_fd *));
    4801127c:	f94017e0 	ldr	x0, [sp, #40]
    48011280:	f9400402 	ldr	x2, [x0, #8]
    48011284:	b98047e0 	ldrsw	x0, [sp, #68]
    48011288:	d37df000 	lsl	x0, x0, #3
    4801128c:	aa0003e1 	mov	x1, x0
    48011290:	aa0203e0 	mov	x0, x2
    48011294:	97ffe378 	bl	4800a074 <rt_realloc>
    48011298:	f9001fe0 	str	x0, [sp, #56]
        if (fds == NULL) goto __exit; /* return fdt->maxfd */
    4801129c:	f9401fe0 	ldr	x0, [sp, #56]
    480112a0:	f100001f 	cmp	x0, #0x0
    480112a4:	54000740 	b.eq	4801138c <fd_alloc+0x1f4>  // b.none

        /* clean the new allocated fds */
        for (index = fdt->maxfd; index < cnt; index ++)
    480112a8:	f94017e0 	ldr	x0, [sp, #40]
    480112ac:	b9400000 	ldr	w0, [x0]
    480112b0:	b9004be0 	str	w0, [sp, #72]
    480112b4:	14000009 	b	480112d8 <fd_alloc+0x140>
        {
            fds[index] = NULL;
    480112b8:	b9804be0 	ldrsw	x0, [sp, #72]
    480112bc:	d37df000 	lsl	x0, x0, #3
    480112c0:	f9401fe1 	ldr	x1, [sp, #56]
    480112c4:	8b000020 	add	x0, x1, x0
    480112c8:	f900001f 	str	xzr, [x0]
        for (index = fdt->maxfd; index < cnt; index ++)
    480112cc:	b9404be0 	ldr	w0, [sp, #72]
    480112d0:	11000400 	add	w0, w0, #0x1
    480112d4:	b9004be0 	str	w0, [sp, #72]
    480112d8:	b9404be1 	ldr	w1, [sp, #72]
    480112dc:	b94047e0 	ldr	w0, [sp, #68]
    480112e0:	6b00003f 	cmp	w1, w0
    480112e4:	54fffeab 	b.lt	480112b8 <fd_alloc+0x120>  // b.tstop
        }

        fdt->fds   = fds;
    480112e8:	f94017e0 	ldr	x0, [sp, #40]
    480112ec:	f9401fe1 	ldr	x1, [sp, #56]
    480112f0:	f9000401 	str	x1, [x0, #8]
        fdt->maxfd = cnt;
    480112f4:	b94047e1 	ldr	w1, [sp, #68]
    480112f8:	f94017e0 	ldr	x0, [sp, #40]
    480112fc:	b9000001 	str	w1, [x0]
    }

    /* allocate  'struct dfs_fd' */
    if (idx < (int)fdt->maxfd && fdt->fds[idx] == RT_NULL)
    48011300:	f94017e0 	ldr	x0, [sp, #40]
    48011304:	b9400000 	ldr	w0, [x0]
    48011308:	2a0003e1 	mov	w1, w0
    4801130c:	b9404fe0 	ldr	w0, [sp, #76]
    48011310:	6b01001f 	cmp	w0, w1
    48011314:	5400040a 	b.ge	48011394 <fd_alloc+0x1fc>  // b.tcont
    48011318:	f94017e0 	ldr	x0, [sp, #40]
    4801131c:	f9400401 	ldr	x1, [x0, #8]
    48011320:	b9804fe0 	ldrsw	x0, [sp, #76]
    48011324:	d37df000 	lsl	x0, x0, #3
    48011328:	8b000020 	add	x0, x1, x0
    4801132c:	f9400000 	ldr	x0, [x0]
    48011330:	f100001f 	cmp	x0, #0x0
    48011334:	54000301 	b.ne	48011394 <fd_alloc+0x1fc>  // b.any
    {
        fdt->fds[idx] = (struct dfs_fd *)rt_calloc(1, sizeof(struct dfs_fd));
    48011338:	f94017e0 	ldr	x0, [sp, #40]
    4801133c:	f9400401 	ldr	x1, [x0, #8]
    48011340:	b9804fe0 	ldrsw	x0, [sp, #76]
    48011344:	d37df000 	lsl	x0, x0, #3
    48011348:	8b000033 	add	x19, x1, x0
    4801134c:	d2800901 	mov	x1, #0x48                  	// #72
    48011350:	d2800020 	mov	x0, #0x1                   	// #1
    48011354:	97ffe406 	bl	4800a36c <rt_calloc>
    48011358:	f9000260 	str	x0, [x19]
        if (fdt->fds[idx] == RT_NULL)
    4801135c:	f94017e0 	ldr	x0, [sp, #40]
    48011360:	f9400401 	ldr	x1, [x0, #8]
    48011364:	b9804fe0 	ldrsw	x0, [sp, #76]
    48011368:	d37df000 	lsl	x0, x0, #3
    4801136c:	8b000020 	add	x0, x1, x0
    48011370:	f9400000 	ldr	x0, [x0]
    48011374:	f100001f 	cmp	x0, #0x0
    48011378:	540000e1 	b.ne	48011394 <fd_alloc+0x1fc>  // b.any
            idx = fdt->maxfd;
    4801137c:	f94017e0 	ldr	x0, [sp, #40]
    48011380:	b9400000 	ldr	w0, [x0]
    48011384:	b9004fe0 	str	w0, [sp, #76]
    48011388:	14000004 	b	48011398 <fd_alloc+0x200>
        if (fds == NULL) goto __exit; /* return fdt->maxfd */
    4801138c:	d503201f 	nop
    48011390:	14000002 	b	48011398 <fd_alloc+0x200>
    }

__exit:
    48011394:	d503201f 	nop
    return idx;
    48011398:	b9404fe0 	ldr	w0, [sp, #76]
}
    4801139c:	f9400bf3 	ldr	x19, [sp, #16]
    480113a0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480113a4:	d65f03c0 	ret

00000000480113a8 <fd_new>:
 * This function will allocate a file descriptor.
 *
 * @return -1 on failed or the allocated file descriptor.
 */
int fd_new(void)
{
    480113a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480113ac:	910003fd 	mov	x29, sp
    struct dfs_fd *d;
    int idx;
    struct dfs_fdtable *fdt;

    fdt = dfs_fdtable_get();
    480113b0:	94000200 	bl	48011bb0 <dfs_fdtable_get>
    480113b4:	f90013e0 	str	x0, [sp, #32]
    /* lock filesystem */
    dfs_lock();
    480113b8:	97ffff57 	bl	48011114 <dfs_lock>

    /* find an empty fd entry */
    idx = fd_alloc(fdt, 0);
    480113bc:	52800001 	mov	w1, #0x0                   	// #0
    480113c0:	f94013e0 	ldr	x0, [sp, #32]
    480113c4:	97ffff75 	bl	48011198 <fd_alloc>
    480113c8:	b9002fe0 	str	w0, [sp, #44]

    /* can't find an empty fd entry */
    if (idx == fdt->maxfd)
    480113cc:	f94013e0 	ldr	x0, [sp, #32]
    480113d0:	b9400001 	ldr	w1, [x0]
    480113d4:	b9402fe0 	ldr	w0, [sp, #44]
    480113d8:	6b00003f 	cmp	w1, w0
    480113dc:	540001a1 	b.ne	48011410 <fd_new+0x68>  // b.any
    {
        idx = -(1 + DFS_FD_OFFSET);
    480113e0:	12800060 	mov	w0, #0xfffffffc            	// #-4
    480113e4:	b9002fe0 	str	w0, [sp, #44]
        LOG_E("DFS fd new is failed! Could not found an empty fd entry.");
    480113e8:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480113ec:	91356000 	add	x0, x0, #0xd58
    480113f0:	97fffa50 	bl	4800fd30 <rt_kprintf>
    480113f4:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480113f8:	9135a000 	add	x0, x0, #0xd68
    480113fc:	97fffa4d 	bl	4800fd30 <rt_kprintf>
    48011400:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011404:	9136a000 	add	x0, x0, #0xda8
    48011408:	97fffa4a 	bl	4800fd30 <rt_kprintf>
        goto __result;
    4801140c:	1400000e 	b	48011444 <fd_new+0x9c>
    }

    d = fdt->fds[idx];
    48011410:	f94013e0 	ldr	x0, [sp, #32]
    48011414:	f9400401 	ldr	x1, [x0, #8]
    48011418:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801141c:	d37df000 	lsl	x0, x0, #3
    48011420:	8b000020 	add	x0, x1, x0
    48011424:	f9400000 	ldr	x0, [x0]
    48011428:	f9000fe0 	str	x0, [sp, #24]
    d->ref_count = 1;
    4801142c:	f9400fe0 	ldr	x0, [sp, #24]
    48011430:	52800021 	mov	w1, #0x1                   	// #1
    48011434:	b9001001 	str	w1, [x0, #16]
    d->magic = DFS_FD_MAGIC;
    48011438:	f9400fe0 	ldr	x0, [sp, #24]
    4801143c:	12804041 	mov	w1, #0xfffffdfd            	// #-515
    48011440:	79000001 	strh	w1, [x0]

__result:
    dfs_unlock();
    48011444:	97ffff4d 	bl	48011178 <dfs_unlock>
    return idx + DFS_FD_OFFSET;
    48011448:	b9402fe0 	ldr	w0, [sp, #44]
    4801144c:	11000c00 	add	w0, w0, #0x3
}
    48011450:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48011454:	d65f03c0 	ret

0000000048011458 <fd_get>:
 *
 * @return NULL on on this file descriptor or the file descriptor structure
 * pointer.
 */
struct dfs_fd *fd_get(int fd)
{
    48011458:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801145c:	910003fd 	mov	x29, sp
    48011460:	b9001fe0 	str	w0, [sp, #28]
#ifdef RT_USING_POSIX_STDIO
    if ((0 <= fd) && (fd <= 2))
        fd = libc_stdio_get_console();
#endif /* RT_USING_POSIX_STDIO */

    fdt = dfs_fdtable_get();
    48011464:	940001d3 	bl	48011bb0 <dfs_fdtable_get>
    48011468:	f90017e0 	str	x0, [sp, #40]
    fd = fd - DFS_FD_OFFSET;
    4801146c:	b9401fe0 	ldr	w0, [sp, #28]
    48011470:	51000c00 	sub	w0, w0, #0x3
    48011474:	b9001fe0 	str	w0, [sp, #28]
    if (fd < 0 || fd >= (int)fdt->maxfd)
    48011478:	b9401fe0 	ldr	w0, [sp, #28]
    4801147c:	7100001f 	cmp	w0, #0x0
    48011480:	540000eb 	b.lt	4801149c <fd_get+0x44>  // b.tstop
    48011484:	f94017e0 	ldr	x0, [sp, #40]
    48011488:	b9400000 	ldr	w0, [x0]
    4801148c:	2a0003e1 	mov	w1, w0
    48011490:	b9401fe0 	ldr	w0, [sp, #28]
    48011494:	6b01001f 	cmp	w0, w1
    48011498:	5400006b 	b.lt	480114a4 <fd_get+0x4c>  // b.tstop
        return NULL;
    4801149c:	d2800000 	mov	x0, #0x0                   	// #0
    480114a0:	1400001b 	b	4801150c <fd_get+0xb4>

    dfs_lock();
    480114a4:	97ffff1c 	bl	48011114 <dfs_lock>
    d = fdt->fds[fd];
    480114a8:	f94017e0 	ldr	x0, [sp, #40]
    480114ac:	f9400401 	ldr	x1, [x0, #8]
    480114b0:	b9801fe0 	ldrsw	x0, [sp, #28]
    480114b4:	d37df000 	lsl	x0, x0, #3
    480114b8:	8b000020 	add	x0, x1, x0
    480114bc:	f9400000 	ldr	x0, [x0]
    480114c0:	f90013e0 	str	x0, [sp, #32]

    /* check dfs_fd valid or not */
    if ((d == NULL) || (d->magic != DFS_FD_MAGIC))
    480114c4:	f94013e0 	ldr	x0, [sp, #32]
    480114c8:	f100001f 	cmp	x0, #0x0
    480114cc:	540000c0 	b.eq	480114e4 <fd_get+0x8c>  // b.none
    480114d0:	f94013e0 	ldr	x0, [sp, #32]
    480114d4:	79400001 	ldrh	w1, [x0]
    480114d8:	529fbfa0 	mov	w0, #0xfdfd                	// #65021
    480114dc:	6b00003f 	cmp	w1, w0
    480114e0:	54000080 	b.eq	480114f0 <fd_get+0x98>  // b.none
    {
        dfs_unlock();
    480114e4:	97ffff25 	bl	48011178 <dfs_unlock>
        return NULL;
    480114e8:	d2800000 	mov	x0, #0x0                   	// #0
    480114ec:	14000008 	b	4801150c <fd_get+0xb4>
    }

    /* increase the reference count */
    d->ref_count ++;
    480114f0:	f94013e0 	ldr	x0, [sp, #32]
    480114f4:	b9401000 	ldr	w0, [x0, #16]
    480114f8:	11000401 	add	w1, w0, #0x1
    480114fc:	f94013e0 	ldr	x0, [sp, #32]
    48011500:	b9001001 	str	w1, [x0, #16]
    dfs_unlock();
    48011504:	97ffff1d 	bl	48011178 <dfs_unlock>

    return d;
    48011508:	f94013e0 	ldr	x0, [sp, #32]
}
    4801150c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48011510:	d65f03c0 	ret

0000000048011514 <fd_put>:
 * @ingroup Fd
 *
 * This function will put the file descriptor.
 */
void fd_put(struct dfs_fd *fd)
{
    48011514:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48011518:	910003fd 	mov	x29, sp
    4801151c:	f9000fe0 	str	x0, [sp, #24]
    RT_ASSERT(fd != NULL);
    48011520:	f9400fe0 	ldr	x0, [sp, #24]
    48011524:	f100001f 	cmp	x0, #0x0
    48011528:	540000e1 	b.ne	48011544 <fd_put+0x30>  // b.any
    4801152c:	d2801fa2 	mov	x2, #0xfd                  	// #253
    48011530:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011534:	913a4001 	add	x1, x0, #0xe90
    48011538:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801153c:	9136c000 	add	x0, x0, #0xdb0
    48011540:	97fffaca 	bl	48010068 <rt_assert_handler>

    dfs_lock();
    48011544:	97fffef4 	bl	48011114 <dfs_lock>

    fd->ref_count --;
    48011548:	f9400fe0 	ldr	x0, [sp, #24]
    4801154c:	b9401000 	ldr	w0, [x0, #16]
    48011550:	51000401 	sub	w1, w0, #0x1
    48011554:	f9400fe0 	ldr	x0, [sp, #24]
    48011558:	b9001001 	str	w1, [x0, #16]

    /* clear this fd entry */
    if (fd->ref_count == 0)
    4801155c:	f9400fe0 	ldr	x0, [sp, #24]
    48011560:	b9401000 	ldr	w0, [x0, #16]
    48011564:	7100001f 	cmp	w0, #0x0
    48011568:	54000401 	b.ne	480115e8 <fd_put+0xd4>  // b.any
    {
        int index;
        struct dfs_fdtable *fdt;

        fdt = dfs_fdtable_get();
    4801156c:	94000191 	bl	48011bb0 <dfs_fdtable_get>
    48011570:	f90013e0 	str	x0, [sp, #32]
        for (index = 0; index < (int)fdt->maxfd; index ++)
    48011574:	b9002fff 	str	wzr, [sp, #44]
    48011578:	14000016 	b	480115d0 <fd_put+0xbc>
        {
            if (fdt->fds[index] == fd)
    4801157c:	f94013e0 	ldr	x0, [sp, #32]
    48011580:	f9400401 	ldr	x1, [x0, #8]
    48011584:	b9802fe0 	ldrsw	x0, [sp, #44]
    48011588:	d37df000 	lsl	x0, x0, #3
    4801158c:	8b000020 	add	x0, x1, x0
    48011590:	f9400000 	ldr	x0, [x0]
    48011594:	f9400fe1 	ldr	x1, [sp, #24]
    48011598:	eb00003f 	cmp	x1, x0
    4801159c:	54000141 	b.ne	480115c4 <fd_put+0xb0>  // b.any
            {
                rt_free(fd);
    480115a0:	f9400fe0 	ldr	x0, [sp, #24]
    480115a4:	97ffe388 	bl	4800a3c4 <rt_free>
                fdt->fds[index] = 0;
    480115a8:	f94013e0 	ldr	x0, [sp, #32]
    480115ac:	f9400401 	ldr	x1, [x0, #8]
    480115b0:	b9802fe0 	ldrsw	x0, [sp, #44]
    480115b4:	d37df000 	lsl	x0, x0, #3
    480115b8:	8b000020 	add	x0, x1, x0
    480115bc:	f900001f 	str	xzr, [x0]
                break;
    480115c0:	1400000a 	b	480115e8 <fd_put+0xd4>
        for (index = 0; index < (int)fdt->maxfd; index ++)
    480115c4:	b9402fe0 	ldr	w0, [sp, #44]
    480115c8:	11000400 	add	w0, w0, #0x1
    480115cc:	b9002fe0 	str	w0, [sp, #44]
    480115d0:	f94013e0 	ldr	x0, [sp, #32]
    480115d4:	b9400000 	ldr	w0, [x0]
    480115d8:	2a0003e1 	mov	w1, w0
    480115dc:	b9402fe0 	ldr	w0, [sp, #44]
    480115e0:	6b01001f 	cmp	w0, w1
    480115e4:	54fffccb 	b.lt	4801157c <fd_put+0x68>  // b.tstop
            }
        }
    }
    dfs_unlock();
    480115e8:	97fffee4 	bl	48011178 <dfs_unlock>
}
    480115ec:	d503201f 	nop
    480115f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480115f4:	d65f03c0 	ret

00000000480115f8 <fd_is_open>:
 * @param pathname the file path name.
 *
 * @return 0 on file has been open successfully, -1 on open failed.
 */
int fd_is_open(const char *pathname)
{
    480115f8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    480115fc:	910003fd 	mov	x29, sp
    48011600:	f9000fe0 	str	x0, [sp, #24]
    unsigned int index;
    struct dfs_filesystem *fs;
    struct dfs_fd *fd;
    struct dfs_fdtable *fdt;

    fdt = dfs_fdtable_get();
    48011604:	9400016b 	bl	48011bb0 <dfs_fdtable_get>
    48011608:	f9001fe0 	str	x0, [sp, #56]
    fullpath = dfs_normalize_path(NULL, pathname);
    4801160c:	f9400fe1 	ldr	x1, [sp, #24]
    48011610:	d2800000 	mov	x0, #0x0                   	// #0
    48011614:	9400007b 	bl	48011800 <dfs_normalize_path>
    48011618:	f9001be0 	str	x0, [sp, #48]
    if (fullpath != NULL)
    4801161c:	f9401be0 	ldr	x0, [sp, #48]
    48011620:	f100001f 	cmp	x0, #0x0
    48011624:	54000a20 	b.eq	48011768 <fd_is_open+0x170>  // b.none
    {
        char *mountpath;
        fs = dfs_filesystem_lookup(fullpath);
    48011628:	f9401be0 	ldr	x0, [sp, #48]
    4801162c:	97fffb6c 	bl	480103dc <dfs_filesystem_lookup>
    48011630:	f90017e0 	str	x0, [sp, #40]
        if (fs == NULL)
    48011634:	f94017e0 	ldr	x0, [sp, #40]
    48011638:	f100001f 	cmp	x0, #0x0
    4801163c:	540000a1 	b.ne	48011650 <fd_is_open+0x58>  // b.any
        {
            /* can't find mounted file system */
            rt_free(fullpath);
    48011640:	f9401be0 	ldr	x0, [sp, #48]
    48011644:	97ffe360 	bl	4800a3c4 <rt_free>

            return -1;
    48011648:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801164c:	14000048 	b	4801176c <fd_is_open+0x174>
        }

        /* get file path name under mounted file system */
        if (fs->path[0] == '/' && fs->path[1] == '\0')
    48011650:	f94017e0 	ldr	x0, [sp, #40]
    48011654:	f9400400 	ldr	x0, [x0, #8]
    48011658:	39400000 	ldrb	w0, [x0]
    4801165c:	7100bc1f 	cmp	w0, #0x2f
    48011660:	54000141 	b.ne	48011688 <fd_is_open+0x90>  // b.any
    48011664:	f94017e0 	ldr	x0, [sp, #40]
    48011668:	f9400400 	ldr	x0, [x0, #8]
    4801166c:	91000400 	add	x0, x0, #0x1
    48011670:	39400000 	ldrb	w0, [x0]
    48011674:	7100001f 	cmp	w0, #0x0
    48011678:	54000081 	b.ne	48011688 <fd_is_open+0x90>  // b.any
            mountpath = fullpath;
    4801167c:	f9401be0 	ldr	x0, [sp, #48]
    48011680:	f90023e0 	str	x0, [sp, #64]
    48011684:	14000008 	b	480116a4 <fd_is_open+0xac>
        else
            mountpath = fullpath + strlen(fs->path);
    48011688:	f94017e0 	ldr	x0, [sp, #40]
    4801168c:	f9400400 	ldr	x0, [x0, #8]
    48011690:	94002abc 	bl	4801c180 <strlen>
    48011694:	aa0003e1 	mov	x1, x0
    48011698:	f9401be0 	ldr	x0, [sp, #48]
    4801169c:	8b010000 	add	x0, x0, x1
    480116a0:	f90023e0 	str	x0, [sp, #64]

        dfs_lock();
    480116a4:	97fffe9c 	bl	48011114 <dfs_lock>

        for (index = 0; index < fdt->maxfd; index++)
    480116a8:	b9004fff 	str	wzr, [sp, #76]
    480116ac:	14000027 	b	48011748 <fd_is_open+0x150>
        {
            fd = fdt->fds[index];
    480116b0:	f9401fe0 	ldr	x0, [sp, #56]
    480116b4:	f9400401 	ldr	x1, [x0, #8]
    480116b8:	b9404fe0 	ldr	w0, [sp, #76]
    480116bc:	d37df000 	lsl	x0, x0, #3
    480116c0:	8b000020 	add	x0, x1, x0
    480116c4:	f9400000 	ldr	x0, [x0]
    480116c8:	f90013e0 	str	x0, [sp, #32]
            if (fd == NULL || fd->fops == NULL || fd->path == NULL) continue;
    480116cc:	f94013e0 	ldr	x0, [sp, #32]
    480116d0:	f100001f 	cmp	x0, #0x0
    480116d4:	54000320 	b.eq	48011738 <fd_is_open+0x140>  // b.none
    480116d8:	f94013e0 	ldr	x0, [sp, #32]
    480116dc:	f9401000 	ldr	x0, [x0, #32]
    480116e0:	f100001f 	cmp	x0, #0x0
    480116e4:	540002a0 	b.eq	48011738 <fd_is_open+0x140>  // b.none
    480116e8:	f94013e0 	ldr	x0, [sp, #32]
    480116ec:	f9400400 	ldr	x0, [x0, #8]
    480116f0:	f100001f 	cmp	x0, #0x0
    480116f4:	54000220 	b.eq	48011738 <fd_is_open+0x140>  // b.none

            if (fd->fs == fs && strcmp(fd->path, mountpath) == 0)
    480116f8:	f94013e0 	ldr	x0, [sp, #32]
    480116fc:	f9400c00 	ldr	x0, [x0, #24]
    48011700:	f94017e1 	ldr	x1, [sp, #40]
    48011704:	eb00003f 	cmp	x1, x0
    48011708:	540001a1 	b.ne	4801173c <fd_is_open+0x144>  // b.any
    4801170c:	f94013e0 	ldr	x0, [sp, #32]
    48011710:	f9400400 	ldr	x0, [x0, #8]
    48011714:	f94023e1 	ldr	x1, [sp, #64]
    48011718:	940029ea 	bl	4801bec0 <strcmp>
    4801171c:	7100001f 	cmp	w0, #0x0
    48011720:	540000e1 	b.ne	4801173c <fd_is_open+0x144>  // b.any
            {
                /* found file in file descriptor table */
                rt_free(fullpath);
    48011724:	f9401be0 	ldr	x0, [sp, #48]
    48011728:	97ffe327 	bl	4800a3c4 <rt_free>
                dfs_unlock();
    4801172c:	97fffe93 	bl	48011178 <dfs_unlock>

                return 0;
    48011730:	52800000 	mov	w0, #0x0                   	// #0
    48011734:	1400000e 	b	4801176c <fd_is_open+0x174>
            if (fd == NULL || fd->fops == NULL || fd->path == NULL) continue;
    48011738:	d503201f 	nop
        for (index = 0; index < fdt->maxfd; index++)
    4801173c:	b9404fe0 	ldr	w0, [sp, #76]
    48011740:	11000400 	add	w0, w0, #0x1
    48011744:	b9004fe0 	str	w0, [sp, #76]
    48011748:	f9401fe0 	ldr	x0, [sp, #56]
    4801174c:	b9400000 	ldr	w0, [x0]
    48011750:	b9404fe1 	ldr	w1, [sp, #76]
    48011754:	6b00003f 	cmp	w1, w0
    48011758:	54fffac3 	b.cc	480116b0 <fd_is_open+0xb8>  // b.lo, b.ul, b.last
            }
        }
        dfs_unlock();
    4801175c:	97fffe87 	bl	48011178 <dfs_unlock>

        rt_free(fullpath);
    48011760:	f9401be0 	ldr	x0, [sp, #48]
    48011764:	97ffe318 	bl	4800a3c4 <rt_free>
    }

    return -1;
    48011768:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801176c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48011770:	d65f03c0 	ret

0000000048011774 <dfs_subdir>:
 * @param filename the filename.
 *
 * @return the subdir pointer in filename
 */
const char *dfs_subdir(const char *directory, const char *filename)
{
    48011774:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48011778:	910003fd 	mov	x29, sp
    4801177c:	f9000bf3 	str	x19, [sp, #16]
    48011780:	f90017e0 	str	x0, [sp, #40]
    48011784:	f90013e1 	str	x1, [sp, #32]
    const char *dir;

    if (strlen(directory) == strlen(filename)) /* it's a same path */
    48011788:	f94017e0 	ldr	x0, [sp, #40]
    4801178c:	94002a7d 	bl	4801c180 <strlen>
    48011790:	aa0003f3 	mov	x19, x0
    48011794:	f94013e0 	ldr	x0, [sp, #32]
    48011798:	94002a7a 	bl	4801c180 <strlen>
    4801179c:	eb00027f 	cmp	x19, x0
    480117a0:	54000061 	b.ne	480117ac <dfs_subdir+0x38>  // b.any
        return NULL;
    480117a4:	d2800000 	mov	x0, #0x0                   	// #0
    480117a8:	14000013 	b	480117f4 <dfs_subdir+0x80>

    dir = filename + strlen(directory);
    480117ac:	f94017e0 	ldr	x0, [sp, #40]
    480117b0:	94002a74 	bl	4801c180 <strlen>
    480117b4:	aa0003e1 	mov	x1, x0
    480117b8:	f94013e0 	ldr	x0, [sp, #32]
    480117bc:	8b010000 	add	x0, x0, x1
    480117c0:	f9001fe0 	str	x0, [sp, #56]
    if ((*dir != '/') && (dir != filename))
    480117c4:	f9401fe0 	ldr	x0, [sp, #56]
    480117c8:	39400000 	ldrb	w0, [x0]
    480117cc:	7100bc1f 	cmp	w0, #0x2f
    480117d0:	54000100 	b.eq	480117f0 <dfs_subdir+0x7c>  // b.none
    480117d4:	f9401fe1 	ldr	x1, [sp, #56]
    480117d8:	f94013e0 	ldr	x0, [sp, #32]
    480117dc:	eb00003f 	cmp	x1, x0
    480117e0:	54000080 	b.eq	480117f0 <dfs_subdir+0x7c>  // b.none
    {
        dir --;
    480117e4:	f9401fe0 	ldr	x0, [sp, #56]
    480117e8:	d1000400 	sub	x0, x0, #0x1
    480117ec:	f9001fe0 	str	x0, [sp, #56]
    }

    return dir;
    480117f0:	f9401fe0 	ldr	x0, [sp, #56]
}
    480117f4:	f9400bf3 	ldr	x19, [sp, #16]
    480117f8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480117fc:	d65f03c0 	ret

0000000048011800 <dfs_normalize_path>:
 * @param filename the file name
 *
 * @return the built full file path (absolute path)
 */
char *dfs_normalize_path(const char *directory, const char *filename)
{
    48011800:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    48011804:	910003fd 	mov	x29, sp
    48011808:	f9000bf3 	str	x19, [sp, #16]
    4801180c:	f90017e0 	str	x0, [sp, #40]
    48011810:	f90013e1 	str	x1, [sp, #32]
    char *fullpath;
    char *dst0, *dst, *src;

    /* check parameters */
    RT_ASSERT(filename != NULL);
    48011814:	f94013e0 	ldr	x0, [sp, #32]
    48011818:	f100001f 	cmp	x0, #0x0
    4801181c:	540000e1 	b.ne	48011838 <dfs_normalize_path+0x38>  // b.any
    48011820:	d2802f82 	mov	x2, #0x17c                 	// #380
    48011824:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011828:	913a6001 	add	x1, x0, #0xe98
    4801182c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011830:	91370000 	add	x0, x0, #0xdc0
    48011834:	97fffa0d 	bl	48010068 <rt_assert_handler>

#ifdef DFS_USING_WORKDIR
    if (directory == NULL) /* shall use working directory */
    48011838:	f94017e0 	ldr	x0, [sp, #40]
    4801183c:	f100001f 	cmp	x0, #0x0
    48011840:	54000081 	b.ne	48011850 <dfs_normalize_path+0x50>  // b.any
        directory = &working_directory[0];
    48011844:	90000080 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48011848:	911a6000 	add	x0, x0, #0x698
    4801184c:	f90017e0 	str	x0, [sp, #40]

        return NULL;
    }
#endif

    if (filename[0] != '/') /* it's a absolute path, use it directly */
    48011850:	f94013e0 	ldr	x0, [sp, #32]
    48011854:	39400000 	ldrb	w0, [x0]
    48011858:	7100bc1f 	cmp	w0, #0x2f
    4801185c:	540003a0 	b.eq	480118d0 <dfs_normalize_path+0xd0>  // b.none
    {
        fullpath = (char *)rt_malloc(strlen(directory) + strlen(filename) + 2);
    48011860:	f94017e0 	ldr	x0, [sp, #40]
    48011864:	94002a47 	bl	4801c180 <strlen>
    48011868:	aa0003f3 	mov	x19, x0
    4801186c:	f94013e0 	ldr	x0, [sp, #32]
    48011870:	94002a44 	bl	4801c180 <strlen>
    48011874:	8b000260 	add	x0, x19, x0
    48011878:	91000800 	add	x0, x0, #0x2
    4801187c:	97ffe0c3 	bl	48009b88 <rt_malloc>
    48011880:	f9002fe0 	str	x0, [sp, #88]

        if (fullpath == NULL)
    48011884:	f9402fe0 	ldr	x0, [sp, #88]
    48011888:	f100001f 	cmp	x0, #0x0
    4801188c:	54000061 	b.ne	48011898 <dfs_normalize_path+0x98>  // b.any
            return NULL;
    48011890:	d2800000 	mov	x0, #0x0                   	// #0
    48011894:	140000c4 	b	48011ba4 <dfs_normalize_path+0x3a4>

        /* join path and file name */
        rt_snprintf(fullpath, strlen(directory) + strlen(filename) + 2,
    48011898:	f94017e0 	ldr	x0, [sp, #40]
    4801189c:	94002a39 	bl	4801c180 <strlen>
    480118a0:	aa0003f3 	mov	x19, x0
    480118a4:	f94013e0 	ldr	x0, [sp, #32]
    480118a8:	94002a36 	bl	4801c180 <strlen>
    480118ac:	8b000260 	add	x0, x19, x0
    480118b0:	91000801 	add	x1, x0, #0x2
    480118b4:	f94013e4 	ldr	x4, [sp, #32]
    480118b8:	f94017e3 	ldr	x3, [sp, #40]
    480118bc:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480118c0:	91376002 	add	x2, x0, #0xdd8
    480118c4:	f9402fe0 	ldr	x0, [sp, #88]
    480118c8:	97fff861 	bl	4800fa4c <rt_snprintf>
    480118cc:	14000009 	b	480118f0 <dfs_normalize_path+0xf0>
                    "%s/%s", directory, filename);
    }
    else
    {
        fullpath = rt_strdup(filename); /* copy string */
    480118d0:	f94013e0 	ldr	x0, [sp, #32]
    480118d4:	97fff492 	bl	4800eb1c <rt_strdup>
    480118d8:	f9002fe0 	str	x0, [sp, #88]

        if (fullpath == NULL)
    480118dc:	f9402fe0 	ldr	x0, [sp, #88]
    480118e0:	f100001f 	cmp	x0, #0x0
    480118e4:	54000061 	b.ne	480118f0 <dfs_normalize_path+0xf0>  // b.any
            return NULL;
    480118e8:	d2800000 	mov	x0, #0x0                   	// #0
    480118ec:	140000ae 	b	48011ba4 <dfs_normalize_path+0x3a4>
    }

    src = fullpath;
    480118f0:	f9402fe0 	ldr	x0, [sp, #88]
    480118f4:	f90027e0 	str	x0, [sp, #72]
    dst = fullpath;
    480118f8:	f9402fe0 	ldr	x0, [sp, #88]
    480118fc:	f9002be0 	str	x0, [sp, #80]

    dst0 = dst;
    48011900:	f9402be0 	ldr	x0, [sp, #80]
    48011904:	f9001fe0 	str	x0, [sp, #56]
    while (1)
    {
        char c = *src;
    48011908:	f94027e0 	ldr	x0, [sp, #72]
    4801190c:	39400000 	ldrb	w0, [x0]
    48011910:	39011fe0 	strb	w0, [sp, #71]

        if (c == '.')
    48011914:	39411fe0 	ldrb	w0, [sp, #71]
    48011918:	7100b81f 	cmp	w0, #0x2e
    4801191c:	540008e1 	b.ne	48011a38 <dfs_normalize_path+0x238>  // b.any
        {
            if (!src[1]) src ++; /* '.' and ends */
    48011920:	f94027e0 	ldr	x0, [sp, #72]
    48011924:	91000400 	add	x0, x0, #0x1
    48011928:	39400000 	ldrb	w0, [x0]
    4801192c:	7100001f 	cmp	w0, #0x0
    48011930:	540000a1 	b.ne	48011944 <dfs_normalize_path+0x144>  // b.any
    48011934:	f94027e0 	ldr	x0, [sp, #72]
    48011938:	91000400 	add	x0, x0, #0x1
    4801193c:	f90027e0 	str	x0, [sp, #72]
    48011940:	1400003e 	b	48011a38 <dfs_normalize_path+0x238>
            else if (src[1] == '/')
    48011944:	f94027e0 	ldr	x0, [sp, #72]
    48011948:	91000400 	add	x0, x0, #0x1
    4801194c:	39400000 	ldrb	w0, [x0]
    48011950:	7100bc1f 	cmp	w0, #0x2f
    48011954:	54000221 	b.ne	48011998 <dfs_normalize_path+0x198>  // b.any
            {
                /* './' case */
                src += 2;
    48011958:	f94027e0 	ldr	x0, [sp, #72]
    4801195c:	91000800 	add	x0, x0, #0x2
    48011960:	f90027e0 	str	x0, [sp, #72]

                while ((*src == '/') && (*src != '\0'))
    48011964:	14000004 	b	48011974 <dfs_normalize_path+0x174>
                    src ++;
    48011968:	f94027e0 	ldr	x0, [sp, #72]
    4801196c:	91000400 	add	x0, x0, #0x1
    48011970:	f90027e0 	str	x0, [sp, #72]
                while ((*src == '/') && (*src != '\0'))
    48011974:	f94027e0 	ldr	x0, [sp, #72]
    48011978:	39400000 	ldrb	w0, [x0]
    4801197c:	7100bc1f 	cmp	w0, #0x2f
    48011980:	54000d61 	b.ne	48011b2c <dfs_normalize_path+0x32c>  // b.any
    48011984:	f94027e0 	ldr	x0, [sp, #72]
    48011988:	39400000 	ldrb	w0, [x0]
    4801198c:	7100001f 	cmp	w0, #0x0
    48011990:	54fffec1 	b.ne	48011968 <dfs_normalize_path+0x168>  // b.any
                continue;
    48011994:	14000066 	b	48011b2c <dfs_normalize_path+0x32c>
            }
            else if (src[1] == '.')
    48011998:	f94027e0 	ldr	x0, [sp, #72]
    4801199c:	91000400 	add	x0, x0, #0x1
    480119a0:	39400000 	ldrb	w0, [x0]
    480119a4:	7100b81f 	cmp	w0, #0x2e
    480119a8:	54000481 	b.ne	48011a38 <dfs_normalize_path+0x238>  // b.any
            {
                if (!src[2])
    480119ac:	f94027e0 	ldr	x0, [sp, #72]
    480119b0:	91000800 	add	x0, x0, #0x2
    480119b4:	39400000 	ldrb	w0, [x0]
    480119b8:	7100001f 	cmp	w0, #0x0
    480119bc:	540000a1 	b.ne	480119d0 <dfs_normalize_path+0x1d0>  // b.any
                {
                    /* '..' and ends case */
                    src += 2;
    480119c0:	f94027e0 	ldr	x0, [sp, #72]
    480119c4:	91000800 	add	x0, x0, #0x2
    480119c8:	f90027e0 	str	x0, [sp, #72]
                    goto up_one;
    480119cc:	14000040 	b	48011acc <dfs_normalize_path+0x2cc>
                }
                else if (src[2] == '/')
    480119d0:	f94027e0 	ldr	x0, [sp, #72]
    480119d4:	91000800 	add	x0, x0, #0x2
    480119d8:	39400000 	ldrb	w0, [x0]
    480119dc:	7100bc1f 	cmp	w0, #0x2f
    480119e0:	540002c1 	b.ne	48011a38 <dfs_normalize_path+0x238>  // b.any
                {
                    /* '../' case */
                    src += 3;
    480119e4:	f94027e0 	ldr	x0, [sp, #72]
    480119e8:	91000c00 	add	x0, x0, #0x3
    480119ec:	f90027e0 	str	x0, [sp, #72]

                    while ((*src == '/') && (*src != '\0'))
    480119f0:	14000004 	b	48011a00 <dfs_normalize_path+0x200>
                        src ++;
    480119f4:	f94027e0 	ldr	x0, [sp, #72]
    480119f8:	91000400 	add	x0, x0, #0x1
    480119fc:	f90027e0 	str	x0, [sp, #72]
                    while ((*src == '/') && (*src != '\0'))
    48011a00:	f94027e0 	ldr	x0, [sp, #72]
    48011a04:	39400000 	ldrb	w0, [x0]
    48011a08:	7100bc1f 	cmp	w0, #0x2f
    48011a0c:	540005e1 	b.ne	48011ac8 <dfs_normalize_path+0x2c8>  // b.any
    48011a10:	f94027e0 	ldr	x0, [sp, #72]
    48011a14:	39400000 	ldrb	w0, [x0]
    48011a18:	7100001f 	cmp	w0, #0x0
    48011a1c:	54fffec1 	b.ne	480119f4 <dfs_normalize_path+0x1f4>  // b.any
                    goto up_one;
    48011a20:	1400002a 	b	48011ac8 <dfs_normalize_path+0x2c8>
            }
        }

        /* copy up the next '/' and erase all '/' */
        while ((c = *src++) != '\0' && c != '/')
            *dst ++ = c;
    48011a24:	f9402be0 	ldr	x0, [sp, #80]
    48011a28:	91000401 	add	x1, x0, #0x1
    48011a2c:	f9002be1 	str	x1, [sp, #80]
    48011a30:	39411fe1 	ldrb	w1, [sp, #71]
    48011a34:	39000001 	strb	w1, [x0]
        while ((c = *src++) != '\0' && c != '/')
    48011a38:	f94027e0 	ldr	x0, [sp, #72]
    48011a3c:	91000401 	add	x1, x0, #0x1
    48011a40:	f90027e1 	str	x1, [sp, #72]
    48011a44:	39400000 	ldrb	w0, [x0]
    48011a48:	39011fe0 	strb	w0, [sp, #71]
    48011a4c:	39411fe0 	ldrb	w0, [sp, #71]
    48011a50:	7100001f 	cmp	w0, #0x0
    48011a54:	54000080 	b.eq	48011a64 <dfs_normalize_path+0x264>  // b.none
    48011a58:	39411fe0 	ldrb	w0, [sp, #71]
    48011a5c:	7100bc1f 	cmp	w0, #0x2f
    48011a60:	54fffe21 	b.ne	48011a24 <dfs_normalize_path+0x224>  // b.any

        if (c == '/')
    48011a64:	39411fe0 	ldrb	w0, [sp, #71]
    48011a68:	7100bc1f 	cmp	w0, #0x2f
    48011a6c:	54000261 	b.ne	48011ab8 <dfs_normalize_path+0x2b8>  // b.any
        {
            *dst ++ = '/';
    48011a70:	f9402be0 	ldr	x0, [sp, #80]
    48011a74:	91000401 	add	x1, x0, #0x1
    48011a78:	f9002be1 	str	x1, [sp, #80]
    48011a7c:	528005e1 	mov	w1, #0x2f                  	// #47
    48011a80:	39000001 	strb	w1, [x0]
            while (c == '/')
    48011a84:	14000006 	b	48011a9c <dfs_normalize_path+0x29c>
                c = *src++;
    48011a88:	f94027e0 	ldr	x0, [sp, #72]
    48011a8c:	91000401 	add	x1, x0, #0x1
    48011a90:	f90027e1 	str	x1, [sp, #72]
    48011a94:	39400000 	ldrb	w0, [x0]
    48011a98:	39011fe0 	strb	w0, [sp, #71]
            while (c == '/')
    48011a9c:	39411fe0 	ldrb	w0, [sp, #71]
    48011aa0:	7100bc1f 	cmp	w0, #0x2f
    48011aa4:	54ffff20 	b.eq	48011a88 <dfs_normalize_path+0x288>  // b.none

            src --;
    48011aa8:	f94027e0 	ldr	x0, [sp, #72]
    48011aac:	d1000400 	sub	x0, x0, #0x1
    48011ab0:	f90027e0 	str	x0, [sp, #72]
        }
        else if (!c)
            break;

        continue;
    48011ab4:	14000020 	b	48011b34 <dfs_normalize_path+0x334>
        else if (!c)
    48011ab8:	39411fe0 	ldrb	w0, [sp, #71]
    48011abc:	7100001f 	cmp	w0, #0x0
    48011ac0:	540003a1 	b.ne	48011b34 <dfs_normalize_path+0x334>  // b.any
            break;
    48011ac4:	1400001e 	b	48011b3c <dfs_normalize_path+0x33c>
                    goto up_one;
    48011ac8:	d503201f 	nop

up_one:
        dst --;
    48011acc:	f9402be0 	ldr	x0, [sp, #80]
    48011ad0:	d1000400 	sub	x0, x0, #0x1
    48011ad4:	f9002be0 	str	x0, [sp, #80]
        if (dst < dst0)
    48011ad8:	f9402be1 	ldr	x1, [sp, #80]
    48011adc:	f9401fe0 	ldr	x0, [sp, #56]
    48011ae0:	eb00003f 	cmp	x1, x0
    48011ae4:	54000102 	b.cs	48011b04 <dfs_normalize_path+0x304>  // b.hs, b.nlast
        {
            rt_free(fullpath);
    48011ae8:	f9402fe0 	ldr	x0, [sp, #88]
    48011aec:	97ffe236 	bl	4800a3c4 <rt_free>
            return NULL;
    48011af0:	d2800000 	mov	x0, #0x0                   	// #0
    48011af4:	1400002c 	b	48011ba4 <dfs_normalize_path+0x3a4>
        }
        while (dst0 < dst && dst[-1] != '/')
            dst --;
    48011af8:	f9402be0 	ldr	x0, [sp, #80]
    48011afc:	d1000400 	sub	x0, x0, #0x1
    48011b00:	f9002be0 	str	x0, [sp, #80]
        while (dst0 < dst && dst[-1] != '/')
    48011b04:	f9401fe1 	ldr	x1, [sp, #56]
    48011b08:	f9402be0 	ldr	x0, [sp, #80]
    48011b0c:	eb00003f 	cmp	x1, x0
    48011b10:	54ffefc2 	b.cs	48011908 <dfs_normalize_path+0x108>  // b.hs, b.nlast
    48011b14:	f9402be0 	ldr	x0, [sp, #80]
    48011b18:	d1000400 	sub	x0, x0, #0x1
    48011b1c:	39400000 	ldrb	w0, [x0]
    48011b20:	7100bc1f 	cmp	w0, #0x2f
    48011b24:	54fffea1 	b.ne	48011af8 <dfs_normalize_path+0x2f8>  // b.any
    48011b28:	17ffff78 	b	48011908 <dfs_normalize_path+0x108>
                continue;
    48011b2c:	d503201f 	nop
    48011b30:	17ffff76 	b	48011908 <dfs_normalize_path+0x108>
        continue;
    48011b34:	d503201f 	nop
    {
    48011b38:	17ffff74 	b	48011908 <dfs_normalize_path+0x108>
    }

    *dst = '\0';
    48011b3c:	f9402be0 	ldr	x0, [sp, #80]
    48011b40:	3900001f 	strb	wzr, [x0]

    /* remove '/' in the end of path if exist */
    dst --;
    48011b44:	f9402be0 	ldr	x0, [sp, #80]
    48011b48:	d1000400 	sub	x0, x0, #0x1
    48011b4c:	f9002be0 	str	x0, [sp, #80]
    if ((dst != fullpath) && (*dst == '/'))
    48011b50:	f9402be1 	ldr	x1, [sp, #80]
    48011b54:	f9402fe0 	ldr	x0, [sp, #88]
    48011b58:	eb00003f 	cmp	x1, x0
    48011b5c:	540000e0 	b.eq	48011b78 <dfs_normalize_path+0x378>  // b.none
    48011b60:	f9402be0 	ldr	x0, [sp, #80]
    48011b64:	39400000 	ldrb	w0, [x0]
    48011b68:	7100bc1f 	cmp	w0, #0x2f
    48011b6c:	54000061 	b.ne	48011b78 <dfs_normalize_path+0x378>  // b.any
        *dst = '\0';
    48011b70:	f9402be0 	ldr	x0, [sp, #80]
    48011b74:	3900001f 	strb	wzr, [x0]

    /* final check fullpath is not empty, for the special path of lwext "/.." */
    if ('\0' == fullpath[0])
    48011b78:	f9402fe0 	ldr	x0, [sp, #88]
    48011b7c:	39400000 	ldrb	w0, [x0]
    48011b80:	7100001f 	cmp	w0, #0x0
    48011b84:	540000e1 	b.ne	48011ba0 <dfs_normalize_path+0x3a0>  // b.any
    {
        fullpath[0] = '/';
    48011b88:	f9402fe0 	ldr	x0, [sp, #88]
    48011b8c:	528005e1 	mov	w1, #0x2f                  	// #47
    48011b90:	39000001 	strb	w1, [x0]
        fullpath[1] = '\0';
    48011b94:	f9402fe0 	ldr	x0, [sp, #88]
    48011b98:	91000400 	add	x0, x0, #0x1
    48011b9c:	3900001f 	strb	wzr, [x0]
    }

    return fullpath;
    48011ba0:	f9402fe0 	ldr	x0, [sp, #88]
}
    48011ba4:	f9400bf3 	ldr	x19, [sp, #16]
    48011ba8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    48011bac:	d65f03c0 	ret

0000000048011bb0 <dfs_fdtable_get>:

/**
 * This function will get the file descriptor table of current process.
 */
struct dfs_fdtable *dfs_fdtable_get(void)
{
    48011bb0:	d10043ff 	sub	sp, sp, #0x10
    if (lwp)
        fdt = &lwp->fdt;
    else
        fdt = &_fdtab;
#else
    fdt = &_fdtab;
    48011bb4:	90000140 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48011bb8:	911cc000 	add	x0, x0, #0x730
    48011bbc:	f90007e0 	str	x0, [sp, #8]
#endif

    return fdt;
    48011bc0:	f94007e0 	ldr	x0, [sp, #8]
}
    48011bc4:	910043ff 	add	sp, sp, #0x10
    48011bc8:	d65f03c0 	ret

0000000048011bcc <list_fd>:

#ifdef RT_USING_FINSH
#include <finsh.h>
int list_fd(void)
{
    48011bcc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48011bd0:	910003fd 	mov	x29, sp
    int index;
    struct dfs_fdtable *fd_table;

    fd_table = dfs_fdtable_get();
    48011bd4:	97fffff7 	bl	48011bb0 <dfs_fdtable_get>
    48011bd8:	f90013e0 	str	x0, [sp, #32]
    if (!fd_table) return -1;
    48011bdc:	f94013e0 	ldr	x0, [sp, #32]
    48011be0:	f100001f 	cmp	x0, #0x0
    48011be4:	54000061 	b.ne	48011bf0 <list_fd+0x24>  // b.any
    48011be8:	12800000 	mov	w0, #0xffffffff            	// #-1
    48011bec:	1400007a 	b	48011dd4 <list_fd+0x208>

    rt_enter_critical();
    48011bf0:	97ffef0a 	bl	4800d818 <rt_enter_critical>

    rt_kprintf("fd type    ref magic  path\n");
    48011bf4:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011bf8:	91378000 	add	x0, x0, #0xde0
    48011bfc:	97fff84d 	bl	4800fd30 <rt_kprintf>
    rt_kprintf("-- ------  --- ----- ------\n");
    48011c00:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011c04:	91380000 	add	x0, x0, #0xe00
    48011c08:	97fff84a 	bl	4800fd30 <rt_kprintf>
    for (index = 0; index < (int)fd_table->maxfd; index ++)
    48011c0c:	b9002fff 	str	wzr, [sp, #44]
    48011c10:	14000069 	b	48011db4 <list_fd+0x1e8>
    {
        struct dfs_fd *fd = fd_table->fds[index];
    48011c14:	f94013e0 	ldr	x0, [sp, #32]
    48011c18:	f9400401 	ldr	x1, [x0, #8]
    48011c1c:	b9802fe0 	ldrsw	x0, [sp, #44]
    48011c20:	d37df000 	lsl	x0, x0, #3
    48011c24:	8b000020 	add	x0, x1, x0
    48011c28:	f9400000 	ldr	x0, [x0]
    48011c2c:	f9000fe0 	str	x0, [sp, #24]

        if (fd && fd->fops)
    48011c30:	f9400fe0 	ldr	x0, [sp, #24]
    48011c34:	f100001f 	cmp	x0, #0x0
    48011c38:	54000b80 	b.eq	48011da8 <list_fd+0x1dc>  // b.none
    48011c3c:	f9400fe0 	ldr	x0, [sp, #24]
    48011c40:	f9401000 	ldr	x0, [x0, #32]
    48011c44:	f100001f 	cmp	x0, #0x0
    48011c48:	54000b00 	b.eq	48011da8 <list_fd+0x1dc>  // b.none
        {
            rt_kprintf("%2d ", index + DFS_FD_OFFSET);
    48011c4c:	b9402fe0 	ldr	w0, [sp, #44]
    48011c50:	11000c00 	add	w0, w0, #0x3
    48011c54:	2a0003e1 	mov	w1, w0
    48011c58:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011c5c:	91388000 	add	x0, x0, #0xe20
    48011c60:	97fff834 	bl	4800fd30 <rt_kprintf>
            if (fd->type == FT_DIRECTORY)    rt_kprintf("%-7.7s ", "dir");
    48011c64:	f9400fe0 	ldr	x0, [sp, #24]
    48011c68:	79400400 	ldrh	w0, [x0, #2]
    48011c6c:	7100081f 	cmp	w0, #0x2
    48011c70:	540000e1 	b.ne	48011c8c <list_fd+0xc0>  // b.any
    48011c74:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011c78:	9138a001 	add	x1, x0, #0xe28
    48011c7c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011c80:	9138c000 	add	x0, x0, #0xe30
    48011c84:	97fff82b 	bl	4800fd30 <rt_kprintf>
    48011c88:	1400002e 	b	48011d40 <list_fd+0x174>
            else if (fd->type == FT_REGULAR) rt_kprintf("%-7.7s ", "file");
    48011c8c:	f9400fe0 	ldr	x0, [sp, #24]
    48011c90:	79400400 	ldrh	w0, [x0, #2]
    48011c94:	7100001f 	cmp	w0, #0x0
    48011c98:	540000e1 	b.ne	48011cb4 <list_fd+0xe8>  // b.any
    48011c9c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011ca0:	9138e001 	add	x1, x0, #0xe38
    48011ca4:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011ca8:	9138c000 	add	x0, x0, #0xe30
    48011cac:	97fff821 	bl	4800fd30 <rt_kprintf>
    48011cb0:	14000024 	b	48011d40 <list_fd+0x174>
            else if (fd->type == FT_SOCKET)  rt_kprintf("%-7.7s ", "socket");
    48011cb4:	f9400fe0 	ldr	x0, [sp, #24]
    48011cb8:	79400400 	ldrh	w0, [x0, #2]
    48011cbc:	7100041f 	cmp	w0, #0x1
    48011cc0:	540000e1 	b.ne	48011cdc <list_fd+0x110>  // b.any
    48011cc4:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011cc8:	91390001 	add	x1, x0, #0xe40
    48011ccc:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011cd0:	9138c000 	add	x0, x0, #0xe30
    48011cd4:	97fff817 	bl	4800fd30 <rt_kprintf>
    48011cd8:	1400001a 	b	48011d40 <list_fd+0x174>
            else if (fd->type == FT_USER)    rt_kprintf("%-7.7s ", "user");
    48011cdc:	f9400fe0 	ldr	x0, [sp, #24]
    48011ce0:	79400400 	ldrh	w0, [x0, #2]
    48011ce4:	71000c1f 	cmp	w0, #0x3
    48011ce8:	540000e1 	b.ne	48011d04 <list_fd+0x138>  // b.any
    48011cec:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011cf0:	91392001 	add	x1, x0, #0xe48
    48011cf4:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011cf8:	9138c000 	add	x0, x0, #0xe30
    48011cfc:	97fff80d 	bl	4800fd30 <rt_kprintf>
    48011d00:	14000010 	b	48011d40 <list_fd+0x174>
            else if (fd->type == FT_DEVICE)   rt_kprintf("%-7.7s ", "device");
    48011d04:	f9400fe0 	ldr	x0, [sp, #24]
    48011d08:	79400400 	ldrh	w0, [x0, #2]
    48011d0c:	7100101f 	cmp	w0, #0x4
    48011d10:	540000e1 	b.ne	48011d2c <list_fd+0x160>  // b.any
    48011d14:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011d18:	91394001 	add	x1, x0, #0xe50
    48011d1c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011d20:	9138c000 	add	x0, x0, #0xe30
    48011d24:	97fff803 	bl	4800fd30 <rt_kprintf>
    48011d28:	14000006 	b	48011d40 <list_fd+0x174>
            else rt_kprintf("%-8.8s ", "unknown");
    48011d2c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011d30:	91396001 	add	x1, x0, #0xe58
    48011d34:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011d38:	91398000 	add	x0, x0, #0xe60
    48011d3c:	97fff7fd 	bl	4800fd30 <rt_kprintf>
            rt_kprintf("%3d ", fd->ref_count);
    48011d40:	f9400fe0 	ldr	x0, [sp, #24]
    48011d44:	b9401000 	ldr	w0, [x0, #16]
    48011d48:	2a0003e1 	mov	w1, w0
    48011d4c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011d50:	9139a000 	add	x0, x0, #0xe68
    48011d54:	97fff7f7 	bl	4800fd30 <rt_kprintf>
            rt_kprintf("%04x  ", fd->magic);
    48011d58:	f9400fe0 	ldr	x0, [sp, #24]
    48011d5c:	79400000 	ldrh	w0, [x0]
    48011d60:	2a0003e1 	mov	w1, w0
    48011d64:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011d68:	9139c000 	add	x0, x0, #0xe70
    48011d6c:	97fff7f1 	bl	4800fd30 <rt_kprintf>
            if (fd->path)
    48011d70:	f9400fe0 	ldr	x0, [sp, #24]
    48011d74:	f9400400 	ldr	x0, [x0, #8]
    48011d78:	f100001f 	cmp	x0, #0x0
    48011d7c:	54000100 	b.eq	48011d9c <list_fd+0x1d0>  // b.none
            {
                rt_kprintf("%s\n", fd->path);
    48011d80:	f9400fe0 	ldr	x0, [sp, #24]
    48011d84:	f9400400 	ldr	x0, [x0, #8]
    48011d88:	aa0003e1 	mov	x1, x0
    48011d8c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011d90:	9139e000 	add	x0, x0, #0xe78
    48011d94:	97fff7e7 	bl	4800fd30 <rt_kprintf>
    48011d98:	14000004 	b	48011da8 <list_fd+0x1dc>
            }
            else
            {
                rt_kprintf("\n");
    48011d9c:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011da0:	9136a000 	add	x0, x0, #0xda8
    48011da4:	97fff7e3 	bl	4800fd30 <rt_kprintf>
    for (index = 0; index < (int)fd_table->maxfd; index ++)
    48011da8:	b9402fe0 	ldr	w0, [sp, #44]
    48011dac:	11000400 	add	w0, w0, #0x1
    48011db0:	b9002fe0 	str	w0, [sp, #44]
    48011db4:	f94013e0 	ldr	x0, [sp, #32]
    48011db8:	b9400000 	ldr	w0, [x0]
    48011dbc:	2a0003e1 	mov	w1, w0
    48011dc0:	b9402fe0 	ldr	w0, [sp, #44]
    48011dc4:	6b01001f 	cmp	w0, w1
    48011dc8:	54fff26b 	b.lt	48011c14 <list_fd+0x48>  // b.tstop
            }
        }
    }
    rt_exit_critical();
    48011dcc:	97ffeea8 	bl	4800d86c <rt_exit_critical>

    return 0;
    48011dd0:	52800000 	mov	w0, #0x0                   	// #0
}
    48011dd4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48011dd8:	d65f03c0 	ret

0000000048011ddc <dfs_file_open>:
 * @param flags the flags for open operator.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_file_open(struct dfs_fd *fd, const char *path, int flags)
{
    48011ddc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48011de0:	910003fd 	mov	x29, sp
    48011de4:	f90017e0 	str	x0, [sp, #40]
    48011de8:	f90013e1 	str	x1, [sp, #32]
    48011dec:	b9001fe2 	str	w2, [sp, #28]
    struct dfs_filesystem *fs;
    char *fullpath;
    int result;

    /* parameter check */
    if (fd == NULL)
    48011df0:	f94017e0 	ldr	x0, [sp, #40]
    48011df4:	f100001f 	cmp	x0, #0x0
    48011df8:	54000061 	b.ne	48011e04 <dfs_file_open+0x28>  // b.any
        return -EINVAL;
    48011dfc:	128002a0 	mov	w0, #0xffffffea            	// #-22
    48011e00:	14000077 	b	48011fdc <dfs_file_open+0x200>

    /* make sure we have an absolute path */
    fullpath = dfs_normalize_path(NULL, path);
    48011e04:	f94013e1 	ldr	x1, [sp, #32]
    48011e08:	d2800000 	mov	x0, #0x0                   	// #0
    48011e0c:	97fffe7d 	bl	48011800 <dfs_normalize_path>
    48011e10:	f90027e0 	str	x0, [sp, #72]
    if (fullpath == NULL)
    48011e14:	f94027e0 	ldr	x0, [sp, #72]
    48011e18:	f100001f 	cmp	x0, #0x0
    48011e1c:	54000061 	b.ne	48011e28 <dfs_file_open+0x4c>  // b.any
    {
        return -ENOMEM;
    48011e20:	12800160 	mov	w0, #0xfffffff4            	// #-12
    48011e24:	1400006e 	b	48011fdc <dfs_file_open+0x200>
    }

    LOG_D("open file:%s", fullpath);

    /* find filesystem */
    fs = dfs_filesystem_lookup(fullpath);
    48011e28:	f94027e0 	ldr	x0, [sp, #72]
    48011e2c:	97fff96c 	bl	480103dc <dfs_filesystem_lookup>
    48011e30:	f90023e0 	str	x0, [sp, #64]
    if (fs == NULL)
    48011e34:	f94023e0 	ldr	x0, [sp, #64]
    48011e38:	f100001f 	cmp	x0, #0x0
    48011e3c:	540000a1 	b.ne	48011e50 <dfs_file_open+0x74>  // b.any
    {
        rt_free(fullpath); /* release path */
    48011e40:	f94027e0 	ldr	x0, [sp, #72]
    48011e44:	97ffe160 	bl	4800a3c4 <rt_free>

        return -ENOENT;
    48011e48:	12800020 	mov	w0, #0xfffffffe            	// #-2
    48011e4c:	14000064 	b	48011fdc <dfs_file_open+0x200>
    }

    LOG_D("open in filesystem:%s", fs->ops->name);
    fd->fs    = fs;             /* set file system */
    48011e50:	f94017e0 	ldr	x0, [sp, #40]
    48011e54:	f94023e1 	ldr	x1, [sp, #64]
    48011e58:	f9000c01 	str	x1, [x0, #24]
    fd->fops  = fs->ops->fops;  /* set file ops */
    48011e5c:	f94023e0 	ldr	x0, [sp, #64]
    48011e60:	f9400800 	ldr	x0, [x0, #16]
    48011e64:	f9400801 	ldr	x1, [x0, #16]
    48011e68:	f94017e0 	ldr	x0, [sp, #40]
    48011e6c:	f9001001 	str	x1, [x0, #32]

    /* initialize the fd item */
    fd->type  = FT_REGULAR;
    48011e70:	f94017e0 	ldr	x0, [sp, #40]
    48011e74:	7900041f 	strh	wzr, [x0, #2]
    fd->flags = flags;
    48011e78:	b9401fe1 	ldr	w1, [sp, #28]
    48011e7c:	f94017e0 	ldr	x0, [sp, #40]
    48011e80:	b9002801 	str	w1, [x0, #40]
    fd->size  = 0;
    48011e84:	f94017e0 	ldr	x0, [sp, #40]
    48011e88:	f900181f 	str	xzr, [x0, #48]
    fd->pos   = 0;
    48011e8c:	f94017e0 	ldr	x0, [sp, #40]
    48011e90:	f9001c1f 	str	xzr, [x0, #56]
    fd->data  = fs;
    48011e94:	f94017e0 	ldr	x0, [sp, #40]
    48011e98:	f94023e1 	ldr	x1, [sp, #64]
    48011e9c:	f9002001 	str	x1, [x0, #64]

    if (!(fs->ops->flags & DFS_FS_FLAG_FULLPATH))
    48011ea0:	f94023e0 	ldr	x0, [sp, #64]
    48011ea4:	f9400800 	ldr	x0, [x0, #16]
    48011ea8:	b9400800 	ldr	w0, [x0, #8]
    48011eac:	12000000 	and	w0, w0, #0x1
    48011eb0:	7100001f 	cmp	w0, #0x0
    48011eb4:	54000321 	b.ne	48011f18 <dfs_file_open+0x13c>  // b.any
    {
        if (dfs_subdir(fs->path, fullpath) == NULL)
    48011eb8:	f94023e0 	ldr	x0, [sp, #64]
    48011ebc:	f9400400 	ldr	x0, [x0, #8]
    48011ec0:	f94027e1 	ldr	x1, [sp, #72]
    48011ec4:	97fffe2c 	bl	48011774 <dfs_subdir>
    48011ec8:	f100001f 	cmp	x0, #0x0
    48011ecc:	54000101 	b.ne	48011eec <dfs_file_open+0x110>  // b.any
            fd->path = rt_strdup("/");
    48011ed0:	d0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48011ed4:	913ac000 	add	x0, x0, #0xeb0
    48011ed8:	97fff311 	bl	4800eb1c <rt_strdup>
    48011edc:	aa0003e1 	mov	x1, x0
    48011ee0:	f94017e0 	ldr	x0, [sp, #40]
    48011ee4:	f9000401 	str	x1, [x0, #8]
    48011ee8:	14000009 	b	48011f0c <dfs_file_open+0x130>
        else
            fd->path = rt_strdup(dfs_subdir(fs->path, fullpath));
    48011eec:	f94023e0 	ldr	x0, [sp, #64]
    48011ef0:	f9400400 	ldr	x0, [x0, #8]
    48011ef4:	f94027e1 	ldr	x1, [sp, #72]
    48011ef8:	97fffe1f 	bl	48011774 <dfs_subdir>
    48011efc:	97fff308 	bl	4800eb1c <rt_strdup>
    48011f00:	aa0003e1 	mov	x1, x0
    48011f04:	f94017e0 	ldr	x0, [sp, #40]
    48011f08:	f9000401 	str	x1, [x0, #8]
        rt_free(fullpath);
    48011f0c:	f94027e0 	ldr	x0, [sp, #72]
    48011f10:	97ffe12d 	bl	4800a3c4 <rt_free>
    48011f14:	14000004 	b	48011f24 <dfs_file_open+0x148>
        LOG_D("Actual file path: %s", fd->path);
    }
    else
    {
        fd->path = fullpath;
    48011f18:	f94017e0 	ldr	x0, [sp, #40]
    48011f1c:	f94027e1 	ldr	x1, [sp, #72]
    48011f20:	f9000401 	str	x1, [x0, #8]
    }

    /* specific file system open routine */
    if (fd->fops->open == NULL)
    48011f24:	f94017e0 	ldr	x0, [sp, #40]
    48011f28:	f9401000 	ldr	x0, [x0, #32]
    48011f2c:	f9400000 	ldr	x0, [x0]
    48011f30:	f100001f 	cmp	x0, #0x0
    48011f34:	54000101 	b.ne	48011f54 <dfs_file_open+0x178>  // b.any
    {
        /* clear fd */
        rt_free(fd->path);
    48011f38:	f94017e0 	ldr	x0, [sp, #40]
    48011f3c:	f9400400 	ldr	x0, [x0, #8]
    48011f40:	97ffe121 	bl	4800a3c4 <rt_free>
        fd->path = NULL;
    48011f44:	f94017e0 	ldr	x0, [sp, #40]
    48011f48:	f900041f 	str	xzr, [x0, #8]

        return -ENOSYS;
    48011f4c:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    48011f50:	14000023 	b	48011fdc <dfs_file_open+0x200>
    }

    if ((result = fd->fops->open(fd)) < 0)
    48011f54:	f94017e0 	ldr	x0, [sp, #40]
    48011f58:	f9401000 	ldr	x0, [x0, #32]
    48011f5c:	f9400001 	ldr	x1, [x0]
    48011f60:	f94017e0 	ldr	x0, [sp, #40]
    48011f64:	d63f0020 	blr	x1
    48011f68:	b9003fe0 	str	w0, [sp, #60]
    48011f6c:	b9403fe0 	ldr	w0, [sp, #60]
    48011f70:	7100001f 	cmp	w0, #0x0
    48011f74:	5400010a 	b.ge	48011f94 <dfs_file_open+0x1b8>  // b.tcont
    {
        /* clear fd */
        rt_free(fd->path);
    48011f78:	f94017e0 	ldr	x0, [sp, #40]
    48011f7c:	f9400400 	ldr	x0, [x0, #8]
    48011f80:	97ffe111 	bl	4800a3c4 <rt_free>
        fd->path = NULL;
    48011f84:	f94017e0 	ldr	x0, [sp, #40]
    48011f88:	f900041f 	str	xzr, [x0, #8]

        LOG_D("%s open failed", fullpath);

        return result;
    48011f8c:	b9403fe0 	ldr	w0, [sp, #60]
    48011f90:	14000013 	b	48011fdc <dfs_file_open+0x200>
    }

    fd->flags |= DFS_F_OPEN;
    48011f94:	f94017e0 	ldr	x0, [sp, #40]
    48011f98:	b9402800 	ldr	w0, [x0, #40]
    48011f9c:	32080001 	orr	w1, w0, #0x1000000
    48011fa0:	f94017e0 	ldr	x0, [sp, #40]
    48011fa4:	b9002801 	str	w1, [x0, #40]
    if (flags & O_DIRECTORY)
    48011fa8:	b9401fe0 	ldr	w0, [sp, #28]
    48011fac:	120b0000 	and	w0, w0, #0x200000
    48011fb0:	7100001f 	cmp	w0, #0x0
    48011fb4:	54000120 	b.eq	48011fd8 <dfs_file_open+0x1fc>  // b.none
    {
        fd->type = FT_DIRECTORY;
    48011fb8:	f94017e0 	ldr	x0, [sp, #40]
    48011fbc:	52800041 	mov	w1, #0x2                   	// #2
    48011fc0:	79000401 	strh	w1, [x0, #2]
        fd->flags |= DFS_F_DIRECTORY;
    48011fc4:	f94017e0 	ldr	x0, [sp, #40]
    48011fc8:	b9402800 	ldr	w0, [x0, #40]
    48011fcc:	32070001 	orr	w1, w0, #0x2000000
    48011fd0:	f94017e0 	ldr	x0, [sp, #40]
    48011fd4:	b9002801 	str	w1, [x0, #40]
    }

    LOG_D("open successful");
    return 0;
    48011fd8:	52800000 	mov	w0, #0x0                   	// #0
}
    48011fdc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48011fe0:	d65f03c0 	ret

0000000048011fe4 <dfs_file_close>:
 * @param fd the file descriptor to be closed.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_file_close(struct dfs_fd *fd)
{
    48011fe4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48011fe8:	910003fd 	mov	x29, sp
    48011fec:	f9000fe0 	str	x0, [sp, #24]
    int result = 0;
    48011ff0:	b9002fff 	str	wzr, [sp, #44]

    if (fd == NULL)
    48011ff4:	f9400fe0 	ldr	x0, [sp, #24]
    48011ff8:	f100001f 	cmp	x0, #0x0
    48011ffc:	54000061 	b.ne	48012008 <dfs_file_close+0x24>  // b.any
        return -ENXIO;
    48012000:	128000a0 	mov	w0, #0xfffffffa            	// #-6
    48012004:	14000017 	b	48012060 <dfs_file_close+0x7c>

    if (fd->fops->close != NULL)
    48012008:	f9400fe0 	ldr	x0, [sp, #24]
    4801200c:	f9401000 	ldr	x0, [x0, #32]
    48012010:	f9400400 	ldr	x0, [x0, #8]
    48012014:	f100001f 	cmp	x0, #0x0
    48012018:	540000e0 	b.eq	48012034 <dfs_file_close+0x50>  // b.none
        result = fd->fops->close(fd);
    4801201c:	f9400fe0 	ldr	x0, [sp, #24]
    48012020:	f9401000 	ldr	x0, [x0, #32]
    48012024:	f9400401 	ldr	x1, [x0, #8]
    48012028:	f9400fe0 	ldr	x0, [sp, #24]
    4801202c:	d63f0020 	blr	x1
    48012030:	b9002fe0 	str	w0, [sp, #44]

    /* close fd error, return */
    if (result < 0)
    48012034:	b9402fe0 	ldr	w0, [sp, #44]
    48012038:	7100001f 	cmp	w0, #0x0
    4801203c:	5400006a 	b.ge	48012048 <dfs_file_close+0x64>  // b.tcont
        return result;
    48012040:	b9402fe0 	ldr	w0, [sp, #44]
    48012044:	14000007 	b	48012060 <dfs_file_close+0x7c>

    rt_free(fd->path);
    48012048:	f9400fe0 	ldr	x0, [sp, #24]
    4801204c:	f9400400 	ldr	x0, [x0, #8]
    48012050:	97ffe0dd 	bl	4800a3c4 <rt_free>
    fd->path = NULL;
    48012054:	f9400fe0 	ldr	x0, [sp, #24]
    48012058:	f900041f 	str	xzr, [x0, #8]

    return result;
    4801205c:	b9402fe0 	ldr	w0, [sp, #44]
}
    48012060:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48012064:	d65f03c0 	ret

0000000048012068 <dfs_file_ioctl>:
 * @param args the argument to send to file descriptor.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_file_ioctl(struct dfs_fd *fd, int cmd, void *args)
{
    48012068:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801206c:	910003fd 	mov	x29, sp
    48012070:	f90017e0 	str	x0, [sp, #40]
    48012074:	b90027e1 	str	w1, [sp, #36]
    48012078:	f9000fe2 	str	x2, [sp, #24]
    if (fd == NULL)
    4801207c:	f94017e0 	ldr	x0, [sp, #40]
    48012080:	f100001f 	cmp	x0, #0x0
    48012084:	54000061 	b.ne	48012090 <dfs_file_ioctl+0x28>  // b.any
        return -EINVAL;
    48012088:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4801208c:	14000034 	b	4801215c <dfs_file_ioctl+0xf4>

    /* regular file system fd */
    if (fd->type == FT_REGULAR)
    48012090:	f94017e0 	ldr	x0, [sp, #40]
    48012094:	79400400 	ldrh	w0, [x0, #2]
    48012098:	7100001f 	cmp	w0, #0x0
    4801209c:	54000441 	b.ne	48012124 <dfs_file_ioctl+0xbc>  // b.any
    {
        switch (cmd)
    480120a0:	b94027e0 	ldr	w0, [sp, #36]
    480120a4:	71000c1f 	cmp	w0, #0x3
    480120a8:	540000a0 	b.eq	480120bc <dfs_file_ioctl+0x54>  // b.none
    480120ac:	b94027e0 	ldr	w0, [sp, #36]
    480120b0:	7100101f 	cmp	w0, #0x4
    480120b4:	540000a0 	b.eq	480120c8 <dfs_file_ioctl+0x60>  // b.none
    480120b8:	1400001b 	b	48012124 <dfs_file_ioctl+0xbc>
        {
        case F_GETFL:
            return fd->flags; /* return flags */
    480120bc:	f94017e0 	ldr	x0, [sp, #40]
    480120c0:	b9402800 	ldr	w0, [x0, #40]
    480120c4:	14000026 	b	4801215c <dfs_file_ioctl+0xf4>
        case F_SETFL:
            {
                int flags = (int)(rt_base_t)args;
    480120c8:	f9400fe0 	ldr	x0, [sp, #24]
    480120cc:	b9003fe0 	str	w0, [sp, #60]
                int mask  = O_NONBLOCK | O_APPEND;
    480120d0:	52880100 	mov	w0, #0x4008                	// #16392
    480120d4:	b9003be0 	str	w0, [sp, #56]

                flags &= mask;
    480120d8:	b9403fe1 	ldr	w1, [sp, #60]
    480120dc:	b9403be0 	ldr	w0, [sp, #56]
    480120e0:	0a000020 	and	w0, w1, w0
    480120e4:	b9003fe0 	str	w0, [sp, #60]
                fd->flags &= ~mask;
    480120e8:	f94017e0 	ldr	x0, [sp, #40]
    480120ec:	b9402800 	ldr	w0, [x0, #40]
    480120f0:	b9403be1 	ldr	w1, [sp, #56]
    480120f4:	2a2103e1 	mvn	w1, w1
    480120f8:	0a010001 	and	w1, w0, w1
    480120fc:	f94017e0 	ldr	x0, [sp, #40]
    48012100:	b9002801 	str	w1, [x0, #40]
                fd->flags |= flags;
    48012104:	f94017e0 	ldr	x0, [sp, #40]
    48012108:	b9402801 	ldr	w1, [x0, #40]
    4801210c:	b9403fe0 	ldr	w0, [sp, #60]
    48012110:	2a000021 	orr	w1, w1, w0
    48012114:	f94017e0 	ldr	x0, [sp, #40]
    48012118:	b9002801 	str	w1, [x0, #40]
            }
            return 0;
    4801211c:	52800000 	mov	w0, #0x0                   	// #0
    48012120:	1400000f 	b	4801215c <dfs_file_ioctl+0xf4>
        }
    }

    if (fd->fops->ioctl != NULL)
    48012124:	f94017e0 	ldr	x0, [sp, #40]
    48012128:	f9401000 	ldr	x0, [x0, #32]
    4801212c:	f9400800 	ldr	x0, [x0, #16]
    48012130:	f100001f 	cmp	x0, #0x0
    48012134:	54000120 	b.eq	48012158 <dfs_file_ioctl+0xf0>  // b.none
        return fd->fops->ioctl(fd, cmd, args);
    48012138:	f94017e0 	ldr	x0, [sp, #40]
    4801213c:	f9401000 	ldr	x0, [x0, #32]
    48012140:	f9400803 	ldr	x3, [x0, #16]
    48012144:	f9400fe2 	ldr	x2, [sp, #24]
    48012148:	b94027e1 	ldr	w1, [sp, #36]
    4801214c:	f94017e0 	ldr	x0, [sp, #40]
    48012150:	d63f0060 	blr	x3
    48012154:	14000002 	b	4801215c <dfs_file_ioctl+0xf4>

    return -ENOSYS;
    48012158:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
}
    4801215c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48012160:	d65f03c0 	ret

0000000048012164 <dfs_file_read>:
 * @param len the length of data buffer to be read.
 *
 * @return the actual read data bytes or 0 on end of file or failed.
 */
int dfs_file_read(struct dfs_fd *fd, void *buf, size_t len)
{
    48012164:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48012168:	910003fd 	mov	x29, sp
    4801216c:	f90017e0 	str	x0, [sp, #40]
    48012170:	f90013e1 	str	x1, [sp, #32]
    48012174:	f9000fe2 	str	x2, [sp, #24]
    int result = 0;
    48012178:	b9003fff 	str	wzr, [sp, #60]

    if (fd == NULL)
    4801217c:	f94017e0 	ldr	x0, [sp, #40]
    48012180:	f100001f 	cmp	x0, #0x0
    48012184:	54000061 	b.ne	48012190 <dfs_file_read+0x2c>  // b.any
        return -EINVAL;
    48012188:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4801218c:	14000019 	b	480121f0 <dfs_file_read+0x8c>

    if (fd->fops->read == NULL)
    48012190:	f94017e0 	ldr	x0, [sp, #40]
    48012194:	f9401000 	ldr	x0, [x0, #32]
    48012198:	f9400c00 	ldr	x0, [x0, #24]
    4801219c:	f100001f 	cmp	x0, #0x0
    480121a0:	54000061 	b.ne	480121ac <dfs_file_read+0x48>  // b.any
        return -ENOSYS;
    480121a4:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    480121a8:	14000012 	b	480121f0 <dfs_file_read+0x8c>

    if ((result = fd->fops->read(fd, buf, len)) < 0)
    480121ac:	f94017e0 	ldr	x0, [sp, #40]
    480121b0:	f9401000 	ldr	x0, [x0, #32]
    480121b4:	f9400c03 	ldr	x3, [x0, #24]
    480121b8:	f9400fe2 	ldr	x2, [sp, #24]
    480121bc:	f94013e1 	ldr	x1, [sp, #32]
    480121c0:	f94017e0 	ldr	x0, [sp, #40]
    480121c4:	d63f0060 	blr	x3
    480121c8:	b9003fe0 	str	w0, [sp, #60]
    480121cc:	b9403fe0 	ldr	w0, [sp, #60]
    480121d0:	7100001f 	cmp	w0, #0x0
    480121d4:	540000ca 	b.ge	480121ec <dfs_file_read+0x88>  // b.tcont
        fd->flags |= DFS_F_EOF;
    480121d8:	f94017e0 	ldr	x0, [sp, #40]
    480121dc:	b9402800 	ldr	w0, [x0, #40]
    480121e0:	32060001 	orr	w1, w0, #0x4000000
    480121e4:	f94017e0 	ldr	x0, [sp, #40]
    480121e8:	b9002801 	str	w1, [x0, #40]

    return result;
    480121ec:	b9403fe0 	ldr	w0, [sp, #60]
}
    480121f0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480121f4:	d65f03c0 	ret

00000000480121f8 <dfs_file_getdents>:
 * @param nbytes the available room in the buffer.
 *
 * @return the read dirent, others on failed.
 */
int dfs_file_getdents(struct dfs_fd *fd, struct dirent *dirp, size_t nbytes)
{
    480121f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480121fc:	910003fd 	mov	x29, sp
    48012200:	f90017e0 	str	x0, [sp, #40]
    48012204:	f90013e1 	str	x1, [sp, #32]
    48012208:	f9000fe2 	str	x2, [sp, #24]
    /* parameter check */
    if (fd == NULL || fd->type != FT_DIRECTORY)
    4801220c:	f94017e0 	ldr	x0, [sp, #40]
    48012210:	f100001f 	cmp	x0, #0x0
    48012214:	540000a0 	b.eq	48012228 <dfs_file_getdents+0x30>  // b.none
    48012218:	f94017e0 	ldr	x0, [sp, #40]
    4801221c:	79400400 	ldrh	w0, [x0, #2]
    48012220:	7100081f 	cmp	w0, #0x2
    48012224:	54000060 	b.eq	48012230 <dfs_file_getdents+0x38>  // b.none
        return -EINVAL;
    48012228:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4801222c:	14000010 	b	4801226c <dfs_file_getdents+0x74>

    if (fd->fops->getdents != NULL)
    48012230:	f94017e0 	ldr	x0, [sp, #40]
    48012234:	f9401000 	ldr	x0, [x0, #32]
    48012238:	f9401c00 	ldr	x0, [x0, #56]
    4801223c:	f100001f 	cmp	x0, #0x0
    48012240:	54000140 	b.eq	48012268 <dfs_file_getdents+0x70>  // b.none
        return fd->fops->getdents(fd, dirp, nbytes);
    48012244:	f94017e0 	ldr	x0, [sp, #40]
    48012248:	f9401000 	ldr	x0, [x0, #32]
    4801224c:	f9401c03 	ldr	x3, [x0, #56]
    48012250:	f9400fe0 	ldr	x0, [sp, #24]
    48012254:	2a0003e2 	mov	w2, w0
    48012258:	f94013e1 	ldr	x1, [sp, #32]
    4801225c:	f94017e0 	ldr	x0, [sp, #40]
    48012260:	d63f0060 	blr	x3
    48012264:	14000002 	b	4801226c <dfs_file_getdents+0x74>

    return -ENOSYS;
    48012268:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
}
    4801226c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48012270:	d65f03c0 	ret

0000000048012274 <dfs_file_unlink>:
 * @param path the specified path file to be unlinked.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_file_unlink(const char *path)
{
    48012274:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48012278:	910003fd 	mov	x29, sp
    4801227c:	f9000bf3 	str	x19, [sp, #16]
    48012280:	f90017e0 	str	x0, [sp, #40]
    int result;
    char *fullpath;
    struct dfs_filesystem *fs;

    /* Make sure we have an absolute path */
    fullpath = dfs_normalize_path(NULL, path);
    48012284:	f94017e1 	ldr	x1, [sp, #40]
    48012288:	d2800000 	mov	x0, #0x0                   	// #0
    4801228c:	97fffd5d 	bl	48011800 <dfs_normalize_path>
    48012290:	f90023e0 	str	x0, [sp, #64]
    if (fullpath == NULL)
    48012294:	f94023e0 	ldr	x0, [sp, #64]
    48012298:	f100001f 	cmp	x0, #0x0
    4801229c:	54000061 	b.ne	480122a8 <dfs_file_unlink+0x34>  // b.any
    {
        return -EINVAL;
    480122a0:	128002a0 	mov	w0, #0xffffffea            	// #-22
    480122a4:	14000044 	b	480123b4 <dfs_file_unlink+0x140>
    }

    /* get filesystem */
    if ((fs = dfs_filesystem_lookup(fullpath)) == NULL)
    480122a8:	f94023e0 	ldr	x0, [sp, #64]
    480122ac:	97fff84c 	bl	480103dc <dfs_filesystem_lookup>
    480122b0:	f9001fe0 	str	x0, [sp, #56]
    480122b4:	f9401fe0 	ldr	x0, [sp, #56]
    480122b8:	f100001f 	cmp	x0, #0x0
    480122bc:	54000081 	b.ne	480122cc <dfs_file_unlink+0x58>  // b.any
    {
        result = -ENOENT;
    480122c0:	12800020 	mov	w0, #0xfffffffe            	// #-2
    480122c4:	b9004fe0 	str	w0, [sp, #76]
        goto __exit;
    480122c8:	14000038 	b	480123a8 <dfs_file_unlink+0x134>
    }

    /* Check whether file is already open */
    if (fd_is_open(fullpath) == 0)
    480122cc:	f94023e0 	ldr	x0, [sp, #64]
    480122d0:	97fffcca 	bl	480115f8 <fd_is_open>
    480122d4:	7100001f 	cmp	w0, #0x0
    480122d8:	54000081 	b.ne	480122e8 <dfs_file_unlink+0x74>  // b.any
    {
        result = -EBUSY;
    480122dc:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    480122e0:	b9004fe0 	str	w0, [sp, #76]
        goto __exit;
    480122e4:	14000031 	b	480123a8 <dfs_file_unlink+0x134>
    }

    if (fs->ops->unlink != NULL)
    480122e8:	f9401fe0 	ldr	x0, [sp, #56]
    480122ec:	f9400800 	ldr	x0, [x0, #16]
    480122f0:	f9401c00 	ldr	x0, [x0, #56]
    480122f4:	f100001f 	cmp	x0, #0x0
    480122f8:	54000540 	b.eq	480123a0 <dfs_file_unlink+0x12c>  // b.none
    {
        if (!(fs->ops->flags & DFS_FS_FLAG_FULLPATH))
    480122fc:	f9401fe0 	ldr	x0, [sp, #56]
    48012300:	f9400800 	ldr	x0, [x0, #16]
    48012304:	b9400800 	ldr	w0, [x0, #8]
    48012308:	12000000 	and	w0, w0, #0x1
    4801230c:	7100001f 	cmp	w0, #0x0
    48012310:	54000381 	b.ne	48012380 <dfs_file_unlink+0x10c>  // b.any
        {
            if (dfs_subdir(fs->path, fullpath) == NULL)
    48012314:	f9401fe0 	ldr	x0, [sp, #56]
    48012318:	f9400400 	ldr	x0, [x0, #8]
    4801231c:	f94023e1 	ldr	x1, [sp, #64]
    48012320:	97fffd15 	bl	48011774 <dfs_subdir>
    48012324:	f100001f 	cmp	x0, #0x0
    48012328:	54000141 	b.ne	48012350 <dfs_file_unlink+0xdc>  // b.any
                result = fs->ops->unlink(fs, "/");
    4801232c:	f9401fe0 	ldr	x0, [sp, #56]
    48012330:	f9400800 	ldr	x0, [x0, #16]
    48012334:	f9401c02 	ldr	x2, [x0, #56]
    48012338:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801233c:	913ac001 	add	x1, x0, #0xeb0
    48012340:	f9401fe0 	ldr	x0, [sp, #56]
    48012344:	d63f0040 	blr	x2
    48012348:	b9004fe0 	str	w0, [sp, #76]
    4801234c:	14000017 	b	480123a8 <dfs_file_unlink+0x134>
            else
                result = fs->ops->unlink(fs, dfs_subdir(fs->path, fullpath));
    48012350:	f9401fe0 	ldr	x0, [sp, #56]
    48012354:	f9400800 	ldr	x0, [x0, #16]
    48012358:	f9401c13 	ldr	x19, [x0, #56]
    4801235c:	f9401fe0 	ldr	x0, [sp, #56]
    48012360:	f9400400 	ldr	x0, [x0, #8]
    48012364:	f94023e1 	ldr	x1, [sp, #64]
    48012368:	97fffd03 	bl	48011774 <dfs_subdir>
    4801236c:	aa0003e1 	mov	x1, x0
    48012370:	f9401fe0 	ldr	x0, [sp, #56]
    48012374:	d63f0260 	blr	x19
    48012378:	b9004fe0 	str	w0, [sp, #76]
    4801237c:	1400000b 	b	480123a8 <dfs_file_unlink+0x134>
        }
        else
            result = fs->ops->unlink(fs, fullpath);
    48012380:	f9401fe0 	ldr	x0, [sp, #56]
    48012384:	f9400800 	ldr	x0, [x0, #16]
    48012388:	f9401c02 	ldr	x2, [x0, #56]
    4801238c:	f94023e1 	ldr	x1, [sp, #64]
    48012390:	f9401fe0 	ldr	x0, [sp, #56]
    48012394:	d63f0040 	blr	x2
    48012398:	b9004fe0 	str	w0, [sp, #76]
    4801239c:	14000003 	b	480123a8 <dfs_file_unlink+0x134>
    }
    else result = -ENOSYS;
    480123a0:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    480123a4:	b9004fe0 	str	w0, [sp, #76]

__exit:
    rt_free(fullpath);
    480123a8:	f94023e0 	ldr	x0, [sp, #64]
    480123ac:	97ffe006 	bl	4800a3c4 <rt_free>
    return result;
    480123b0:	b9404fe0 	ldr	w0, [sp, #76]
}
    480123b4:	f9400bf3 	ldr	x19, [sp, #16]
    480123b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480123bc:	d65f03c0 	ret

00000000480123c0 <dfs_file_write>:
 * @param len the data buffer length
 *
 * @return the actual written data length.
 */
int dfs_file_write(struct dfs_fd *fd, const void *buf, size_t len)
{
    480123c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480123c4:	910003fd 	mov	x29, sp
    480123c8:	f90017e0 	str	x0, [sp, #40]
    480123cc:	f90013e1 	str	x1, [sp, #32]
    480123d0:	f9000fe2 	str	x2, [sp, #24]
    if (fd == NULL)
    480123d4:	f94017e0 	ldr	x0, [sp, #40]
    480123d8:	f100001f 	cmp	x0, #0x0
    480123dc:	54000061 	b.ne	480123e8 <dfs_file_write+0x28>  // b.any
        return -EINVAL;
    480123e0:	128002a0 	mov	w0, #0xffffffea            	// #-22
    480123e4:	1400000f 	b	48012420 <dfs_file_write+0x60>

    if (fd->fops->write == NULL)
    480123e8:	f94017e0 	ldr	x0, [sp, #40]
    480123ec:	f9401000 	ldr	x0, [x0, #32]
    480123f0:	f9401000 	ldr	x0, [x0, #32]
    480123f4:	f100001f 	cmp	x0, #0x0
    480123f8:	54000061 	b.ne	48012404 <dfs_file_write+0x44>  // b.any
        return -ENOSYS;
    480123fc:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    48012400:	14000008 	b	48012420 <dfs_file_write+0x60>

    return fd->fops->write(fd, buf, len);
    48012404:	f94017e0 	ldr	x0, [sp, #40]
    48012408:	f9401000 	ldr	x0, [x0, #32]
    4801240c:	f9401003 	ldr	x3, [x0, #32]
    48012410:	f9400fe2 	ldr	x2, [sp, #24]
    48012414:	f94013e1 	ldr	x1, [sp, #32]
    48012418:	f94017e0 	ldr	x0, [sp, #40]
    4801241c:	d63f0060 	blr	x3
}
    48012420:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48012424:	d65f03c0 	ret

0000000048012428 <dfs_file_flush>:
 * @param fd the file descriptor.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_file_flush(struct dfs_fd *fd)
{
    48012428:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801242c:	910003fd 	mov	x29, sp
    48012430:	f9000fe0 	str	x0, [sp, #24]
    if (fd == NULL)
    48012434:	f9400fe0 	ldr	x0, [sp, #24]
    48012438:	f100001f 	cmp	x0, #0x0
    4801243c:	54000061 	b.ne	48012448 <dfs_file_flush+0x20>  // b.any
        return -EINVAL;
    48012440:	128002a0 	mov	w0, #0xffffffea            	// #-22
    48012444:	1400000d 	b	48012478 <dfs_file_flush+0x50>

    if (fd->fops->flush == NULL)
    48012448:	f9400fe0 	ldr	x0, [sp, #24]
    4801244c:	f9401000 	ldr	x0, [x0, #32]
    48012450:	f9401400 	ldr	x0, [x0, #40]
    48012454:	f100001f 	cmp	x0, #0x0
    48012458:	54000061 	b.ne	48012464 <dfs_file_flush+0x3c>  // b.any
        return -ENOSYS;
    4801245c:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    48012460:	14000006 	b	48012478 <dfs_file_flush+0x50>

    return fd->fops->flush(fd);
    48012464:	f9400fe0 	ldr	x0, [sp, #24]
    48012468:	f9401000 	ldr	x0, [x0, #32]
    4801246c:	f9401401 	ldr	x1, [x0, #40]
    48012470:	f9400fe0 	ldr	x0, [sp, #24]
    48012474:	d63f0020 	blr	x1
}
    48012478:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801247c:	d65f03c0 	ret

0000000048012480 <dfs_file_lseek>:
 * @param offset the offset to be sought.
 *
 * @return the current position after seek.
 */
int dfs_file_lseek(struct dfs_fd *fd, off_t offset)
{
    48012480:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48012484:	910003fd 	mov	x29, sp
    48012488:	f9000fe0 	str	x0, [sp, #24]
    4801248c:	f9000be1 	str	x1, [sp, #16]
    int result;

    if (fd == NULL)
    48012490:	f9400fe0 	ldr	x0, [sp, #24]
    48012494:	f100001f 	cmp	x0, #0x0
    48012498:	54000061 	b.ne	480124a4 <dfs_file_lseek+0x24>  // b.any
        return -EINVAL;
    4801249c:	128002a0 	mov	w0, #0xffffffea            	// #-22
    480124a0:	14000016 	b	480124f8 <dfs_file_lseek+0x78>

    if (fd->fops->lseek == NULL)
    480124a4:	f9400fe0 	ldr	x0, [sp, #24]
    480124a8:	f9401000 	ldr	x0, [x0, #32]
    480124ac:	f9401800 	ldr	x0, [x0, #48]
    480124b0:	f100001f 	cmp	x0, #0x0
    480124b4:	54000061 	b.ne	480124c0 <dfs_file_lseek+0x40>  // b.any
        return -ENOSYS;
    480124b8:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    480124bc:	1400000f 	b	480124f8 <dfs_file_lseek+0x78>

    result = fd->fops->lseek(fd, offset);
    480124c0:	f9400fe0 	ldr	x0, [sp, #24]
    480124c4:	f9401000 	ldr	x0, [x0, #32]
    480124c8:	f9401802 	ldr	x2, [x0, #48]
    480124cc:	f9400be1 	ldr	x1, [sp, #16]
    480124d0:	f9400fe0 	ldr	x0, [sp, #24]
    480124d4:	d63f0040 	blr	x2
    480124d8:	b9002fe0 	str	w0, [sp, #44]

    /* update current position */
    if (result >= 0)
    480124dc:	b9402fe0 	ldr	w0, [sp, #44]
    480124e0:	7100001f 	cmp	w0, #0x0
    480124e4:	5400008b 	b.lt	480124f4 <dfs_file_lseek+0x74>  // b.tstop
        fd->pos = result;
    480124e8:	b9802fe1 	ldrsw	x1, [sp, #44]
    480124ec:	f9400fe0 	ldr	x0, [sp, #24]
    480124f0:	f9001c01 	str	x1, [x0, #56]

    return result;
    480124f4:	b9402fe0 	ldr	w0, [sp, #44]
}
    480124f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480124fc:	d65f03c0 	ret

0000000048012500 <dfs_file_stat>:
 * @param buf the data buffer to save stat description.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_file_stat(const char *path, struct stat *buf)
{
    48012500:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48012504:	910003fd 	mov	x29, sp
    48012508:	f9000bf3 	str	x19, [sp, #16]
    4801250c:	f90017e0 	str	x0, [sp, #40]
    48012510:	f90013e1 	str	x1, [sp, #32]
    int result;
    char *fullpath;
    struct dfs_filesystem *fs;

    fullpath = dfs_normalize_path(NULL, path);
    48012514:	f94017e1 	ldr	x1, [sp, #40]
    48012518:	d2800000 	mov	x0, #0x0                   	// #0
    4801251c:	97fffcb9 	bl	48011800 <dfs_normalize_path>
    48012520:	f90023e0 	str	x0, [sp, #64]
    if (fullpath == NULL)
    48012524:	f94023e0 	ldr	x0, [sp, #64]
    48012528:	f100001f 	cmp	x0, #0x0
    4801252c:	54000061 	b.ne	48012538 <dfs_file_stat+0x38>  // b.any
    {
        return -1;
    48012530:	12800000 	mov	w0, #0xffffffff            	// #-1
    48012534:	14000067 	b	480126d0 <dfs_file_stat+0x1d0>
    }

    if ((fs = dfs_filesystem_lookup(fullpath)) == NULL)
    48012538:	f94023e0 	ldr	x0, [sp, #64]
    4801253c:	97fff7a8 	bl	480103dc <dfs_filesystem_lookup>
    48012540:	f9001fe0 	str	x0, [sp, #56]
    48012544:	f9401fe0 	ldr	x0, [sp, #56]
    48012548:	f100001f 	cmp	x0, #0x0
    4801254c:	540001e1 	b.ne	48012588 <dfs_file_stat+0x88>  // b.any
    {
        LOG_E("can't find mounted filesystem on this path:%s", fullpath);
    48012550:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012554:	913ae000 	add	x0, x0, #0xeb8
    48012558:	97fff5f6 	bl	4800fd30 <rt_kprintf>
    4801255c:	f94023e1 	ldr	x1, [sp, #64]
    48012560:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012564:	913b2000 	add	x0, x0, #0xec8
    48012568:	97fff5f2 	bl	4800fd30 <rt_kprintf>
    4801256c:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012570:	913be000 	add	x0, x0, #0xef8
    48012574:	97fff5ef 	bl	4800fd30 <rt_kprintf>
        rt_free(fullpath);
    48012578:	f94023e0 	ldr	x0, [sp, #64]
    4801257c:	97ffdf92 	bl	4800a3c4 <rt_free>

        return -ENOENT;
    48012580:	12800020 	mov	w0, #0xfffffffe            	// #-2
    48012584:	14000053 	b	480126d0 <dfs_file_stat+0x1d0>
    }

    if ((fullpath[0] == '/' && fullpath[1] == '\0') ||
    48012588:	f94023e0 	ldr	x0, [sp, #64]
    4801258c:	39400000 	ldrb	w0, [x0]
    48012590:	7100bc1f 	cmp	w0, #0x2f
    48012594:	540000c1 	b.ne	480125ac <dfs_file_stat+0xac>  // b.any
    48012598:	f94023e0 	ldr	x0, [sp, #64]
    4801259c:	91000400 	add	x0, x0, #0x1
    480125a0:	39400000 	ldrb	w0, [x0]
    480125a4:	7100001f 	cmp	w0, #0x0
    480125a8:	540000e0 	b.eq	480125c4 <dfs_file_stat+0xc4>  // b.none
        (dfs_subdir(fs->path, fullpath) == NULL))
    480125ac:	f9401fe0 	ldr	x0, [sp, #56]
    480125b0:	f9400400 	ldr	x0, [x0, #8]
    480125b4:	f94023e1 	ldr	x1, [sp, #64]
    480125b8:	97fffc6f 	bl	48011774 <dfs_subdir>
    if ((fullpath[0] == '/' && fullpath[1] == '\0') ||
    480125bc:	f100001f 	cmp	x0, #0x0
    480125c0:	54000281 	b.ne	48012610 <dfs_file_stat+0x110>  // b.any
    {
        /* it's the root directory */
        buf->st_dev   = 0;
    480125c4:	f94013e0 	ldr	x0, [sp, #32]
    480125c8:	7900001f 	strh	wzr, [x0]

        buf->st_mode  = S_IRUSR | S_IRGRP | S_IROTH |
    480125cc:	f94013e0 	ldr	x0, [sp, #32]
    480125d0:	528036c1 	mov	w1, #0x1b6                 	// #438
    480125d4:	b9000401 	str	w1, [x0, #4]
                        S_IWUSR | S_IWGRP | S_IWOTH;
        buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
    480125d8:	f94013e0 	ldr	x0, [sp, #32]
    480125dc:	b9400401 	ldr	w1, [x0, #4]
    480125e0:	52880920 	mov	w0, #0x4049                	// #16457
    480125e4:	2a000021 	orr	w1, w1, w0
    480125e8:	f94013e0 	ldr	x0, [sp, #32]
    480125ec:	b9000401 	str	w1, [x0, #4]

        buf->st_size    = 0;
    480125f0:	f94013e0 	ldr	x0, [sp, #32]
    480125f4:	f900081f 	str	xzr, [x0, #16]
        buf->st_mtime   = 0;
    480125f8:	f94013e0 	ldr	x0, [sp, #32]
    480125fc:	f900141f 	str	xzr, [x0, #40]

        /* release full path */
        rt_free(fullpath);
    48012600:	f94023e0 	ldr	x0, [sp, #64]
    48012604:	97ffdf70 	bl	4800a3c4 <rt_free>

        return RT_EOK;
    48012608:	52800000 	mov	w0, #0x0                   	// #0
    4801260c:	14000031 	b	480126d0 <dfs_file_stat+0x1d0>
    }
    else
    {
        if (fs->ops->stat == NULL)
    48012610:	f9401fe0 	ldr	x0, [sp, #56]
    48012614:	f9400800 	ldr	x0, [x0, #16]
    48012618:	f9402000 	ldr	x0, [x0, #64]
    4801261c:	f100001f 	cmp	x0, #0x0
    48012620:	540001c1 	b.ne	48012658 <dfs_file_stat+0x158>  // b.any
        {
            rt_free(fullpath);
    48012624:	f94023e0 	ldr	x0, [sp, #64]
    48012628:	97ffdf67 	bl	4800a3c4 <rt_free>
            LOG_E("the filesystem didn't implement this function");
    4801262c:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012630:	913ae000 	add	x0, x0, #0xeb8
    48012634:	97fff5bf 	bl	4800fd30 <rt_kprintf>
    48012638:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    4801263c:	913c0000 	add	x0, x0, #0xf00
    48012640:	97fff5bc 	bl	4800fd30 <rt_kprintf>
    48012644:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012648:	913be000 	add	x0, x0, #0xef8
    4801264c:	97fff5b9 	bl	4800fd30 <rt_kprintf>

            return -ENOSYS;
    48012650:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    48012654:	1400001f 	b	480126d0 <dfs_file_stat+0x1d0>
        }

        /* get the real file path and get file stat */
        if (fs->ops->flags & DFS_FS_FLAG_FULLPATH)
    48012658:	f9401fe0 	ldr	x0, [sp, #56]
    4801265c:	f9400800 	ldr	x0, [x0, #16]
    48012660:	b9400800 	ldr	w0, [x0, #8]
    48012664:	12000000 	and	w0, w0, #0x1
    48012668:	7100001f 	cmp	w0, #0x0
    4801266c:	54000140 	b.eq	48012694 <dfs_file_stat+0x194>  // b.none
            result = fs->ops->stat(fs, fullpath, buf);
    48012670:	f9401fe0 	ldr	x0, [sp, #56]
    48012674:	f9400800 	ldr	x0, [x0, #16]
    48012678:	f9402003 	ldr	x3, [x0, #64]
    4801267c:	f94013e2 	ldr	x2, [sp, #32]
    48012680:	f94023e1 	ldr	x1, [sp, #64]
    48012684:	f9401fe0 	ldr	x0, [sp, #56]
    48012688:	d63f0060 	blr	x3
    4801268c:	b9004fe0 	str	w0, [sp, #76]
    48012690:	1400000d 	b	480126c4 <dfs_file_stat+0x1c4>
        else
            result = fs->ops->stat(fs, dfs_subdir(fs->path, fullpath), buf);
    48012694:	f9401fe0 	ldr	x0, [sp, #56]
    48012698:	f9400800 	ldr	x0, [x0, #16]
    4801269c:	f9402013 	ldr	x19, [x0, #64]
    480126a0:	f9401fe0 	ldr	x0, [sp, #56]
    480126a4:	f9400400 	ldr	x0, [x0, #8]
    480126a8:	f94023e1 	ldr	x1, [sp, #64]
    480126ac:	97fffc32 	bl	48011774 <dfs_subdir>
    480126b0:	f94013e2 	ldr	x2, [sp, #32]
    480126b4:	aa0003e1 	mov	x1, x0
    480126b8:	f9401fe0 	ldr	x0, [sp, #56]
    480126bc:	d63f0260 	blr	x19
    480126c0:	b9004fe0 	str	w0, [sp, #76]
    }

    rt_free(fullpath);
    480126c4:	f94023e0 	ldr	x0, [sp, #64]
    480126c8:	97ffdf3f 	bl	4800a3c4 <rt_free>

    return result;
    480126cc:	b9404fe0 	ldr	w0, [sp, #76]
}
    480126d0:	f9400bf3 	ldr	x19, [sp, #16]
    480126d4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480126d8:	d65f03c0 	ret

00000000480126dc <dfs_file_rename>:
 * @param newpath the new path name.
 *
 * @return 0 on successful, -1 on failed.
 */
int dfs_file_rename(const char *oldpath, const char *newpath)
{
    480126dc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    480126e0:	910003fd 	mov	x29, sp
    480126e4:	a90153f3 	stp	x19, x20, [sp, #16]
    480126e8:	f90017e0 	str	x0, [sp, #40]
    480126ec:	f90013e1 	str	x1, [sp, #32]
    int result;
    struct dfs_filesystem *oldfs, *newfs;
    char *oldfullpath, *newfullpath;

    result = RT_EOK;
    480126f0:	b9005fff 	str	wzr, [sp, #92]
    newfullpath = NULL;
    480126f4:	f9002bff 	str	xzr, [sp, #80]
    oldfullpath = NULL;
    480126f8:	f90027ff 	str	xzr, [sp, #72]

    oldfullpath = dfs_normalize_path(NULL, oldpath);
    480126fc:	f94017e1 	ldr	x1, [sp, #40]
    48012700:	d2800000 	mov	x0, #0x0                   	// #0
    48012704:	97fffc3f 	bl	48011800 <dfs_normalize_path>
    48012708:	f90027e0 	str	x0, [sp, #72]
    if (oldfullpath == NULL)
    4801270c:	f94027e0 	ldr	x0, [sp, #72]
    48012710:	f100001f 	cmp	x0, #0x0
    48012714:	54000081 	b.ne	48012724 <dfs_file_rename+0x48>  // b.any
    {
        result = -ENOENT;
    48012718:	12800020 	mov	w0, #0xfffffffe            	// #-2
    4801271c:	b9005fe0 	str	w0, [sp, #92]
        goto __exit;
    48012720:	14000040 	b	48012820 <dfs_file_rename+0x144>
    }

    newfullpath = dfs_normalize_path(NULL, newpath);
    48012724:	f94013e1 	ldr	x1, [sp, #32]
    48012728:	d2800000 	mov	x0, #0x0                   	// #0
    4801272c:	97fffc35 	bl	48011800 <dfs_normalize_path>
    48012730:	f9002be0 	str	x0, [sp, #80]
    if (newfullpath == NULL)
    48012734:	f9402be0 	ldr	x0, [sp, #80]
    48012738:	f100001f 	cmp	x0, #0x0
    4801273c:	54000081 	b.ne	4801274c <dfs_file_rename+0x70>  // b.any
    {
        result = -ENOENT;
    48012740:	12800020 	mov	w0, #0xfffffffe            	// #-2
    48012744:	b9005fe0 	str	w0, [sp, #92]
        goto __exit;
    48012748:	14000036 	b	48012820 <dfs_file_rename+0x144>
    }

    oldfs = dfs_filesystem_lookup(oldfullpath);
    4801274c:	f94027e0 	ldr	x0, [sp, #72]
    48012750:	97fff723 	bl	480103dc <dfs_filesystem_lookup>
    48012754:	f90023e0 	str	x0, [sp, #64]
    newfs = dfs_filesystem_lookup(newfullpath);
    48012758:	f9402be0 	ldr	x0, [sp, #80]
    4801275c:	97fff720 	bl	480103dc <dfs_filesystem_lookup>
    48012760:	f9001fe0 	str	x0, [sp, #56]

    if (oldfs == newfs)
    48012764:	f94023e1 	ldr	x1, [sp, #64]
    48012768:	f9401fe0 	ldr	x0, [sp, #56]
    4801276c:	eb00003f 	cmp	x1, x0
    48012770:	54000541 	b.ne	48012818 <dfs_file_rename+0x13c>  // b.any
    {
        if (oldfs->ops->rename == NULL)
    48012774:	f94023e0 	ldr	x0, [sp, #64]
    48012778:	f9400800 	ldr	x0, [x0, #16]
    4801277c:	f9402400 	ldr	x0, [x0, #72]
    48012780:	f100001f 	cmp	x0, #0x0
    48012784:	54000081 	b.ne	48012794 <dfs_file_rename+0xb8>  // b.any
        {
            result = -ENOSYS;
    48012788:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    4801278c:	b9005fe0 	str	w0, [sp, #92]
    48012790:	14000024 	b	48012820 <dfs_file_rename+0x144>
        }
        else
        {
            if (oldfs->ops->flags & DFS_FS_FLAG_FULLPATH)
    48012794:	f94023e0 	ldr	x0, [sp, #64]
    48012798:	f9400800 	ldr	x0, [x0, #16]
    4801279c:	b9400800 	ldr	w0, [x0, #8]
    480127a0:	12000000 	and	w0, w0, #0x1
    480127a4:	7100001f 	cmp	w0, #0x0
    480127a8:	54000140 	b.eq	480127d0 <dfs_file_rename+0xf4>  // b.none
                result = oldfs->ops->rename(oldfs, oldfullpath, newfullpath);
    480127ac:	f94023e0 	ldr	x0, [sp, #64]
    480127b0:	f9400800 	ldr	x0, [x0, #16]
    480127b4:	f9402403 	ldr	x3, [x0, #72]
    480127b8:	f9402be2 	ldr	x2, [sp, #80]
    480127bc:	f94027e1 	ldr	x1, [sp, #72]
    480127c0:	f94023e0 	ldr	x0, [sp, #64]
    480127c4:	d63f0060 	blr	x3
    480127c8:	b9005fe0 	str	w0, [sp, #92]
    480127cc:	14000015 	b	48012820 <dfs_file_rename+0x144>
            else
                /* use sub directory to rename in file system */
                result = oldfs->ops->rename(oldfs,
    480127d0:	f94023e0 	ldr	x0, [sp, #64]
    480127d4:	f9400800 	ldr	x0, [x0, #16]
    480127d8:	f9402413 	ldr	x19, [x0, #72]
                                            dfs_subdir(oldfs->path, oldfullpath),
    480127dc:	f94023e0 	ldr	x0, [sp, #64]
    480127e0:	f9400400 	ldr	x0, [x0, #8]
                result = oldfs->ops->rename(oldfs,
    480127e4:	f94027e1 	ldr	x1, [sp, #72]
    480127e8:	97fffbe3 	bl	48011774 <dfs_subdir>
    480127ec:	aa0003f4 	mov	x20, x0
                                            dfs_subdir(newfs->path, newfullpath));
    480127f0:	f9401fe0 	ldr	x0, [sp, #56]
    480127f4:	f9400400 	ldr	x0, [x0, #8]
                result = oldfs->ops->rename(oldfs,
    480127f8:	f9402be1 	ldr	x1, [sp, #80]
    480127fc:	97fffbde 	bl	48011774 <dfs_subdir>
    48012800:	aa0003e2 	mov	x2, x0
    48012804:	aa1403e1 	mov	x1, x20
    48012808:	f94023e0 	ldr	x0, [sp, #64]
    4801280c:	d63f0260 	blr	x19
    48012810:	b9005fe0 	str	w0, [sp, #92]
    48012814:	14000003 	b	48012820 <dfs_file_rename+0x144>
        }
    }
    else
    {
        result = -EXDEV;
    48012818:	12800220 	mov	w0, #0xffffffee            	// #-18
    4801281c:	b9005fe0 	str	w0, [sp, #92]
    }

__exit:
    rt_free(oldfullpath);
    48012820:	f94027e0 	ldr	x0, [sp, #72]
    48012824:	97ffdee8 	bl	4800a3c4 <rt_free>
    rt_free(newfullpath);
    48012828:	f9402be0 	ldr	x0, [sp, #80]
    4801282c:	97ffdee6 	bl	4800a3c4 <rt_free>

    /* not at same file system, return EXDEV */
    return result;
    48012830:	b9405fe0 	ldr	w0, [sp, #92]
}
    48012834:	a94153f3 	ldp	x19, x20, [sp, #16]
    48012838:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4801283c:	d65f03c0 	ret

0000000048012840 <dfs_file_ftruncate>:
 * @param length the length to be truncated.
 *
 * @return the status of truncated.
 */
int dfs_file_ftruncate(struct dfs_fd *fd, off_t length)
{
    48012840:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48012844:	910003fd 	mov	x29, sp
    48012848:	f9000fe0 	str	x0, [sp, #24]
    4801284c:	f9000be1 	str	x1, [sp, #16]
    int result;

    /* fd is null or not a regular file system fd, or length is invalid */
    if (fd == NULL || fd->type != FT_REGULAR || length < 0)
    48012850:	f9400fe0 	ldr	x0, [sp, #24]
    48012854:	f100001f 	cmp	x0, #0x0
    48012858:	54000100 	b.eq	48012878 <dfs_file_ftruncate+0x38>  // b.none
    4801285c:	f9400fe0 	ldr	x0, [sp, #24]
    48012860:	79400400 	ldrh	w0, [x0, #2]
    48012864:	7100001f 	cmp	w0, #0x0
    48012868:	54000081 	b.ne	48012878 <dfs_file_ftruncate+0x38>  // b.any
    4801286c:	f9400be0 	ldr	x0, [sp, #16]
    48012870:	f100001f 	cmp	x0, #0x0
    48012874:	5400006a 	b.ge	48012880 <dfs_file_ftruncate+0x40>  // b.tcont
        return -EINVAL;
    48012878:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4801287c:	14000019 	b	480128e0 <dfs_file_ftruncate+0xa0>

    if (fd->fops->ioctl == NULL)
    48012880:	f9400fe0 	ldr	x0, [sp, #24]
    48012884:	f9401000 	ldr	x0, [x0, #32]
    48012888:	f9400800 	ldr	x0, [x0, #16]
    4801288c:	f100001f 	cmp	x0, #0x0
    48012890:	54000061 	b.ne	4801289c <dfs_file_ftruncate+0x5c>  // b.any
        return -ENOSYS;
    48012894:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    48012898:	14000012 	b	480128e0 <dfs_file_ftruncate+0xa0>

    result = fd->fops->ioctl(fd, RT_FIOFTRUNCATE, (void*)&length);
    4801289c:	f9400fe0 	ldr	x0, [sp, #24]
    480128a0:	f9401000 	ldr	x0, [x0, #32]
    480128a4:	f9400803 	ldr	x3, [x0, #16]
    480128a8:	910043e0 	add	x0, sp, #0x10
    480128ac:	aa0003e2 	mov	x2, x0
    480128b0:	52aa4a81 	mov	w1, #0x52540000            	// #1381236736
    480128b4:	f9400fe0 	ldr	x0, [sp, #24]
    480128b8:	d63f0060 	blr	x3
    480128bc:	b9002fe0 	str	w0, [sp, #44]

    /* update current size */
    if (result == 0)
    480128c0:	b9402fe0 	ldr	w0, [sp, #44]
    480128c4:	7100001f 	cmp	w0, #0x0
    480128c8:	540000a1 	b.ne	480128dc <dfs_file_ftruncate+0x9c>  // b.any
        fd->size = length;
    480128cc:	f9400be0 	ldr	x0, [sp, #16]
    480128d0:	aa0003e1 	mov	x1, x0
    480128d4:	f9400fe0 	ldr	x0, [sp, #24]
    480128d8:	f9001801 	str	x1, [x0, #48]

    return result;
    480128dc:	b9402fe0 	ldr	w0, [sp, #44]
}
    480128e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480128e4:	d65f03c0 	ret

00000000480128e8 <ls>:
#include <finsh.h>

static struct dfs_fd fd;
static struct dirent dirent;
void ls(const char *pathname)
{
    480128e8:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    480128ec:	910003fd 	mov	x29, sp
    480128f0:	f9000fe0 	str	x0, [sp, #24]
    struct stat stat;
    int length;
    char *fullpath, *path;

    fullpath = NULL;
    480128f4:	f9004bff 	str	xzr, [sp, #144]
    if (pathname == NULL)
    480128f8:	f9400fe0 	ldr	x0, [sp, #24]
    480128fc:	f100001f 	cmp	x0, #0x0
    48012900:	54000121 	b.ne	48012924 <ls+0x3c>  // b.any
    {
#ifdef DFS_USING_WORKDIR
        /* open current working directory */
        path = rt_strdup(working_directory);
    48012904:	f0000060 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48012908:	911a6000 	add	x0, x0, #0x698
    4801290c:	97fff084 	bl	4800eb1c <rt_strdup>
    48012910:	f9004fe0 	str	x0, [sp, #152]
#else
        path = rt_strdup("/");
#endif
        if (path == NULL)
    48012914:	f9404fe0 	ldr	x0, [sp, #152]
    48012918:	f100001f 	cmp	x0, #0x0
    4801291c:	54000081 	b.ne	4801292c <ls+0x44>  // b.any
            return ; /* out of memory */
    48012920:	1400005c 	b	48012a90 <ls+0x1a8>
    }
    else
    {
        path = (char *)pathname;
    48012924:	f9400fe0 	ldr	x0, [sp, #24]
    48012928:	f9004fe0 	str	x0, [sp, #152]
    }

    /* list directory */
    if (dfs_file_open(&fd, path, O_DIRECTORY) == 0)
    4801292c:	52a00402 	mov	w2, #0x200000              	// #2097152
    48012930:	f9404fe1 	ldr	x1, [sp, #152]
    48012934:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012938:	911d2000 	add	x0, x0, #0x748
    4801293c:	97fffd28 	bl	48011ddc <dfs_file_open>
    48012940:	7100001f 	cmp	w0, #0x0
    48012944:	54000961 	b.ne	48012a70 <ls+0x188>  // b.any
    {
        rt_kprintf("Directory %s:\n", path);
    48012948:	f9404fe1 	ldr	x1, [sp, #152]
    4801294c:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012950:	913cc000 	add	x0, x0, #0xf30
    48012954:	97fff4f7 	bl	4800fd30 <rt_kprintf>
        do
        {
            memset(&dirent, 0, sizeof(struct dirent));
    48012958:	d2802082 	mov	x2, #0x104                 	// #260
    4801295c:	52800001 	mov	w1, #0x0                   	// #0
    48012960:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012964:	911e4000 	add	x0, x0, #0x790
    48012968:	940024d6 	bl	4801bcc0 <memset>
            length = dfs_file_getdents(&fd, &dirent, sizeof(struct dirent));
    4801296c:	d2802082 	mov	x2, #0x104                 	// #260
    48012970:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012974:	911e4001 	add	x1, x0, #0x790
    48012978:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801297c:	911d2000 	add	x0, x0, #0x748
    48012980:	97fffe1e 	bl	480121f8 <dfs_file_getdents>
    48012984:	b9008fe0 	str	w0, [sp, #140]
            if (length > 0)
    48012988:	b9408fe0 	ldr	w0, [sp, #140]
    4801298c:	7100001f 	cmp	w0, #0x0
    48012990:	540005ed 	b.le	48012a4c <ls+0x164>
            {
                memset(&stat, 0, sizeof(struct stat));
    48012994:	910083e0 	add	x0, sp, #0x20
    48012998:	d2800d02 	mov	x2, #0x68                  	// #104
    4801299c:	52800001 	mov	w1, #0x0                   	// #0
    480129a0:	940024c8 	bl	4801bcc0 <memset>

                /* build full path for each file */
                fullpath = dfs_normalize_path(path, dirent.d_name);
    480129a4:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480129a8:	911e5001 	add	x1, x0, #0x794
    480129ac:	f9404fe0 	ldr	x0, [sp, #152]
    480129b0:	97fffb94 	bl	48011800 <dfs_normalize_path>
    480129b4:	f9004be0 	str	x0, [sp, #144]
                if (fullpath == NULL)
    480129b8:	f9404be0 	ldr	x0, [sp, #144]
    480129bc:	f100001f 	cmp	x0, #0x0
    480129c0:	540004e0 	b.eq	48012a5c <ls+0x174>  // b.none
                    break;

                if (dfs_file_stat(fullpath, &stat) == 0)
    480129c4:	910083e0 	add	x0, sp, #0x20
    480129c8:	aa0003e1 	mov	x1, x0
    480129cc:	f9404be0 	ldr	x0, [sp, #144]
    480129d0:	97fffecc 	bl	48012500 <dfs_file_stat>
    480129d4:	7100001f 	cmp	w0, #0x0
    480129d8:	540002c1 	b.ne	48012a30 <ls+0x148>  // b.any
                {
                    rt_kprintf("%-20s", dirent.d_name);
    480129dc:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480129e0:	911e5001 	add	x1, x0, #0x794
    480129e4:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    480129e8:	913d0000 	add	x0, x0, #0xf40
    480129ec:	97fff4d1 	bl	4800fd30 <rt_kprintf>
                    if (S_ISDIR(stat.st_mode))
    480129f0:	b94027e0 	ldr	w0, [sp, #36]
    480129f4:	12140c00 	and	w0, w0, #0xf000
    480129f8:	7140101f 	cmp	w0, #0x4, lsl #12
    480129fc:	540000e1 	b.ne	48012a18 <ls+0x130>  // b.any
                    {
                        rt_kprintf("%-25s\n", "<DIR>");
    48012a00:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012a04:	913d2001 	add	x1, x0, #0xf48
    48012a08:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012a0c:	913d4000 	add	x0, x0, #0xf50
    48012a10:	97fff4c8 	bl	4800fd30 <rt_kprintf>
    48012a14:	1400000c 	b	48012a44 <ls+0x15c>
                    }
                    else
                    {
                        rt_kprintf("%-25lu\n", (unsigned long)stat.st_size);
    48012a18:	f9401be0 	ldr	x0, [sp, #48]
    48012a1c:	aa0003e1 	mov	x1, x0
    48012a20:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012a24:	913d6000 	add	x0, x0, #0xf58
    48012a28:	97fff4c2 	bl	4800fd30 <rt_kprintf>
    48012a2c:	14000006 	b	48012a44 <ls+0x15c>
                    }
                }
                else
                    rt_kprintf("BAD file: %s\n", dirent.d_name);
    48012a30:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012a34:	911e5001 	add	x1, x0, #0x794
    48012a38:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012a3c:	913d8000 	add	x0, x0, #0xf60
    48012a40:	97fff4bc 	bl	4800fd30 <rt_kprintf>
                rt_free(fullpath);
    48012a44:	f9404be0 	ldr	x0, [sp, #144]
    48012a48:	97ffde5f 	bl	4800a3c4 <rt_free>
            }
        }
        while (length > 0);
    48012a4c:	b9408fe0 	ldr	w0, [sp, #140]
    48012a50:	7100001f 	cmp	w0, #0x0
    48012a54:	54fff82c 	b.gt	48012958 <ls+0x70>
    48012a58:	14000002 	b	48012a60 <ls+0x178>
                    break;
    48012a5c:	d503201f 	nop

        dfs_file_close(&fd);
    48012a60:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012a64:	911d2000 	add	x0, x0, #0x748
    48012a68:	97fffd5f 	bl	48011fe4 <dfs_file_close>
    48012a6c:	14000004 	b	48012a7c <ls+0x194>
    }
    else
    {
        rt_kprintf("No such directory\n");
    48012a70:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012a74:	913dc000 	add	x0, x0, #0xf70
    48012a78:	97fff4ae 	bl	4800fd30 <rt_kprintf>
    }
    if (pathname == NULL)
    48012a7c:	f9400fe0 	ldr	x0, [sp, #24]
    48012a80:	f100001f 	cmp	x0, #0x0
    48012a84:	54000061 	b.ne	48012a90 <ls+0x1a8>  // b.any
        rt_free(path);
    48012a88:	f9404fe0 	ldr	x0, [sp, #152]
    48012a8c:	97ffde4e 	bl	4800a3c4 <rt_free>
}
    48012a90:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    48012a94:	d65f03c0 	ret

0000000048012a98 <rm>:
FINSH_FUNCTION_EXPORT(ls, list directory contents);

void rm(const char *filename)
{
    48012a98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48012a9c:	910003fd 	mov	x29, sp
    48012aa0:	f9000fe0 	str	x0, [sp, #24]
    if (dfs_file_unlink(filename) < 0)
    48012aa4:	f9400fe0 	ldr	x0, [sp, #24]
    48012aa8:	97fffdf3 	bl	48012274 <dfs_file_unlink>
    48012aac:	7100001f 	cmp	w0, #0x0
    48012ab0:	540000aa 	b.ge	48012ac4 <rm+0x2c>  // b.tcont
    {
        rt_kprintf("Delete %s failed\n", filename);
    48012ab4:	f9400fe1 	ldr	x1, [sp, #24]
    48012ab8:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012abc:	913e2000 	add	x0, x0, #0xf88
    48012ac0:	97fff49c 	bl	4800fd30 <rt_kprintf>
    }
}
    48012ac4:	d503201f 	nop
    48012ac8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48012acc:	d65f03c0 	ret

0000000048012ad0 <cat>:
FINSH_FUNCTION_EXPORT(rm, remove files or directories);

void cat(const char *filename)
{
    48012ad0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    48012ad4:	910003fd 	mov	x29, sp
    48012ad8:	f9000fe0 	str	x0, [sp, #24]
    uint32_t length;
    char buffer[81];

    if (dfs_file_open(&fd, filename, O_RDONLY) < 0)
    48012adc:	52800002 	mov	w2, #0x0                   	// #0
    48012ae0:	f9400fe1 	ldr	x1, [sp, #24]
    48012ae4:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012ae8:	911d2000 	add	x0, x0, #0x748
    48012aec:	97fffcbc 	bl	48011ddc <dfs_file_open>
    48012af0:	7100001f 	cmp	w0, #0x0
    48012af4:	540000ca 	b.ge	48012b0c <cat+0x3c>  // b.tcont
    {
        rt_kprintf("Open %s failed\n", filename);
    48012af8:	f9400fe1 	ldr	x1, [sp, #24]
    48012afc:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012b00:	913e8000 	add	x0, x0, #0xfa0
    48012b04:	97fff48b 	bl	4800fd30 <rt_kprintf>
    48012b08:	1400001d 	b	48012b7c <cat+0xac>
        return;
    }

    do
    {
        memset(buffer, 0, sizeof(buffer));
    48012b0c:	9100a3e0 	add	x0, sp, #0x28
    48012b10:	d2800a22 	mov	x2, #0x51                  	// #81
    48012b14:	52800001 	mov	w1, #0x0                   	// #0
    48012b18:	9400246a 	bl	4801bcc0 <memset>
        length = dfs_file_read(&fd, buffer, sizeof(buffer) - 1);
    48012b1c:	9100a3e0 	add	x0, sp, #0x28
    48012b20:	d2800a02 	mov	x2, #0x50                  	// #80
    48012b24:	aa0003e1 	mov	x1, x0
    48012b28:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012b2c:	911d2000 	add	x0, x0, #0x748
    48012b30:	97fffd8d 	bl	48012164 <dfs_file_read>
    48012b34:	b9007fe0 	str	w0, [sp, #124]
        if (length > 0)
    48012b38:	b9407fe0 	ldr	w0, [sp, #124]
    48012b3c:	7100001f 	cmp	w0, #0x0
    48012b40:	540000c0 	b.eq	48012b58 <cat+0x88>  // b.none
        {
            rt_kprintf("%s", buffer);
    48012b44:	9100a3e0 	add	x0, sp, #0x28
    48012b48:	aa0003e1 	mov	x1, x0
    48012b4c:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012b50:	913ec000 	add	x0, x0, #0xfb0
    48012b54:	97fff477 	bl	4800fd30 <rt_kprintf>
        }
    }
    while (length > 0);
    48012b58:	b9407fe0 	ldr	w0, [sp, #124]
    48012b5c:	7100001f 	cmp	w0, #0x0
    48012b60:	54fffd61 	b.ne	48012b0c <cat+0x3c>  // b.any
    rt_kprintf("\n");
    48012b64:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012b68:	913be000 	add	x0, x0, #0xef8
    48012b6c:	97fff471 	bl	4800fd30 <rt_kprintf>

    dfs_file_close(&fd);
    48012b70:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012b74:	911d2000 	add	x0, x0, #0x748
    48012b78:	97fffd1b 	bl	48011fe4 <dfs_file_close>
}
    48012b7c:	a8c87bfd 	ldp	x29, x30, [sp], #128
    48012b80:	d65f03c0 	ret

0000000048012b84 <copyfile>:
FINSH_FUNCTION_EXPORT(cat, print file);

#ifdef RT_USING_POSIX
#define BUF_SZ  4096
static void copyfile(const char *src, const char *dst)
{
    48012b84:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    48012b88:	910003fd 	mov	x29, sp
    48012b8c:	f9000fe0 	str	x0, [sp, #24]
    48012b90:	f9000be1 	str	x1, [sp, #16]
    struct dfs_fd src_fd;
    rt_uint8_t *block_ptr;
    rt_int32_t read_bytes;

    block_ptr = (rt_uint8_t *)rt_malloc(BUF_SZ);
    48012b94:	d2820000 	mov	x0, #0x1000                	// #4096
    48012b98:	97ffdbfc 	bl	48009b88 <rt_malloc>
    48012b9c:	f9003fe0 	str	x0, [sp, #120]
    if (block_ptr == NULL)
    48012ba0:	f9403fe0 	ldr	x0, [sp, #120]
    48012ba4:	f100001f 	cmp	x0, #0x0
    48012ba8:	540000a1 	b.ne	48012bbc <copyfile+0x38>  // b.any
    {
        rt_kprintf("out of memory\n");
    48012bac:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012bb0:	913ee000 	add	x0, x0, #0xfb8
    48012bb4:	97fff45f 	bl	4800fd30 <rt_kprintf>

        return;
    48012bb8:	14000040 	b	48012cb8 <copyfile+0x134>
    }

    if (dfs_file_open(&src_fd, src, O_RDONLY) < 0)
    48012bbc:	9100a3e0 	add	x0, sp, #0x28
    48012bc0:	52800002 	mov	w2, #0x0                   	// #0
    48012bc4:	f9400fe1 	ldr	x1, [sp, #24]
    48012bc8:	97fffc85 	bl	48011ddc <dfs_file_open>
    48012bcc:	7100001f 	cmp	w0, #0x0
    48012bd0:	5400010a 	b.ge	48012bf0 <copyfile+0x6c>  // b.tcont
    {
        rt_free(block_ptr);
    48012bd4:	f9403fe0 	ldr	x0, [sp, #120]
    48012bd8:	97ffddfb 	bl	4800a3c4 <rt_free>
        rt_kprintf("Read %s failed\n", src);
    48012bdc:	f9400fe1 	ldr	x1, [sp, #24]
    48012be0:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012be4:	913f2000 	add	x0, x0, #0xfc8
    48012be8:	97fff452 	bl	4800fd30 <rt_kprintf>

        return;
    48012bec:	14000033 	b	48012cb8 <copyfile+0x134>
    }
    if (dfs_file_open(&fd, dst, O_WRONLY | O_CREAT) < 0)
    48012bf0:	52804022 	mov	w2, #0x201                 	// #513
    48012bf4:	f9400be1 	ldr	x1, [sp, #16]
    48012bf8:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012bfc:	911d2000 	add	x0, x0, #0x748
    48012c00:	97fffc77 	bl	48011ddc <dfs_file_open>
    48012c04:	7100001f 	cmp	w0, #0x0
    48012c08:	5400014a 	b.ge	48012c30 <copyfile+0xac>  // b.tcont
    {
        rt_free(block_ptr);
    48012c0c:	f9403fe0 	ldr	x0, [sp, #120]
    48012c10:	97ffdded 	bl	4800a3c4 <rt_free>
        dfs_file_close(&src_fd);
    48012c14:	9100a3e0 	add	x0, sp, #0x28
    48012c18:	97fffcf3 	bl	48011fe4 <dfs_file_close>

        rt_kprintf("Write %s failed\n", dst);
    48012c1c:	f9400be1 	ldr	x1, [sp, #16]
    48012c20:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012c24:	913f6000 	add	x0, x0, #0xfd8
    48012c28:	97fff442 	bl	4800fd30 <rt_kprintf>

        return;
    48012c2c:	14000023 	b	48012cb8 <copyfile+0x134>
    }

    do
    {
        read_bytes = dfs_file_read(&src_fd, block_ptr, BUF_SZ);
    48012c30:	9100a3e0 	add	x0, sp, #0x28
    48012c34:	d2820002 	mov	x2, #0x1000                	// #4096
    48012c38:	f9403fe1 	ldr	x1, [sp, #120]
    48012c3c:	97fffd4a 	bl	48012164 <dfs_file_read>
    48012c40:	b90077e0 	str	w0, [sp, #116]
        if (read_bytes > 0)
    48012c44:	b94077e0 	ldr	w0, [sp, #116]
    48012c48:	7100001f 	cmp	w0, #0x0
    48012c4c:	5400022d 	b.le	48012c90 <copyfile+0x10c>
        {
            int length;

            length = dfs_file_write(&fd, block_ptr, read_bytes);
    48012c50:	b98077e0 	ldrsw	x0, [sp, #116]
    48012c54:	aa0003e2 	mov	x2, x0
    48012c58:	f9403fe1 	ldr	x1, [sp, #120]
    48012c5c:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012c60:	911d2000 	add	x0, x0, #0x748
    48012c64:	97fffdd7 	bl	480123c0 <dfs_file_write>
    48012c68:	b90073e0 	str	w0, [sp, #112]
            if (length != read_bytes)
    48012c6c:	b94073e1 	ldr	w1, [sp, #112]
    48012c70:	b94077e0 	ldr	w0, [sp, #116]
    48012c74:	6b00003f 	cmp	w1, w0
    48012c78:	540000c0 	b.eq	48012c90 <copyfile+0x10c>  // b.none
            {
                /* write failed. */
                rt_kprintf("Write file data failed, errno=%d\n", length);
    48012c7c:	b94073e1 	ldr	w1, [sp, #112]
    48012c80:	b0000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48012c84:	913fc000 	add	x0, x0, #0xff0
    48012c88:	97fff42a 	bl	4800fd30 <rt_kprintf>
                break;
    48012c8c:	14000004 	b	48012c9c <copyfile+0x118>
            }
        }
    }
    while (read_bytes > 0);
    48012c90:	b94077e0 	ldr	w0, [sp, #116]
    48012c94:	7100001f 	cmp	w0, #0x0
    48012c98:	54fffccc 	b.gt	48012c30 <copyfile+0xac>

    dfs_file_close(&src_fd);
    48012c9c:	9100a3e0 	add	x0, sp, #0x28
    48012ca0:	97fffcd1 	bl	48011fe4 <dfs_file_close>
    dfs_file_close(&fd);
    48012ca4:	f0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48012ca8:	911d2000 	add	x0, x0, #0x748
    48012cac:	97fffcce 	bl	48011fe4 <dfs_file_close>
    rt_free(block_ptr);
    48012cb0:	f9403fe0 	ldr	x0, [sp, #120]
    48012cb4:	97ffddc4 	bl	4800a3c4 <rt_free>
}
    48012cb8:	a8c87bfd 	ldp	x29, x30, [sp], #128
    48012cbc:	d65f03c0 	ret

0000000048012cc0 <copydir>:

extern int mkdir(const char *path, mode_t mode);
static void copydir(const char *src, const char *dst)
{
    48012cc0:	a9a17bfd 	stp	x29, x30, [sp, #-496]!
    48012cc4:	910003fd 	mov	x29, sp
    48012cc8:	f9000fe0 	str	x0, [sp, #24]
    48012ccc:	f9000be1 	str	x1, [sp, #16]
    struct dirent dirent;
    struct stat stat;
    int length;
    struct dfs_fd cpfd;
    if (dfs_file_open(&cpfd, src, O_DIRECTORY) < 0)
    48012cd0:	910083e0 	add	x0, sp, #0x20
    48012cd4:	52a00402 	mov	w2, #0x200000              	// #2097152
    48012cd8:	f9400fe1 	ldr	x1, [sp, #24]
    48012cdc:	97fffc40 	bl	48011ddc <dfs_file_open>
    48012ce0:	7100001f 	cmp	w0, #0x0
    48012ce4:	540000ca 	b.ge	48012cfc <copydir+0x3c>  // b.tcont
    {
        rt_kprintf("open %s failed\n", src);
    48012ce8:	f9400fe1 	ldr	x1, [sp, #24]
    48012cec:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012cf0:	91006000 	add	x0, x0, #0x18
    48012cf4:	97fff40f 	bl	4800fd30 <rt_kprintf>
    48012cf8:	14000065 	b	48012e8c <copydir+0x1cc>
        return ;
    }

    do
    {
        memset(&dirent, 0, sizeof(struct dirent));
    48012cfc:	910343e0 	add	x0, sp, #0xd0
    48012d00:	d2802082 	mov	x2, #0x104                 	// #260
    48012d04:	52800001 	mov	w1, #0x0                   	// #0
    48012d08:	940023ee 	bl	4801bcc0 <memset>

        length = dfs_file_getdents(&cpfd, &dirent, sizeof(struct dirent));
    48012d0c:	910343e1 	add	x1, sp, #0xd0
    48012d10:	910083e0 	add	x0, sp, #0x20
    48012d14:	d2802082 	mov	x2, #0x104                 	// #260
    48012d18:	97fffd38 	bl	480121f8 <dfs_file_getdents>
    48012d1c:	b901efe0 	str	w0, [sp, #492]
        if (length > 0)
    48012d20:	b941efe0 	ldr	w0, [sp, #492]
    48012d24:	7100001f 	cmp	w0, #0x0
    48012d28:	54000a8d 	b.le	48012e78 <copydir+0x1b8>
        {
            char *src_entry_full = NULL;
    48012d2c:	f900f3ff 	str	xzr, [sp, #480]
            char *dst_entry_full = NULL;
    48012d30:	f900efff 	str	xzr, [sp, #472]

            if (strcmp(dirent.d_name, "..") == 0 || strcmp(dirent.d_name, ".") == 0)
    48012d34:	910343e0 	add	x0, sp, #0xd0
    48012d38:	91001002 	add	x2, x0, #0x4
    48012d3c:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012d40:	9100a001 	add	x1, x0, #0x28
    48012d44:	aa0203e0 	mov	x0, x2
    48012d48:	9400245e 	bl	4801bec0 <strcmp>
    48012d4c:	7100001f 	cmp	w0, #0x0
    48012d50:	54000920 	b.eq	48012e74 <copydir+0x1b4>  // b.none
    48012d54:	910343e0 	add	x0, sp, #0xd0
    48012d58:	91001002 	add	x2, x0, #0x4
    48012d5c:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012d60:	9100c001 	add	x1, x0, #0x30
    48012d64:	aa0203e0 	mov	x0, x2
    48012d68:	94002456 	bl	4801bec0 <strcmp>
    48012d6c:	7100001f 	cmp	w0, #0x0
    48012d70:	54000820 	b.eq	48012e74 <copydir+0x1b4>  // b.none
                continue;

            /* build full path for each file */
            if ((src_entry_full = dfs_normalize_path(src, dirent.d_name)) == NULL)
    48012d74:	910343e0 	add	x0, sp, #0xd0
    48012d78:	91001000 	add	x0, x0, #0x4
    48012d7c:	aa0003e1 	mov	x1, x0
    48012d80:	f9400fe0 	ldr	x0, [sp, #24]
    48012d84:	97fffa9f 	bl	48011800 <dfs_normalize_path>
    48012d88:	f900f3e0 	str	x0, [sp, #480]
    48012d8c:	f940f3e0 	ldr	x0, [sp, #480]
    48012d90:	f100001f 	cmp	x0, #0x0
    48012d94:	540000a1 	b.ne	48012da8 <copydir+0xe8>  // b.any
            {
                rt_kprintf("out of memory!\n");
    48012d98:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012d9c:	9100e000 	add	x0, x0, #0x38
    48012da0:	97fff3e4 	bl	4800fd30 <rt_kprintf>
                break;
    48012da4:	14000038 	b	48012e84 <copydir+0x1c4>
            }
            if ((dst_entry_full = dfs_normalize_path(dst, dirent.d_name)) == NULL)
    48012da8:	910343e0 	add	x0, sp, #0xd0
    48012dac:	91001000 	add	x0, x0, #0x4
    48012db0:	aa0003e1 	mov	x1, x0
    48012db4:	f9400be0 	ldr	x0, [sp, #16]
    48012db8:	97fffa92 	bl	48011800 <dfs_normalize_path>
    48012dbc:	f900efe0 	str	x0, [sp, #472]
    48012dc0:	f940efe0 	ldr	x0, [sp, #472]
    48012dc4:	f100001f 	cmp	x0, #0x0
    48012dc8:	540000e1 	b.ne	48012de4 <copydir+0x124>  // b.any
            {
                rt_kprintf("out of memory!\n");
    48012dcc:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012dd0:	9100e000 	add	x0, x0, #0x38
    48012dd4:	97fff3d7 	bl	4800fd30 <rt_kprintf>
                rt_free(src_entry_full);
    48012dd8:	f940f3e0 	ldr	x0, [sp, #480]
    48012ddc:	97ffdd7a 	bl	4800a3c4 <rt_free>
                break;
    48012de0:	14000029 	b	48012e84 <copydir+0x1c4>
            }

            memset(&stat, 0, sizeof(struct stat));
    48012de4:	9101a3e0 	add	x0, sp, #0x68
    48012de8:	d2800d02 	mov	x2, #0x68                  	// #104
    48012dec:	52800001 	mov	w1, #0x0                   	// #0
    48012df0:	940023b4 	bl	4801bcc0 <memset>
            if (dfs_file_stat(src_entry_full, &stat) != 0)
    48012df4:	9101a3e0 	add	x0, sp, #0x68
    48012df8:	aa0003e1 	mov	x1, x0
    48012dfc:	f940f3e0 	ldr	x0, [sp, #480]
    48012e00:	97fffdc0 	bl	48012500 <dfs_file_stat>
    48012e04:	7100001f 	cmp	w0, #0x0
    48012e08:	54000100 	b.eq	48012e28 <copydir+0x168>  // b.none
            {
                rt_kprintf("open file: %s failed\n", dirent.d_name);
    48012e0c:	910343e0 	add	x0, sp, #0xd0
    48012e10:	91001000 	add	x0, x0, #0x4
    48012e14:	aa0003e1 	mov	x1, x0
    48012e18:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012e1c:	91012000 	add	x0, x0, #0x48
    48012e20:	97fff3c4 	bl	4800fd30 <rt_kprintf>
                continue;
    48012e24:	14000015 	b	48012e78 <copydir+0x1b8>
            }

            if (S_ISDIR(stat.st_mode))
    48012e28:	b9406fe0 	ldr	w0, [sp, #108]
    48012e2c:	12140c00 	and	w0, w0, #0xf000
    48012e30:	7140101f 	cmp	w0, #0x4, lsl #12
    48012e34:	54000101 	b.ne	48012e54 <copydir+0x194>  // b.any
            {
                mkdir(dst_entry_full, 0);
    48012e38:	52800001 	mov	w1, #0x0                   	// #0
    48012e3c:	f940efe0 	ldr	x0, [sp, #472]
    48012e40:	9400214f 	bl	4801b37c <mkdir>
                copydir(src_entry_full, dst_entry_full);
    48012e44:	f940efe1 	ldr	x1, [sp, #472]
    48012e48:	f940f3e0 	ldr	x0, [sp, #480]
    48012e4c:	97ffff9d 	bl	48012cc0 <copydir>
    48012e50:	14000004 	b	48012e60 <copydir+0x1a0>
            }
            else
            {
                copyfile(src_entry_full, dst_entry_full);
    48012e54:	f940efe1 	ldr	x1, [sp, #472]
    48012e58:	f940f3e0 	ldr	x0, [sp, #480]
    48012e5c:	97ffff4a 	bl	48012b84 <copyfile>
            }
            rt_free(src_entry_full);
    48012e60:	f940f3e0 	ldr	x0, [sp, #480]
    48012e64:	97ffdd58 	bl	4800a3c4 <rt_free>
            rt_free(dst_entry_full);
    48012e68:	f940efe0 	ldr	x0, [sp, #472]
    48012e6c:	97ffdd56 	bl	4800a3c4 <rt_free>
    48012e70:	14000002 	b	48012e78 <copydir+0x1b8>
                continue;
    48012e74:	d503201f 	nop
        }
    }
    while (length > 0);
    48012e78:	b941efe0 	ldr	w0, [sp, #492]
    48012e7c:	7100001f 	cmp	w0, #0x0
    48012e80:	54fff3ec 	b.gt	48012cfc <copydir+0x3c>

    dfs_file_close(&cpfd);
    48012e84:	910083e0 	add	x0, sp, #0x20
    48012e88:	97fffc57 	bl	48011fe4 <dfs_file_close>
}
    48012e8c:	a8df7bfd 	ldp	x29, x30, [sp], #496
    48012e90:	d65f03c0 	ret

0000000048012e94 <_get_path_lastname>:

static const char *_get_path_lastname(const char *path)
{
    48012e94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48012e98:	910003fd 	mov	x29, sp
    48012e9c:	f9000fe0 	str	x0, [sp, #24]
    char *ptr;
    if ((ptr = (char *)strrchr(path, '/')) == NULL)
    48012ea0:	528005e1 	mov	w1, #0x2f                  	// #47
    48012ea4:	f9400fe0 	ldr	x0, [sp, #24]
    48012ea8:	9400257b 	bl	4801c494 <strrchr>
    48012eac:	f90017e0 	str	x0, [sp, #40]
    48012eb0:	f94017e0 	ldr	x0, [sp, #40]
    48012eb4:	f100001f 	cmp	x0, #0x0
    48012eb8:	54000061 	b.ne	48012ec4 <_get_path_lastname+0x30>  // b.any
        return path;
    48012ebc:	f9400fe0 	ldr	x0, [sp, #24]
    48012ec0:	14000005 	b	48012ed4 <_get_path_lastname+0x40>

    /* skip the '/' then return */
    return ++ptr;
    48012ec4:	f94017e0 	ldr	x0, [sp, #40]
    48012ec8:	91000400 	add	x0, x0, #0x1
    48012ecc:	f90017e0 	str	x0, [sp, #40]
    48012ed0:	f94017e0 	ldr	x0, [sp, #40]
}
    48012ed4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48012ed8:	d65f03c0 	ret

0000000048012edc <copy>:

void copy(const char *src, const char *dst)
{
    48012edc:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    48012ee0:	910003fd 	mov	x29, sp
    48012ee4:	f9000fe0 	str	x0, [sp, #24]
    48012ee8:	f9000be1 	str	x1, [sp, #16]
#define FLAG_DST_IS_DIR    0x04
#define FLAG_DST_IS_FILE   0x08
#define FLAG_DST_NON_EXSIT 0x00

    struct stat stat;
    uint32_t flag = 0;
    48012eec:	b9009fff 	str	wzr, [sp, #156]

    /* check the staus of src and dst */
    if (dfs_file_stat(src, &stat) < 0)
    48012ef0:	910083e0 	add	x0, sp, #0x20
    48012ef4:	aa0003e1 	mov	x1, x0
    48012ef8:	f9400fe0 	ldr	x0, [sp, #24]
    48012efc:	97fffd81 	bl	48012500 <dfs_file_stat>
    48012f00:	7100001f 	cmp	w0, #0x0
    48012f04:	540000ca 	b.ge	48012f1c <copy+0x40>  // b.tcont
    {
        rt_kprintf("copy failed, bad %s\n", src);
    48012f08:	f9400fe1 	ldr	x1, [sp, #24]
    48012f0c:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012f10:	91018000 	add	x0, x0, #0x60
    48012f14:	97fff387 	bl	4800fd30 <rt_kprintf>
        return;
    48012f18:	14000070 	b	480130d8 <copy+0x1fc>
    }
    if (S_ISDIR(stat.st_mode))
    48012f1c:	b94027e0 	ldr	w0, [sp, #36]
    48012f20:	12140c00 	and	w0, w0, #0xf000
    48012f24:	7140101f 	cmp	w0, #0x4, lsl #12
    48012f28:	540000a1 	b.ne	48012f3c <copy+0x60>  // b.any
        flag |= FLAG_SRC_IS_DIR;
    48012f2c:	b9409fe0 	ldr	w0, [sp, #156]
    48012f30:	32000000 	orr	w0, w0, #0x1
    48012f34:	b9009fe0 	str	w0, [sp, #156]
    48012f38:	14000004 	b	48012f48 <copy+0x6c>
    else
        flag |= FLAG_SRC_IS_FILE;
    48012f3c:	b9409fe0 	ldr	w0, [sp, #156]
    48012f40:	321f0000 	orr	w0, w0, #0x2
    48012f44:	b9009fe0 	str	w0, [sp, #156]

    if (dfs_file_stat(dst, &stat) < 0)
    48012f48:	910083e0 	add	x0, sp, #0x20
    48012f4c:	aa0003e1 	mov	x1, x0
    48012f50:	f9400be0 	ldr	x0, [sp, #16]
    48012f54:	97fffd6b 	bl	48012500 <dfs_file_stat>
    48012f58:	7100001f 	cmp	w0, #0x0
    48012f5c:	5400018b 	b.lt	48012f8c <copy+0xb0>  // b.tstop
    {
        flag |= FLAG_DST_NON_EXSIT;
    }
    else
    {
        if (S_ISDIR(stat.st_mode))
    48012f60:	b94027e0 	ldr	w0, [sp, #36]
    48012f64:	12140c00 	and	w0, w0, #0xf000
    48012f68:	7140101f 	cmp	w0, #0x4, lsl #12
    48012f6c:	540000a1 	b.ne	48012f80 <copy+0xa4>  // b.any
            flag |= FLAG_DST_IS_DIR;
    48012f70:	b9409fe0 	ldr	w0, [sp, #156]
    48012f74:	321e0000 	orr	w0, w0, #0x4
    48012f78:	b9009fe0 	str	w0, [sp, #156]
    48012f7c:	14000004 	b	48012f8c <copy+0xb0>
        else
            flag |= FLAG_DST_IS_FILE;
    48012f80:	b9409fe0 	ldr	w0, [sp, #156]
    48012f84:	321d0000 	orr	w0, w0, #0x8
    48012f88:	b9009fe0 	str	w0, [sp, #156]
    }

    //2. check status
    if ((flag & FLAG_SRC_IS_DIR) && (flag & FLAG_DST_IS_FILE))
    48012f8c:	b9409fe0 	ldr	w0, [sp, #156]
    48012f90:	12000000 	and	w0, w0, #0x1
    48012f94:	7100001f 	cmp	w0, #0x0
    48012f98:	54000120 	b.eq	48012fbc <copy+0xe0>  // b.none
    48012f9c:	b9409fe0 	ldr	w0, [sp, #156]
    48012fa0:	121d0000 	and	w0, w0, #0x8
    48012fa4:	7100001f 	cmp	w0, #0x0
    48012fa8:	540000a0 	b.eq	48012fbc <copy+0xe0>  // b.none
    {
        rt_kprintf("cp faild, cp dir to file is not permitted!\n");
    48012fac:	d0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48012fb0:	9101e000 	add	x0, x0, #0x78
    48012fb4:	97fff35f 	bl	4800fd30 <rt_kprintf>
        return ;
    48012fb8:	14000048 	b	480130d8 <copy+0x1fc>
    }

    //3. do copy
    if (flag & FLAG_SRC_IS_FILE)
    48012fbc:	b9409fe0 	ldr	w0, [sp, #156]
    48012fc0:	121f0000 	and	w0, w0, #0x2
    48012fc4:	7100001f 	cmp	w0, #0x0
    48012fc8:	54000380 	b.eq	48013038 <copy+0x15c>  // b.none
    {
        if (flag & FLAG_DST_IS_DIR)
    48012fcc:	b9409fe0 	ldr	w0, [sp, #156]
    48012fd0:	121e0000 	and	w0, w0, #0x4
    48012fd4:	7100001f 	cmp	w0, #0x0
    48012fd8:	54000280 	b.eq	48013028 <copy+0x14c>  // b.none
        {
            char *fdst;
            fdst = dfs_normalize_path(dst, _get_path_lastname(src));
    48012fdc:	f9400fe0 	ldr	x0, [sp, #24]
    48012fe0:	97ffffad 	bl	48012e94 <_get_path_lastname>
    48012fe4:	aa0003e1 	mov	x1, x0
    48012fe8:	f9400be0 	ldr	x0, [sp, #16]
    48012fec:	97fffa05 	bl	48011800 <dfs_normalize_path>
    48012ff0:	f90047e0 	str	x0, [sp, #136]
            if (fdst == NULL)
    48012ff4:	f94047e0 	ldr	x0, [sp, #136]
    48012ff8:	f100001f 	cmp	x0, #0x0
    48012ffc:	540000a1 	b.ne	48013010 <copy+0x134>  // b.any
            {
                rt_kprintf("out of memory\n");
    48013000:	90000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48013004:	913ee000 	add	x0, x0, #0xfb8
    48013008:	97fff34a 	bl	4800fd30 <rt_kprintf>
                return;
    4801300c:	14000033 	b	480130d8 <copy+0x1fc>
            }
            copyfile(src, fdst);
    48013010:	f94047e1 	ldr	x1, [sp, #136]
    48013014:	f9400fe0 	ldr	x0, [sp, #24]
    48013018:	97fffedb 	bl	48012b84 <copyfile>
            rt_free(fdst);
    4801301c:	f94047e0 	ldr	x0, [sp, #136]
    48013020:	97ffdce9 	bl	4800a3c4 <rt_free>
    48013024:	1400002d 	b	480130d8 <copy+0x1fc>
        }
        else
        {
            copyfile(src, dst);
    48013028:	f9400be1 	ldr	x1, [sp, #16]
    4801302c:	f9400fe0 	ldr	x0, [sp, #24]
    48013030:	97fffed5 	bl	48012b84 <copyfile>
    48013034:	14000029 	b	480130d8 <copy+0x1fc>
        }
    }
    else //flag & FLAG_SRC_IS_DIR
    {
        if (flag & FLAG_DST_IS_DIR)
    48013038:	b9409fe0 	ldr	w0, [sp, #156]
    4801303c:	121e0000 	and	w0, w0, #0x4
    48013040:	7100001f 	cmp	w0, #0x0
    48013044:	540002e0 	b.eq	480130a0 <copy+0x1c4>  // b.none
        {
            char *fdst;
            fdst = dfs_normalize_path(dst, _get_path_lastname(src));
    48013048:	f9400fe0 	ldr	x0, [sp, #24]
    4801304c:	97ffff92 	bl	48012e94 <_get_path_lastname>
    48013050:	aa0003e1 	mov	x1, x0
    48013054:	f9400be0 	ldr	x0, [sp, #16]
    48013058:	97fff9ea 	bl	48011800 <dfs_normalize_path>
    4801305c:	f9004be0 	str	x0, [sp, #144]
            if (fdst == NULL)
    48013060:	f9404be0 	ldr	x0, [sp, #144]
    48013064:	f100001f 	cmp	x0, #0x0
    48013068:	540000a1 	b.ne	4801307c <copy+0x1a0>  // b.any
            {
                rt_kprintf("out of memory\n");
    4801306c:	90000060 	adrp	x0, 4801f000 <__FUNCTION__.0+0x2d8>
    48013070:	913ee000 	add	x0, x0, #0xfb8
    48013074:	97fff32f 	bl	4800fd30 <rt_kprintf>
                return;
    48013078:	14000018 	b	480130d8 <copy+0x1fc>
            }
            mkdir(fdst, 0);
    4801307c:	52800001 	mov	w1, #0x0                   	// #0
    48013080:	f9404be0 	ldr	x0, [sp, #144]
    48013084:	940020be 	bl	4801b37c <mkdir>
            copydir(src, fdst);
    48013088:	f9404be1 	ldr	x1, [sp, #144]
    4801308c:	f9400fe0 	ldr	x0, [sp, #24]
    48013090:	97ffff0c 	bl	48012cc0 <copydir>
            rt_free(fdst);
    48013094:	f9404be0 	ldr	x0, [sp, #144]
    48013098:	97ffdccb 	bl	4800a3c4 <rt_free>
    4801309c:	1400000f 	b	480130d8 <copy+0x1fc>
        }
        else if ((flag & FLAG_DST_TYPE) == FLAG_DST_NON_EXSIT)
    480130a0:	b9409fe0 	ldr	w0, [sp, #156]
    480130a4:	121e0400 	and	w0, w0, #0xc
    480130a8:	7100001f 	cmp	w0, #0x0
    480130ac:	54000101 	b.ne	480130cc <copy+0x1f0>  // b.any
        {
            mkdir(dst, 0);
    480130b0:	52800001 	mov	w1, #0x0                   	// #0
    480130b4:	f9400be0 	ldr	x0, [sp, #16]
    480130b8:	940020b1 	bl	4801b37c <mkdir>
            copydir(src, dst);
    480130bc:	f9400be1 	ldr	x1, [sp, #16]
    480130c0:	f9400fe0 	ldr	x0, [sp, #24]
    480130c4:	97fffeff 	bl	48012cc0 <copydir>
    480130c8:	14000004 	b	480130d8 <copy+0x1fc>
        }
        else
        {
            copydir(src, dst);
    480130cc:	f9400be1 	ldr	x1, [sp, #16]
    480130d0:	f9400fe0 	ldr	x0, [sp, #24]
    480130d4:	97fffefb 	bl	48012cc0 <copydir>
        }
    }
}
    480130d8:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    480130dc:	d65f03c0 	ret

00000000480130e0 <dfs_device_fs_mount>:
    rt_uint16_t read_index;
    rt_uint16_t device_count;
};

int dfs_device_fs_mount(struct dfs_filesystem *fs, unsigned long rwflag, const void *data)
{
    480130e0:	d10083ff 	sub	sp, sp, #0x20
    480130e4:	f9000fe0 	str	x0, [sp, #24]
    480130e8:	f9000be1 	str	x1, [sp, #16]
    480130ec:	f90007e2 	str	x2, [sp, #8]
    return RT_EOK;
    480130f0:	52800000 	mov	w0, #0x0                   	// #0
}
    480130f4:	910083ff 	add	sp, sp, #0x20
    480130f8:	d65f03c0 	ret

00000000480130fc <dfs_device_fs_ioctl>:

int dfs_device_fs_ioctl(struct dfs_fd *file, int cmd, void *args)
{
    480130fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013100:	910003fd 	mov	x29, sp
    48013104:	f90017e0 	str	x0, [sp, #40]
    48013108:	b90027e1 	str	w1, [sp, #36]
    4801310c:	f9000fe2 	str	x2, [sp, #24]
    rt_err_t result;
    rt_device_t dev_id;

    RT_ASSERT(file != RT_NULL);
    48013110:	f94017e0 	ldr	x0, [sp, #40]
    48013114:	f100001f 	cmp	x0, #0x0
    48013118:	540000e1 	b.ne	48013134 <dfs_device_fs_ioctl+0x38>  // b.any
    4801311c:	d28004a2 	mov	x2, #0x25                  	// #37
    48013120:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013124:	91068001 	add	x1, x0, #0x1a0
    48013128:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801312c:	9102a000 	add	x0, x0, #0xa8
    48013130:	97fff3ce 	bl	48010068 <rt_assert_handler>

    /* get device handler */
    dev_id = (rt_device_t)file->data;
    48013134:	f94017e0 	ldr	x0, [sp, #40]
    48013138:	f9402000 	ldr	x0, [x0, #64]
    4801313c:	f9001fe0 	str	x0, [sp, #56]
    RT_ASSERT(dev_id != RT_NULL);
    48013140:	f9401fe0 	ldr	x0, [sp, #56]
    48013144:	f100001f 	cmp	x0, #0x0
    48013148:	540000e1 	b.ne	48013164 <dfs_device_fs_ioctl+0x68>  // b.any
    4801314c:	d2800522 	mov	x2, #0x29                  	// #41
    48013150:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013154:	91068001 	add	x1, x0, #0x1a0
    48013158:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801315c:	9102e000 	add	x0, x0, #0xb8
    48013160:	97fff3c2 	bl	48010068 <rt_assert_handler>

    /* close device handler */
    result = rt_device_control(dev_id, cmd, args);
    48013164:	f9400fe2 	ldr	x2, [sp, #24]
    48013168:	b94027e1 	ldr	w1, [sp, #36]
    4801316c:	f9401fe0 	ldr	x0, [sp, #56]
    48013170:	97ffe752 	bl	4800ceb8 <rt_device_control>
    48013174:	f9001be0 	str	x0, [sp, #48]
    if (result == RT_EOK)
    48013178:	f9401be0 	ldr	x0, [sp, #48]
    4801317c:	f100001f 	cmp	x0, #0x0
    48013180:	54000061 	b.ne	4801318c <dfs_device_fs_ioctl+0x90>  // b.any
        return RT_EOK;
    48013184:	52800000 	mov	w0, #0x0                   	// #0
    48013188:	14000002 	b	48013190 <dfs_device_fs_ioctl+0x94>

    return result;
    4801318c:	f9401be0 	ldr	x0, [sp, #48]
}
    48013190:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013194:	d65f03c0 	ret

0000000048013198 <dfs_device_fs_read>:

int dfs_device_fs_read(struct dfs_fd *file, void *buf, size_t count)
{
    48013198:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801319c:	910003fd 	mov	x29, sp
    480131a0:	f90017e0 	str	x0, [sp, #40]
    480131a4:	f90013e1 	str	x1, [sp, #32]
    480131a8:	f9000fe2 	str	x2, [sp, #24]
    int result;
    rt_device_t dev_id;

    RT_ASSERT(file != RT_NULL);
    480131ac:	f94017e0 	ldr	x0, [sp, #40]
    480131b0:	f100001f 	cmp	x0, #0x0
    480131b4:	540000e1 	b.ne	480131d0 <dfs_device_fs_read+0x38>  // b.any
    480131b8:	d2800702 	mov	x2, #0x38                  	// #56
    480131bc:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480131c0:	9106e001 	add	x1, x0, #0x1b8
    480131c4:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480131c8:	9102a000 	add	x0, x0, #0xa8
    480131cc:	97fff3a7 	bl	48010068 <rt_assert_handler>

    /* get device handler */
    dev_id = (rt_device_t)file->data;
    480131d0:	f94017e0 	ldr	x0, [sp, #40]
    480131d4:	f9402000 	ldr	x0, [x0, #64]
    480131d8:	f9001fe0 	str	x0, [sp, #56]
    RT_ASSERT(dev_id != RT_NULL);
    480131dc:	f9401fe0 	ldr	x0, [sp, #56]
    480131e0:	f100001f 	cmp	x0, #0x0
    480131e4:	540000e1 	b.ne	48013200 <dfs_device_fs_read+0x68>  // b.any
    480131e8:	d2800782 	mov	x2, #0x3c                  	// #60
    480131ec:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480131f0:	9106e001 	add	x1, x0, #0x1b8
    480131f4:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480131f8:	9102e000 	add	x0, x0, #0xb8
    480131fc:	97fff39b 	bl	48010068 <rt_assert_handler>

    /* read device data */
    result = rt_device_read(dev_id, file->pos, buf, count);
    48013200:	f94017e0 	ldr	x0, [sp, #40]
    48013204:	f9401c00 	ldr	x0, [x0, #56]
    48013208:	f9400fe3 	ldr	x3, [sp, #24]
    4801320c:	f94013e2 	ldr	x2, [sp, #32]
    48013210:	aa0003e1 	mov	x1, x0
    48013214:	f9401fe0 	ldr	x0, [sp, #56]
    48013218:	97ffe6c2 	bl	4800cd20 <rt_device_read>
    4801321c:	b90037e0 	str	w0, [sp, #52]
    file->pos += result;
    48013220:	f94017e0 	ldr	x0, [sp, #40]
    48013224:	f9401c01 	ldr	x1, [x0, #56]
    48013228:	b98037e0 	ldrsw	x0, [sp, #52]
    4801322c:	8b000021 	add	x1, x1, x0
    48013230:	f94017e0 	ldr	x0, [sp, #40]
    48013234:	f9001c01 	str	x1, [x0, #56]

    return result;
    48013238:	b94037e0 	ldr	w0, [sp, #52]
}
    4801323c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013240:	d65f03c0 	ret

0000000048013244 <dfs_device_fs_write>:

int dfs_device_fs_write(struct dfs_fd *file, const void *buf, size_t count)
{
    48013244:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013248:	910003fd 	mov	x29, sp
    4801324c:	f90017e0 	str	x0, [sp, #40]
    48013250:	f90013e1 	str	x1, [sp, #32]
    48013254:	f9000fe2 	str	x2, [sp, #24]
    int result;
    rt_device_t dev_id;

    RT_ASSERT(file != RT_NULL);
    48013258:	f94017e0 	ldr	x0, [sp, #40]
    4801325c:	f100001f 	cmp	x0, #0x0
    48013260:	540000e1 	b.ne	4801327c <dfs_device_fs_write+0x38>  // b.any
    48013264:	d2800942 	mov	x2, #0x4a                  	// #74
    48013268:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801326c:	91074001 	add	x1, x0, #0x1d0
    48013270:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013274:	9102a000 	add	x0, x0, #0xa8
    48013278:	97fff37c 	bl	48010068 <rt_assert_handler>

    /* get device handler */
    dev_id = (rt_device_t)file->data;
    4801327c:	f94017e0 	ldr	x0, [sp, #40]
    48013280:	f9402000 	ldr	x0, [x0, #64]
    48013284:	f9001fe0 	str	x0, [sp, #56]
    RT_ASSERT(dev_id != RT_NULL);
    48013288:	f9401fe0 	ldr	x0, [sp, #56]
    4801328c:	f100001f 	cmp	x0, #0x0
    48013290:	540000e1 	b.ne	480132ac <dfs_device_fs_write+0x68>  // b.any
    48013294:	d28009c2 	mov	x2, #0x4e                  	// #78
    48013298:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801329c:	91074001 	add	x1, x0, #0x1d0
    480132a0:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480132a4:	9102e000 	add	x0, x0, #0xb8
    480132a8:	97fff370 	bl	48010068 <rt_assert_handler>

    /* read device data */
    result = rt_device_write(dev_id, file->pos, buf, count);
    480132ac:	f94017e0 	ldr	x0, [sp, #40]
    480132b0:	f9401c00 	ldr	x0, [x0, #56]
    480132b4:	f9400fe3 	ldr	x3, [sp, #24]
    480132b8:	f94013e2 	ldr	x2, [sp, #32]
    480132bc:	aa0003e1 	mov	x1, x0
    480132c0:	f9401fe0 	ldr	x0, [sp, #56]
    480132c4:	97ffe6ca 	bl	4800cdec <rt_device_write>
    480132c8:	b90037e0 	str	w0, [sp, #52]
    file->pos += result;
    480132cc:	f94017e0 	ldr	x0, [sp, #40]
    480132d0:	f9401c01 	ldr	x1, [x0, #56]
    480132d4:	b98037e0 	ldrsw	x0, [sp, #52]
    480132d8:	8b000021 	add	x1, x1, x0
    480132dc:	f94017e0 	ldr	x0, [sp, #40]
    480132e0:	f9001c01 	str	x1, [x0, #56]

    return result;
    480132e4:	b94037e0 	ldr	w0, [sp, #52]
}
    480132e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480132ec:	d65f03c0 	ret

00000000480132f0 <dfs_device_fs_close>:

int dfs_device_fs_close(struct dfs_fd *file)
{
    480132f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480132f4:	910003fd 	mov	x29, sp
    480132f8:	f9000fe0 	str	x0, [sp, #24]
    rt_err_t result;
    rt_device_t dev_id;

    RT_ASSERT(file != RT_NULL);
    480132fc:	f9400fe0 	ldr	x0, [sp, #24]
    48013300:	f100001f 	cmp	x0, #0x0
    48013304:	540000e1 	b.ne	48013320 <dfs_device_fs_close+0x30>  // b.any
    48013308:	d2800b82 	mov	x2, #0x5c                  	// #92
    4801330c:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013310:	9107a001 	add	x1, x0, #0x1e8
    48013314:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013318:	9102a000 	add	x0, x0, #0xa8
    4801331c:	97fff353 	bl	48010068 <rt_assert_handler>

    if (file->type == FT_DIRECTORY)
    48013320:	f9400fe0 	ldr	x0, [sp, #24]
    48013324:	79400400 	ldrh	w0, [x0, #2]
    48013328:	7100081f 	cmp	w0, #0x2
    4801332c:	54000221 	b.ne	48013370 <dfs_device_fs_close+0x80>  // b.any
    {
        struct device_dirent *root_dirent;

        root_dirent = (struct device_dirent *)file->data;
    48013330:	f9400fe0 	ldr	x0, [sp, #24]
    48013334:	f9402000 	ldr	x0, [x0, #64]
    48013338:	f90017e0 	str	x0, [sp, #40]
        RT_ASSERT(root_dirent != RT_NULL);
    4801333c:	f94017e0 	ldr	x0, [sp, #40]
    48013340:	f100001f 	cmp	x0, #0x0
    48013344:	540000e1 	b.ne	48013360 <dfs_device_fs_close+0x70>  // b.any
    48013348:	d2800c62 	mov	x2, #0x63                  	// #99
    4801334c:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013350:	9107a001 	add	x1, x0, #0x1e8
    48013354:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013358:	91034000 	add	x0, x0, #0xd0
    4801335c:	97fff343 	bl	48010068 <rt_assert_handler>

        /* release dirent */
        rt_free(root_dirent);
    48013360:	f94017e0 	ldr	x0, [sp, #40]
    48013364:	97ffdc18 	bl	4800a3c4 <rt_free>
        return RT_EOK;
    48013368:	52800000 	mov	w0, #0x0                   	// #0
    4801336c:	14000018 	b	480133cc <dfs_device_fs_close+0xdc>
    }

    /* get device handler */
    dev_id = (rt_device_t)file->data;
    48013370:	f9400fe0 	ldr	x0, [sp, #24]
    48013374:	f9402000 	ldr	x0, [x0, #64]
    48013378:	f9001fe0 	str	x0, [sp, #56]
    RT_ASSERT(dev_id != RT_NULL);
    4801337c:	f9401fe0 	ldr	x0, [sp, #56]
    48013380:	f100001f 	cmp	x0, #0x0
    48013384:	540000e1 	b.ne	480133a0 <dfs_device_fs_close+0xb0>  // b.any
    48013388:	d2800d82 	mov	x2, #0x6c                  	// #108
    4801338c:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013390:	9107a001 	add	x1, x0, #0x1e8
    48013394:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013398:	9102e000 	add	x0, x0, #0xb8
    4801339c:	97fff333 	bl	48010068 <rt_assert_handler>

    /* close device handler */
    result = rt_device_close(dev_id);
    480133a0:	f9401fe0 	ldr	x0, [sp, #56]
    480133a4:	97ffe621 	bl	4800cc28 <rt_device_close>
    480133a8:	f9001be0 	str	x0, [sp, #48]
    if (result == RT_EOK)
    480133ac:	f9401be0 	ldr	x0, [sp, #48]
    480133b0:	f100001f 	cmp	x0, #0x0
    480133b4:	540000a1 	b.ne	480133c8 <dfs_device_fs_close+0xd8>  // b.any
    {
        file->data = RT_NULL;
    480133b8:	f9400fe0 	ldr	x0, [sp, #24]
    480133bc:	f900201f 	str	xzr, [x0, #64]

        return RT_EOK;
    480133c0:	52800000 	mov	w0, #0x0                   	// #0
    480133c4:	14000002 	b	480133cc <dfs_device_fs_close+0xdc>
    }

    return -EIO;
    480133c8:	12800080 	mov	w0, #0xfffffffb            	// #-5
}
    480133cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480133d0:	d65f03c0 	ret

00000000480133d4 <dfs_device_fs_open>:

int dfs_device_fs_open(struct dfs_fd *file)
{
    480133d4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    480133d8:	910003fd 	mov	x29, sp
    480133dc:	f9000fe0 	str	x0, [sp, #24]
    rt_err_t result;
    rt_device_t device;

    /* open root directory */
    if ((file->path[0] == '/') && (file->path[1] == '\0') &&
    480133e0:	f9400fe0 	ldr	x0, [sp, #24]
    480133e4:	f9400400 	ldr	x0, [x0, #8]
    480133e8:	39400000 	ldrb	w0, [x0]
    480133ec:	7100bc1f 	cmp	w0, #0x2f
    480133f0:	54000b61 	b.ne	4801355c <dfs_device_fs_open+0x188>  // b.any
    480133f4:	f9400fe0 	ldr	x0, [sp, #24]
    480133f8:	f9400400 	ldr	x0, [x0, #8]
    480133fc:	91000400 	add	x0, x0, #0x1
    48013400:	39400000 	ldrb	w0, [x0]
    48013404:	7100001f 	cmp	w0, #0x0
    48013408:	54000aa1 	b.ne	4801355c <dfs_device_fs_open+0x188>  // b.any
        (file->flags & O_DIRECTORY))
    4801340c:	f9400fe0 	ldr	x0, [sp, #24]
    48013410:	b9402800 	ldr	w0, [x0, #40]
    48013414:	120b0000 	and	w0, w0, #0x200000
    if ((file->path[0] == '/') && (file->path[1] == '\0') &&
    48013418:	7100001f 	cmp	w0, #0x0
    4801341c:	54000a00 	b.eq	4801355c <dfs_device_fs_open+0x188>  // b.none
    {
        struct rt_object *object;
        struct rt_list_node *node;
        struct rt_object_information *information;
        struct device_dirent *root_dirent;
        rt_uint32_t count = 0;
    48013420:	b90057ff 	str	wzr, [sp, #84]

        /* lock scheduler */
        rt_enter_critical();
    48013424:	97ffe8fd 	bl	4800d818 <rt_enter_critical>

        /* traverse device object */
        information = rt_object_get_information(RT_Object_Class_Device);
    48013428:	52800120 	mov	w0, #0x9                   	// #9
    4801342c:	97ffe992 	bl	4800da74 <rt_object_get_information>
    48013430:	f90027e0 	str	x0, [sp, #72]
        RT_ASSERT(information != RT_NULL);
    48013434:	f94027e0 	ldr	x0, [sp, #72]
    48013438:	f100001f 	cmp	x0, #0x0
    4801343c:	540000e1 	b.ne	48013458 <dfs_device_fs_open+0x84>  // b.any
    48013440:	d28011c2 	mov	x2, #0x8e                  	// #142
    48013444:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013448:	91080001 	add	x1, x0, #0x200
    4801344c:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013450:	9103a000 	add	x0, x0, #0xe8
    48013454:	97fff305 	bl	48010068 <rt_assert_handler>
        for (node = information->object_list.next; node != &(information->object_list); node = node->next)
    48013458:	f94027e0 	ldr	x0, [sp, #72]
    4801345c:	f9400400 	ldr	x0, [x0, #8]
    48013460:	f9002fe0 	str	x0, [sp, #88]
    48013464:	14000007 	b	48013480 <dfs_device_fs_open+0xac>
        {
            count ++;
    48013468:	b94057e0 	ldr	w0, [sp, #84]
    4801346c:	11000400 	add	w0, w0, #0x1
    48013470:	b90057e0 	str	w0, [sp, #84]
        for (node = information->object_list.next; node != &(information->object_list); node = node->next)
    48013474:	f9402fe0 	ldr	x0, [sp, #88]
    48013478:	f9400000 	ldr	x0, [x0]
    4801347c:	f9002fe0 	str	x0, [sp, #88]
    48013480:	f94027e0 	ldr	x0, [sp, #72]
    48013484:	91002000 	add	x0, x0, #0x8
    48013488:	f9402fe1 	ldr	x1, [sp, #88]
    4801348c:	eb00003f 	cmp	x1, x0
    48013490:	54fffec1 	b.ne	48013468 <dfs_device_fs_open+0x94>  // b.any
        }

        root_dirent = (struct device_dirent *)rt_malloc(sizeof(struct device_dirent) +
    48013494:	b94057e0 	ldr	w0, [sp, #84]
    48013498:	91000800 	add	x0, x0, #0x2
    4801349c:	d37df000 	lsl	x0, x0, #3
    480134a0:	97ffd9ba 	bl	48009b88 <rt_malloc>
    480134a4:	f90023e0 	str	x0, [sp, #64]
                      count * sizeof(rt_device_t));
        if (root_dirent != RT_NULL)
    480134a8:	f94023e0 	ldr	x0, [sp, #64]
    480134ac:	f100001f 	cmp	x0, #0x0
    480134b0:	540004a0 	b.eq	48013544 <dfs_device_fs_open+0x170>  // b.none
        {
            root_dirent->devices = (rt_device_t *)(root_dirent + 1);
    480134b4:	f94023e0 	ldr	x0, [sp, #64]
    480134b8:	91004001 	add	x1, x0, #0x10
    480134bc:	f94023e0 	ldr	x0, [sp, #64]
    480134c0:	f9000001 	str	x1, [x0]
            root_dirent->read_index = 0;
    480134c4:	f94023e0 	ldr	x0, [sp, #64]
    480134c8:	7900101f 	strh	wzr, [x0, #8]
            root_dirent->device_count = count;
    480134cc:	b94057e0 	ldr	w0, [sp, #84]
    480134d0:	12003c01 	and	w1, w0, #0xffff
    480134d4:	f94023e0 	ldr	x0, [sp, #64]
    480134d8:	79001401 	strh	w1, [x0, #10]
            count = 0;
    480134dc:	b90057ff 	str	wzr, [sp, #84]
            /* get all device node */
            for (node = information->object_list.next; node != &(information->object_list); node = node->next)
    480134e0:	f94027e0 	ldr	x0, [sp, #72]
    480134e4:	f9400400 	ldr	x0, [x0, #8]
    480134e8:	f9002fe0 	str	x0, [sp, #88]
    480134ec:	14000011 	b	48013530 <dfs_device_fs_open+0x15c>
            {
                object = rt_list_entry(node, struct rt_object, list);
    480134f0:	f9402fe0 	ldr	x0, [sp, #88]
    480134f4:	d1004000 	sub	x0, x0, #0x10
    480134f8:	f9001fe0 	str	x0, [sp, #56]
                root_dirent->devices[count] = (rt_device_t)object;
    480134fc:	f94023e0 	ldr	x0, [sp, #64]
    48013500:	f9400001 	ldr	x1, [x0]
    48013504:	b94057e0 	ldr	w0, [sp, #84]
    48013508:	d37df000 	lsl	x0, x0, #3
    4801350c:	8b000020 	add	x0, x1, x0
    48013510:	f9401fe1 	ldr	x1, [sp, #56]
    48013514:	f9000001 	str	x1, [x0]
                count ++;
    48013518:	b94057e0 	ldr	w0, [sp, #84]
    4801351c:	11000400 	add	w0, w0, #0x1
    48013520:	b90057e0 	str	w0, [sp, #84]
            for (node = information->object_list.next; node != &(information->object_list); node = node->next)
    48013524:	f9402fe0 	ldr	x0, [sp, #88]
    48013528:	f9400000 	ldr	x0, [x0]
    4801352c:	f9002fe0 	str	x0, [sp, #88]
    48013530:	f94027e0 	ldr	x0, [sp, #72]
    48013534:	91002000 	add	x0, x0, #0x8
    48013538:	f9402fe1 	ldr	x1, [sp, #88]
    4801353c:	eb00003f 	cmp	x1, x0
    48013540:	54fffd81 	b.ne	480134f0 <dfs_device_fs_open+0x11c>  // b.any
            }
        }
        rt_exit_critical();
    48013544:	97ffe8ca 	bl	4800d86c <rt_exit_critical>

        /* set data */
        file->data = root_dirent;
    48013548:	f9400fe0 	ldr	x0, [sp, #24]
    4801354c:	f94023e1 	ldr	x1, [sp, #64]
    48013550:	f9002001 	str	x1, [x0, #64]

        return RT_EOK;
    48013554:	52800000 	mov	w0, #0x0                   	// #0
    48013558:	14000042 	b	48013660 <dfs_device_fs_open+0x28c>
    }

    device = rt_device_find(&file->path[1]);
    4801355c:	f9400fe0 	ldr	x0, [sp, #24]
    48013560:	f9400400 	ldr	x0, [x0, #8]
    48013564:	91000400 	add	x0, x0, #0x1
    48013568:	97ffe4c0 	bl	4800c868 <rt_device_find>
    4801356c:	f9001be0 	str	x0, [sp, #48]
    if (device == RT_NULL)
    48013570:	f9401be0 	ldr	x0, [sp, #48]
    48013574:	f100001f 	cmp	x0, #0x0
    48013578:	54000061 	b.ne	48013584 <dfs_device_fs_open+0x1b0>  // b.any
        return -ENODEV;
    4801357c:	12800240 	mov	w0, #0xffffffed            	// #-19
    48013580:	14000038 	b	48013660 <dfs_device_fs_open+0x28c>

#ifdef RT_USING_POSIX
    if (device->fops)
    48013584:	f9401be0 	ldr	x0, [sp, #48]
    48013588:	f9403800 	ldr	x0, [x0, #112]
    4801358c:	f100001f 	cmp	x0, #0x0
    48013590:	540003e0 	b.eq	4801360c <dfs_device_fs_open+0x238>  // b.none
    {
        /* use device fops */
        file->fops = device->fops;
    48013594:	f9401be0 	ldr	x0, [sp, #48]
    48013598:	f9403801 	ldr	x1, [x0, #112]
    4801359c:	f9400fe0 	ldr	x0, [sp, #24]
    480135a0:	f9001001 	str	x1, [x0, #32]
        file->data = (void *)device;
    480135a4:	f9400fe0 	ldr	x0, [sp, #24]
    480135a8:	f9401be1 	ldr	x1, [sp, #48]
    480135ac:	f9002001 	str	x1, [x0, #64]

        /* use fops */
        if (file->fops->open)
    480135b0:	f9400fe0 	ldr	x0, [sp, #24]
    480135b4:	f9401000 	ldr	x0, [x0, #32]
    480135b8:	f9400000 	ldr	x0, [x0]
    480135bc:	f100001f 	cmp	x0, #0x0
    480135c0:	540004a0 	b.eq	48013654 <dfs_device_fs_open+0x280>  // b.none
        {
            result = file->fops->open(file);
    480135c4:	f9400fe0 	ldr	x0, [sp, #24]
    480135c8:	f9401000 	ldr	x0, [x0, #32]
    480135cc:	f9400001 	ldr	x1, [x0]
    480135d0:	f9400fe0 	ldr	x0, [sp, #24]
    480135d4:	d63f0020 	blr	x1
    480135d8:	93407c00 	sxtw	x0, w0
    480135dc:	f90017e0 	str	x0, [sp, #40]
            if (result == RT_EOK || result == -RT_ENOSYS)
    480135e0:	f94017e0 	ldr	x0, [sp, #40]
    480135e4:	f100001f 	cmp	x0, #0x0
    480135e8:	54000080 	b.eq	480135f8 <dfs_device_fs_open+0x224>  // b.none
    480135ec:	f94017e0 	ldr	x0, [sp, #40]
    480135f0:	b100181f 	cmn	x0, #0x6
    480135f4:	54000301 	b.ne	48013654 <dfs_device_fs_open+0x280>  // b.any
            {
                file->type = FT_DEVICE;
    480135f8:	f9400fe0 	ldr	x0, [sp, #24]
    480135fc:	52800081 	mov	w1, #0x4                   	// #4
    48013600:	79000401 	strh	w1, [x0, #2]
                return 0;
    48013604:	52800000 	mov	w0, #0x0                   	// #0
    48013608:	14000016 	b	48013660 <dfs_device_fs_open+0x28c>
        }
    }
    else
#endif
    {
        result = rt_device_open(device, RT_DEVICE_OFLAG_RDWR);
    4801360c:	52800061 	mov	w1, #0x3                   	// #3
    48013610:	f9401be0 	ldr	x0, [sp, #48]
    48013614:	97ffe511 	bl	4800ca58 <rt_device_open>
    48013618:	f90017e0 	str	x0, [sp, #40]
        if (result == RT_EOK || result == -RT_ENOSYS)
    4801361c:	f94017e0 	ldr	x0, [sp, #40]
    48013620:	f100001f 	cmp	x0, #0x0
    48013624:	54000080 	b.eq	48013634 <dfs_device_fs_open+0x260>  // b.none
    48013628:	f94017e0 	ldr	x0, [sp, #40]
    4801362c:	b100181f 	cmn	x0, #0x6
    48013630:	54000121 	b.ne	48013654 <dfs_device_fs_open+0x280>  // b.any
        {
            file->data = device;
    48013634:	f9400fe0 	ldr	x0, [sp, #24]
    48013638:	f9401be1 	ldr	x1, [sp, #48]
    4801363c:	f9002001 	str	x1, [x0, #64]
            file->type = FT_DEVICE;
    48013640:	f9400fe0 	ldr	x0, [sp, #24]
    48013644:	52800081 	mov	w1, #0x4                   	// #4
    48013648:	79000401 	strh	w1, [x0, #2]
            return RT_EOK;
    4801364c:	52800000 	mov	w0, #0x0                   	// #0
    48013650:	14000004 	b	48013660 <dfs_device_fs_open+0x28c>
        }
    }

    file->data = RT_NULL;
    48013654:	f9400fe0 	ldr	x0, [sp, #24]
    48013658:	f900201f 	str	xzr, [x0, #64]
    /* open device failed. */
    return -EIO;
    4801365c:	12800080 	mov	w0, #0xfffffffb            	// #-5
}
    48013660:	a8c67bfd 	ldp	x29, x30, [sp], #96
    48013664:	d65f03c0 	ret

0000000048013668 <dfs_device_fs_stat>:

int dfs_device_fs_stat(struct dfs_filesystem *fs, const char *path, struct stat *st)
{
    48013668:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801366c:	910003fd 	mov	x29, sp
    48013670:	f90017e0 	str	x0, [sp, #40]
    48013674:	f90013e1 	str	x1, [sp, #32]
    48013678:	f9000fe2 	str	x2, [sp, #24]
    /* stat root directory */
    if ((path[0] == '/') && (path[1] == '\0'))
    4801367c:	f94013e0 	ldr	x0, [sp, #32]
    48013680:	39400000 	ldrb	w0, [x0]
    48013684:	7100bc1f 	cmp	w0, #0x2f
    48013688:	54000381 	b.ne	480136f8 <dfs_device_fs_stat+0x90>  // b.any
    4801368c:	f94013e0 	ldr	x0, [sp, #32]
    48013690:	91000400 	add	x0, x0, #0x1
    48013694:	39400000 	ldrb	w0, [x0]
    48013698:	7100001f 	cmp	w0, #0x0
    4801369c:	540002e1 	b.ne	480136f8 <dfs_device_fs_stat+0x90>  // b.any
    {
        st->st_dev = 0;
    480136a0:	f9400fe0 	ldr	x0, [sp, #24]
    480136a4:	7900001f 	strh	wzr, [x0]

        st->st_mode = S_IFREG | S_IRUSR | S_IRGRP | S_IROTH |
    480136a8:	f9400fe0 	ldr	x0, [sp, #24]
    480136ac:	529036c1 	mov	w1, #0x81b6                	// #33206
    480136b0:	b9000401 	str	w1, [x0, #4]
                      S_IWUSR | S_IWGRP | S_IWOTH;
        st->st_mode &= ~S_IFREG;
    480136b4:	f9400fe0 	ldr	x0, [sp, #24]
    480136b8:	b9400400 	ldr	w0, [x0, #4]
    480136bc:	12107801 	and	w1, w0, #0xffff7fff
    480136c0:	f9400fe0 	ldr	x0, [sp, #24]
    480136c4:	b9000401 	str	w1, [x0, #4]
        st->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
    480136c8:	f9400fe0 	ldr	x0, [sp, #24]
    480136cc:	b9400401 	ldr	w1, [x0, #4]
    480136d0:	52880920 	mov	w0, #0x4049                	// #16457
    480136d4:	2a000021 	orr	w1, w1, w0
    480136d8:	f9400fe0 	ldr	x0, [sp, #24]
    480136dc:	b9000401 	str	w1, [x0, #4]

        st->st_size  = 0;
    480136e0:	f9400fe0 	ldr	x0, [sp, #24]
    480136e4:	f900081f 	str	xzr, [x0, #16]
        st->st_mtime = 0;
    480136e8:	f9400fe0 	ldr	x0, [sp, #24]
    480136ec:	f900141f 	str	xzr, [x0, #40]

        return RT_EOK;
    480136f0:	52800000 	mov	w0, #0x0                   	// #0
    480136f4:	14000037 	b	480137d0 <dfs_device_fs_stat+0x168>
    }
    else
    {
        rt_device_t dev_id;

        dev_id = rt_device_find(&path[1]);
    480136f8:	f94013e0 	ldr	x0, [sp, #32]
    480136fc:	91000400 	add	x0, x0, #0x1
    48013700:	97ffe45a 	bl	4800c868 <rt_device_find>
    48013704:	f9001fe0 	str	x0, [sp, #56]
        if (dev_id != RT_NULL)
    48013708:	f9401fe0 	ldr	x0, [sp, #56]
    4801370c:	f100001f 	cmp	x0, #0x0
    48013710:	540005e0 	b.eq	480137cc <dfs_device_fs_stat+0x164>  // b.none
        {
            st->st_dev = 0;
    48013714:	f9400fe0 	ldr	x0, [sp, #24]
    48013718:	7900001f 	strh	wzr, [x0]

            st->st_mode = S_IRUSR | S_IRGRP | S_IROTH |
    4801371c:	f9400fe0 	ldr	x0, [sp, #24]
    48013720:	528036c1 	mov	w1, #0x1b6                 	// #438
    48013724:	b9000401 	str	w1, [x0, #4]
                          S_IWUSR | S_IWGRP | S_IWOTH;

            if (dev_id->type == RT_Device_Class_Char)
    48013728:	f9401fe0 	ldr	x0, [sp, #56]
    4801372c:	b9402000 	ldr	w0, [x0, #32]
    48013730:	7100001f 	cmp	w0, #0x0
    48013734:	540000e1 	b.ne	48013750 <dfs_device_fs_stat+0xe8>  // b.any
                st->st_mode |= S_IFCHR;
    48013738:	f9400fe0 	ldr	x0, [sp, #24]
    4801373c:	b9400400 	ldr	w0, [x0, #4]
    48013740:	32130001 	orr	w1, w0, #0x2000
    48013744:	f9400fe0 	ldr	x0, [sp, #24]
    48013748:	b9000401 	str	w1, [x0, #4]
    4801374c:	1400001a 	b	480137b4 <dfs_device_fs_stat+0x14c>
            else if (dev_id->type == RT_Device_Class_Block)
    48013750:	f9401fe0 	ldr	x0, [sp, #56]
    48013754:	b9402000 	ldr	w0, [x0, #32]
    48013758:	7100041f 	cmp	w0, #0x1
    4801375c:	540000e1 	b.ne	48013778 <dfs_device_fs_stat+0x110>  // b.any
                st->st_mode |= S_IFBLK;
    48013760:	f9400fe0 	ldr	x0, [sp, #24]
    48013764:	b9400400 	ldr	w0, [x0, #4]
    48013768:	32130401 	orr	w1, w0, #0x6000
    4801376c:	f9400fe0 	ldr	x0, [sp, #24]
    48013770:	b9000401 	str	w1, [x0, #4]
    48013774:	14000010 	b	480137b4 <dfs_device_fs_stat+0x14c>
            else if (dev_id->type == RT_Device_Class_Pipe)
    48013778:	f9401fe0 	ldr	x0, [sp, #56]
    4801377c:	b9402000 	ldr	w0, [x0, #32]
    48013780:	7100401f 	cmp	w0, #0x10
    48013784:	540000e1 	b.ne	480137a0 <dfs_device_fs_stat+0x138>  // b.any
                st->st_mode |= S_IFIFO;
    48013788:	f9400fe0 	ldr	x0, [sp, #24]
    4801378c:	b9400400 	ldr	w0, [x0, #4]
    48013790:	32140001 	orr	w1, w0, #0x1000
    48013794:	f9400fe0 	ldr	x0, [sp, #24]
    48013798:	b9000401 	str	w1, [x0, #4]
    4801379c:	14000006 	b	480137b4 <dfs_device_fs_stat+0x14c>
            else
                st->st_mode |= S_IFREG;
    480137a0:	f9400fe0 	ldr	x0, [sp, #24]
    480137a4:	b9400400 	ldr	w0, [x0, #4]
    480137a8:	32110001 	orr	w1, w0, #0x8000
    480137ac:	f9400fe0 	ldr	x0, [sp, #24]
    480137b0:	b9000401 	str	w1, [x0, #4]

            st->st_size  = 0;
    480137b4:	f9400fe0 	ldr	x0, [sp, #24]
    480137b8:	f900081f 	str	xzr, [x0, #16]
            st->st_mtime = 0;
    480137bc:	f9400fe0 	ldr	x0, [sp, #24]
    480137c0:	f900141f 	str	xzr, [x0, #40]

            return RT_EOK;
    480137c4:	52800000 	mov	w0, #0x0                   	// #0
    480137c8:	14000002 	b	480137d0 <dfs_device_fs_stat+0x168>
        }
    }

    return -ENOENT;
    480137cc:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
    480137d0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480137d4:	d65f03c0 	ret

00000000480137d8 <dfs_device_fs_getdents>:

int dfs_device_fs_getdents(struct dfs_fd *file, struct dirent *dirp, uint32_t count)
{
    480137d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    480137dc:	910003fd 	mov	x29, sp
    480137e0:	f90017e0 	str	x0, [sp, #40]
    480137e4:	f90013e1 	str	x1, [sp, #32]
    480137e8:	b9001fe2 	str	w2, [sp, #28]
    rt_uint32_t index;
    rt_object_t object;
    struct dirent *d;
    struct device_dirent *root_dirent;

    root_dirent = (struct device_dirent *)file->data;
    480137ec:	f94017e0 	ldr	x0, [sp, #40]
    480137f0:	f9402000 	ldr	x0, [x0, #64]
    480137f4:	f90023e0 	str	x0, [sp, #64]
    RT_ASSERT(root_dirent != RT_NULL);
    480137f8:	f94023e0 	ldr	x0, [sp, #64]
    480137fc:	f100001f 	cmp	x0, #0x0
    48013800:	540000e1 	b.ne	4801381c <dfs_device_fs_getdents+0x44>  // b.any
    48013804:	d2802162 	mov	x2, #0x10b                 	// #267
    48013808:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801380c:	91086001 	add	x1, x0, #0x218
    48013810:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013814:	91034000 	add	x0, x0, #0xd0
    48013818:	97fff214 	bl	48010068 <rt_assert_handler>

    /* make integer count */
    count = (count / sizeof(struct dirent));
    4801381c:	b9401fe1 	ldr	w1, [sp, #28]
    48013820:	52981fa0 	mov	w0, #0xc0fd                	// #49405
    48013824:	72bf81e0 	movk	w0, #0xfc0f, lsl #16
    48013828:	9ba07c20 	umull	x0, w1, w0
    4801382c:	d360fc00 	lsr	x0, x0, #32
    48013830:	53087c00 	lsr	w0, w0, #8
    48013834:	b9001fe0 	str	w0, [sp, #28]
    if (count == 0)
    48013838:	b9401fe0 	ldr	w0, [sp, #28]
    4801383c:	7100001f 	cmp	w0, #0x0
    48013840:	54000061 	b.ne	4801384c <dfs_device_fs_getdents+0x74>  // b.any
        return -EINVAL;
    48013844:	128002a0 	mov	w0, #0xffffffea            	// #-22
    48013848:	1400003e 	b	48013940 <dfs_device_fs_getdents+0x168>

    for (index = 0; index < count && index + root_dirent->read_index < root_dirent->device_count;
    4801384c:	b9004fff 	str	wzr, [sp, #76]
    48013850:	14000024 	b	480138e0 <dfs_device_fs_getdents+0x108>
        index ++)
    {
        object = (rt_object_t)root_dirent->devices[root_dirent->read_index + index];
    48013854:	f94023e0 	ldr	x0, [sp, #64]
    48013858:	f9400001 	ldr	x1, [x0]
    4801385c:	f94023e0 	ldr	x0, [sp, #64]
    48013860:	79401000 	ldrh	w0, [x0, #8]
    48013864:	2a0003e2 	mov	w2, w0
    48013868:	b9404fe0 	ldr	w0, [sp, #76]
    4801386c:	0b000040 	add	w0, w2, w0
    48013870:	2a0003e0 	mov	w0, w0
    48013874:	d37df000 	lsl	x0, x0, #3
    48013878:	8b000020 	add	x0, x1, x0
    4801387c:	f9400000 	ldr	x0, [x0]
    48013880:	f9001fe0 	str	x0, [sp, #56]

        d = dirp + index;
    48013884:	b9404fe1 	ldr	w1, [sp, #76]
    48013888:	d2802080 	mov	x0, #0x104                 	// #260
    4801388c:	9b007c20 	mul	x0, x1, x0
    48013890:	f94013e1 	ldr	x1, [sp, #32]
    48013894:	8b000020 	add	x0, x1, x0
    48013898:	f9001be0 	str	x0, [sp, #48]
        d->d_type = DT_REG;
    4801389c:	f9401be0 	ldr	x0, [sp, #48]
    480138a0:	52800021 	mov	w1, #0x1                   	// #1
    480138a4:	39000001 	strb	w1, [x0]
        d->d_namlen = RT_NAME_MAX;
    480138a8:	f9401be0 	ldr	x0, [sp, #48]
    480138ac:	52800101 	mov	w1, #0x8                   	// #8
    480138b0:	39000401 	strb	w1, [x0, #1]
        d->d_reclen = (rt_uint16_t)sizeof(struct dirent);
    480138b4:	f9401be0 	ldr	x0, [sp, #48]
    480138b8:	52802081 	mov	w1, #0x104                 	// #260
    480138bc:	79000401 	strh	w1, [x0, #2]
        rt_strncpy(d->d_name, object->name, RT_NAME_MAX);
    480138c0:	f9401be0 	ldr	x0, [sp, #48]
    480138c4:	91001000 	add	x0, x0, #0x4
    480138c8:	f9401fe1 	ldr	x1, [sp, #56]
    480138cc:	d2800102 	mov	x2, #0x8                   	// #8
    480138d0:	97ffec02 	bl	4800e8d8 <rt_strncpy>
        index ++)
    480138d4:	b9404fe0 	ldr	w0, [sp, #76]
    480138d8:	11000400 	add	w0, w0, #0x1
    480138dc:	b9004fe0 	str	w0, [sp, #76]
    for (index = 0; index < count && index + root_dirent->read_index < root_dirent->device_count;
    480138e0:	b9404fe1 	ldr	w1, [sp, #76]
    480138e4:	b9401fe0 	ldr	w0, [sp, #28]
    480138e8:	6b00003f 	cmp	w1, w0
    480138ec:	54000142 	b.cs	48013914 <dfs_device_fs_getdents+0x13c>  // b.hs, b.nlast
    480138f0:	f94023e0 	ldr	x0, [sp, #64]
    480138f4:	79401000 	ldrh	w0, [x0, #8]
    480138f8:	2a0003e1 	mov	w1, w0
    480138fc:	b9404fe0 	ldr	w0, [sp, #76]
    48013900:	0b000020 	add	w0, w1, w0
    48013904:	f94023e1 	ldr	x1, [sp, #64]
    48013908:	79401421 	ldrh	w1, [x1, #10]
    4801390c:	6b01001f 	cmp	w0, w1
    48013910:	54fffa23 	b.cc	48013854 <dfs_device_fs_getdents+0x7c>  // b.lo, b.ul, b.last
    }

    root_dirent->read_index += index;
    48013914:	f94023e0 	ldr	x0, [sp, #64]
    48013918:	79401001 	ldrh	w1, [x0, #8]
    4801391c:	b9404fe0 	ldr	w0, [sp, #76]
    48013920:	12003c00 	and	w0, w0, #0xffff
    48013924:	0b000020 	add	w0, w1, w0
    48013928:	12003c01 	and	w1, w0, #0xffff
    4801392c:	f94023e0 	ldr	x0, [sp, #64]
    48013930:	79001001 	strh	w1, [x0, #8]

    return index * sizeof(struct dirent);
    48013934:	b9404fe1 	ldr	w1, [sp, #76]
    48013938:	52802080 	mov	w0, #0x104                 	// #260
    4801393c:	1b007c20 	mul	w0, w1, w0
}
    48013940:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48013944:	d65f03c0 	ret

0000000048013948 <dfs_device_fs_poll>:

static int dfs_device_fs_poll(struct dfs_fd *fd, struct rt_pollreq *req)
{
    48013948:	d10083ff 	sub	sp, sp, #0x20
    4801394c:	f90007e0 	str	x0, [sp, #8]
    48013950:	f90003e1 	str	x1, [sp]
    int mask = 0;
    48013954:	b9001fff 	str	wzr, [sp, #28]

    return mask;
    48013958:	b9401fe0 	ldr	w0, [sp, #28]
}
    4801395c:	910083ff 	add	sp, sp, #0x20
    48013960:	d65f03c0 	ret

0000000048013964 <devfs_init>:
    dfs_device_fs_stat,
    RT_NULL, /*rename*/
};

int devfs_init(void)
{
    48013964:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48013968:	910003fd 	mov	x29, sp
    /* register device file system */
    dfs_register(&_device_fs);
    4801396c:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013970:	91054000 	add	x0, x0, #0x150
    48013974:	97fff251 	bl	480102b8 <dfs_register>

    return 0;
    48013978:	52800000 	mov	w0, #0x0                   	// #0
}
    4801397c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48013980:	d65f03c0 	ret

0000000048013984 <rt_poll_add>:
    poll_queue_proc _proc;
    short _key;
} rt_pollreq_t;

rt_inline void rt_poll_add(rt_wqueue_t *wq, rt_pollreq_t *req)
{
    48013984:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48013988:	910003fd 	mov	x29, sp
    4801398c:	f9000fe0 	str	x0, [sp, #24]
    48013990:	f9000be1 	str	x1, [sp, #16]
    if (req && req->_proc && wq)
    48013994:	f9400be0 	ldr	x0, [sp, #16]
    48013998:	f100001f 	cmp	x0, #0x0
    4801399c:	540001a0 	b.eq	480139d0 <rt_poll_add+0x4c>  // b.none
    480139a0:	f9400be0 	ldr	x0, [sp, #16]
    480139a4:	f9400000 	ldr	x0, [x0]
    480139a8:	f100001f 	cmp	x0, #0x0
    480139ac:	54000120 	b.eq	480139d0 <rt_poll_add+0x4c>  // b.none
    480139b0:	f9400fe0 	ldr	x0, [sp, #24]
    480139b4:	f100001f 	cmp	x0, #0x0
    480139b8:	540000c0 	b.eq	480139d0 <rt_poll_add+0x4c>  // b.none
    {
        req->_proc(wq, req);
    480139bc:	f9400be0 	ldr	x0, [sp, #16]
    480139c0:	f9400002 	ldr	x2, [x0]
    480139c4:	f9400be1 	ldr	x1, [sp, #16]
    480139c8:	f9400fe0 	ldr	x0, [sp, #24]
    480139cc:	d63f0040 	blr	x2
    }
}
    480139d0:	d503201f 	nop
    480139d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480139d8:	d65f03c0 	ret

00000000480139dc <serial_fops_rx_ind>:
#ifdef putc
#undef putc
#endif

static rt_err_t serial_fops_rx_ind(rt_device_t dev, rt_size_t size)
{
    480139dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480139e0:	910003fd 	mov	x29, sp
    480139e4:	f9000fe0 	str	x0, [sp, #24]
    480139e8:	f9000be1 	str	x1, [sp, #16]
    rt_wqueue_wakeup(&(dev->wait_queue), (void*)POLLIN);
    480139ec:	f9400fe0 	ldr	x0, [sp, #24]
    480139f0:	9101e000 	add	x0, x0, #0x78
    480139f4:	d2800021 	mov	x1, #0x1                   	// #1
    480139f8:	94000982 	bl	48016000 <rt_wqueue_wakeup>

    return RT_EOK;
    480139fc:	d2800000 	mov	x0, #0x0                   	// #0
}
    48013a00:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48013a04:	d65f03c0 	ret

0000000048013a08 <serial_fops_open>:

/* fops for serial */
static int serial_fops_open(struct dfs_fd *fd)
{
    48013a08:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013a0c:	910003fd 	mov	x29, sp
    48013a10:	f9000fe0 	str	x0, [sp, #24]
    rt_err_t ret = 0;
    48013a14:	f9001bff 	str	xzr, [sp, #48]
    rt_uint16_t flags = 0;
    48013a18:	79007fff 	strh	wzr, [sp, #62]
    rt_device_t device;

    device = (rt_device_t)fd->data;
    48013a1c:	f9400fe0 	ldr	x0, [sp, #24]
    48013a20:	f9402000 	ldr	x0, [x0, #64]
    48013a24:	f90017e0 	str	x0, [sp, #40]
    RT_ASSERT(device != RT_NULL);
    48013a28:	f94017e0 	ldr	x0, [sp, #40]
    48013a2c:	f100001f 	cmp	x0, #0x0
    48013a30:	540000e1 	b.ne	48013a4c <serial_fops_open+0x44>  // b.any
    48013a34:	d2800902 	mov	x2, #0x48                  	// #72
    48013a38:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013a3c:	91128001 	add	x1, x0, #0x4a0
    48013a40:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013a44:	9108c000 	add	x0, x0, #0x230
    48013a48:	97fff188 	bl	48010068 <rt_assert_handler>

    switch (fd->flags & O_ACCMODE)
    48013a4c:	f9400fe0 	ldr	x0, [sp, #24]
    48013a50:	b9402800 	ldr	w0, [x0, #40]
    48013a54:	12000400 	and	w0, w0, #0x3
    48013a58:	7100081f 	cmp	w0, #0x2
    48013a5c:	540001c0 	b.eq	48013a94 <serial_fops_open+0x8c>  // b.none
    48013a60:	7100081f 	cmp	w0, #0x2
    48013a64:	540001e8 	b.hi	48013aa0 <serial_fops_open+0x98>  // b.pmore
    48013a68:	7100001f 	cmp	w0, #0x0
    48013a6c:	54000080 	b.eq	48013a7c <serial_fops_open+0x74>  // b.none
    48013a70:	7100041f 	cmp	w0, #0x1
    48013a74:	540000a0 	b.eq	48013a88 <serial_fops_open+0x80>  // b.none
    48013a78:	1400000a 	b	48013aa0 <serial_fops_open+0x98>
    {
        case O_RDONLY:
            LOG_D("fops open: O_RDONLY!");
            flags = RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_RDONLY;
    48013a7c:	52802020 	mov	w0, #0x101                 	// #257
    48013a80:	79007fe0 	strh	w0, [sp, #62]
            break;
    48013a84:	14000015 	b	48013ad8 <serial_fops_open+0xd0>
        case O_WRONLY:
            LOG_D("fops open: O_WRONLY!");
            flags = RT_DEVICE_FLAG_WRONLY;
    48013a88:	52800040 	mov	w0, #0x2                   	// #2
    48013a8c:	79007fe0 	strh	w0, [sp, #62]
            break;
    48013a90:	14000012 	b	48013ad8 <serial_fops_open+0xd0>
        case O_RDWR:
            LOG_D("fops open: O_RDWR!");
            flags = RT_DEVICE_FLAG_INT_RX | RT_DEVICE_FLAG_RDWR;
    48013a94:	52802060 	mov	w0, #0x103                 	// #259
    48013a98:	79007fe0 	strh	w0, [sp, #62]
            break;
    48013a9c:	1400000f 	b	48013ad8 <serial_fops_open+0xd0>
        default:
            LOG_E("fops open: unknown mode - %d!", fd->flags & O_ACCMODE);
    48013aa0:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013aa4:	91092000 	add	x0, x0, #0x248
    48013aa8:	97fff0a2 	bl	4800fd30 <rt_kprintf>
    48013aac:	f9400fe0 	ldr	x0, [sp, #24]
    48013ab0:	b9402800 	ldr	w0, [x0, #40]
    48013ab4:	12000400 	and	w0, w0, #0x3
    48013ab8:	2a0003e1 	mov	w1, w0
    48013abc:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013ac0:	91096000 	add	x0, x0, #0x258
    48013ac4:	97fff09b 	bl	4800fd30 <rt_kprintf>
    48013ac8:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013acc:	9109e000 	add	x0, x0, #0x278
    48013ad0:	97fff098 	bl	4800fd30 <rt_kprintf>
            break;
    48013ad4:	d503201f 	nop
    }

    if ((fd->flags & O_ACCMODE) != O_WRONLY)
    48013ad8:	f9400fe0 	ldr	x0, [sp, #24]
    48013adc:	b9402800 	ldr	w0, [x0, #40]
    48013ae0:	12000400 	and	w0, w0, #0x3
    48013ae4:	7100041f 	cmp	w0, #0x1
    48013ae8:	540000a0 	b.eq	48013afc <serial_fops_open+0xf4>  // b.none
        rt_device_set_rx_indicate(device, serial_fops_rx_ind);
    48013aec:	90000000 	adrp	x0, 48013000 <copy+0x124>
    48013af0:	91277001 	add	x1, x0, #0x9dc
    48013af4:	f94017e0 	ldr	x0, [sp, #40]
    48013af8:	97ffe517 	bl	4800cf54 <rt_device_set_rx_indicate>
    ret = rt_device_open(device, flags);
    48013afc:	79407fe1 	ldrh	w1, [sp, #62]
    48013b00:	f94017e0 	ldr	x0, [sp, #40]
    48013b04:	97ffe3d5 	bl	4800ca58 <rt_device_open>
    48013b08:	f9001be0 	str	x0, [sp, #48]
    if (ret == RT_EOK) return 0;
    48013b0c:	f9401be0 	ldr	x0, [sp, #48]
    48013b10:	f100001f 	cmp	x0, #0x0
    48013b14:	54000061 	b.ne	48013b20 <serial_fops_open+0x118>  // b.any
    48013b18:	52800000 	mov	w0, #0x0                   	// #0
    48013b1c:	14000002 	b	48013b24 <serial_fops_open+0x11c>

    return ret;
    48013b20:	f9401be0 	ldr	x0, [sp, #48]
}
    48013b24:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013b28:	d65f03c0 	ret

0000000048013b2c <serial_fops_close>:

static int serial_fops_close(struct dfs_fd *fd)
{
    48013b2c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48013b30:	910003fd 	mov	x29, sp
    48013b34:	f9000fe0 	str	x0, [sp, #24]
    rt_device_t device;

    device = (rt_device_t)fd->data;
    48013b38:	f9400fe0 	ldr	x0, [sp, #24]
    48013b3c:	f9402000 	ldr	x0, [x0, #64]
    48013b40:	f90017e0 	str	x0, [sp, #40]

    rt_device_set_rx_indicate(device, RT_NULL);
    48013b44:	d2800001 	mov	x1, #0x0                   	// #0
    48013b48:	f94017e0 	ldr	x0, [sp, #40]
    48013b4c:	97ffe502 	bl	4800cf54 <rt_device_set_rx_indicate>
    rt_device_close(device);
    48013b50:	f94017e0 	ldr	x0, [sp, #40]
    48013b54:	97ffe435 	bl	4800cc28 <rt_device_close>

    return 0;
    48013b58:	52800000 	mov	w0, #0x0                   	// #0
}
    48013b5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48013b60:	d65f03c0 	ret

0000000048013b64 <serial_fops_ioctl>:

static int serial_fops_ioctl(struct dfs_fd *fd, int cmd, void *args)
{
    48013b64:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013b68:	910003fd 	mov	x29, sp
    48013b6c:	f90017e0 	str	x0, [sp, #40]
    48013b70:	b90027e1 	str	w1, [sp, #36]
    48013b74:	f9000fe2 	str	x2, [sp, #24]
    rt_device_t device;

    device = (rt_device_t)fd->data;
    48013b78:	f94017e0 	ldr	x0, [sp, #40]
    48013b7c:	f9402000 	ldr	x0, [x0, #64]
    48013b80:	f9001fe0 	str	x0, [sp, #56]
    switch (cmd)
    48013b84:	b94027e1 	ldr	w1, [sp, #36]
    48013b88:	528ccf20 	mov	w0, #0x6679                	// #26233
    48013b8c:	72b00080 	movk	w0, #0x8004, lsl #16
    48013b90:	6b00003f 	cmp	w1, w0
    48013b94:	540000c0 	b.eq	48013bac <serial_fops_ioctl+0x48>  // b.none
    48013b98:	b94027e1 	ldr	w1, [sp, #36]
    48013b9c:	528ccfe0 	mov	w0, #0x667f                	// #26239
    48013ba0:	72b00080 	movk	w0, #0x8004, lsl #16
    48013ba4:	6b00003f 	cmp	w1, w0
    48013ba8:	14000002 	b	48013bb0 <serial_fops_ioctl+0x4c>
    {
    case FIONREAD:
        break;
    case FIONWRITE:
        break;
    48013bac:	d503201f 	nop
    }

    return rt_device_control(device, cmd, args);
    48013bb0:	f9400fe2 	ldr	x2, [sp, #24]
    48013bb4:	b94027e1 	ldr	w1, [sp, #36]
    48013bb8:	f9401fe0 	ldr	x0, [sp, #56]
    48013bbc:	97ffe4bf 	bl	4800ceb8 <rt_device_control>
}
    48013bc0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013bc4:	d65f03c0 	ret

0000000048013bc8 <serial_fops_read>:

static int serial_fops_read(struct dfs_fd *fd, void *buf, size_t count)
{
    48013bc8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013bcc:	910003fd 	mov	x29, sp
    48013bd0:	f90017e0 	str	x0, [sp, #40]
    48013bd4:	f90013e1 	str	x1, [sp, #32]
    48013bd8:	f9000fe2 	str	x2, [sp, #24]
    int size = 0;
    48013bdc:	b9003fff 	str	wzr, [sp, #60]
    rt_device_t device;

    device = (rt_device_t)fd->data;
    48013be0:	f94017e0 	ldr	x0, [sp, #40]
    48013be4:	f9402000 	ldr	x0, [x0, #64]
    48013be8:	f9001be0 	str	x0, [sp, #48]

    do
    {
        size = rt_device_read(device, -1, buf, count);
    48013bec:	f9400fe3 	ldr	x3, [sp, #24]
    48013bf0:	f94013e2 	ldr	x2, [sp, #32]
    48013bf4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    48013bf8:	f9401be0 	ldr	x0, [sp, #48]
    48013bfc:	97ffe449 	bl	4800cd20 <rt_device_read>
    48013c00:	b9003fe0 	str	w0, [sp, #60]
        if (size <= 0)
    48013c04:	b9403fe0 	ldr	w0, [sp, #60]
    48013c08:	7100001f 	cmp	w0, #0x0
    48013c0c:	540001cc 	b.gt	48013c44 <serial_fops_read+0x7c>
        {
            if (fd->flags & O_NONBLOCK)
    48013c10:	f94017e0 	ldr	x0, [sp, #40]
    48013c14:	b9402800 	ldr	w0, [x0, #40]
    48013c18:	12120000 	and	w0, w0, #0x4000
    48013c1c:	7100001f 	cmp	w0, #0x0
    48013c20:	54000080 	b.eq	48013c30 <serial_fops_read+0x68>  // b.none
            {
                size = -EAGAIN;
    48013c24:	12800140 	mov	w0, #0xfffffff5            	// #-11
    48013c28:	b9003fe0 	str	w0, [sp, #60]
                break;
    48013c2c:	14000009 	b	48013c50 <serial_fops_read+0x88>
            }

            rt_wqueue_wait(&(device->wait_queue), 0, RT_WAITING_FOREVER);
    48013c30:	f9401be0 	ldr	x0, [sp, #48]
    48013c34:	9101e000 	add	x0, x0, #0x78
    48013c38:	12800002 	mov	w2, #0xffffffff            	// #-1
    48013c3c:	52800001 	mov	w1, #0x0                   	// #0
    48013c40:	94000927 	bl	480160dc <rt_wqueue_wait>
        }
    }while (size <= 0);
    48013c44:	b9403fe0 	ldr	w0, [sp, #60]
    48013c48:	7100001f 	cmp	w0, #0x0
    48013c4c:	54fffd0d 	b.le	48013bec <serial_fops_read+0x24>

    return size;
    48013c50:	b9403fe0 	ldr	w0, [sp, #60]
}
    48013c54:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013c58:	d65f03c0 	ret

0000000048013c5c <serial_fops_write>:

static int serial_fops_write(struct dfs_fd *fd, const void *buf, size_t count)
{
    48013c5c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013c60:	910003fd 	mov	x29, sp
    48013c64:	f90017e0 	str	x0, [sp, #40]
    48013c68:	f90013e1 	str	x1, [sp, #32]
    48013c6c:	f9000fe2 	str	x2, [sp, #24]
    rt_device_t device;

    device = (rt_device_t)fd->data;
    48013c70:	f94017e0 	ldr	x0, [sp, #40]
    48013c74:	f9402000 	ldr	x0, [x0, #64]
    48013c78:	f9001fe0 	str	x0, [sp, #56]
    return rt_device_write(device, -1, buf, count);
    48013c7c:	f9400fe3 	ldr	x3, [sp, #24]
    48013c80:	f94013e2 	ldr	x2, [sp, #32]
    48013c84:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    48013c88:	f9401fe0 	ldr	x0, [sp, #56]
    48013c8c:	97ffe458 	bl	4800cdec <rt_device_write>
}
    48013c90:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013c94:	d65f03c0 	ret

0000000048013c98 <serial_fops_poll>:

static int serial_fops_poll(struct dfs_fd *fd, struct rt_pollreq *req)
{
    48013c98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48013c9c:	910003fd 	mov	x29, sp
    48013ca0:	f9000fe0 	str	x0, [sp, #24]
    48013ca4:	f9000be1 	str	x1, [sp, #16]
    int mask = 0;
    48013ca8:	b9004fff 	str	wzr, [sp, #76]
    int flags = 0;
    48013cac:	b9004bff 	str	wzr, [sp, #72]
    rt_device_t device;
    struct rt_serial_device *serial;

    device = (rt_device_t)fd->data;
    48013cb0:	f9400fe0 	ldr	x0, [sp, #24]
    48013cb4:	f9402000 	ldr	x0, [x0, #64]
    48013cb8:	f90023e0 	str	x0, [sp, #64]
    RT_ASSERT(device != RT_NULL);
    48013cbc:	f94023e0 	ldr	x0, [sp, #64]
    48013cc0:	f100001f 	cmp	x0, #0x0
    48013cc4:	540000e1 	b.ne	48013ce0 <serial_fops_poll+0x48>  // b.any
    48013cc8:	d2801542 	mov	x2, #0xaa                  	// #170
    48013ccc:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013cd0:	9112e001 	add	x1, x0, #0x4b8
    48013cd4:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013cd8:	9108c000 	add	x0, x0, #0x230
    48013cdc:	97fff0e3 	bl	48010068 <rt_assert_handler>

    serial = (struct rt_serial_device *)device;
    48013ce0:	f94023e0 	ldr	x0, [sp, #64]
    48013ce4:	f9001fe0 	str	x0, [sp, #56]

    /* only support POLLIN */
    flags = fd->flags & O_ACCMODE;
    48013ce8:	f9400fe0 	ldr	x0, [sp, #24]
    48013cec:	b9402800 	ldr	w0, [x0, #40]
    48013cf0:	12000400 	and	w0, w0, #0x3
    48013cf4:	b9004be0 	str	w0, [sp, #72]
    if (flags == O_RDONLY || flags == O_RDWR)
    48013cf8:	b9404be0 	ldr	w0, [sp, #72]
    48013cfc:	7100001f 	cmp	w0, #0x0
    48013d00:	54000080 	b.eq	48013d10 <serial_fops_poll+0x78>  // b.none
    48013d04:	b9404be0 	ldr	w0, [sp, #72]
    48013d08:	7100081f 	cmp	w0, #0x2
    48013d0c:	540003e1 	b.ne	48013d88 <serial_fops_poll+0xf0>  // b.any
    {
        rt_base_t level;
        struct rt_serial_rx_fifo* rx_fifo;

        rt_poll_add(&(device->wait_queue), req);
    48013d10:	f94023e0 	ldr	x0, [sp, #64]
    48013d14:	9101e000 	add	x0, x0, #0x78
    48013d18:	f9400be1 	ldr	x1, [sp, #16]
    48013d1c:	97ffff1a 	bl	48013984 <rt_poll_add>

        rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    48013d20:	f9401fe0 	ldr	x0, [sp, #56]
    48013d24:	f9405400 	ldr	x0, [x0, #168]
    48013d28:	f9001be0 	str	x0, [sp, #48]

        level = rt_hw_interrupt_disable();
    48013d2c:	97ffc1c0 	bl	4800442c <rt_hw_interrupt_disable>
    48013d30:	f90017e0 	str	x0, [sp, #40]
        if ((rx_fifo->get_index != rx_fifo->put_index) || (rx_fifo->get_index == rx_fifo->put_index && rx_fifo->is_full == RT_TRUE))
    48013d34:	f9401be0 	ldr	x0, [sp, #48]
    48013d38:	79401401 	ldrh	w1, [x0, #10]
    48013d3c:	f9401be0 	ldr	x0, [sp, #48]
    48013d40:	79401000 	ldrh	w0, [x0, #8]
    48013d44:	6b00003f 	cmp	w1, w0
    48013d48:	54000161 	b.ne	48013d74 <serial_fops_poll+0xdc>  // b.any
    48013d4c:	f9401be0 	ldr	x0, [sp, #48]
    48013d50:	79401401 	ldrh	w1, [x0, #10]
    48013d54:	f9401be0 	ldr	x0, [sp, #48]
    48013d58:	79401000 	ldrh	w0, [x0, #8]
    48013d5c:	6b00003f 	cmp	w1, w0
    48013d60:	54000101 	b.ne	48013d80 <serial_fops_poll+0xe8>  // b.any
    48013d64:	f9401be0 	ldr	x0, [sp, #48]
    48013d68:	b9400c00 	ldr	w0, [x0, #12]
    48013d6c:	7100041f 	cmp	w0, #0x1
    48013d70:	54000081 	b.ne	48013d80 <serial_fops_poll+0xe8>  // b.any
            mask |= POLLIN;
    48013d74:	b9404fe0 	ldr	w0, [sp, #76]
    48013d78:	32000000 	orr	w0, w0, #0x1
    48013d7c:	b9004fe0 	str	w0, [sp, #76]
        rt_hw_interrupt_enable(level);
    48013d80:	f94017e0 	ldr	x0, [sp, #40]
    48013d84:	97ffc1ae 	bl	4800443c <rt_hw_interrupt_enable>
    }

    return mask;
    48013d88:	b9404fe0 	ldr	w0, [sp, #76]
}
    48013d8c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48013d90:	d65f03c0 	ret

0000000048013d94 <_serial_poll_rx>:

/*
 * Serial poll routines
 */
rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
    48013d94:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013d98:	910003fd 	mov	x29, sp
    48013d9c:	f90017e0 	str	x0, [sp, #40]
    48013da0:	f90013e1 	str	x1, [sp, #32]
    48013da4:	b9001fe2 	str	w2, [sp, #28]
    int ch;
    int size;

    RT_ASSERT(serial != RT_NULL);
    48013da8:	f94017e0 	ldr	x0, [sp, #40]
    48013dac:	f100001f 	cmp	x0, #0x0
    48013db0:	540000e1 	b.ne	48013dcc <_serial_poll_rx+0x38>  // b.any
    48013db4:	d2801b02 	mov	x2, #0xd8                  	// #216
    48013db8:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013dbc:	91164001 	add	x1, x0, #0x590
    48013dc0:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013dc4:	910b2000 	add	x0, x0, #0x2c8
    48013dc8:	97fff0a8 	bl	48010068 <rt_assert_handler>
    size = length;
    48013dcc:	b9401fe0 	ldr	w0, [sp, #28]
    48013dd0:	b9003fe0 	str	w0, [sp, #60]

    while (length)
    48013dd4:	1400001c 	b	48013e44 <_serial_poll_rx+0xb0>
    {
        ch = serial->ops->getc(serial);
    48013dd8:	f94017e0 	ldr	x0, [sp, #40]
    48013ddc:	f9404c00 	ldr	x0, [x0, #152]
    48013de0:	f9400c01 	ldr	x1, [x0, #24]
    48013de4:	f94017e0 	ldr	x0, [sp, #40]
    48013de8:	d63f0020 	blr	x1
    48013dec:	b9003be0 	str	w0, [sp, #56]
        if (ch == -1) break;
    48013df0:	b9403be0 	ldr	w0, [sp, #56]
    48013df4:	3100041f 	cmn	w0, #0x1
    48013df8:	540002e0 	b.eq	48013e54 <_serial_poll_rx+0xc0>  // b.none

        *data = ch;
    48013dfc:	b9403be0 	ldr	w0, [sp, #56]
    48013e00:	12001c01 	and	w1, w0, #0xff
    48013e04:	f94013e0 	ldr	x0, [sp, #32]
    48013e08:	39000001 	strb	w1, [x0]
        data ++; length --;
    48013e0c:	f94013e0 	ldr	x0, [sp, #32]
    48013e10:	91000400 	add	x0, x0, #0x1
    48013e14:	f90013e0 	str	x0, [sp, #32]
    48013e18:	b9401fe0 	ldr	w0, [sp, #28]
    48013e1c:	51000400 	sub	w0, w0, #0x1
    48013e20:	b9001fe0 	str	w0, [sp, #28]

        if(serial->parent.open_flag & RT_DEVICE_FLAG_STREAM)
    48013e24:	f94017e0 	ldr	x0, [sp, #40]
    48013e28:	79404c00 	ldrh	w0, [x0, #38]
    48013e2c:	121a0000 	and	w0, w0, #0x40
    48013e30:	7100001f 	cmp	w0, #0x0
    48013e34:	54000080 	b.eq	48013e44 <_serial_poll_rx+0xb0>  // b.none
        {
            if (ch == '\n') break;
    48013e38:	b9403be0 	ldr	w0, [sp, #56]
    48013e3c:	7100281f 	cmp	w0, #0xa
    48013e40:	540000e0 	b.eq	48013e5c <_serial_poll_rx+0xc8>  // b.none
    while (length)
    48013e44:	b9401fe0 	ldr	w0, [sp, #28]
    48013e48:	7100001f 	cmp	w0, #0x0
    48013e4c:	54fffc61 	b.ne	48013dd8 <_serial_poll_rx+0x44>  // b.any
    48013e50:	14000004 	b	48013e60 <_serial_poll_rx+0xcc>
        if (ch == -1) break;
    48013e54:	d503201f 	nop
    48013e58:	14000002 	b	48013e60 <_serial_poll_rx+0xcc>
            if (ch == '\n') break;
    48013e5c:	d503201f 	nop
        }
    }

    return size - length;
    48013e60:	b9403fe1 	ldr	w1, [sp, #60]
    48013e64:	b9401fe0 	ldr	w0, [sp, #28]
    48013e68:	4b000020 	sub	w0, w1, w0
}
    48013e6c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013e70:	d65f03c0 	ret

0000000048013e74 <_serial_poll_tx>:

rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
    48013e74:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48013e78:	910003fd 	mov	x29, sp
    48013e7c:	f90017e0 	str	x0, [sp, #40]
    48013e80:	f90013e1 	str	x1, [sp, #32]
    48013e84:	b9001fe2 	str	w2, [sp, #28]
    int size;
    RT_ASSERT(serial != RT_NULL);
    48013e88:	f94017e0 	ldr	x0, [sp, #40]
    48013e8c:	f100001f 	cmp	x0, #0x0
    48013e90:	540000e1 	b.ne	48013eac <_serial_poll_tx+0x38>  // b.any
    48013e94:	d2801de2 	mov	x2, #0xef                  	// #239
    48013e98:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013e9c:	91170001 	add	x1, x0, #0x5c0
    48013ea0:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013ea4:	910b2000 	add	x0, x0, #0x2c8
    48013ea8:	97fff070 	bl	48010068 <rt_assert_handler>

    size = length;
    48013eac:	b9401fe0 	ldr	w0, [sp, #28]
    48013eb0:	b9003fe0 	str	w0, [sp, #60]
    while (length)
    48013eb4:	1400001e 	b	48013f2c <_serial_poll_tx+0xb8>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
    48013eb8:	f94013e0 	ldr	x0, [sp, #32]
    48013ebc:	39400000 	ldrb	w0, [x0]
    48013ec0:	7100281f 	cmp	w0, #0xa
    48013ec4:	54000181 	b.ne	48013ef4 <_serial_poll_tx+0x80>  // b.any
    48013ec8:	f94017e0 	ldr	x0, [sp, #40]
    48013ecc:	79404c00 	ldrh	w0, [x0, #38]
    48013ed0:	121a0000 	and	w0, w0, #0x40
    48013ed4:	7100001f 	cmp	w0, #0x0
    48013ed8:	540000e0 	b.eq	48013ef4 <_serial_poll_tx+0x80>  // b.none
        {
            serial->ops->putc(serial, '\r');
    48013edc:	f94017e0 	ldr	x0, [sp, #40]
    48013ee0:	f9404c00 	ldr	x0, [x0, #152]
    48013ee4:	f9400802 	ldr	x2, [x0, #16]
    48013ee8:	528001a1 	mov	w1, #0xd                   	// #13
    48013eec:	f94017e0 	ldr	x0, [sp, #40]
    48013ef0:	d63f0040 	blr	x2
        }

        serial->ops->putc(serial, *data);
    48013ef4:	f94017e0 	ldr	x0, [sp, #40]
    48013ef8:	f9404c00 	ldr	x0, [x0, #152]
    48013efc:	f9400802 	ldr	x2, [x0, #16]
    48013f00:	f94013e0 	ldr	x0, [sp, #32]
    48013f04:	39400000 	ldrb	w0, [x0]
    48013f08:	2a0003e1 	mov	w1, w0
    48013f0c:	f94017e0 	ldr	x0, [sp, #40]
    48013f10:	d63f0040 	blr	x2

        ++ data;
    48013f14:	f94013e0 	ldr	x0, [sp, #32]
    48013f18:	91000400 	add	x0, x0, #0x1
    48013f1c:	f90013e0 	str	x0, [sp, #32]
        -- length;
    48013f20:	b9401fe0 	ldr	w0, [sp, #28]
    48013f24:	51000400 	sub	w0, w0, #0x1
    48013f28:	b9001fe0 	str	w0, [sp, #28]
    while (length)
    48013f2c:	b9401fe0 	ldr	w0, [sp, #28]
    48013f30:	7100001f 	cmp	w0, #0x0
    48013f34:	54fffc21 	b.ne	48013eb8 <_serial_poll_tx+0x44>  // b.any
    }

    return size - length;
    48013f38:	b9403fe1 	ldr	w1, [sp, #60]
    48013f3c:	b9401fe0 	ldr	w0, [sp, #28]
    48013f40:	4b000020 	sub	w0, w1, w0
}
    48013f44:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48013f48:	d65f03c0 	ret

0000000048013f4c <_serial_int_rx>:

/*
 * Serial interrupt routines
 */
rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
    48013f4c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48013f50:	910003fd 	mov	x29, sp
    48013f54:	f90017e0 	str	x0, [sp, #40]
    48013f58:	f90013e1 	str	x1, [sp, #32]
    48013f5c:	b9001fe2 	str	w2, [sp, #28]
    int size;
    struct rt_serial_rx_fifo* rx_fifo;

    RT_ASSERT(serial != RT_NULL);
    48013f60:	f94017e0 	ldr	x0, [sp, #40]
    48013f64:	f100001f 	cmp	x0, #0x0
    48013f68:	540000e1 	b.ne	48013f84 <_serial_int_rx+0x38>  // b.any
    48013f6c:	d28021c2 	mov	x2, #0x10e                 	// #270
    48013f70:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013f74:	9115c001 	add	x1, x0, #0x570
    48013f78:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013f7c:	910b2000 	add	x0, x0, #0x2c8
    48013f80:	97fff03a 	bl	48010068 <rt_assert_handler>
    size = length;
    48013f84:	b9401fe0 	ldr	w0, [sp, #28]
    48013f88:	b9004fe0 	str	w0, [sp, #76]

    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    48013f8c:	f94017e0 	ldr	x0, [sp, #40]
    48013f90:	f9405400 	ldr	x0, [x0, #168]
    48013f94:	f90023e0 	str	x0, [sp, #64]
    RT_ASSERT(rx_fifo != RT_NULL);
    48013f98:	f94023e0 	ldr	x0, [sp, #64]
    48013f9c:	f100001f 	cmp	x0, #0x0
    48013fa0:	54000821 	b.ne	480140a4 <_serial_int_rx+0x158>  // b.any
    48013fa4:	d2802242 	mov	x2, #0x112                 	// #274
    48013fa8:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013fac:	9115c001 	add	x1, x0, #0x570
    48013fb0:	b0000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48013fb4:	910b8000 	add	x0, x0, #0x2e0
    48013fb8:	97fff02c 	bl	48010068 <rt_assert_handler>

    /* read from software FIFO */
    while (length)
    48013fbc:	1400003a 	b	480140a4 <_serial_int_rx+0x158>
    {
        int ch;
        rt_base_t level;

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    48013fc0:	97ffc11b 	bl	4800442c <rt_hw_interrupt_disable>
    48013fc4:	f9001fe0 	str	x0, [sp, #56]

        /* there's no data: */
        if ((rx_fifo->get_index == rx_fifo->put_index) && (rx_fifo->is_full == RT_FALSE))
    48013fc8:	f94023e0 	ldr	x0, [sp, #64]
    48013fcc:	79401401 	ldrh	w1, [x0, #10]
    48013fd0:	f94023e0 	ldr	x0, [sp, #64]
    48013fd4:	79401000 	ldrh	w0, [x0, #8]
    48013fd8:	6b00003f 	cmp	w1, w0
    48013fdc:	54000101 	b.ne	48013ffc <_serial_int_rx+0xb0>  // b.any
    48013fe0:	f94023e0 	ldr	x0, [sp, #64]
    48013fe4:	b9400c00 	ldr	w0, [x0, #12]
    48013fe8:	7100001f 	cmp	w0, #0x0
    48013fec:	54000081 	b.ne	48013ffc <_serial_int_rx+0xb0>  // b.any
        {
            /* no data, enable interrupt and break out */
            rt_hw_interrupt_enable(level);
    48013ff0:	f9401fe0 	ldr	x0, [sp, #56]
    48013ff4:	97ffc112 	bl	4800443c <rt_hw_interrupt_enable>
            break;
    48013ff8:	1400002e 	b	480140b0 <_serial_int_rx+0x164>
        }

        /* otherwise there's the data: */
        ch = rx_fifo->buffer[rx_fifo->get_index];
    48013ffc:	f94023e0 	ldr	x0, [sp, #64]
    48014000:	f9400001 	ldr	x1, [x0]
    48014004:	f94023e0 	ldr	x0, [sp, #64]
    48014008:	79401400 	ldrh	w0, [x0, #10]
    4801400c:	92403c00 	and	x0, x0, #0xffff
    48014010:	8b000020 	add	x0, x1, x0
    48014014:	39400000 	ldrb	w0, [x0]
    48014018:	b90037e0 	str	w0, [sp, #52]
        rx_fifo->get_index += 1;
    4801401c:	f94023e0 	ldr	x0, [sp, #64]
    48014020:	79401400 	ldrh	w0, [x0, #10]
    48014024:	11000400 	add	w0, w0, #0x1
    48014028:	12003c01 	and	w1, w0, #0xffff
    4801402c:	f94023e0 	ldr	x0, [sp, #64]
    48014030:	79001401 	strh	w1, [x0, #10]
        if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
    48014034:	f94023e0 	ldr	x0, [sp, #64]
    48014038:	79401401 	ldrh	w1, [x0, #10]
    4801403c:	f94017e0 	ldr	x0, [sp, #40]
    48014040:	f9405000 	ldr	x0, [x0, #160]
    48014044:	d36ae400 	ubfx	x0, x0, #42, #16
    48014048:	12003c00 	and	w0, w0, #0xffff
    4801404c:	6b00003f 	cmp	w1, w0
    48014050:	54000063 	b.cc	4801405c <_serial_int_rx+0x110>  // b.lo, b.ul, b.last
    48014054:	f94023e0 	ldr	x0, [sp, #64]
    48014058:	7900141f 	strh	wzr, [x0, #10]

        if (rx_fifo->is_full == RT_TRUE)
    4801405c:	f94023e0 	ldr	x0, [sp, #64]
    48014060:	b9400c00 	ldr	w0, [x0, #12]
    48014064:	7100041f 	cmp	w0, #0x1
    48014068:	54000061 	b.ne	48014074 <_serial_int_rx+0x128>  // b.any
        {
            rx_fifo->is_full = RT_FALSE;
    4801406c:	f94023e0 	ldr	x0, [sp, #64]
    48014070:	b9000c1f 	str	wzr, [x0, #12]
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    48014074:	f9401fe0 	ldr	x0, [sp, #56]
    48014078:	97ffc0f1 	bl	4800443c <rt_hw_interrupt_enable>

        *data = ch & 0xff;
    4801407c:	b94037e0 	ldr	w0, [sp, #52]
    48014080:	12001c01 	and	w1, w0, #0xff
    48014084:	f94013e0 	ldr	x0, [sp, #32]
    48014088:	39000001 	strb	w1, [x0]
        data ++; length --;
    4801408c:	f94013e0 	ldr	x0, [sp, #32]
    48014090:	91000400 	add	x0, x0, #0x1
    48014094:	f90013e0 	str	x0, [sp, #32]
    48014098:	b9401fe0 	ldr	w0, [sp, #28]
    4801409c:	51000400 	sub	w0, w0, #0x1
    480140a0:	b9001fe0 	str	w0, [sp, #28]
    while (length)
    480140a4:	b9401fe0 	ldr	w0, [sp, #28]
    480140a8:	7100001f 	cmp	w0, #0x0
    480140ac:	54fff8a1 	b.ne	48013fc0 <_serial_int_rx+0x74>  // b.any
    }

    return size - length;
    480140b0:	b9404fe1 	ldr	w1, [sp, #76]
    480140b4:	b9401fe0 	ldr	w0, [sp, #28]
    480140b8:	4b000020 	sub	w0, w1, w0
}
    480140bc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480140c0:	d65f03c0 	ret

00000000480140c4 <_serial_int_tx>:

rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
    480140c4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480140c8:	910003fd 	mov	x29, sp
    480140cc:	f90017e0 	str	x0, [sp, #40]
    480140d0:	f90013e1 	str	x1, [sp, #32]
    480140d4:	b9001fe2 	str	w2, [sp, #28]
    int size;
    struct rt_serial_tx_fifo *tx;

    RT_ASSERT(serial != RT_NULL);
    480140d8:	f94017e0 	ldr	x0, [sp, #40]
    480140dc:	f100001f 	cmp	x0, #0x0
    480140e0:	540000e1 	b.ne	480140fc <_serial_int_tx+0x38>  // b.any
    480140e4:	d28027c2 	mov	x2, #0x13e                 	// #318
    480140e8:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480140ec:	9116c001 	add	x1, x0, #0x5b0
    480140f0:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480140f4:	910b2000 	add	x0, x0, #0x2c8
    480140f8:	97ffefdc 	bl	48010068 <rt_assert_handler>

    size = length;
    480140fc:	b9401fe0 	ldr	w0, [sp, #28]
    48014100:	b9003fe0 	str	w0, [sp, #60]
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    48014104:	f94017e0 	ldr	x0, [sp, #40]
    48014108:	f9405800 	ldr	x0, [x0, #176]
    4801410c:	f9001be0 	str	x0, [sp, #48]
    RT_ASSERT(tx != RT_NULL);
    48014110:	f9401be0 	ldr	x0, [sp, #48]
    48014114:	f100001f 	cmp	x0, #0x0
    48014118:	54000621 	b.ne	480141dc <_serial_int_tx+0x118>  // b.any
    4801411c:	d2802842 	mov	x2, #0x142                 	// #322
    48014120:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014124:	9116c001 	add	x1, x0, #0x5b0
    48014128:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801412c:	910be000 	add	x0, x0, #0x2f8
    48014130:	97ffefce 	bl	48010068 <rt_assert_handler>

    while (length)
    48014134:	1400002a 	b	480141dc <_serial_int_tx+0x118>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
    48014138:	f94013e0 	ldr	x0, [sp, #32]
    4801413c:	39400000 	ldrb	w0, [x0]
    48014140:	7100281f 	cmp	w0, #0xa
    48014144:	54000241 	b.ne	4801418c <_serial_int_tx+0xc8>  // b.any
    48014148:	f94017e0 	ldr	x0, [sp, #40]
    4801414c:	79404c00 	ldrh	w0, [x0, #38]
    48014150:	121a0000 	and	w0, w0, #0x40
    48014154:	7100001f 	cmp	w0, #0x0
    48014158:	540001a0 	b.eq	4801418c <_serial_int_tx+0xc8>  // b.none
        {
            if (serial->ops->putc(serial, '\r') == -1)
    4801415c:	f94017e0 	ldr	x0, [sp, #40]
    48014160:	f9404c00 	ldr	x0, [x0, #152]
    48014164:	f9400802 	ldr	x2, [x0, #16]
    48014168:	528001a1 	mov	w1, #0xd                   	// #13
    4801416c:	f94017e0 	ldr	x0, [sp, #40]
    48014170:	d63f0040 	blr	x2
    48014174:	3100041f 	cmn	w0, #0x1
    48014178:	540000a1 	b.ne	4801418c <_serial_int_tx+0xc8>  // b.any
            {
                rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
    4801417c:	f9401be0 	ldr	x0, [sp, #48]
    48014180:	12800001 	mov	w1, #0xffffffff            	// #-1
    48014184:	94000ba0 	bl	48017004 <rt_completion_wait>
                continue;
    48014188:	14000015 	b	480141dc <_serial_int_tx+0x118>
            }
        }

        if (serial->ops->putc(serial, *(char*)data) == -1)
    4801418c:	f94017e0 	ldr	x0, [sp, #40]
    48014190:	f9404c00 	ldr	x0, [x0, #152]
    48014194:	f9400802 	ldr	x2, [x0, #16]
    48014198:	f94013e0 	ldr	x0, [sp, #32]
    4801419c:	39400000 	ldrb	w0, [x0]
    480141a0:	2a0003e1 	mov	w1, w0
    480141a4:	f94017e0 	ldr	x0, [sp, #40]
    480141a8:	d63f0040 	blr	x2
    480141ac:	3100041f 	cmn	w0, #0x1
    480141b0:	540000a1 	b.ne	480141c4 <_serial_int_tx+0x100>  // b.any
        {
            rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
    480141b4:	f9401be0 	ldr	x0, [sp, #48]
    480141b8:	12800001 	mov	w1, #0xffffffff            	// #-1
    480141bc:	94000b92 	bl	48017004 <rt_completion_wait>
            continue;
    480141c0:	14000007 	b	480141dc <_serial_int_tx+0x118>
        }

        data ++; length --;
    480141c4:	f94013e0 	ldr	x0, [sp, #32]
    480141c8:	91000400 	add	x0, x0, #0x1
    480141cc:	f90013e0 	str	x0, [sp, #32]
    480141d0:	b9401fe0 	ldr	w0, [sp, #28]
    480141d4:	51000400 	sub	w0, w0, #0x1
    480141d8:	b9001fe0 	str	w0, [sp, #28]
    while (length)
    480141dc:	b9401fe0 	ldr	w0, [sp, #28]
    480141e0:	7100001f 	cmp	w0, #0x0
    480141e4:	54fffaa1 	b.ne	48014138 <_serial_int_tx+0x74>  // b.any
    }

    return size - length;
    480141e8:	b9403fe1 	ldr	w1, [sp, #60]
    480141ec:	b9401fe0 	ldr	w0, [sp, #28]
    480141f0:	4b000020 	sub	w0, w1, w0
}
    480141f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480141f8:	d65f03c0 	ret

00000000480141fc <_serial_check_buffer_size>:

static void _serial_check_buffer_size(void)
{
    480141fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    48014200:	910003fd 	mov	x29, sp
    static rt_bool_t already_output = RT_FALSE;

    if (already_output == RT_FALSE)
    48014204:	b0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48014208:	91225000 	add	x0, x0, #0x894
    4801420c:	b9400000 	ldr	w0, [x0]
    48014210:	7100001f 	cmp	w0, #0x0
    48014214:	540001c1 	b.ne	4801424c <_serial_check_buffer_size+0x50>  // b.any
    {
#if !defined(RT_USING_ULOG) || defined(ULOG_USING_ISR_LOG)
        LOG_W("Warning: There is no enough buffer for saving data,"
    48014218:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801421c:	910c2000 	add	x0, x0, #0x308
    48014220:	97ffeec4 	bl	4800fd30 <rt_kprintf>
    48014224:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014228:	910c6000 	add	x0, x0, #0x318
    4801422c:	97ffeec1 	bl	4800fd30 <rt_kprintf>
    48014230:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014234:	9109e000 	add	x0, x0, #0x278
    48014238:	97ffeebe 	bl	4800fd30 <rt_kprintf>
              " please increase the RT_SERIAL_RB_BUFSZ option.");
#endif
        already_output = RT_TRUE;
    4801423c:	b0000120 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48014240:	91225000 	add	x0, x0, #0x894
    48014244:	52800021 	mov	w1, #0x1                   	// #1
    48014248:	b9000001 	str	w1, [x0]
    }
}
    4801424c:	d503201f 	nop
    48014250:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48014254:	d65f03c0 	ret

0000000048014258 <_serial_fifo_calc_recved_len>:

#if defined(RT_USING_POSIX) || defined(RT_SERIAL_USING_DMA)
static rt_size_t _serial_fifo_calc_recved_len(struct rt_serial_device *serial)
{
    48014258:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801425c:	910003fd 	mov	x29, sp
    48014260:	f9000fe0 	str	x0, [sp, #24]
    struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *) serial->serial_rx;
    48014264:	f9400fe0 	ldr	x0, [sp, #24]
    48014268:	f9405400 	ldr	x0, [x0, #168]
    4801426c:	f90017e0 	str	x0, [sp, #40]

    RT_ASSERT(rx_fifo != RT_NULL);
    48014270:	f94017e0 	ldr	x0, [sp, #40]
    48014274:	f100001f 	cmp	x0, #0x0
    48014278:	540000e1 	b.ne	48014294 <_serial_fifo_calc_recved_len+0x3c>  // b.any
    4801427c:	d2802e42 	mov	x2, #0x172                 	// #370
    48014280:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014284:	91134001 	add	x1, x0, #0x4d0
    48014288:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801428c:	910b8000 	add	x0, x0, #0x2e0
    48014290:	97ffef76 	bl	48010068 <rt_assert_handler>

    if (rx_fifo->put_index == rx_fifo->get_index)
    48014294:	f94017e0 	ldr	x0, [sp, #40]
    48014298:	79401001 	ldrh	w1, [x0, #8]
    4801429c:	f94017e0 	ldr	x0, [sp, #40]
    480142a0:	79401400 	ldrh	w0, [x0, #10]
    480142a4:	6b00003f 	cmp	w1, w0
    480142a8:	540001a1 	b.ne	480142dc <_serial_fifo_calc_recved_len+0x84>  // b.any
    {
        return (rx_fifo->is_full == RT_FALSE ? 0 : serial->config.bufsz);
    480142ac:	f94017e0 	ldr	x0, [sp, #40]
    480142b0:	b9400c00 	ldr	w0, [x0, #12]
    480142b4:	7100001f 	cmp	w0, #0x0
    480142b8:	540000e0 	b.eq	480142d4 <_serial_fifo_calc_recved_len+0x7c>  // b.none
    480142bc:	f9400fe0 	ldr	x0, [sp, #24]
    480142c0:	f9405000 	ldr	x0, [x0, #160]
    480142c4:	d36ae400 	ubfx	x0, x0, #42, #16
    480142c8:	12003c00 	and	w0, w0, #0xffff
    480142cc:	92403c00 	and	x0, x0, #0xffff
    480142d0:	1400001e 	b	48014348 <_serial_fifo_calc_recved_len+0xf0>
    480142d4:	d2800000 	mov	x0, #0x0                   	// #0
    480142d8:	1400001c 	b	48014348 <_serial_fifo_calc_recved_len+0xf0>
    }
    else
    {
        if (rx_fifo->put_index > rx_fifo->get_index)
    480142dc:	f94017e0 	ldr	x0, [sp, #40]
    480142e0:	79401001 	ldrh	w1, [x0, #8]
    480142e4:	f94017e0 	ldr	x0, [sp, #40]
    480142e8:	79401400 	ldrh	w0, [x0, #10]
    480142ec:	6b00003f 	cmp	w1, w0
    480142f0:	54000129 	b.ls	48014314 <_serial_fifo_calc_recved_len+0xbc>  // b.plast
        {
            return rx_fifo->put_index - rx_fifo->get_index;
    480142f4:	f94017e0 	ldr	x0, [sp, #40]
    480142f8:	79401000 	ldrh	w0, [x0, #8]
    480142fc:	2a0003e1 	mov	w1, w0
    48014300:	f94017e0 	ldr	x0, [sp, #40]
    48014304:	79401400 	ldrh	w0, [x0, #10]
    48014308:	4b000020 	sub	w0, w1, w0
    4801430c:	93407c00 	sxtw	x0, w0
    48014310:	1400000e 	b	48014348 <_serial_fifo_calc_recved_len+0xf0>
        }
        else
        {
            return serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index);
    48014314:	f9400fe0 	ldr	x0, [sp, #24]
    48014318:	f9405000 	ldr	x0, [x0, #160]
    4801431c:	d36ae400 	ubfx	x0, x0, #42, #16
    48014320:	12003c00 	and	w0, w0, #0xffff
    48014324:	2a0003e1 	mov	w1, w0
    48014328:	f94017e0 	ldr	x0, [sp, #40]
    4801432c:	79401400 	ldrh	w0, [x0, #10]
    48014330:	2a0003e2 	mov	w2, w0
    48014334:	f94017e0 	ldr	x0, [sp, #40]
    48014338:	79401000 	ldrh	w0, [x0, #8]
    4801433c:	4b000040 	sub	w0, w2, w0
    48014340:	4b000020 	sub	w0, w1, w0
    48014344:	93407c00 	sxtw	x0, w0
        }
    }
}
    48014348:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801434c:	d65f03c0 	ret

0000000048014350 <rt_dma_calc_recved_len>:
 * @param serial serial device
 *
 * @return length
 */
static rt_size_t rt_dma_calc_recved_len(struct rt_serial_device *serial)
{
    48014350:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48014354:	910003fd 	mov	x29, sp
    48014358:	f9000fe0 	str	x0, [sp, #24]
    return _serial_fifo_calc_recved_len(serial);
    4801435c:	f9400fe0 	ldr	x0, [sp, #24]
    48014360:	97ffffbe 	bl	48014258 <_serial_fifo_calc_recved_len>
}
    48014364:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48014368:	d65f03c0 	ret

000000004801436c <rt_dma_recv_update_get_index>:
 *
 * @param serial serial device
 * @param len get data length for this operate
 */
static void rt_dma_recv_update_get_index(struct rt_serial_device *serial, rt_size_t len)
{
    4801436c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48014370:	910003fd 	mov	x29, sp
    48014374:	f9000fe0 	str	x0, [sp, #24]
    48014378:	f9000be1 	str	x1, [sp, #16]
    struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *) serial->serial_rx;
    4801437c:	f9400fe0 	ldr	x0, [sp, #24]
    48014380:	f9405400 	ldr	x0, [x0, #168]
    48014384:	f90017e0 	str	x0, [sp, #40]

    RT_ASSERT(rx_fifo != RT_NULL);
    48014388:	f94017e0 	ldr	x0, [sp, #40]
    4801438c:	f100001f 	cmp	x0, #0x0
    48014390:	540000e1 	b.ne	480143ac <rt_dma_recv_update_get_index+0x40>  // b.any
    48014394:	d28033a2 	mov	x2, #0x19d                 	// #413
    48014398:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801439c:	9113c001 	add	x1, x0, #0x4f0
    480143a0:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480143a4:	910b8000 	add	x0, x0, #0x2e0
    480143a8:	97ffef30 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(len <= rt_dma_calc_recved_len(serial));
    480143ac:	f9400fe0 	ldr	x0, [sp, #24]
    480143b0:	97ffffe8 	bl	48014350 <rt_dma_calc_recved_len>
    480143b4:	aa0003e1 	mov	x1, x0
    480143b8:	f9400be0 	ldr	x0, [sp, #16]
    480143bc:	eb01001f 	cmp	x0, x1
    480143c0:	540000e9 	b.ls	480143dc <rt_dma_recv_update_get_index+0x70>  // b.plast
    480143c4:	d28033c2 	mov	x2, #0x19e                 	// #414
    480143c8:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480143cc:	9113c001 	add	x1, x0, #0x4f0
    480143d0:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480143d4:	910e0000 	add	x0, x0, #0x380
    480143d8:	97ffef24 	bl	48010068 <rt_assert_handler>

    if (rx_fifo->is_full && len != 0) rx_fifo->is_full = RT_FALSE;
    480143dc:	f94017e0 	ldr	x0, [sp, #40]
    480143e0:	b9400c00 	ldr	w0, [x0, #12]
    480143e4:	7100001f 	cmp	w0, #0x0
    480143e8:	540000c0 	b.eq	48014400 <rt_dma_recv_update_get_index+0x94>  // b.none
    480143ec:	f9400be0 	ldr	x0, [sp, #16]
    480143f0:	f100001f 	cmp	x0, #0x0
    480143f4:	54000060 	b.eq	48014400 <rt_dma_recv_update_get_index+0x94>  // b.none
    480143f8:	f94017e0 	ldr	x0, [sp, #40]
    480143fc:	b9000c1f 	str	wzr, [x0, #12]

    rx_fifo->get_index += len;
    48014400:	f94017e0 	ldr	x0, [sp, #40]
    48014404:	79401401 	ldrh	w1, [x0, #10]
    48014408:	f9400be0 	ldr	x0, [sp, #16]
    4801440c:	12003c00 	and	w0, w0, #0xffff
    48014410:	0b000020 	add	w0, w1, w0
    48014414:	12003c01 	and	w1, w0, #0xffff
    48014418:	f94017e0 	ldr	x0, [sp, #40]
    4801441c:	79001401 	strh	w1, [x0, #10]
    if (rx_fifo->get_index >= serial->config.bufsz)
    48014420:	f94017e0 	ldr	x0, [sp, #40]
    48014424:	79401401 	ldrh	w1, [x0, #10]
    48014428:	f9400fe0 	ldr	x0, [sp, #24]
    4801442c:	f9405000 	ldr	x0, [x0, #160]
    48014430:	d36ae400 	ubfx	x0, x0, #42, #16
    48014434:	12003c00 	and	w0, w0, #0xffff
    48014438:	6b00003f 	cmp	w1, w0
    4801443c:	540001a3 	b.cc	48014470 <rt_dma_recv_update_get_index+0x104>  // b.lo, b.ul, b.last
    {
        rx_fifo->get_index %= serial->config.bufsz;
    48014440:	f94017e0 	ldr	x0, [sp, #40]
    48014444:	79401400 	ldrh	w0, [x0, #10]
    48014448:	f9400fe1 	ldr	x1, [sp, #24]
    4801444c:	f9405021 	ldr	x1, [x1, #160]
    48014450:	d36ae421 	ubfx	x1, x1, #42, #16
    48014454:	12003c21 	and	w1, w1, #0xffff
    48014458:	1ac10802 	udiv	w2, w0, w1
    4801445c:	1b017c41 	mul	w1, w2, w1
    48014460:	4b010000 	sub	w0, w0, w1
    48014464:	12003c01 	and	w1, w0, #0xffff
    48014468:	f94017e0 	ldr	x0, [sp, #40]
    4801446c:	79001401 	strh	w1, [x0, #10]
    }
}
    48014470:	d503201f 	nop
    48014474:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48014478:	d65f03c0 	ret

000000004801447c <rt_dma_recv_update_put_index>:
 *
 * @param serial serial device
 * @param len received length for this transmit
 */
static void rt_dma_recv_update_put_index(struct rt_serial_device *serial, rt_size_t len)
{
    4801447c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48014480:	910003fd 	mov	x29, sp
    48014484:	f9000fe0 	str	x0, [sp, #24]
    48014488:	f9000be1 	str	x1, [sp, #16]
    struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *)serial->serial_rx;
    4801448c:	f9400fe0 	ldr	x0, [sp, #24]
    48014490:	f9405400 	ldr	x0, [x0, #168]
    48014494:	f90017e0 	str	x0, [sp, #40]

    RT_ASSERT(rx_fifo != RT_NULL);
    48014498:	f94017e0 	ldr	x0, [sp, #40]
    4801449c:	f100001f 	cmp	x0, #0x0
    480144a0:	540000e1 	b.ne	480144bc <rt_dma_recv_update_put_index+0x40>  // b.any
    480144a4:	d2803662 	mov	x2, #0x1b3                 	// #435
    480144a8:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480144ac:	91144001 	add	x1, x0, #0x510
    480144b0:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480144b4:	910b8000 	add	x0, x0, #0x2e0
    480144b8:	97ffeeec 	bl	48010068 <rt_assert_handler>

    if (rx_fifo->get_index <= rx_fifo->put_index)
    480144bc:	f94017e0 	ldr	x0, [sp, #40]
    480144c0:	79401401 	ldrh	w1, [x0, #10]
    480144c4:	f94017e0 	ldr	x0, [sp, #40]
    480144c8:	79401000 	ldrh	w0, [x0, #8]
    480144cc:	6b00003f 	cmp	w1, w0
    480144d0:	540004e8 	b.hi	4801456c <rt_dma_recv_update_put_index+0xf0>  // b.pmore
    {
        rx_fifo->put_index += len;
    480144d4:	f94017e0 	ldr	x0, [sp, #40]
    480144d8:	79401001 	ldrh	w1, [x0, #8]
    480144dc:	f9400be0 	ldr	x0, [sp, #16]
    480144e0:	12003c00 	and	w0, w0, #0xffff
    480144e4:	0b000020 	add	w0, w1, w0
    480144e8:	12003c01 	and	w1, w0, #0xffff
    480144ec:	f94017e0 	ldr	x0, [sp, #40]
    480144f0:	79001001 	strh	w1, [x0, #8]
        /* beyond the fifo end */
        if (rx_fifo->put_index >= serial->config.bufsz)
    480144f4:	f94017e0 	ldr	x0, [sp, #40]
    480144f8:	79401001 	ldrh	w1, [x0, #8]
    480144fc:	f9400fe0 	ldr	x0, [sp, #24]
    48014500:	f9405000 	ldr	x0, [x0, #160]
    48014504:	d36ae400 	ubfx	x0, x0, #42, #16
    48014508:	12003c00 	and	w0, w0, #0xffff
    4801450c:	6b00003f 	cmp	w1, w0
    48014510:	54000783 	b.cc	48014600 <rt_dma_recv_update_put_index+0x184>  // b.lo, b.ul, b.last
        {
            rx_fifo->put_index %= serial->config.bufsz;
    48014514:	f94017e0 	ldr	x0, [sp, #40]
    48014518:	79401000 	ldrh	w0, [x0, #8]
    4801451c:	f9400fe1 	ldr	x1, [sp, #24]
    48014520:	f9405021 	ldr	x1, [x1, #160]
    48014524:	d36ae421 	ubfx	x1, x1, #42, #16
    48014528:	12003c21 	and	w1, w1, #0xffff
    4801452c:	1ac10802 	udiv	w2, w0, w1
    48014530:	1b017c41 	mul	w1, w2, w1
    48014534:	4b010000 	sub	w0, w0, w1
    48014538:	12003c01 	and	w1, w0, #0xffff
    4801453c:	f94017e0 	ldr	x0, [sp, #40]
    48014540:	79001001 	strh	w1, [x0, #8]
            /* force overwrite get index */
            if (rx_fifo->put_index >= rx_fifo->get_index)
    48014544:	f94017e0 	ldr	x0, [sp, #40]
    48014548:	79401001 	ldrh	w1, [x0, #8]
    4801454c:	f94017e0 	ldr	x0, [sp, #40]
    48014550:	79401400 	ldrh	w0, [x0, #10]
    48014554:	6b00003f 	cmp	w1, w0
    48014558:	54000543 	b.cc	48014600 <rt_dma_recv_update_put_index+0x184>  // b.lo, b.ul, b.last
            {
                rx_fifo->is_full = RT_TRUE;
    4801455c:	f94017e0 	ldr	x0, [sp, #40]
    48014560:	52800021 	mov	w1, #0x1                   	// #1
    48014564:	b9000c01 	str	w1, [x0, #12]
    48014568:	14000026 	b	48014600 <rt_dma_recv_update_put_index+0x184>
            }
        }
    }
    else
    {
        rx_fifo->put_index += len;
    4801456c:	f94017e0 	ldr	x0, [sp, #40]
    48014570:	79401001 	ldrh	w1, [x0, #8]
    48014574:	f9400be0 	ldr	x0, [sp, #16]
    48014578:	12003c00 	and	w0, w0, #0xffff
    4801457c:	0b000020 	add	w0, w1, w0
    48014580:	12003c01 	and	w1, w0, #0xffff
    48014584:	f94017e0 	ldr	x0, [sp, #40]
    48014588:	79001001 	strh	w1, [x0, #8]
        if (rx_fifo->put_index >= rx_fifo->get_index)
    4801458c:	f94017e0 	ldr	x0, [sp, #40]
    48014590:	79401001 	ldrh	w1, [x0, #8]
    48014594:	f94017e0 	ldr	x0, [sp, #40]
    48014598:	79401400 	ldrh	w0, [x0, #10]
    4801459c:	6b00003f 	cmp	w1, w0
    480145a0:	54000303 	b.cc	48014600 <rt_dma_recv_update_put_index+0x184>  // b.lo, b.ul, b.last
        {
            /* beyond the fifo end */
            if (rx_fifo->put_index >= serial->config.bufsz)
    480145a4:	f94017e0 	ldr	x0, [sp, #40]
    480145a8:	79401001 	ldrh	w1, [x0, #8]
    480145ac:	f9400fe0 	ldr	x0, [sp, #24]
    480145b0:	f9405000 	ldr	x0, [x0, #160]
    480145b4:	d36ae400 	ubfx	x0, x0, #42, #16
    480145b8:	12003c00 	and	w0, w0, #0xffff
    480145bc:	6b00003f 	cmp	w1, w0
    480145c0:	540001a3 	b.cc	480145f4 <rt_dma_recv_update_put_index+0x178>  // b.lo, b.ul, b.last
            {
                rx_fifo->put_index %= serial->config.bufsz;
    480145c4:	f94017e0 	ldr	x0, [sp, #40]
    480145c8:	79401000 	ldrh	w0, [x0, #8]
    480145cc:	f9400fe1 	ldr	x1, [sp, #24]
    480145d0:	f9405021 	ldr	x1, [x1, #160]
    480145d4:	d36ae421 	ubfx	x1, x1, #42, #16
    480145d8:	12003c21 	and	w1, w1, #0xffff
    480145dc:	1ac10802 	udiv	w2, w0, w1
    480145e0:	1b017c41 	mul	w1, w2, w1
    480145e4:	4b010000 	sub	w0, w0, w1
    480145e8:	12003c01 	and	w1, w0, #0xffff
    480145ec:	f94017e0 	ldr	x0, [sp, #40]
    480145f0:	79001001 	strh	w1, [x0, #8]
            }
            /* force overwrite get index */
            rx_fifo->is_full = RT_TRUE;
    480145f4:	f94017e0 	ldr	x0, [sp, #40]
    480145f8:	52800021 	mov	w1, #0x1                   	// #1
    480145fc:	b9000c01 	str	w1, [x0, #12]
        }
    }

    if(rx_fifo->is_full == RT_TRUE)
    48014600:	f94017e0 	ldr	x0, [sp, #40]
    48014604:	b9400c00 	ldr	w0, [x0, #12]
    48014608:	7100041f 	cmp	w0, #0x1
    4801460c:	540000c1 	b.ne	48014624 <rt_dma_recv_update_put_index+0x1a8>  // b.any
    {
        _serial_check_buffer_size();
    48014610:	97fffefb 	bl	480141fc <_serial_check_buffer_size>
        rx_fifo->get_index = rx_fifo->put_index;
    48014614:	f94017e0 	ldr	x0, [sp, #40]
    48014618:	79401001 	ldrh	w1, [x0, #8]
    4801461c:	f94017e0 	ldr	x0, [sp, #40]
    48014620:	79001401 	strh	w1, [x0, #10]
    }
}
    48014624:	d503201f 	nop
    48014628:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801462c:	d65f03c0 	ret

0000000048014630 <_serial_dma_rx>:

/*
 * Serial DMA routines
 */
rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
    48014630:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    48014634:	910003fd 	mov	x29, sp
    48014638:	f90017e0 	str	x0, [sp, #40]
    4801463c:	f90013e1 	str	x1, [sp, #32]
    48014640:	b9001fe2 	str	w2, [sp, #28]
    rt_base_t level;

    RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
    48014644:	f94017e0 	ldr	x0, [sp, #40]
    48014648:	f100001f 	cmp	x0, #0x0
    4801464c:	54000080 	b.eq	4801465c <_serial_dma_rx+0x2c>  // b.none
    48014650:	f94013e0 	ldr	x0, [sp, #32]
    48014654:	f100001f 	cmp	x0, #0x0
    48014658:	540000e1 	b.ne	48014674 <_serial_dma_rx+0x44>  // b.any
    4801465c:	d2803c02 	mov	x2, #0x1e0                 	// #480
    48014660:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014664:	91160001 	add	x1, x0, #0x580
    48014668:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801466c:	910ea000 	add	x0, x0, #0x3a8
    48014670:	97ffee7e 	bl	48010068 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
    48014674:	97ffbf6e 	bl	4800442c <rt_hw_interrupt_disable>
    48014678:	f90027e0 	str	x0, [sp, #72]

    if (serial->config.bufsz == 0)
    4801467c:	f94017e0 	ldr	x0, [sp, #40]
    48014680:	b940a400 	ldr	w0, [x0, #164]
    48014684:	12163c00 	and	w0, w0, #0x3fffc00
    48014688:	7100001f 	cmp	w0, #0x0
    4801468c:	540006e1 	b.ne	48014768 <_serial_dma_rx+0x138>  // b.any
    {
        int result = RT_EOK;
    48014690:	b9005fff 	str	wzr, [sp, #92]
        struct rt_serial_rx_dma *rx_dma;

        rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
    48014694:	f94017e0 	ldr	x0, [sp, #40]
    48014698:	f9405400 	ldr	x0, [x0, #168]
    4801469c:	f9001be0 	str	x0, [sp, #48]
        RT_ASSERT(rx_dma != RT_NULL);
    480146a0:	f9401be0 	ldr	x0, [sp, #48]
    480146a4:	f100001f 	cmp	x0, #0x0
    480146a8:	540000e1 	b.ne	480146c4 <_serial_dma_rx+0x94>  // b.any
    480146ac:	d2803d42 	mov	x2, #0x1ea                 	// #490
    480146b0:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480146b4:	91160001 	add	x1, x0, #0x580
    480146b8:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480146bc:	910f6000 	add	x0, x0, #0x3d8
    480146c0:	97ffee6a 	bl	48010068 <rt_assert_handler>

        if (rx_dma->activated != RT_TRUE)
    480146c4:	f9401be0 	ldr	x0, [sp, #48]
    480146c8:	b9400000 	ldr	w0, [x0]
    480146cc:	7100041f 	cmp	w0, #0x1
    480146d0:	54000320 	b.eq	48014734 <_serial_dma_rx+0x104>  // b.none
        {
            rx_dma->activated = RT_TRUE;
    480146d4:	f9401be0 	ldr	x0, [sp, #48]
    480146d8:	52800021 	mov	w1, #0x1                   	// #1
    480146dc:	b9000001 	str	w1, [x0]
            RT_ASSERT(serial->ops->dma_transmit != RT_NULL);
    480146e0:	f94017e0 	ldr	x0, [sp, #40]
    480146e4:	f9404c00 	ldr	x0, [x0, #152]
    480146e8:	f9401000 	ldr	x0, [x0, #32]
    480146ec:	f100001f 	cmp	x0, #0x0
    480146f0:	540000e1 	b.ne	4801470c <_serial_dma_rx+0xdc>  // b.any
    480146f4:	d2803de2 	mov	x2, #0x1ef                 	// #495
    480146f8:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480146fc:	91160001 	add	x1, x0, #0x580
    48014700:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014704:	910fc000 	add	x0, x0, #0x3f0
    48014708:	97ffee58 	bl	48010068 <rt_assert_handler>
            serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
    4801470c:	f94017e0 	ldr	x0, [sp, #40]
    48014710:	f9404c00 	ldr	x0, [x0, #152]
    48014714:	f9401004 	ldr	x4, [x0, #32]
    48014718:	b9801fe0 	ldrsw	x0, [sp, #28]
    4801471c:	52800023 	mov	w3, #0x1                   	// #1
    48014720:	aa0003e2 	mov	x2, x0
    48014724:	f94013e1 	ldr	x1, [sp, #32]
    48014728:	f94017e0 	ldr	x0, [sp, #40]
    4801472c:	d63f0080 	blr	x4
    48014730:	14000003 	b	4801473c <_serial_dma_rx+0x10c>
        }
        else result = -RT_EBUSY;
    48014734:	128000c0 	mov	w0, #0xfffffff9            	// #-7
    48014738:	b9005fe0 	str	w0, [sp, #92]
        rt_hw_interrupt_enable(level);
    4801473c:	f94027e0 	ldr	x0, [sp, #72]
    48014740:	97ffbf3f 	bl	4800443c <rt_hw_interrupt_enable>

        if (result == RT_EOK) return length;
    48014744:	b9405fe0 	ldr	w0, [sp, #92]
    48014748:	7100001f 	cmp	w0, #0x0
    4801474c:	54000061 	b.ne	48014758 <_serial_dma_rx+0x128>  // b.any
    48014750:	b9401fe0 	ldr	w0, [sp, #28]
    48014754:	1400006a 	b	480148fc <_serial_dma_rx+0x2cc>

        rt_set_errno(result);
    48014758:	b9805fe0 	ldrsw	x0, [sp, #92]
    4801475c:	97ffe6c2 	bl	4800e264 <rt_set_errno>
        return 0;
    48014760:	52800000 	mov	w0, #0x0                   	// #0
    48014764:	14000066 	b	480148fc <_serial_dma_rx+0x2cc>
    }
    else
    {
        struct rt_serial_rx_fifo *rx_fifo = (struct rt_serial_rx_fifo *) serial->serial_rx;
    48014768:	f94017e0 	ldr	x0, [sp, #40]
    4801476c:	f9405400 	ldr	x0, [x0, #168]
    48014770:	f90023e0 	str	x0, [sp, #64]
        rt_size_t recv_len = 0, fifo_recved_len = rt_dma_calc_recved_len(serial);
    48014774:	f9002bff 	str	xzr, [sp, #80]
    48014778:	f94017e0 	ldr	x0, [sp, #40]
    4801477c:	97fffef5 	bl	48014350 <rt_dma_calc_recved_len>
    48014780:	f9001fe0 	str	x0, [sp, #56]

        RT_ASSERT(rx_fifo != RT_NULL);
    48014784:	f94023e0 	ldr	x0, [sp, #64]
    48014788:	f100001f 	cmp	x0, #0x0
    4801478c:	540000e1 	b.ne	480147a8 <_serial_dma_rx+0x178>  // b.any
    48014790:	d2803fe2 	mov	x2, #0x1ff                 	// #511
    48014794:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014798:	91160001 	add	x1, x0, #0x580
    4801479c:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480147a0:	910b8000 	add	x0, x0, #0x2e0
    480147a4:	97ffee31 	bl	48010068 <rt_assert_handler>

        if (length < (int)fifo_recved_len)
    480147a8:	f9401fe0 	ldr	x0, [sp, #56]
    480147ac:	2a0003e1 	mov	w1, w0
    480147b0:	b9401fe0 	ldr	w0, [sp, #28]
    480147b4:	6b01001f 	cmp	w0, w1
    480147b8:	5400008a 	b.ge	480147c8 <_serial_dma_rx+0x198>  // b.tcont
            recv_len = length;
    480147bc:	b9801fe0 	ldrsw	x0, [sp, #28]
    480147c0:	f9002be0 	str	x0, [sp, #80]
    480147c4:	14000003 	b	480147d0 <_serial_dma_rx+0x1a0>
        else
            recv_len = fifo_recved_len;
    480147c8:	f9401fe0 	ldr	x0, [sp, #56]
    480147cc:	f9002be0 	str	x0, [sp, #80]

        if (rx_fifo->get_index + recv_len < serial->config.bufsz)
    480147d0:	f94023e0 	ldr	x0, [sp, #64]
    480147d4:	79401400 	ldrh	w0, [x0, #10]
    480147d8:	92403c01 	and	x1, x0, #0xffff
    480147dc:	f9402be0 	ldr	x0, [sp, #80]
    480147e0:	8b000021 	add	x1, x1, x0
    480147e4:	f94017e0 	ldr	x0, [sp, #40]
    480147e8:	f9405000 	ldr	x0, [x0, #160]
    480147ec:	d36ae400 	ubfx	x0, x0, #42, #16
    480147f0:	12003c00 	and	w0, w0, #0xffff
    480147f4:	92403c00 	and	x0, x0, #0xffff
    480147f8:	eb00003f 	cmp	x1, x0
    480147fc:	54000182 	b.cs	4801482c <_serial_dma_rx+0x1fc>  // b.hs, b.nlast
            rt_memcpy(data, rx_fifo->buffer + rx_fifo->get_index, recv_len);
    48014800:	f94023e0 	ldr	x0, [sp, #64]
    48014804:	f9400001 	ldr	x1, [x0]
    48014808:	f94023e0 	ldr	x0, [sp, #64]
    4801480c:	79401400 	ldrh	w0, [x0, #10]
    48014810:	92403c00 	and	x0, x0, #0xffff
    48014814:	8b000020 	add	x0, x1, x0
    48014818:	f9402be2 	ldr	x2, [sp, #80]
    4801481c:	aa0003e1 	mov	x1, x0
    48014820:	f94013e0 	ldr	x0, [sp, #32]
    48014824:	97ffe71a 	bl	4800e48c <rt_memcpy>
    48014828:	1400002f 	b	480148e4 <_serial_dma_rx+0x2b4>
        else
        {
            rt_memcpy(data, rx_fifo->buffer + rx_fifo->get_index,
    4801482c:	f94023e0 	ldr	x0, [sp, #64]
    48014830:	f9400001 	ldr	x1, [x0]
    48014834:	f94023e0 	ldr	x0, [sp, #64]
    48014838:	79401400 	ldrh	w0, [x0, #10]
    4801483c:	92403c00 	and	x0, x0, #0xffff
    48014840:	8b000021 	add	x1, x1, x0
                    serial->config.bufsz - rx_fifo->get_index);
    48014844:	f94017e0 	ldr	x0, [sp, #40]
    48014848:	f9405000 	ldr	x0, [x0, #160]
    4801484c:	d36ae400 	ubfx	x0, x0, #42, #16
    48014850:	12003c00 	and	w0, w0, #0xffff
    48014854:	2a0003e2 	mov	w2, w0
    48014858:	f94023e0 	ldr	x0, [sp, #64]
    4801485c:	79401400 	ldrh	w0, [x0, #10]
    48014860:	4b000040 	sub	w0, w2, w0
            rt_memcpy(data, rx_fifo->buffer + rx_fifo->get_index,
    48014864:	93407c00 	sxtw	x0, w0
    48014868:	aa0003e2 	mov	x2, x0
    4801486c:	f94013e0 	ldr	x0, [sp, #32]
    48014870:	97ffe707 	bl	4800e48c <rt_memcpy>
            rt_memcpy(data + serial->config.bufsz - rx_fifo->get_index, rx_fifo->buffer,
    48014874:	f94017e0 	ldr	x0, [sp, #40]
    48014878:	f9405000 	ldr	x0, [x0, #160]
    4801487c:	d36ae400 	ubfx	x0, x0, #42, #16
    48014880:	12003c00 	and	w0, w0, #0xffff
    48014884:	92403c01 	and	x1, x0, #0xffff
    48014888:	f94023e0 	ldr	x0, [sp, #64]
    4801488c:	79401400 	ldrh	w0, [x0, #10]
    48014890:	92403c00 	and	x0, x0, #0xffff
    48014894:	cb000020 	sub	x0, x1, x0
    48014898:	f94013e1 	ldr	x1, [sp, #32]
    4801489c:	8b000023 	add	x3, x1, x0
    480148a0:	f94023e0 	ldr	x0, [sp, #64]
    480148a4:	f9400004 	ldr	x4, [x0]
                    recv_len + rx_fifo->get_index - serial->config.bufsz);
    480148a8:	f94023e0 	ldr	x0, [sp, #64]
    480148ac:	79401400 	ldrh	w0, [x0, #10]
    480148b0:	92403c01 	and	x1, x0, #0xffff
    480148b4:	f9402be0 	ldr	x0, [sp, #80]
    480148b8:	8b000021 	add	x1, x1, x0
    480148bc:	f94017e0 	ldr	x0, [sp, #40]
    480148c0:	f9405000 	ldr	x0, [x0, #160]
    480148c4:	d36ae400 	ubfx	x0, x0, #42, #16
    480148c8:	12003c00 	and	w0, w0, #0xffff
    480148cc:	92403c00 	and	x0, x0, #0xffff
            rt_memcpy(data + serial->config.bufsz - rx_fifo->get_index, rx_fifo->buffer,
    480148d0:	cb000020 	sub	x0, x1, x0
    480148d4:	aa0003e2 	mov	x2, x0
    480148d8:	aa0403e1 	mov	x1, x4
    480148dc:	aa0303e0 	mov	x0, x3
    480148e0:	97ffe6eb 	bl	4800e48c <rt_memcpy>
        }
        rt_dma_recv_update_get_index(serial, recv_len);
    480148e4:	f9402be1 	ldr	x1, [sp, #80]
    480148e8:	f94017e0 	ldr	x0, [sp, #40]
    480148ec:	97fffea0 	bl	4801436c <rt_dma_recv_update_get_index>
        rt_hw_interrupt_enable(level);
    480148f0:	f94027e0 	ldr	x0, [sp, #72]
    480148f4:	97ffbed2 	bl	4800443c <rt_hw_interrupt_enable>
        return recv_len;
    480148f8:	f9402be0 	ldr	x0, [sp, #80]
    }
}
    480148fc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    48014900:	d65f03c0 	ret

0000000048014904 <_serial_dma_tx>:

rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
    48014904:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48014908:	910003fd 	mov	x29, sp
    4801490c:	f90017e0 	str	x0, [sp, #40]
    48014910:	f90013e1 	str	x1, [sp, #32]
    48014914:	b9001fe2 	str	w2, [sp, #28]
    rt_base_t level;
    rt_err_t result;
    struct rt_serial_tx_dma *tx_dma;

    tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
    48014918:	f94017e0 	ldr	x0, [sp, #40]
    4801491c:	f9405800 	ldr	x0, [x0, #176]
    48014920:	f90027e0 	str	x0, [sp, #72]

    result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER);
    48014924:	f94027e0 	ldr	x0, [sp, #72]
    48014928:	91002000 	add	x0, x0, #0x8
    4801492c:	b9801fe1 	ldrsw	x1, [sp, #28]
    48014930:	12800003 	mov	w3, #0xffffffff            	// #-1
    48014934:	aa0103e2 	mov	x2, x1
    48014938:	f94013e1 	ldr	x1, [sp, #32]
    4801493c:	940006b3 	bl	48016408 <rt_data_queue_push>
    48014940:	f90023e0 	str	x0, [sp, #64]
    if (result == RT_EOK)
    48014944:	f94023e0 	ldr	x0, [sp, #64]
    48014948:	f100001f 	cmp	x0, #0x0
    4801494c:	54000341 	b.ne	480149b4 <_serial_dma_tx+0xb0>  // b.any
    {
        level = rt_hw_interrupt_disable();
    48014950:	97ffbeb7 	bl	4800442c <rt_hw_interrupt_disable>
    48014954:	f9001fe0 	str	x0, [sp, #56]
        if (tx_dma->activated != RT_TRUE)
    48014958:	f94027e0 	ldr	x0, [sp, #72]
    4801495c:	b9400000 	ldr	w0, [x0]
    48014960:	7100041f 	cmp	w0, #0x1
    48014964:	54000200 	b.eq	480149a4 <_serial_dma_tx+0xa0>  // b.none
        {
            tx_dma->activated = RT_TRUE;
    48014968:	f94027e0 	ldr	x0, [sp, #72]
    4801496c:	52800021 	mov	w1, #0x1                   	// #1
    48014970:	b9000001 	str	w1, [x0]
            rt_hw_interrupt_enable(level);
    48014974:	f9401fe0 	ldr	x0, [sp, #56]
    48014978:	97ffbeb1 	bl	4800443c <rt_hw_interrupt_enable>

            /* make a DMA transfer */
            serial->ops->dma_transmit(serial, (rt_uint8_t *)data, length, RT_SERIAL_DMA_TX);
    4801497c:	f94017e0 	ldr	x0, [sp, #40]
    48014980:	f9404c00 	ldr	x0, [x0, #152]
    48014984:	f9401004 	ldr	x4, [x0, #32]
    48014988:	b9801fe0 	ldrsw	x0, [sp, #28]
    4801498c:	52800043 	mov	w3, #0x2                   	// #2
    48014990:	aa0003e2 	mov	x2, x0
    48014994:	f94013e1 	ldr	x1, [sp, #32]
    48014998:	f94017e0 	ldr	x0, [sp, #40]
    4801499c:	d63f0080 	blr	x4
    480149a0:	14000003 	b	480149ac <_serial_dma_tx+0xa8>
        }
        else
        {
            rt_hw_interrupt_enable(level);
    480149a4:	f9401fe0 	ldr	x0, [sp, #56]
    480149a8:	97ffbea5 	bl	4800443c <rt_hw_interrupt_enable>
        }

        return length;
    480149ac:	b9401fe0 	ldr	w0, [sp, #28]
    480149b0:	14000004 	b	480149c0 <_serial_dma_tx+0xbc>
    }
    else
    {
        rt_set_errno(result);
    480149b4:	f94023e0 	ldr	x0, [sp, #64]
    480149b8:	97ffe62b 	bl	4800e264 <rt_set_errno>
        return 0;
    480149bc:	52800000 	mov	w0, #0x0                   	// #0
    }
}
    480149c0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480149c4:	d65f03c0 	ret

00000000480149c8 <rt_serial_init>:
/* RT-Thread Device Interface */
/*
 * This function initializes serial device.
 */
static rt_err_t rt_serial_init(struct rt_device *dev)
{
    480149c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480149cc:	910003fd 	mov	x29, sp
    480149d0:	f9000fe0 	str	x0, [sp, #24]
    rt_err_t result = RT_EOK;
    480149d4:	f90017ff 	str	xzr, [sp, #40]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
    480149d8:	f9400fe0 	ldr	x0, [sp, #24]
    480149dc:	f100001f 	cmp	x0, #0x0
    480149e0:	540000e1 	b.ne	480149fc <rt_serial_init+0x34>  // b.any
    480149e4:	d2804822 	mov	x2, #0x241                 	// #577
    480149e8:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480149ec:	9114c001 	add	x1, x0, #0x530
    480149f0:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480149f4:	91106000 	add	x0, x0, #0x418
    480149f8:	97ffed9c 	bl	48010068 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
    480149fc:	f9400fe0 	ldr	x0, [sp, #24]
    48014a00:	f90013e0 	str	x0, [sp, #32]

    /* initialize rx/tx */
    serial->serial_rx = RT_NULL;
    48014a04:	f94013e0 	ldr	x0, [sp, #32]
    48014a08:	f900541f 	str	xzr, [x0, #168]
    serial->serial_tx = RT_NULL;
    48014a0c:	f94013e0 	ldr	x0, [sp, #32]
    48014a10:	f900581f 	str	xzr, [x0, #176]

    /* apply configuration */
    if (serial->ops->configure)
    48014a14:	f94013e0 	ldr	x0, [sp, #32]
    48014a18:	f9404c00 	ldr	x0, [x0, #152]
    48014a1c:	f9400000 	ldr	x0, [x0]
    48014a20:	f100001f 	cmp	x0, #0x0
    48014a24:	54000140 	b.eq	48014a4c <rt_serial_init+0x84>  // b.none
        result = serial->ops->configure(serial, &serial->config);
    48014a28:	f94013e0 	ldr	x0, [sp, #32]
    48014a2c:	f9404c00 	ldr	x0, [x0, #152]
    48014a30:	f9400002 	ldr	x2, [x0]
    48014a34:	f94013e0 	ldr	x0, [sp, #32]
    48014a38:	91028000 	add	x0, x0, #0xa0
    48014a3c:	aa0003e1 	mov	x1, x0
    48014a40:	f94013e0 	ldr	x0, [sp, #32]
    48014a44:	d63f0040 	blr	x2
    48014a48:	f90017e0 	str	x0, [sp, #40]

    return result;
    48014a4c:	f94017e0 	ldr	x0, [sp, #40]
}
    48014a50:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48014a54:	d65f03c0 	ret

0000000048014a58 <rt_serial_open>:

static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
{
    48014a58:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    48014a5c:	910003fd 	mov	x29, sp
    48014a60:	f9000fe0 	str	x0, [sp, #24]
    48014a64:	79002fe1 	strh	w1, [sp, #22]
    rt_uint16_t stream_flag = 0;
    48014a68:	7900bfff 	strh	wzr, [sp, #94]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
    48014a6c:	f9400fe0 	ldr	x0, [sp, #24]
    48014a70:	f100001f 	cmp	x0, #0x0
    48014a74:	540000e1 	b.ne	48014a90 <rt_serial_open+0x38>  // b.any
    48014a78:	d2804a82 	mov	x2, #0x254                 	// #596
    48014a7c:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014a80:	91150001 	add	x1, x0, #0x540
    48014a84:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014a88:	91106000 	add	x0, x0, #0x418
    48014a8c:	97ffed77 	bl	48010068 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
    48014a90:	f9400fe0 	ldr	x0, [sp, #24]
    48014a94:	f9002be0 	str	x0, [sp, #80]

    LOG_D("open serial device: 0x%08x with open flag: 0x%04x",
        dev, oflag);
    /* check device flag with the open flag */
    if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX))
    48014a98:	79402fe0 	ldrh	w0, [sp, #22]
    48014a9c:	12170000 	and	w0, w0, #0x200
    48014aa0:	7100001f 	cmp	w0, #0x0
    48014aa4:	54000100 	b.eq	48014ac4 <rt_serial_open+0x6c>  // b.none
    48014aa8:	f9400fe0 	ldr	x0, [sp, #24]
    48014aac:	79404800 	ldrh	w0, [x0, #36]
    48014ab0:	12170000 	and	w0, w0, #0x200
    48014ab4:	7100001f 	cmp	w0, #0x0
    48014ab8:	54000061 	b.ne	48014ac4 <rt_serial_open+0x6c>  // b.any
        return -RT_EIO;
    48014abc:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
    48014ac0:	1400014b 	b	48014fec <rt_serial_open+0x594>
    if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
    48014ac4:	79402fe0 	ldrh	w0, [sp, #22]
    48014ac8:	12150000 	and	w0, w0, #0x800
    48014acc:	7100001f 	cmp	w0, #0x0
    48014ad0:	54000100 	b.eq	48014af0 <rt_serial_open+0x98>  // b.none
    48014ad4:	f9400fe0 	ldr	x0, [sp, #24]
    48014ad8:	79404800 	ldrh	w0, [x0, #36]
    48014adc:	12150000 	and	w0, w0, #0x800
    48014ae0:	7100001f 	cmp	w0, #0x0
    48014ae4:	54000061 	b.ne	48014af0 <rt_serial_open+0x98>  // b.any
        return -RT_EIO;
    48014ae8:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
    48014aec:	14000140 	b	48014fec <rt_serial_open+0x594>
    if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
    48014af0:	79402fe0 	ldrh	w0, [sp, #22]
    48014af4:	12180000 	and	w0, w0, #0x100
    48014af8:	7100001f 	cmp	w0, #0x0
    48014afc:	54000100 	b.eq	48014b1c <rt_serial_open+0xc4>  // b.none
    48014b00:	f9400fe0 	ldr	x0, [sp, #24]
    48014b04:	79404800 	ldrh	w0, [x0, #36]
    48014b08:	12180000 	and	w0, w0, #0x100
    48014b0c:	7100001f 	cmp	w0, #0x0
    48014b10:	54000061 	b.ne	48014b1c <rt_serial_open+0xc4>  // b.any
        return -RT_EIO;
    48014b14:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
    48014b18:	14000135 	b	48014fec <rt_serial_open+0x594>
    if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
    48014b1c:	79402fe0 	ldrh	w0, [sp, #22]
    48014b20:	12160000 	and	w0, w0, #0x400
    48014b24:	7100001f 	cmp	w0, #0x0
    48014b28:	54000100 	b.eq	48014b48 <rt_serial_open+0xf0>  // b.none
    48014b2c:	f9400fe0 	ldr	x0, [sp, #24]
    48014b30:	79404800 	ldrh	w0, [x0, #36]
    48014b34:	12160000 	and	w0, w0, #0x400
    48014b38:	7100001f 	cmp	w0, #0x0
    48014b3c:	54000061 	b.ne	48014b48 <rt_serial_open+0xf0>  // b.any
        return -RT_EIO;
    48014b40:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
    48014b44:	1400012a 	b	48014fec <rt_serial_open+0x594>

    /* keep steam flag */
    if ((oflag & RT_DEVICE_FLAG_STREAM) || (dev->open_flag & RT_DEVICE_FLAG_STREAM))
    48014b48:	79402fe0 	ldrh	w0, [sp, #22]
    48014b4c:	121a0000 	and	w0, w0, #0x40
    48014b50:	7100001f 	cmp	w0, #0x0
    48014b54:	540000c1 	b.ne	48014b6c <rt_serial_open+0x114>  // b.any
    48014b58:	f9400fe0 	ldr	x0, [sp, #24]
    48014b5c:	79404c00 	ldrh	w0, [x0, #38]
    48014b60:	121a0000 	and	w0, w0, #0x40
    48014b64:	7100001f 	cmp	w0, #0x0
    48014b68:	54000060 	b.eq	48014b74 <rt_serial_open+0x11c>  // b.none
        stream_flag = RT_DEVICE_FLAG_STREAM;
    48014b6c:	52800800 	mov	w0, #0x40                  	// #64
    48014b70:	7900bfe0 	strh	w0, [sp, #94]

    /* get open flags */
    dev->open_flag = oflag & 0xff;
    48014b74:	79402fe0 	ldrh	w0, [sp, #22]
    48014b78:	12001c00 	and	w0, w0, #0xff
    48014b7c:	12003c01 	and	w1, w0, #0xffff
    48014b80:	f9400fe0 	ldr	x0, [sp, #24]
    48014b84:	79004c01 	strh	w1, [x0, #38]

    /* initialize the Rx/Tx structure according to open flag */
    if (serial->serial_rx == RT_NULL)
    48014b88:	f9402be0 	ldr	x0, [sp, #80]
    48014b8c:	f9405400 	ldr	x0, [x0, #168]
    48014b90:	f100001f 	cmp	x0, #0x0
    48014b94:	54001221 	b.ne	48014dd8 <rt_serial_open+0x380>  // b.any
    {
        if (oflag & RT_DEVICE_FLAG_INT_RX)
    48014b98:	79402fe0 	ldrh	w0, [sp, #22]
    48014b9c:	12180000 	and	w0, w0, #0x100
    48014ba0:	7100001f 	cmp	w0, #0x0
    48014ba4:	54000700 	b.eq	48014c84 <rt_serial_open+0x22c>  // b.none
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) +
                serial->config.bufsz);
    48014ba8:	f9402be0 	ldr	x0, [sp, #80]
    48014bac:	f9405000 	ldr	x0, [x0, #160]
    48014bb0:	d36ae400 	ubfx	x0, x0, #42, #16
    48014bb4:	12003c00 	and	w0, w0, #0xffff
    48014bb8:	92403c00 	and	x0, x0, #0xffff
            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) +
    48014bbc:	91004000 	add	x0, x0, #0x10
    48014bc0:	97ffd3f2 	bl	48009b88 <rt_malloc>
    48014bc4:	f9001fe0 	str	x0, [sp, #56]
            RT_ASSERT(rx_fifo != RT_NULL);
    48014bc8:	f9401fe0 	ldr	x0, [sp, #56]
    48014bcc:	f100001f 	cmp	x0, #0x0
    48014bd0:	540000e1 	b.ne	48014bec <rt_serial_open+0x194>  // b.any
    48014bd4:	d2804e62 	mov	x2, #0x273                 	// #627
    48014bd8:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014bdc:	91150001 	add	x1, x0, #0x540
    48014be0:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014be4:	910b8000 	add	x0, x0, #0x2e0
    48014be8:	97ffed20 	bl	48010068 <rt_assert_handler>
            rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
    48014bec:	f9401fe0 	ldr	x0, [sp, #56]
    48014bf0:	91004001 	add	x1, x0, #0x10
    48014bf4:	f9401fe0 	ldr	x0, [sp, #56]
    48014bf8:	f9000001 	str	x1, [x0]
            rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
    48014bfc:	f9401fe0 	ldr	x0, [sp, #56]
    48014c00:	f9400003 	ldr	x3, [x0]
    48014c04:	f9402be0 	ldr	x0, [sp, #80]
    48014c08:	f9405000 	ldr	x0, [x0, #160]
    48014c0c:	d36ae400 	ubfx	x0, x0, #42, #16
    48014c10:	12003c00 	and	w0, w0, #0xffff
    48014c14:	92403c00 	and	x0, x0, #0xffff
    48014c18:	aa0003e2 	mov	x2, x0
    48014c1c:	52800001 	mov	w1, #0x0                   	// #0
    48014c20:	aa0303e0 	mov	x0, x3
    48014c24:	97ffe5c2 	bl	4800e32c <rt_memset>
            rx_fifo->put_index = 0;
    48014c28:	f9401fe0 	ldr	x0, [sp, #56]
    48014c2c:	7900101f 	strh	wzr, [x0, #8]
            rx_fifo->get_index = 0;
    48014c30:	f9401fe0 	ldr	x0, [sp, #56]
    48014c34:	7900141f 	strh	wzr, [x0, #10]
            rx_fifo->is_full = RT_FALSE;
    48014c38:	f9401fe0 	ldr	x0, [sp, #56]
    48014c3c:	b9000c1f 	str	wzr, [x0, #12]

            serial->serial_rx = rx_fifo;
    48014c40:	f9402be0 	ldr	x0, [sp, #80]
    48014c44:	f9401fe1 	ldr	x1, [sp, #56]
    48014c48:	f9005401 	str	x1, [x0, #168]
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
    48014c4c:	f9400fe0 	ldr	x0, [sp, #24]
    48014c50:	79404c00 	ldrh	w0, [x0, #38]
    48014c54:	32180000 	orr	w0, w0, #0x100
    48014c58:	12003c01 	and	w1, w0, #0xffff
    48014c5c:	f9400fe0 	ldr	x0, [sp, #24]
    48014c60:	79004c01 	strh	w1, [x0, #38]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
    48014c64:	f9402be0 	ldr	x0, [sp, #80]
    48014c68:	f9404c00 	ldr	x0, [x0, #152]
    48014c6c:	f9400403 	ldr	x3, [x0, #8]
    48014c70:	d2802002 	mov	x2, #0x100                 	// #256
    48014c74:	52800201 	mov	w1, #0x10                  	// #16
    48014c78:	f9402be0 	ldr	x0, [sp, #80]
    48014c7c:	d63f0060 	blr	x3
    48014c80:	1400006b 	b	48014e2c <rt_serial_open+0x3d4>
        }
#ifdef RT_SERIAL_USING_DMA
        else if (oflag & RT_DEVICE_FLAG_DMA_RX)
    48014c84:	79402fe0 	ldrh	w0, [sp, #22]
    48014c88:	12170000 	and	w0, w0, #0x200
    48014c8c:	7100001f 	cmp	w0, #0x0
    48014c90:	540009e0 	b.eq	48014dcc <rt_serial_open+0x374>  // b.none
        {
            if (serial->config.bufsz == 0) {
    48014c94:	f9402be0 	ldr	x0, [sp, #80]
    48014c98:	b940a400 	ldr	w0, [x0, #164]
    48014c9c:	12163c00 	and	w0, w0, #0x3fffc00
    48014ca0:	7100001f 	cmp	w0, #0x0
    48014ca4:	54000261 	b.ne	48014cf0 <rt_serial_open+0x298>  // b.any
                struct rt_serial_rx_dma* rx_dma;

                rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
    48014ca8:	d2800080 	mov	x0, #0x4                   	// #4
    48014cac:	97ffd3b7 	bl	48009b88 <rt_malloc>
    48014cb0:	f90023e0 	str	x0, [sp, #64]
                RT_ASSERT(rx_dma != RT_NULL);
    48014cb4:	f94023e0 	ldr	x0, [sp, #64]
    48014cb8:	f100001f 	cmp	x0, #0x0
    48014cbc:	540000e1 	b.ne	48014cd8 <rt_serial_open+0x280>  // b.any
    48014cc0:	d28050c2 	mov	x2, #0x286                 	// #646
    48014cc4:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014cc8:	91150001 	add	x1, x0, #0x540
    48014ccc:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014cd0:	910f6000 	add	x0, x0, #0x3d8
    48014cd4:	97ffece5 	bl	48010068 <rt_assert_handler>
                rx_dma->activated = RT_FALSE;
    48014cd8:	f94023e0 	ldr	x0, [sp, #64]
    48014cdc:	b900001f 	str	wzr, [x0]

                serial->serial_rx = rx_dma;
    48014ce0:	f9402be0 	ldr	x0, [sp, #80]
    48014ce4:	f94023e1 	ldr	x1, [sp, #64]
    48014ce8:	f9005401 	str	x1, [x0, #168]
    48014cec:	14000031 	b	48014db0 <rt_serial_open+0x358>
            } else {
                struct rt_serial_rx_fifo* rx_fifo;

                rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) +
                    serial->config.bufsz);
    48014cf0:	f9402be0 	ldr	x0, [sp, #80]
    48014cf4:	f9405000 	ldr	x0, [x0, #160]
    48014cf8:	d36ae400 	ubfx	x0, x0, #42, #16
    48014cfc:	12003c00 	and	w0, w0, #0xffff
    48014d00:	92403c00 	and	x0, x0, #0xffff
                rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) +
    48014d04:	91004000 	add	x0, x0, #0x10
    48014d08:	97ffd3a0 	bl	48009b88 <rt_malloc>
    48014d0c:	f90027e0 	str	x0, [sp, #72]
                RT_ASSERT(rx_fifo != RT_NULL);
    48014d10:	f94027e0 	ldr	x0, [sp, #72]
    48014d14:	f100001f 	cmp	x0, #0x0
    48014d18:	540000e1 	b.ne	48014d34 <rt_serial_open+0x2dc>  // b.any
    48014d1c:	d28051e2 	mov	x2, #0x28f                 	// #655
    48014d20:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014d24:	91150001 	add	x1, x0, #0x540
    48014d28:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014d2c:	910b8000 	add	x0, x0, #0x2e0
    48014d30:	97ffecce 	bl	48010068 <rt_assert_handler>
                rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
    48014d34:	f94027e0 	ldr	x0, [sp, #72]
    48014d38:	91004001 	add	x1, x0, #0x10
    48014d3c:	f94027e0 	ldr	x0, [sp, #72]
    48014d40:	f9000001 	str	x1, [x0]
                rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
    48014d44:	f94027e0 	ldr	x0, [sp, #72]
    48014d48:	f9400003 	ldr	x3, [x0]
    48014d4c:	f9402be0 	ldr	x0, [sp, #80]
    48014d50:	f9405000 	ldr	x0, [x0, #160]
    48014d54:	d36ae400 	ubfx	x0, x0, #42, #16
    48014d58:	12003c00 	and	w0, w0, #0xffff
    48014d5c:	92403c00 	and	x0, x0, #0xffff
    48014d60:	aa0003e2 	mov	x2, x0
    48014d64:	52800001 	mov	w1, #0x0                   	// #0
    48014d68:	aa0303e0 	mov	x0, x3
    48014d6c:	97ffe570 	bl	4800e32c <rt_memset>
                rx_fifo->put_index = 0;
    48014d70:	f94027e0 	ldr	x0, [sp, #72]
    48014d74:	7900101f 	strh	wzr, [x0, #8]
                rx_fifo->get_index = 0;
    48014d78:	f94027e0 	ldr	x0, [sp, #72]
    48014d7c:	7900141f 	strh	wzr, [x0, #10]
                rx_fifo->is_full = RT_FALSE;
    48014d80:	f94027e0 	ldr	x0, [sp, #72]
    48014d84:	b9000c1f 	str	wzr, [x0, #12]
                serial->serial_rx = rx_fifo;
    48014d88:	f9402be0 	ldr	x0, [sp, #80]
    48014d8c:	f94027e1 	ldr	x1, [sp, #72]
    48014d90:	f9005401 	str	x1, [x0, #168]
                /* configure fifo address and length to low level device */
                serial->ops->control(serial, RT_DEVICE_CTRL_CONFIG, (void *) RT_DEVICE_FLAG_DMA_RX);
    48014d94:	f9402be0 	ldr	x0, [sp, #80]
    48014d98:	f9404c00 	ldr	x0, [x0, #152]
    48014d9c:	f9400403 	ldr	x3, [x0, #8]
    48014da0:	d2804002 	mov	x2, #0x200                 	// #512
    48014da4:	52800061 	mov	w1, #0x3                   	// #3
    48014da8:	f9402be0 	ldr	x0, [sp, #80]
    48014dac:	d63f0060 	blr	x3
            }
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
    48014db0:	f9400fe0 	ldr	x0, [sp, #24]
    48014db4:	79404c00 	ldrh	w0, [x0, #38]
    48014db8:	32170000 	orr	w0, w0, #0x200
    48014dbc:	12003c01 	and	w1, w0, #0xffff
    48014dc0:	f9400fe0 	ldr	x0, [sp, #24]
    48014dc4:	79004c01 	strh	w1, [x0, #38]
    48014dc8:	14000019 	b	48014e2c <rt_serial_open+0x3d4>
        }
#endif /* RT_SERIAL_USING_DMA */
        else
        {
            serial->serial_rx = RT_NULL;
    48014dcc:	f9402be0 	ldr	x0, [sp, #80]
    48014dd0:	f900541f 	str	xzr, [x0, #168]
    48014dd4:	14000016 	b	48014e2c <rt_serial_open+0x3d4>
        }
    }
    else
    {
        if (oflag & RT_DEVICE_FLAG_INT_RX)
    48014dd8:	79402fe0 	ldrh	w0, [sp, #22]
    48014ddc:	12180000 	and	w0, w0, #0x100
    48014de0:	7100001f 	cmp	w0, #0x0
    48014de4:	54000100 	b.eq	48014e04 <rt_serial_open+0x3ac>  // b.none
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
    48014de8:	f9400fe0 	ldr	x0, [sp, #24]
    48014dec:	79404c00 	ldrh	w0, [x0, #38]
    48014df0:	32180000 	orr	w0, w0, #0x100
    48014df4:	12003c01 	and	w1, w0, #0xffff
    48014df8:	f9400fe0 	ldr	x0, [sp, #24]
    48014dfc:	79004c01 	strh	w1, [x0, #38]
    48014e00:	1400000b 	b	48014e2c <rt_serial_open+0x3d4>
#ifdef RT_SERIAL_USING_DMA
        else if (oflag & RT_DEVICE_FLAG_DMA_RX)
    48014e04:	79402fe0 	ldrh	w0, [sp, #22]
    48014e08:	12170000 	and	w0, w0, #0x200
    48014e0c:	7100001f 	cmp	w0, #0x0
    48014e10:	540000e0 	b.eq	48014e2c <rt_serial_open+0x3d4>  // b.none
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
    48014e14:	f9400fe0 	ldr	x0, [sp, #24]
    48014e18:	79404c00 	ldrh	w0, [x0, #38]
    48014e1c:	32170000 	orr	w0, w0, #0x200
    48014e20:	12003c01 	and	w1, w0, #0xffff
    48014e24:	f9400fe0 	ldr	x0, [sp, #24]
    48014e28:	79004c01 	strh	w1, [x0, #38]
#endif /* RT_SERIAL_USING_DMA */
    }

    if (serial->serial_tx == RT_NULL)
    48014e2c:	f9402be0 	ldr	x0, [sp, #80]
    48014e30:	f9405800 	ldr	x0, [x0, #176]
    48014e34:	f100001f 	cmp	x0, #0x0
    48014e38:	54000a01 	b.ne	48014f78 <rt_serial_open+0x520>  // b.any
    {
        if (oflag & RT_DEVICE_FLAG_INT_TX)
    48014e3c:	79402fe0 	ldrh	w0, [sp, #22]
    48014e40:	12160000 	and	w0, w0, #0x400
    48014e44:	7100001f 	cmp	w0, #0x0
    48014e48:	54000400 	b.eq	48014ec8 <rt_serial_open+0x470>  // b.none
        {
            struct rt_serial_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
    48014e4c:	d2800300 	mov	x0, #0x18                  	// #24
    48014e50:	97ffd34e 	bl	48009b88 <rt_malloc>
    48014e54:	f90017e0 	str	x0, [sp, #40]
            RT_ASSERT(tx_fifo != RT_NULL);
    48014e58:	f94017e0 	ldr	x0, [sp, #40]
    48014e5c:	f100001f 	cmp	x0, #0x0
    48014e60:	540000e1 	b.ne	48014e7c <rt_serial_open+0x424>  // b.any
    48014e64:	d2805642 	mov	x2, #0x2b2                 	// #690
    48014e68:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014e6c:	91150001 	add	x1, x0, #0x540
    48014e70:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014e74:	9110a000 	add	x0, x0, #0x428
    48014e78:	97ffec7c 	bl	48010068 <rt_assert_handler>

            rt_completion_init(&(tx_fifo->completion));
    48014e7c:	f94017e0 	ldr	x0, [sp, #40]
    48014e80:	94000849 	bl	48016fa4 <rt_completion_init>
            serial->serial_tx = tx_fifo;
    48014e84:	f9402be0 	ldr	x0, [sp, #80]
    48014e88:	f94017e1 	ldr	x1, [sp, #40]
    48014e8c:	f9005801 	str	x1, [x0, #176]

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
    48014e90:	f9400fe0 	ldr	x0, [sp, #24]
    48014e94:	79404c00 	ldrh	w0, [x0, #38]
    48014e98:	32160000 	orr	w0, w0, #0x400
    48014e9c:	12003c01 	and	w1, w0, #0xffff
    48014ea0:	f9400fe0 	ldr	x0, [sp, #24]
    48014ea4:	79004c01 	strh	w1, [x0, #38]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
    48014ea8:	f9402be0 	ldr	x0, [sp, #80]
    48014eac:	f9404c00 	ldr	x0, [x0, #152]
    48014eb0:	f9400403 	ldr	x3, [x0, #8]
    48014eb4:	d2808002 	mov	x2, #0x400                 	// #1024
    48014eb8:	52800201 	mov	w1, #0x10                  	// #16
    48014ebc:	f9402be0 	ldr	x0, [sp, #80]
    48014ec0:	d63f0060 	blr	x3
    48014ec4:	14000042 	b	48014fcc <rt_serial_open+0x574>
        }
#ifdef RT_SERIAL_USING_DMA
        else if (oflag & RT_DEVICE_FLAG_DMA_TX)
    48014ec8:	79402fe0 	ldrh	w0, [sp, #22]
    48014ecc:	12150000 	and	w0, w0, #0x800
    48014ed0:	7100001f 	cmp	w0, #0x0
    48014ed4:	540004c0 	b.eq	48014f6c <rt_serial_open+0x514>  // b.none
        {
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
    48014ed8:	d2800900 	mov	x0, #0x48                  	// #72
    48014edc:	97ffd32b 	bl	48009b88 <rt_malloc>
    48014ee0:	f9001be0 	str	x0, [sp, #48]
            RT_ASSERT(tx_dma != RT_NULL);
    48014ee4:	f9401be0 	ldr	x0, [sp, #48]
    48014ee8:	f100001f 	cmp	x0, #0x0
    48014eec:	540000e1 	b.ne	48014f08 <rt_serial_open+0x4b0>  // b.any
    48014ef0:	d2805822 	mov	x2, #0x2c1                 	// #705
    48014ef4:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014ef8:	91150001 	add	x1, x0, #0x540
    48014efc:	90000060 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48014f00:	91110000 	add	x0, x0, #0x440
    48014f04:	97ffec59 	bl	48010068 <rt_assert_handler>
            tx_dma->activated = RT_FALSE;
    48014f08:	f9401be0 	ldr	x0, [sp, #48]
    48014f0c:	b900001f 	str	wzr, [x0]

            rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
    48014f10:	f9401be0 	ldr	x0, [sp, #48]
    48014f14:	91002000 	add	x0, x0, #0x8
    48014f18:	d2800003 	mov	x3, #0x0                   	// #0
    48014f1c:	52800082 	mov	w2, #0x4                   	// #4
    48014f20:	52800101 	mov	w1, #0x8                   	// #8
    48014f24:	940004ef 	bl	480162e0 <rt_data_queue_init>
            serial->serial_tx = tx_dma;
    48014f28:	f9402be0 	ldr	x0, [sp, #80]
    48014f2c:	f9401be1 	ldr	x1, [sp, #48]
    48014f30:	f9005801 	str	x1, [x0, #176]

            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
    48014f34:	f9400fe0 	ldr	x0, [sp, #24]
    48014f38:	79404c00 	ldrh	w0, [x0, #38]
    48014f3c:	32150000 	orr	w0, w0, #0x800
    48014f40:	12003c01 	and	w1, w0, #0xffff
    48014f44:	f9400fe0 	ldr	x0, [sp, #24]
    48014f48:	79004c01 	strh	w1, [x0, #38]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_CONFIG, (void *)RT_DEVICE_FLAG_DMA_TX);
    48014f4c:	f9402be0 	ldr	x0, [sp, #80]
    48014f50:	f9404c00 	ldr	x0, [x0, #152]
    48014f54:	f9400403 	ldr	x3, [x0, #8]
    48014f58:	d2810002 	mov	x2, #0x800                 	// #2048
    48014f5c:	52800061 	mov	w1, #0x3                   	// #3
    48014f60:	f9402be0 	ldr	x0, [sp, #80]
    48014f64:	d63f0060 	blr	x3
    48014f68:	14000019 	b	48014fcc <rt_serial_open+0x574>
        }
#endif /* RT_SERIAL_USING_DMA */
        else
        {
            serial->serial_tx = RT_NULL;
    48014f6c:	f9402be0 	ldr	x0, [sp, #80]
    48014f70:	f900581f 	str	xzr, [x0, #176]
    48014f74:	14000016 	b	48014fcc <rt_serial_open+0x574>
        }
    }
    else
    {
        if (oflag & RT_DEVICE_FLAG_INT_TX)
    48014f78:	79402fe0 	ldrh	w0, [sp, #22]
    48014f7c:	12160000 	and	w0, w0, #0x400
    48014f80:	7100001f 	cmp	w0, #0x0
    48014f84:	54000100 	b.eq	48014fa4 <rt_serial_open+0x54c>  // b.none
            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
    48014f88:	f9400fe0 	ldr	x0, [sp, #24]
    48014f8c:	79404c00 	ldrh	w0, [x0, #38]
    48014f90:	32160000 	orr	w0, w0, #0x400
    48014f94:	12003c01 	and	w1, w0, #0xffff
    48014f98:	f9400fe0 	ldr	x0, [sp, #24]
    48014f9c:	79004c01 	strh	w1, [x0, #38]
    48014fa0:	1400000b 	b	48014fcc <rt_serial_open+0x574>
#ifdef RT_SERIAL_USING_DMA
        else if (oflag & RT_DEVICE_FLAG_DMA_TX)
    48014fa4:	79402fe0 	ldrh	w0, [sp, #22]
    48014fa8:	12150000 	and	w0, w0, #0x800
    48014fac:	7100001f 	cmp	w0, #0x0
    48014fb0:	540000e0 	b.eq	48014fcc <rt_serial_open+0x574>  // b.none
            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
    48014fb4:	f9400fe0 	ldr	x0, [sp, #24]
    48014fb8:	79404c00 	ldrh	w0, [x0, #38]
    48014fbc:	32150000 	orr	w0, w0, #0x800
    48014fc0:	12003c01 	and	w1, w0, #0xffff
    48014fc4:	f9400fe0 	ldr	x0, [sp, #24]
    48014fc8:	79004c01 	strh	w1, [x0, #38]
#endif /* RT_SERIAL_USING_DMA */
    }

    /* set stream flag */
    dev->open_flag |= stream_flag;
    48014fcc:	f9400fe0 	ldr	x0, [sp, #24]
    48014fd0:	79404c01 	ldrh	w1, [x0, #38]
    48014fd4:	7940bfe0 	ldrh	w0, [sp, #94]
    48014fd8:	2a000020 	orr	w0, w1, w0
    48014fdc:	12003c01 	and	w1, w0, #0xffff
    48014fe0:	f9400fe0 	ldr	x0, [sp, #24]
    48014fe4:	79004c01 	strh	w1, [x0, #38]

    return RT_EOK;
    48014fe8:	d2800000 	mov	x0, #0x0                   	// #0
}
    48014fec:	a8c67bfd 	ldp	x29, x30, [sp], #96
    48014ff0:	d65f03c0 	ret

0000000048014ff4 <rt_serial_close>:

static rt_err_t rt_serial_close(struct rt_device *dev)
{
    48014ff4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48014ff8:	910003fd 	mov	x29, sp
    48014ffc:	f9000fe0 	str	x0, [sp, #24]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
    48015000:	f9400fe0 	ldr	x0, [sp, #24]
    48015004:	f100001f 	cmp	x0, #0x0
    48015008:	540000e1 	b.ne	48015024 <rt_serial_close+0x30>  // b.any
    4801500c:	d2805ca2 	mov	x2, #0x2e5                 	// #741
    48015010:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015014:	91154001 	add	x1, x0, #0x550
    48015018:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801501c:	91106000 	add	x0, x0, #0x418
    48015020:	97ffec12 	bl	48010068 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
    48015024:	f9400fe0 	ldr	x0, [sp, #24]
    48015028:	f90027e0 	str	x0, [sp, #72]

    /* this device has more reference count */
    if (dev->ref_count > 1) return RT_EOK;
    4801502c:	f9400fe0 	ldr	x0, [sp, #24]
    48015030:	3940a000 	ldrb	w0, [x0, #40]
    48015034:	7100041f 	cmp	w0, #0x1
    48015038:	54000069 	b.ls	48015044 <rt_serial_close+0x50>  // b.plast
    4801503c:	d2800000 	mov	x0, #0x0                   	// #0
    48015040:	140000b0 	b	48015300 <rt_serial_close+0x30c>

    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
    48015044:	f9400fe0 	ldr	x0, [sp, #24]
    48015048:	79404c00 	ldrh	w0, [x0, #38]
    4801504c:	12180000 	and	w0, w0, #0x100
    48015050:	7100001f 	cmp	w0, #0x0
    48015054:	540003e0 	b.eq	480150d0 <rt_serial_close+0xdc>  // b.none
    {
        struct rt_serial_rx_fifo* rx_fifo;

        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_RX);
    48015058:	f94027e0 	ldr	x0, [sp, #72]
    4801505c:	f9404c00 	ldr	x0, [x0, #152]
    48015060:	f9400403 	ldr	x3, [x0, #8]
    48015064:	d2802002 	mov	x2, #0x100                 	// #256
    48015068:	52800221 	mov	w1, #0x11                  	// #17
    4801506c:	f94027e0 	ldr	x0, [sp, #72]
    48015070:	d63f0060 	blr	x3
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
    48015074:	f9400fe0 	ldr	x0, [sp, #24]
    48015078:	79404c00 	ldrh	w0, [x0, #38]
    4801507c:	12177800 	and	w0, w0, #0xfffffeff
    48015080:	12003c01 	and	w1, w0, #0xffff
    48015084:	f9400fe0 	ldr	x0, [sp, #24]
    48015088:	79004c01 	strh	w1, [x0, #38]

        rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
    4801508c:	f94027e0 	ldr	x0, [sp, #72]
    48015090:	f9405400 	ldr	x0, [x0, #168]
    48015094:	f9001be0 	str	x0, [sp, #48]
        RT_ASSERT(rx_fifo != RT_NULL);
    48015098:	f9401be0 	ldr	x0, [sp, #48]
    4801509c:	f100001f 	cmp	x0, #0x0
    480150a0:	540000e1 	b.ne	480150bc <rt_serial_close+0xc8>  // b.any
    480150a4:	d2805e82 	mov	x2, #0x2f4                 	// #756
    480150a8:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480150ac:	91154001 	add	x1, x0, #0x550
    480150b0:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480150b4:	910b8000 	add	x0, x0, #0x2e0
    480150b8:	97ffebec 	bl	48010068 <rt_assert_handler>

        rt_free(rx_fifo);
    480150bc:	f9401be0 	ldr	x0, [sp, #48]
    480150c0:	97ffd4c1 	bl	4800a3c4 <rt_free>
        serial->serial_rx = RT_NULL;
    480150c4:	f94027e0 	ldr	x0, [sp, #72]
    480150c8:	f900541f 	str	xzr, [x0, #168]
    480150cc:	14000037 	b	480151a8 <rt_serial_close+0x1b4>

    }
#ifdef RT_SERIAL_USING_DMA
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
    480150d0:	f9400fe0 	ldr	x0, [sp, #24]
    480150d4:	79404c00 	ldrh	w0, [x0, #38]
    480150d8:	12170000 	and	w0, w0, #0x200
    480150dc:	7100001f 	cmp	w0, #0x0
    480150e0:	54000640 	b.eq	480151a8 <rt_serial_close+0x1b4>  // b.none
    {
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void *) RT_DEVICE_FLAG_DMA_RX);
    480150e4:	f94027e0 	ldr	x0, [sp, #72]
    480150e8:	f9404c00 	ldr	x0, [x0, #152]
    480150ec:	f9400403 	ldr	x3, [x0, #8]
    480150f0:	d2804002 	mov	x2, #0x200                 	// #512
    480150f4:	52800221 	mov	w1, #0x11                  	// #17
    480150f8:	f94027e0 	ldr	x0, [sp, #72]
    480150fc:	d63f0060 	blr	x3
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
    48015100:	f9400fe0 	ldr	x0, [sp, #24]
    48015104:	79404c00 	ldrh	w0, [x0, #38]
    48015108:	12167800 	and	w0, w0, #0xfffffdff
    4801510c:	12003c01 	and	w1, w0, #0xffff
    48015110:	f9400fe0 	ldr	x0, [sp, #24]
    48015114:	79004c01 	strh	w1, [x0, #38]

        if (serial->config.bufsz == 0)
    48015118:	f94027e0 	ldr	x0, [sp, #72]
    4801511c:	b940a400 	ldr	w0, [x0, #164]
    48015120:	12163c00 	and	w0, w0, #0x3fffc00
    48015124:	7100001f 	cmp	w0, #0x0
    48015128:	54000201 	b.ne	48015168 <rt_serial_close+0x174>  // b.any
        {
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
    4801512c:	f94027e0 	ldr	x0, [sp, #72]
    48015130:	f9405400 	ldr	x0, [x0, #168]
    48015134:	f9001fe0 	str	x0, [sp, #56]
            RT_ASSERT(rx_dma != RT_NULL);
    48015138:	f9401fe0 	ldr	x0, [sp, #56]
    4801513c:	f100001f 	cmp	x0, #0x0
    48015140:	540000e1 	b.ne	4801515c <rt_serial_close+0x168>  // b.any
    48015144:	d28060c2 	mov	x2, #0x306                 	// #774
    48015148:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801514c:	91154001 	add	x1, x0, #0x550
    48015150:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015154:	910f6000 	add	x0, x0, #0x3d8
    48015158:	97ffebc4 	bl	48010068 <rt_assert_handler>

            rt_free(rx_dma);
    4801515c:	f9401fe0 	ldr	x0, [sp, #56]
    48015160:	97ffd499 	bl	4800a3c4 <rt_free>
    48015164:	1400000f 	b	480151a0 <rt_serial_close+0x1ac>
        }
        else
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
    48015168:	f94027e0 	ldr	x0, [sp, #72]
    4801516c:	f9405400 	ldr	x0, [x0, #168]
    48015170:	f90023e0 	str	x0, [sp, #64]
            RT_ASSERT(rx_fifo != RT_NULL);
    48015174:	f94023e0 	ldr	x0, [sp, #64]
    48015178:	f100001f 	cmp	x0, #0x0
    4801517c:	540000e1 	b.ne	48015198 <rt_serial_close+0x1a4>  // b.any
    48015180:	d28061e2 	mov	x2, #0x30f                 	// #783
    48015184:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015188:	91154001 	add	x1, x0, #0x550
    4801518c:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015190:	910b8000 	add	x0, x0, #0x2e0
    48015194:	97ffebb5 	bl	48010068 <rt_assert_handler>

            rt_free(rx_fifo);
    48015198:	f94023e0 	ldr	x0, [sp, #64]
    4801519c:	97ffd48a 	bl	4800a3c4 <rt_free>
        }
        serial->serial_rx = RT_NULL;
    480151a0:	f94027e0 	ldr	x0, [sp, #72]
    480151a4:	f900541f 	str	xzr, [x0, #168]

    }
#endif /* RT_SERIAL_USING_DMA */

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
    480151a8:	f9400fe0 	ldr	x0, [sp, #24]
    480151ac:	79404c00 	ldrh	w0, [x0, #38]
    480151b0:	12160000 	and	w0, w0, #0x400
    480151b4:	7100001f 	cmp	w0, #0x0
    480151b8:	540003e0 	b.eq	48015234 <rt_serial_close+0x240>  // b.none
    {
        struct rt_serial_tx_fifo* tx_fifo;

        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
    480151bc:	f94027e0 	ldr	x0, [sp, #72]
    480151c0:	f9404c00 	ldr	x0, [x0, #152]
    480151c4:	f9400403 	ldr	x3, [x0, #8]
    480151c8:	d2808002 	mov	x2, #0x400                 	// #1024
    480151cc:	52800221 	mov	w1, #0x11                  	// #17
    480151d0:	f94027e0 	ldr	x0, [sp, #72]
    480151d4:	d63f0060 	blr	x3
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
    480151d8:	f9400fe0 	ldr	x0, [sp, #24]
    480151dc:	79404c00 	ldrh	w0, [x0, #38]
    480151e0:	12157800 	and	w0, w0, #0xfffffbff
    480151e4:	12003c01 	and	w1, w0, #0xffff
    480151e8:	f9400fe0 	ldr	x0, [sp, #24]
    480151ec:	79004c01 	strh	w1, [x0, #38]

        tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
    480151f0:	f94027e0 	ldr	x0, [sp, #72]
    480151f4:	f9405800 	ldr	x0, [x0, #176]
    480151f8:	f90013e0 	str	x0, [sp, #32]
        RT_ASSERT(tx_fifo != RT_NULL);
    480151fc:	f94013e0 	ldr	x0, [sp, #32]
    48015200:	f100001f 	cmp	x0, #0x0
    48015204:	540000e1 	b.ne	48015220 <rt_serial_close+0x22c>  // b.any
    48015208:	d2806402 	mov	x2, #0x320                 	// #800
    4801520c:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015210:	91154001 	add	x1, x0, #0x550
    48015214:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015218:	9110a000 	add	x0, x0, #0x428
    4801521c:	97ffeb93 	bl	48010068 <rt_assert_handler>

        rt_free(tx_fifo);
    48015220:	f94013e0 	ldr	x0, [sp, #32]
    48015224:	97ffd468 	bl	4800a3c4 <rt_free>
        serial->serial_tx = RT_NULL;
    48015228:	f94027e0 	ldr	x0, [sp, #72]
    4801522c:	f900581f 	str	xzr, [x0, #176]
    48015230:	14000026 	b	480152c8 <rt_serial_close+0x2d4>

        /* configure low level device */
    }
#ifdef RT_SERIAL_USING_DMA
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
    48015234:	f9400fe0 	ldr	x0, [sp, #24]
    48015238:	79404c00 	ldrh	w0, [x0, #38]
    4801523c:	12150000 	and	w0, w0, #0x800
    48015240:	7100001f 	cmp	w0, #0x0
    48015244:	54000420 	b.eq	480152c8 <rt_serial_close+0x2d4>  // b.none
    {
        struct rt_serial_tx_dma* tx_dma;

        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void *) RT_DEVICE_FLAG_DMA_TX);
    48015248:	f94027e0 	ldr	x0, [sp, #72]
    4801524c:	f9404c00 	ldr	x0, [x0, #152]
    48015250:	f9400403 	ldr	x3, [x0, #8]
    48015254:	d2810002 	mov	x2, #0x800                 	// #2048
    48015258:	52800221 	mov	w1, #0x11                  	// #17
    4801525c:	f94027e0 	ldr	x0, [sp, #72]
    48015260:	d63f0060 	blr	x3
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
    48015264:	f9400fe0 	ldr	x0, [sp, #24]
    48015268:	79404c00 	ldrh	w0, [x0, #38]
    4801526c:	12147800 	and	w0, w0, #0xfffff7ff
    48015270:	12003c01 	and	w1, w0, #0xffff
    48015274:	f9400fe0 	ldr	x0, [sp, #24]
    48015278:	79004c01 	strh	w1, [x0, #38]

        tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
    4801527c:	f94027e0 	ldr	x0, [sp, #72]
    48015280:	f9405800 	ldr	x0, [x0, #176]
    48015284:	f90017e0 	str	x0, [sp, #40]
        RT_ASSERT(tx_dma != RT_NULL);
    48015288:	f94017e0 	ldr	x0, [sp, #40]
    4801528c:	f100001f 	cmp	x0, #0x0
    48015290:	540000e1 	b.ne	480152ac <rt_serial_close+0x2b8>  // b.any
    48015294:	d2806622 	mov	x2, #0x331                 	// #817
    48015298:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801529c:	91154001 	add	x1, x0, #0x550
    480152a0:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480152a4:	91110000 	add	x0, x0, #0x440
    480152a8:	97ffeb70 	bl	48010068 <rt_assert_handler>

        rt_data_queue_deinit(&(tx_dma->data_queue));
    480152ac:	f94017e0 	ldr	x0, [sp, #40]
    480152b0:	91002000 	add	x0, x0, #0x8
    480152b4:	940006a0 	bl	48016d34 <rt_data_queue_deinit>

        rt_free(tx_dma);
    480152b8:	f94017e0 	ldr	x0, [sp, #40]
    480152bc:	97ffd442 	bl	4800a3c4 <rt_free>
        serial->serial_tx = RT_NULL;
    480152c0:	f94027e0 	ldr	x0, [sp, #72]
    480152c4:	f900581f 	str	xzr, [x0, #176]

    }
#endif /* RT_SERIAL_USING_DMA */

    serial->ops->control(serial, RT_DEVICE_CTRL_CLOSE, RT_NULL);
    480152c8:	f94027e0 	ldr	x0, [sp, #72]
    480152cc:	f9404c00 	ldr	x0, [x0, #152]
    480152d0:	f9400403 	ldr	x3, [x0, #8]
    480152d4:	d2800002 	mov	x2, #0x0                   	// #0
    480152d8:	52800081 	mov	w1, #0x4                   	// #4
    480152dc:	f94027e0 	ldr	x0, [sp, #72]
    480152e0:	d63f0060 	blr	x3
    dev->flag &= ~RT_DEVICE_FLAG_ACTIVATED;
    480152e4:	f9400fe0 	ldr	x0, [sp, #24]
    480152e8:	79404800 	ldrh	w0, [x0, #36]
    480152ec:	121b7800 	and	w0, w0, #0xffffffef
    480152f0:	12003c01 	and	w1, w0, #0xffff
    480152f4:	f9400fe0 	ldr	x0, [sp, #24]
    480152f8:	79004801 	strh	w1, [x0, #36]

    return RT_EOK;
    480152fc:	d2800000 	mov	x0, #0x0                   	// #0
}
    48015300:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48015304:	d65f03c0 	ret

0000000048015308 <rt_serial_read>:

static rt_size_t rt_serial_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
    48015308:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801530c:	910003fd 	mov	x29, sp
    48015310:	f90017e0 	str	x0, [sp, #40]
    48015314:	f90013e1 	str	x1, [sp, #32]
    48015318:	f9000fe2 	str	x2, [sp, #24]
    4801531c:	f9000be3 	str	x3, [sp, #16]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
    48015320:	f94017e0 	ldr	x0, [sp, #40]
    48015324:	f100001f 	cmp	x0, #0x0
    48015328:	540000e1 	b.ne	48015344 <rt_serial_read+0x3c>  // b.any
    4801532c:	d2806902 	mov	x2, #0x348                 	// #840
    48015330:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015334:	91158001 	add	x1, x0, #0x560
    48015338:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801533c:	91106000 	add	x0, x0, #0x418
    48015340:	97ffeb4a 	bl	48010068 <rt_assert_handler>
    if (size == 0) return 0;
    48015344:	f9400be0 	ldr	x0, [sp, #16]
    48015348:	f100001f 	cmp	x0, #0x0
    4801534c:	54000061 	b.ne	48015358 <rt_serial_read+0x50>  // b.any
    48015350:	d2800000 	mov	x0, #0x0                   	// #0
    48015354:	14000021 	b	480153d8 <rt_serial_read+0xd0>

    serial = (struct rt_serial_device *)dev;
    48015358:	f94017e0 	ldr	x0, [sp, #40]
    4801535c:	f9001fe0 	str	x0, [sp, #56]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
    48015360:	f94017e0 	ldr	x0, [sp, #40]
    48015364:	79404c00 	ldrh	w0, [x0, #38]
    48015368:	12180000 	and	w0, w0, #0x100
    4801536c:	7100001f 	cmp	w0, #0x0
    48015370:	54000100 	b.eq	48015390 <rt_serial_read+0x88>  // b.none
    {
        return _serial_int_rx(serial, (rt_uint8_t *)buffer, size);
    48015374:	f9400be0 	ldr	x0, [sp, #16]
    48015378:	2a0003e2 	mov	w2, w0
    4801537c:	f9400fe1 	ldr	x1, [sp, #24]
    48015380:	f9401fe0 	ldr	x0, [sp, #56]
    48015384:	97fffaf2 	bl	48013f4c <_serial_int_rx>
    48015388:	93407c00 	sxtw	x0, w0
    4801538c:	14000013 	b	480153d8 <rt_serial_read+0xd0>
    }
#ifdef RT_SERIAL_USING_DMA
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
    48015390:	f94017e0 	ldr	x0, [sp, #40]
    48015394:	79404c00 	ldrh	w0, [x0, #38]
    48015398:	12170000 	and	w0, w0, #0x200
    4801539c:	7100001f 	cmp	w0, #0x0
    480153a0:	54000100 	b.eq	480153c0 <rt_serial_read+0xb8>  // b.none
    {
        return _serial_dma_rx(serial, (rt_uint8_t *)buffer, size);
    480153a4:	f9400be0 	ldr	x0, [sp, #16]
    480153a8:	2a0003e2 	mov	w2, w0
    480153ac:	f9400fe1 	ldr	x1, [sp, #24]
    480153b0:	f9401fe0 	ldr	x0, [sp, #56]
    480153b4:	97fffc9f 	bl	48014630 <_serial_dma_rx>
    480153b8:	93407c00 	sxtw	x0, w0
    480153bc:	14000007 	b	480153d8 <rt_serial_read+0xd0>
    }
#endif /* RT_SERIAL_USING_DMA */

    return _serial_poll_rx(serial, (rt_uint8_t *)buffer, size);
    480153c0:	f9400be0 	ldr	x0, [sp, #16]
    480153c4:	2a0003e2 	mov	w2, w0
    480153c8:	f9400fe1 	ldr	x1, [sp, #24]
    480153cc:	f9401fe0 	ldr	x0, [sp, #56]
    480153d0:	97fffa71 	bl	48013d94 <_serial_poll_rx>
    480153d4:	93407c00 	sxtw	x0, w0
}
    480153d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480153dc:	d65f03c0 	ret

00000000480153e0 <rt_serial_write>:

static rt_size_t rt_serial_write(struct rt_device *dev,
                                 rt_off_t          pos,
                                 const void       *buffer,
                                 rt_size_t         size)
{
    480153e0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480153e4:	910003fd 	mov	x29, sp
    480153e8:	f90017e0 	str	x0, [sp, #40]
    480153ec:	f90013e1 	str	x1, [sp, #32]
    480153f0:	f9000fe2 	str	x2, [sp, #24]
    480153f4:	f9000be3 	str	x3, [sp, #16]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
    480153f8:	f94017e0 	ldr	x0, [sp, #40]
    480153fc:	f100001f 	cmp	x0, #0x0
    48015400:	540000e1 	b.ne	4801541c <rt_serial_write+0x3c>  // b.any
    48015404:	d2806c42 	mov	x2, #0x362                 	// #866
    48015408:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801540c:	91168001 	add	x1, x0, #0x5a0
    48015410:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015414:	91106000 	add	x0, x0, #0x418
    48015418:	97ffeb14 	bl	48010068 <rt_assert_handler>
    if (size == 0) return 0;
    4801541c:	f9400be0 	ldr	x0, [sp, #16]
    48015420:	f100001f 	cmp	x0, #0x0
    48015424:	54000061 	b.ne	48015430 <rt_serial_write+0x50>  // b.any
    48015428:	d2800000 	mov	x0, #0x0                   	// #0
    4801542c:	14000021 	b	480154b0 <rt_serial_write+0xd0>

    serial = (struct rt_serial_device *)dev;
    48015430:	f94017e0 	ldr	x0, [sp, #40]
    48015434:	f9001fe0 	str	x0, [sp, #56]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
    48015438:	f94017e0 	ldr	x0, [sp, #40]
    4801543c:	79404c00 	ldrh	w0, [x0, #38]
    48015440:	12160000 	and	w0, w0, #0x400
    48015444:	7100001f 	cmp	w0, #0x0
    48015448:	54000100 	b.eq	48015468 <rt_serial_write+0x88>  // b.none
    {
        return _serial_int_tx(serial, (const rt_uint8_t *)buffer, size);
    4801544c:	f9400be0 	ldr	x0, [sp, #16]
    48015450:	2a0003e2 	mov	w2, w0
    48015454:	f9400fe1 	ldr	x1, [sp, #24]
    48015458:	f9401fe0 	ldr	x0, [sp, #56]
    4801545c:	97fffb1a 	bl	480140c4 <_serial_int_tx>
    48015460:	93407c00 	sxtw	x0, w0
    48015464:	14000013 	b	480154b0 <rt_serial_write+0xd0>
    }
#ifdef RT_SERIAL_USING_DMA
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
    48015468:	f94017e0 	ldr	x0, [sp, #40]
    4801546c:	79404c00 	ldrh	w0, [x0, #38]
    48015470:	12150000 	and	w0, w0, #0x800
    48015474:	7100001f 	cmp	w0, #0x0
    48015478:	54000100 	b.eq	48015498 <rt_serial_write+0xb8>  // b.none
    {
        return _serial_dma_tx(serial, (const rt_uint8_t *)buffer, size);
    4801547c:	f9400be0 	ldr	x0, [sp, #16]
    48015480:	2a0003e2 	mov	w2, w0
    48015484:	f9400fe1 	ldr	x1, [sp, #24]
    48015488:	f9401fe0 	ldr	x0, [sp, #56]
    4801548c:	97fffd1e 	bl	48014904 <_serial_dma_tx>
    48015490:	93407c00 	sxtw	x0, w0
    48015494:	14000007 	b	480154b0 <rt_serial_write+0xd0>
    }
#endif /* RT_SERIAL_USING_DMA */
    else
    {
        return _serial_poll_tx(serial, (const rt_uint8_t *)buffer, size);
    48015498:	f9400be0 	ldr	x0, [sp, #16]
    4801549c:	2a0003e2 	mov	w2, w0
    480154a0:	f9400fe1 	ldr	x1, [sp, #24]
    480154a4:	f9401fe0 	ldr	x0, [sp, #56]
    480154a8:	97fffa73 	bl	48013e74 <_serial_poll_tx>
    480154ac:	93407c00 	sxtw	x0, w0
    }
}
    480154b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    480154b4:	d65f03c0 	ret

00000000480154b8 <rt_serial_control>:
#endif

static rt_err_t rt_serial_control(struct rt_device *dev,
                                  int              cmd,
                                  void             *args)
{
    480154b8:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
    480154bc:	910003fd 	mov	x29, sp
    480154c0:	f9000bf3 	str	x19, [sp, #16]
    480154c4:	f9001fe0 	str	x0, [sp, #56]
    480154c8:	b90037e1 	str	w1, [sp, #52]
    480154cc:	f90017e2 	str	x2, [sp, #40]
    rt_err_t ret = RT_EOK;
    480154d0:	f9005fff 	str	xzr, [sp, #184]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
    480154d4:	f9401fe0 	ldr	x0, [sp, #56]
    480154d8:	f100001f 	cmp	x0, #0x0
    480154dc:	540000e1 	b.ne	480154f8 <rt_serial_control+0x40>  // b.any
    480154e0:	d2807ba2 	mov	x2, #0x3dd                 	// #989
    480154e4:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480154e8:	91174001 	add	x1, x0, #0x5d0
    480154ec:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480154f0:	91106000 	add	x0, x0, #0x418
    480154f4:	97ffeadd 	bl	48010068 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
    480154f8:	f9401fe0 	ldr	x0, [sp, #56]
    480154fc:	f90053e0 	str	x0, [sp, #160]

    switch (cmd)
    48015500:	b94037e1 	ldr	w1, [sp, #52]
    48015504:	528a8280 	mov	w0, #0x5414                	// #21524
    48015508:	6b00003f 	cmp	w1, w0
    4801550c:	54000a80 	b.eq	4801565c <rt_serial_control+0x1a4>  // b.none
    48015510:	b94037e1 	ldr	w1, [sp, #52]
    48015514:	528a8280 	mov	w0, #0x5414                	// #21524
    48015518:	6b00003f 	cmp	w1, w0
    4801551c:	5400206c 	b.gt	48015928 <rt_serial_control+0x470>
    48015520:	b94037e1 	ldr	w1, [sp, #52]
    48015524:	528a8260 	mov	w0, #0x5413                	// #21523
    48015528:	6b00003f 	cmp	w1, w0
    4801552c:	54000b00 	b.eq	4801568c <rt_serial_control+0x1d4>  // b.none
    48015530:	b94037e1 	ldr	w1, [sp, #52]
    48015534:	528a8260 	mov	w0, #0x5413                	// #21523
    48015538:	6b00003f 	cmp	w1, w0
    4801553c:	54001f6c 	b.gt	48015928 <rt_serial_control+0x470>
    48015540:	b94037e0 	ldr	w0, [sp, #52]
    48015544:	71000c1f 	cmp	w0, #0x3
    48015548:	54000420 	b.eq	480155cc <rt_serial_control+0x114>  // b.none
    4801554c:	b94037e0 	ldr	w0, [sp, #52]
    48015550:	71000c1f 	cmp	w0, #0x3
    48015554:	54001eac 	b.gt	48015928 <rt_serial_control+0x470>
    48015558:	b94037e0 	ldr	w0, [sp, #52]
    4801555c:	7100081f 	cmp	w0, #0x2
    48015560:	540001a0 	b.eq	48015594 <rt_serial_control+0xdc>  // b.none
    48015564:	b94037e0 	ldr	w0, [sp, #52]
    48015568:	7100081f 	cmp	w0, #0x2
    4801556c:	54001dec 	b.gt	48015928 <rt_serial_control+0x470>
    48015570:	b94037e1 	ldr	w1, [sp, #52]
    48015574:	528ccfe0 	mov	w0, #0x667f                	// #26239
    48015578:	72b00080 	movk	w0, #0x8004, lsl #16
    4801557c:	6b00003f 	cmp	w1, w0
    48015580:	54001bc0 	b.eq	480158f8 <rt_serial_control+0x440>  // b.none
    48015584:	b94037e0 	ldr	w0, [sp, #52]
    48015588:	7100041f 	cmp	w0, #0x1
    4801558c:	54000120 	b.eq	480155b0 <rt_serial_control+0xf8>  // b.none
    48015590:	140000e6 	b	48015928 <rt_serial_control+0x470>
    {
        case RT_DEVICE_CTRL_SUSPEND:
            /* suspend device */
            dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
    48015594:	f9401fe0 	ldr	x0, [sp, #56]
    48015598:	79404800 	ldrh	w0, [x0, #36]
    4801559c:	321b0000 	orr	w0, w0, #0x20
    480155a0:	12003c01 	and	w1, w0, #0xffff
    480155a4:	f9401fe0 	ldr	x0, [sp, #56]
    480155a8:	79004801 	strh	w1, [x0, #36]
            break;
    480155ac:	140000e9 	b	48015950 <rt_serial_control+0x498>

        case RT_DEVICE_CTRL_RESUME:
            /* resume device */
            dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
    480155b0:	f9401fe0 	ldr	x0, [sp, #56]
    480155b4:	79404800 	ldrh	w0, [x0, #36]
    480155b8:	121a7800 	and	w0, w0, #0xffffffdf
    480155bc:	12003c01 	and	w1, w0, #0xffff
    480155c0:	f9401fe0 	ldr	x0, [sp, #56]
    480155c4:	79004801 	strh	w1, [x0, #36]
            break;
    480155c8:	140000e2 	b	48015950 <rt_serial_control+0x498>

        case RT_DEVICE_CTRL_CONFIG:
            if (args)
    480155cc:	f94017e0 	ldr	x0, [sp, #40]
    480155d0:	f100001f 	cmp	x0, #0x0
    480155d4:	54001bc0 	b.eq	4801594c <rt_serial_control+0x494>  // b.none
            {
                struct serial_configure *pconfig = (struct serial_configure *) args;
    480155d8:	f94017e0 	ldr	x0, [sp, #40]
    480155dc:	f90043e0 	str	x0, [sp, #128]
                if (pconfig->bufsz != serial->config.bufsz && serial->parent.ref_count)
    480155e0:	f94043e0 	ldr	x0, [sp, #128]
    480155e4:	f9400000 	ldr	x0, [x0]
    480155e8:	d36ae400 	ubfx	x0, x0, #42, #16
    480155ec:	12003c01 	and	w1, w0, #0xffff
    480155f0:	f94053e0 	ldr	x0, [sp, #160]
    480155f4:	f9405000 	ldr	x0, [x0, #160]
    480155f8:	d36ae400 	ubfx	x0, x0, #42, #16
    480155fc:	12003c00 	and	w0, w0, #0xffff
    48015600:	6b00003f 	cmp	w1, w0
    48015604:	540000e0 	b.eq	48015620 <rt_serial_control+0x168>  // b.none
    48015608:	f94053e0 	ldr	x0, [sp, #160]
    4801560c:	3940a000 	ldrb	w0, [x0, #40]
    48015610:	7100001f 	cmp	w0, #0x0
    48015614:	54000060 	b.eq	48015620 <rt_serial_control+0x168>  // b.none
                {
                    /*can not change buffer size*/
                    return RT_EBUSY;
    48015618:	d28000e0 	mov	x0, #0x7                   	// #7
    4801561c:	140000ce 	b	48015954 <rt_serial_control+0x49c>
                }
                /* set serial configure */
                serial->config = *pconfig;
    48015620:	f94053e0 	ldr	x0, [sp, #160]
    48015624:	f94043e1 	ldr	x1, [sp, #128]
    48015628:	f9400021 	ldr	x1, [x1]
    4801562c:	f9005001 	str	x1, [x0, #160]
                if (serial->parent.ref_count)
    48015630:	f94053e0 	ldr	x0, [sp, #160]
    48015634:	3940a000 	ldrb	w0, [x0, #40]
    48015638:	7100001f 	cmp	w0, #0x0
    4801563c:	54001880 	b.eq	4801594c <rt_serial_control+0x494>  // b.none
                {
                    /* serial device has been opened, to configure it */
                    serial->ops->configure(serial, (struct serial_configure *) args);
    48015640:	f94053e0 	ldr	x0, [sp, #160]
    48015644:	f9404c00 	ldr	x0, [x0, #152]
    48015648:	f9400002 	ldr	x2, [x0]
    4801564c:	f94017e1 	ldr	x1, [sp, #40]
    48015650:	f94053e0 	ldr	x0, [sp, #160]
    48015654:	d63f0040 	blr	x2
                }
            }

            break;
    48015658:	140000bd 	b	4801594c <rt_serial_control+0x494>
#endif /*RT_USING_POSIX_TERMIOS*/
        case TIOCSWINSZ:
            {
                struct winsize* p_winsize;

                p_winsize = (struct winsize*)args;
    4801565c:	f94017e0 	ldr	x0, [sp, #40]
    48015660:	f9004fe0 	str	x0, [sp, #152]
                rt_kprintf("\x1b[8;%d;%dt", p_winsize->ws_col, p_winsize->ws_row);
    48015664:	f9404fe0 	ldr	x0, [sp, #152]
    48015668:	79400400 	ldrh	w0, [x0, #2]
    4801566c:	2a0003e1 	mov	w1, w0
    48015670:	f9404fe0 	ldr	x0, [sp, #152]
    48015674:	79400000 	ldrh	w0, [x0]
    48015678:	2a0003e2 	mov	w2, w0
    4801567c:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015680:	91116000 	add	x0, x0, #0x458
    48015684:	97ffe9ab 	bl	4800fd30 <rt_kprintf>
            }
            break;
    48015688:	140000b2 	b	48015950 <rt_serial_control+0x498>
        case TIOCGWINSZ:
            {
                struct winsize* p_winsize;
                p_winsize = (struct winsize*)args;
    4801568c:	f94017e0 	ldr	x0, [sp, #40]
    48015690:	f9004be0 	str	x0, [sp, #144]

                if(rt_thread_self() != rt_thread_find("tshell"))
    48015694:	97ffd942 	bl	4800bb9c <rt_thread_self>
    48015698:	aa0003f3 	mov	x19, x0
    4801569c:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480156a0:	9111a000 	add	x0, x0, #0x468
    480156a4:	97ffdc00 	bl	4800c6a4 <rt_thread_find>
    480156a8:	eb00027f 	cmp	x19, x0
    480156ac:	54000100 	b.eq	480156cc <rt_serial_control+0x214>  // b.none
                {
                    /* only can be used in tshell thread; otherwise, return default size */
                    p_winsize->ws_col = 80;
    480156b0:	f9404be0 	ldr	x0, [sp, #144]
    480156b4:	52800a01 	mov	w1, #0x50                  	// #80
    480156b8:	79000401 	strh	w1, [x0, #2]
                    p_winsize->ws_row = 24;
    480156bc:	f9404be0 	ldr	x0, [sp, #144]
    480156c0:	52800301 	mov	w1, #0x18                  	// #24
    480156c4:	79000001 	strh	w1, [x0]
    480156c8:	14000087 	b	480158e4 <rt_serial_control+0x42c>
                    char _tio_buf[_TIO_BUFLEN];
                    unsigned char cnt1, cnt2, cnt3, i;
                    char row_s[4], col_s[4];
                    char *p;

                    rt_memset(_tio_buf, 0, _TIO_BUFLEN);
    480156cc:	910163e0 	add	x0, sp, #0x58
    480156d0:	d2800282 	mov	x2, #0x14                  	// #20
    480156d4:	52800001 	mov	w1, #0x0                   	// #0
    480156d8:	97ffe315 	bl	4800e32c <rt_memset>

                    /* send the command to terminal for getting the window size of the terminal */
                    rt_kprintf("\033[18t");
    480156dc:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480156e0:	9111c000 	add	x0, x0, #0x470
    480156e4:	97ffe993 	bl	4800fd30 <rt_kprintf>

                    /* waiting for the response from the terminal */
                    i = 0;
    480156e8:	3902d7ff 	strb	wzr, [sp, #181]
                    while(i < _TIO_BUFLEN)
    480156ec:	14000011 	b	48015730 <rt_serial_control+0x278>
                    {
                        _tio_buf[i] = getchar();
    480156f0:	94001c24 	bl	4801c780 <getchar>
    480156f4:	2a0003e1 	mov	w1, w0
    480156f8:	3942d7e0 	ldrb	w0, [sp, #181]
    480156fc:	12001c22 	and	w2, w1, #0xff
    48015700:	93407c00 	sxtw	x0, w0
    48015704:	910163e1 	add	x1, sp, #0x58
    48015708:	38206822 	strb	w2, [x1, x0]
                        if(_tio_buf[i] != 't')
    4801570c:	3942d7e0 	ldrb	w0, [sp, #181]
    48015710:	93407c00 	sxtw	x0, w0
    48015714:	910163e1 	add	x1, sp, #0x58
    48015718:	38606820 	ldrb	w0, [x1, x0]
    4801571c:	7101d01f 	cmp	w0, #0x74
    48015720:	54000100 	b.eq	48015740 <rt_serial_control+0x288>  // b.none
                        {
                            i ++;
    48015724:	3942d7e0 	ldrb	w0, [sp, #181]
    48015728:	11000400 	add	w0, w0, #0x1
    4801572c:	3902d7e0 	strb	w0, [sp, #181]
                    while(i < _TIO_BUFLEN)
    48015730:	3942d7e0 	ldrb	w0, [sp, #181]
    48015734:	71004c1f 	cmp	w0, #0x13
    48015738:	54fffdc9 	b.ls	480156f0 <rt_serial_control+0x238>  // b.plast
    4801573c:	14000002 	b	48015744 <rt_serial_control+0x28c>
                        }
                        else
                        {
                            break;
    48015740:	d503201f 	nop
                        }
                    }
                    if(i == _TIO_BUFLEN)
    48015744:	3942d7e0 	ldrb	w0, [sp, #181]
    48015748:	7100501f 	cmp	w0, #0x14
    4801574c:	54000101 	b.ne	4801576c <rt_serial_control+0x2b4>  // b.any
                    {
                        /* buffer overloaded, and return default size */
                        p_winsize->ws_col = 80;
    48015750:	f9404be0 	ldr	x0, [sp, #144]
    48015754:	52800a01 	mov	w1, #0x50                  	// #80
    48015758:	79000401 	strh	w1, [x0, #2]
                        p_winsize->ws_row = 24;
    4801575c:	f9404be0 	ldr	x0, [sp, #144]
    48015760:	52800301 	mov	w1, #0x18                  	// #24
    48015764:	79000001 	strh	w1, [x0]
    48015768:	1400007a 	b	48015950 <rt_serial_control+0x498>
                        break;
                    }

                    /* interpreting data eg: "\033[8;1;15t" which means row is 1 and col is 15 (unit: size of ONE character) */
                    rt_memset(row_s,0,4);
    4801576c:	910143e0 	add	x0, sp, #0x50
    48015770:	d2800082 	mov	x2, #0x4                   	// #4
    48015774:	52800001 	mov	w1, #0x0                   	// #0
    48015778:	97ffe2ed 	bl	4800e32c <rt_memset>
                    rt_memset(col_s,0,4);
    4801577c:	910123e0 	add	x0, sp, #0x48
    48015780:	d2800082 	mov	x2, #0x4                   	// #4
    48015784:	52800001 	mov	w1, #0x0                   	// #0
    48015788:	97ffe2e9 	bl	4800e32c <rt_memset>
                    cnt1 = 0;
    4801578c:	3902dfff 	strb	wzr, [sp, #183]
                    while(_tio_buf[cnt1] != ';' && cnt1 < _TIO_BUFLEN)
    48015790:	14000004 	b	480157a0 <rt_serial_control+0x2e8>
                    {
                        cnt1++;
    48015794:	3942dfe0 	ldrb	w0, [sp, #183]
    48015798:	11000400 	add	w0, w0, #0x1
    4801579c:	3902dfe0 	strb	w0, [sp, #183]
                    while(_tio_buf[cnt1] != ';' && cnt1 < _TIO_BUFLEN)
    480157a0:	3942dfe0 	ldrb	w0, [sp, #183]
    480157a4:	93407c00 	sxtw	x0, w0
    480157a8:	910163e1 	add	x1, sp, #0x58
    480157ac:	38606820 	ldrb	w0, [x1, x0]
    480157b0:	7100ec1f 	cmp	w0, #0x3b
    480157b4:	54000080 	b.eq	480157c4 <rt_serial_control+0x30c>  // b.none
    480157b8:	3942dfe0 	ldrb	w0, [sp, #183]
    480157bc:	71004c1f 	cmp	w0, #0x13
    480157c0:	54fffea9 	b.ls	48015794 <rt_serial_control+0x2dc>  // b.plast
                    }
                    cnt2 = ++cnt1;
    480157c4:	3942dfe0 	ldrb	w0, [sp, #183]
    480157c8:	11000400 	add	w0, w0, #0x1
    480157cc:	3902dfe0 	strb	w0, [sp, #183]
    480157d0:	3942dfe0 	ldrb	w0, [sp, #183]
    480157d4:	3902dbe0 	strb	w0, [sp, #182]
                    while(_tio_buf[cnt2] != ';' && cnt2 < _TIO_BUFLEN)
    480157d8:	14000004 	b	480157e8 <rt_serial_control+0x330>
                    {
                        cnt2++;
    480157dc:	3942dbe0 	ldrb	w0, [sp, #182]
    480157e0:	11000400 	add	w0, w0, #0x1
    480157e4:	3902dbe0 	strb	w0, [sp, #182]
                    while(_tio_buf[cnt2] != ';' && cnt2 < _TIO_BUFLEN)
    480157e8:	3942dbe0 	ldrb	w0, [sp, #182]
    480157ec:	93407c00 	sxtw	x0, w0
    480157f0:	910163e1 	add	x1, sp, #0x58
    480157f4:	38606820 	ldrb	w0, [x1, x0]
    480157f8:	7100ec1f 	cmp	w0, #0x3b
    480157fc:	54000080 	b.eq	4801580c <rt_serial_control+0x354>  // b.none
    48015800:	3942dbe0 	ldrb	w0, [sp, #182]
    48015804:	71004c1f 	cmp	w0, #0x13
    48015808:	54fffea9 	b.ls	480157dc <rt_serial_control+0x324>  // b.plast
                    }
                    p = row_s;
    4801580c:	910143e0 	add	x0, sp, #0x50
    48015810:	f90057e0 	str	x0, [sp, #168]
                    while(cnt1 < cnt2)
    48015814:	1400000c 	b	48015844 <rt_serial_control+0x38c>
                    {
                        *p++ = _tio_buf[cnt1++];
    48015818:	3942dfe0 	ldrb	w0, [sp, #183]
    4801581c:	11000401 	add	w1, w0, #0x1
    48015820:	3902dfe1 	strb	w1, [sp, #183]
    48015824:	2a0003e2 	mov	w2, w0
    48015828:	f94057e0 	ldr	x0, [sp, #168]
    4801582c:	91000401 	add	x1, x0, #0x1
    48015830:	f90057e1 	str	x1, [sp, #168]
    48015834:	93407c41 	sxtw	x1, w2
    48015838:	910163e2 	add	x2, sp, #0x58
    4801583c:	38616841 	ldrb	w1, [x2, x1]
    48015840:	39000001 	strb	w1, [x0]
                    while(cnt1 < cnt2)
    48015844:	3942dfe1 	ldrb	w1, [sp, #183]
    48015848:	3942dbe0 	ldrb	w0, [sp, #182]
    4801584c:	6b00003f 	cmp	w1, w0
    48015850:	54fffe43 	b.cc	48015818 <rt_serial_control+0x360>  // b.lo, b.ul, b.last
                    }
                    p = col_s;
    48015854:	910123e0 	add	x0, sp, #0x48
    48015858:	f90057e0 	str	x0, [sp, #168]
                    cnt2++;
    4801585c:	3942dbe0 	ldrb	w0, [sp, #182]
    48015860:	11000400 	add	w0, w0, #0x1
    48015864:	3902dbe0 	strb	w0, [sp, #182]
                    cnt3 = rt_strlen(_tio_buf) - 1;
    48015868:	910163e0 	add	x0, sp, #0x58
    4801586c:	97ffe482 	bl	4800ea74 <rt_strlen>
    48015870:	12001c00 	and	w0, w0, #0xff
    48015874:	51000400 	sub	w0, w0, #0x1
    48015878:	39023fe0 	strb	w0, [sp, #143]
                    while(cnt2 < cnt3)
    4801587c:	1400000c 	b	480158ac <rt_serial_control+0x3f4>
                    {
                        *p++ = _tio_buf[cnt2++];
    48015880:	3942dbe0 	ldrb	w0, [sp, #182]
    48015884:	11000401 	add	w1, w0, #0x1
    48015888:	3902dbe1 	strb	w1, [sp, #182]
    4801588c:	2a0003e2 	mov	w2, w0
    48015890:	f94057e0 	ldr	x0, [sp, #168]
    48015894:	91000401 	add	x1, x0, #0x1
    48015898:	f90057e1 	str	x1, [sp, #168]
    4801589c:	93407c41 	sxtw	x1, w2
    480158a0:	910163e2 	add	x2, sp, #0x58
    480158a4:	38616841 	ldrb	w1, [x2, x1]
    480158a8:	39000001 	strb	w1, [x0]
                    while(cnt2 < cnt3)
    480158ac:	3942dbe1 	ldrb	w1, [sp, #182]
    480158b0:	39423fe0 	ldrb	w0, [sp, #143]
    480158b4:	6b00003f 	cmp	w1, w0
    480158b8:	54fffe43 	b.cc	48015880 <rt_serial_control+0x3c8>  // b.lo, b.ul, b.last
                    }

                    /* load the window size date */
                    p_winsize->ws_col = atoi(col_s);
    480158bc:	910123e0 	add	x0, sp, #0x48
    480158c0:	94001ba8 	bl	4801c760 <atoi>
    480158c4:	12003c01 	and	w1, w0, #0xffff
    480158c8:	f9404be0 	ldr	x0, [sp, #144]
    480158cc:	79000401 	strh	w1, [x0, #2]
                    p_winsize->ws_row = atoi(row_s);
    480158d0:	910143e0 	add	x0, sp, #0x50
    480158d4:	94001ba3 	bl	4801c760 <atoi>
    480158d8:	12003c01 	and	w1, w0, #0xffff
    480158dc:	f9404be0 	ldr	x0, [sp, #144]
    480158e0:	79000001 	strh	w1, [x0]
                #undef _TIO_BUFLEN
                }

                p_winsize->ws_xpixel = 0;/* unused */
    480158e4:	f9404be0 	ldr	x0, [sp, #144]
    480158e8:	7900081f 	strh	wzr, [x0, #4]
                p_winsize->ws_ypixel = 0;/* unused */
    480158ec:	f9404be0 	ldr	x0, [sp, #144]
    480158f0:	79000c1f 	strh	wzr, [x0, #6]
            }
            break;
    480158f4:	14000017 	b	48015950 <rt_serial_control+0x498>
        case FIONREAD:
            {
                rt_size_t recved = 0;
    480158f8:	f9003fff 	str	xzr, [sp, #120]
                rt_base_t level;

                level = rt_hw_interrupt_disable();
    480158fc:	97ffbacc 	bl	4800442c <rt_hw_interrupt_disable>
    48015900:	f9003be0 	str	x0, [sp, #112]
                recved = _serial_fifo_calc_recved_len(serial);
    48015904:	f94053e0 	ldr	x0, [sp, #160]
    48015908:	97fffa54 	bl	48014258 <_serial_fifo_calc_recved_len>
    4801590c:	f9003fe0 	str	x0, [sp, #120]
                rt_hw_interrupt_enable(level);
    48015910:	f9403be0 	ldr	x0, [sp, #112]
    48015914:	97ffbaca 	bl	4800443c <rt_hw_interrupt_enable>

                *(rt_size_t *)args = recved;
    48015918:	f94017e0 	ldr	x0, [sp, #40]
    4801591c:	f9403fe1 	ldr	x1, [sp, #120]
    48015920:	f9000001 	str	x1, [x0]
            }
            break;
    48015924:	1400000b 	b	48015950 <rt_serial_control+0x498>
#endif /*RT_USING_POSIX*/
        default :
            /* control device */
            ret = serial->ops->control(serial, cmd, args);
    48015928:	f94053e0 	ldr	x0, [sp, #160]
    4801592c:	f9404c00 	ldr	x0, [x0, #152]
    48015930:	f9400403 	ldr	x3, [x0, #8]
    48015934:	f94017e2 	ldr	x2, [sp, #40]
    48015938:	b94037e1 	ldr	w1, [sp, #52]
    4801593c:	f94053e0 	ldr	x0, [sp, #160]
    48015940:	d63f0060 	blr	x3
    48015944:	f9005fe0 	str	x0, [sp, #184]
            break;
    48015948:	14000002 	b	48015950 <rt_serial_control+0x498>
            break;
    4801594c:	d503201f 	nop
    }

    return ret;
    48015950:	f9405fe0 	ldr	x0, [sp, #184]
}
    48015954:	f9400bf3 	ldr	x19, [sp, #16]
    48015958:	a8cc7bfd 	ldp	x29, x30, [sp], #192
    4801595c:	d65f03c0 	ret

0000000048015960 <rt_hw_serial_register>:
 */
rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
    48015960:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48015964:	910003fd 	mov	x29, sp
    48015968:	f90017e0 	str	x0, [sp, #40]
    4801596c:	f90013e1 	str	x1, [sp, #32]
    48015970:	b9001fe2 	str	w2, [sp, #28]
    48015974:	f9000be3 	str	x3, [sp, #16]
    rt_err_t ret;
    struct rt_device *device;
    RT_ASSERT(serial != RT_NULL);
    48015978:	f94017e0 	ldr	x0, [sp, #40]
    4801597c:	f100001f 	cmp	x0, #0x0
    48015980:	540000e1 	b.ne	4801599c <rt_hw_serial_register+0x3c>  // b.any
    48015984:	d2809c42 	mov	x2, #0x4e2                 	// #1250
    48015988:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801598c:	9117a001 	add	x1, x0, #0x5e8
    48015990:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015994:	910b2000 	add	x0, x0, #0x2c8
    48015998:	97ffe9b4 	bl	48010068 <rt_assert_handler>

    device = &(serial->parent);
    4801599c:	f94017e0 	ldr	x0, [sp, #40]
    480159a0:	f9001fe0 	str	x0, [sp, #56]

    device->type        = RT_Device_Class_Char;
    480159a4:	f9401fe0 	ldr	x0, [sp, #56]
    480159a8:	b900201f 	str	wzr, [x0, #32]
    device->rx_indicate = RT_NULL;
    480159ac:	f9401fe0 	ldr	x0, [sp, #56]
    480159b0:	f900181f 	str	xzr, [x0, #48]
    device->tx_complete = RT_NULL;
    480159b4:	f9401fe0 	ldr	x0, [sp, #56]
    480159b8:	f9001c1f 	str	xzr, [x0, #56]

#ifdef RT_USING_DEVICE_OPS
    device->ops         = &serial_ops;
#else
    device->init        = rt_serial_init;
    480159bc:	f9401fe0 	ldr	x0, [sp, #56]
    480159c0:	f0ffffe1 	adrp	x1, 48014000 <_serial_int_rx+0xb4>
    480159c4:	91272021 	add	x1, x1, #0x9c8
    480159c8:	f9002001 	str	x1, [x0, #64]
    device->open        = rt_serial_open;
    480159cc:	f9401fe0 	ldr	x0, [sp, #56]
    480159d0:	f0ffffe1 	adrp	x1, 48014000 <_serial_int_rx+0xb4>
    480159d4:	91296021 	add	x1, x1, #0xa58
    480159d8:	f9002401 	str	x1, [x0, #72]
    device->close       = rt_serial_close;
    480159dc:	f9401fe0 	ldr	x0, [sp, #56]
    480159e0:	f0ffffe1 	adrp	x1, 48014000 <_serial_int_rx+0xb4>
    480159e4:	913fd021 	add	x1, x1, #0xff4
    480159e8:	f9002801 	str	x1, [x0, #80]
    device->read        = rt_serial_read;
    480159ec:	f9401fe0 	ldr	x0, [sp, #56]
    480159f0:	90000001 	adrp	x1, 48015000 <rt_serial_close+0xc>
    480159f4:	910c2021 	add	x1, x1, #0x308
    480159f8:	f9002c01 	str	x1, [x0, #88]
    device->write       = rt_serial_write;
    480159fc:	f9401fe0 	ldr	x0, [sp, #56]
    48015a00:	90000001 	adrp	x1, 48015000 <rt_serial_close+0xc>
    48015a04:	910f8021 	add	x1, x1, #0x3e0
    48015a08:	f9003001 	str	x1, [x0, #96]
    device->control     = rt_serial_control;
    48015a0c:	f9401fe0 	ldr	x0, [sp, #56]
    48015a10:	90000001 	adrp	x1, 48015000 <rt_serial_close+0xc>
    48015a14:	9112e021 	add	x1, x1, #0x4b8
    48015a18:	f9003401 	str	x1, [x0, #104]
#endif
    device->user_data   = data;
    48015a1c:	f9401fe0 	ldr	x0, [sp, #56]
    48015a20:	f9400be1 	ldr	x1, [sp, #16]
    48015a24:	f9004801 	str	x1, [x0, #144]

    /* register a character device */
    ret = rt_device_register(device, name, flag);
    48015a28:	b9401fe0 	ldr	w0, [sp, #28]
    48015a2c:	12003c00 	and	w0, w0, #0xffff
    48015a30:	2a0003e2 	mov	w2, w0
    48015a34:	f94013e1 	ldr	x1, [sp, #32]
    48015a38:	f9401fe0 	ldr	x0, [sp, #56]
    48015a3c:	97ffdb42 	bl	4800c744 <rt_device_register>
    48015a40:	f9001be0 	str	x0, [sp, #48]

#if defined(RT_USING_POSIX)
    /* set fops */
    device->fops        = &_serial_fops;
    48015a44:	f9401fe0 	ldr	x0, [sp, #56]
    48015a48:	f0000041 	adrp	x1, 48020000 <__FUNCTION__.0+0x168>
    48015a4c:	910a0021 	add	x1, x1, #0x280
    48015a50:	f9003801 	str	x1, [x0, #112]
#endif

    return ret;
    48015a54:	f9401be0 	ldr	x0, [sp, #48]
}
    48015a58:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48015a5c:	d65f03c0 	ret

0000000048015a60 <rt_hw_serial_isr>:

/* ISR for serial interrupt */
void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
{
    48015a60:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    48015a64:	910003fd 	mov	x29, sp
    48015a68:	f9000fe0 	str	x0, [sp, #24]
    48015a6c:	b90017e1 	str	w1, [sp, #20]
    switch (event & 0xff)
    48015a70:	b94017e0 	ldr	w0, [sp, #20]
    48015a74:	12001c00 	and	w0, w0, #0xff
    48015a78:	7100101f 	cmp	w0, #0x4
    48015a7c:	540011e0 	b.eq	48015cb8 <rt_hw_serial_isr+0x258>  // b.none
    48015a80:	7100101f 	cmp	w0, #0x4
    48015a84:	54001eec 	b.gt	48015e60 <rt_hw_serial_isr+0x400>
    48015a88:	71000c1f 	cmp	w0, #0x3
    48015a8c:	540016a0 	b.eq	48015d60 <rt_hw_serial_isr+0x300>  // b.none
    48015a90:	71000c1f 	cmp	w0, #0x3
    48015a94:	54001e6c 	b.gt	48015e60 <rt_hw_serial_isr+0x400>
    48015a98:	7100041f 	cmp	w0, #0x1
    48015a9c:	54000080 	b.eq	48015aac <rt_hw_serial_isr+0x4c>  // b.none
    48015aa0:	7100081f 	cmp	w0, #0x2
    48015aa4:	54000fe0 	b.eq	48015ca0 <rt_hw_serial_isr+0x240>  // b.none
            }
            break;
        }
#endif /* RT_SERIAL_USING_DMA */
    }
}
    48015aa8:	140000ee 	b	48015e60 <rt_hw_serial_isr+0x400>
            int ch = -1;
    48015aac:	12800000 	mov	w0, #0xffffffff            	// #-1
    48015ab0:	b90057e0 	str	w0, [sp, #84]
            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
    48015ab4:	f9400fe0 	ldr	x0, [sp, #24]
    48015ab8:	f9405400 	ldr	x0, [x0, #168]
    48015abc:	f90027e0 	str	x0, [sp, #72]
            RT_ASSERT(rx_fifo != RT_NULL);
    48015ac0:	f94027e0 	ldr	x0, [sp, #72]
    48015ac4:	f100001f 	cmp	x0, #0x0
    48015ac8:	540000e1 	b.ne	48015ae4 <rt_hw_serial_isr+0x84>  // b.any
    48015acc:	d280a1c2 	mov	x2, #0x50e                 	// #1294
    48015ad0:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015ad4:	91180001 	add	x1, x0, #0x600
    48015ad8:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015adc:	910b8000 	add	x0, x0, #0x2e0
    48015ae0:	97ffe962 	bl	48010068 <rt_assert_handler>
                ch = serial->ops->getc(serial);
    48015ae4:	f9400fe0 	ldr	x0, [sp, #24]
    48015ae8:	f9404c00 	ldr	x0, [x0, #152]
    48015aec:	f9400c01 	ldr	x1, [x0, #24]
    48015af0:	f9400fe0 	ldr	x0, [sp, #24]
    48015af4:	d63f0020 	blr	x1
    48015af8:	b90057e0 	str	w0, [sp, #84]
                if (ch == -1) break;
    48015afc:	b94057e0 	ldr	w0, [sp, #84]
    48015b00:	3100041f 	cmn	w0, #0x1
    48015b04:	54000720 	b.eq	48015be8 <rt_hw_serial_isr+0x188>  // b.none
                level = rt_hw_interrupt_disable();
    48015b08:	97ffba49 	bl	4800442c <rt_hw_interrupt_disable>
    48015b0c:	f90023e0 	str	x0, [sp, #64]
                rx_fifo->buffer[rx_fifo->put_index] = ch;
    48015b10:	f94027e0 	ldr	x0, [sp, #72]
    48015b14:	f9400001 	ldr	x1, [x0]
    48015b18:	f94027e0 	ldr	x0, [sp, #72]
    48015b1c:	79401000 	ldrh	w0, [x0, #8]
    48015b20:	92403c00 	and	x0, x0, #0xffff
    48015b24:	8b000020 	add	x0, x1, x0
    48015b28:	b94057e1 	ldr	w1, [sp, #84]
    48015b2c:	12001c21 	and	w1, w1, #0xff
    48015b30:	39000001 	strb	w1, [x0]
                rx_fifo->put_index += 1;
    48015b34:	f94027e0 	ldr	x0, [sp, #72]
    48015b38:	79401000 	ldrh	w0, [x0, #8]
    48015b3c:	11000400 	add	w0, w0, #0x1
    48015b40:	12003c01 	and	w1, w0, #0xffff
    48015b44:	f94027e0 	ldr	x0, [sp, #72]
    48015b48:	79001001 	strh	w1, [x0, #8]
                if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
    48015b4c:	f94027e0 	ldr	x0, [sp, #72]
    48015b50:	79401001 	ldrh	w1, [x0, #8]
    48015b54:	f9400fe0 	ldr	x0, [sp, #24]
    48015b58:	f9405000 	ldr	x0, [x0, #160]
    48015b5c:	d36ae400 	ubfx	x0, x0, #42, #16
    48015b60:	12003c00 	and	w0, w0, #0xffff
    48015b64:	6b00003f 	cmp	w1, w0
    48015b68:	54000063 	b.cc	48015b74 <rt_hw_serial_isr+0x114>  // b.lo, b.ul, b.last
    48015b6c:	f94027e0 	ldr	x0, [sp, #72]
    48015b70:	7900101f 	strh	wzr, [x0, #8]
                if (rx_fifo->put_index == rx_fifo->get_index)
    48015b74:	f94027e0 	ldr	x0, [sp, #72]
    48015b78:	79401001 	ldrh	w1, [x0, #8]
    48015b7c:	f94027e0 	ldr	x0, [sp, #72]
    48015b80:	79401400 	ldrh	w0, [x0, #10]
    48015b84:	6b00003f 	cmp	w1, w0
    48015b88:	540002a1 	b.ne	48015bdc <rt_hw_serial_isr+0x17c>  // b.any
                    rx_fifo->get_index += 1;
    48015b8c:	f94027e0 	ldr	x0, [sp, #72]
    48015b90:	79401400 	ldrh	w0, [x0, #10]
    48015b94:	11000400 	add	w0, w0, #0x1
    48015b98:	12003c01 	and	w1, w0, #0xffff
    48015b9c:	f94027e0 	ldr	x0, [sp, #72]
    48015ba0:	79001401 	strh	w1, [x0, #10]
                    rx_fifo->is_full = RT_TRUE;
    48015ba4:	f94027e0 	ldr	x0, [sp, #72]
    48015ba8:	52800021 	mov	w1, #0x1                   	// #1
    48015bac:	b9000c01 	str	w1, [x0, #12]
                    if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
    48015bb0:	f94027e0 	ldr	x0, [sp, #72]
    48015bb4:	79401401 	ldrh	w1, [x0, #10]
    48015bb8:	f9400fe0 	ldr	x0, [sp, #24]
    48015bbc:	f9405000 	ldr	x0, [x0, #160]
    48015bc0:	d36ae400 	ubfx	x0, x0, #42, #16
    48015bc4:	12003c00 	and	w0, w0, #0xffff
    48015bc8:	6b00003f 	cmp	w1, w0
    48015bcc:	54000063 	b.cc	48015bd8 <rt_hw_serial_isr+0x178>  // b.lo, b.ul, b.last
    48015bd0:	f94027e0 	ldr	x0, [sp, #72]
    48015bd4:	7900141f 	strh	wzr, [x0, #10]
                    _serial_check_buffer_size();
    48015bd8:	97fff989 	bl	480141fc <_serial_check_buffer_size>
                rt_hw_interrupt_enable(level);
    48015bdc:	f94023e0 	ldr	x0, [sp, #64]
    48015be0:	97ffba17 	bl	4800443c <rt_hw_interrupt_enable>
                ch = serial->ops->getc(serial);
    48015be4:	17ffffc0 	b	48015ae4 <rt_hw_serial_isr+0x84>
                if (ch == -1) break;
    48015be8:	d503201f 	nop
            if (serial->parent.rx_indicate != RT_NULL)
    48015bec:	f9400fe0 	ldr	x0, [sp, #24]
    48015bf0:	f9401800 	ldr	x0, [x0, #48]
    48015bf4:	f100001f 	cmp	x0, #0x0
    48015bf8:	540012a0 	b.eq	48015e4c <rt_hw_serial_isr+0x3ec>  // b.none
                level = rt_hw_interrupt_disable();
    48015bfc:	97ffba0c 	bl	4800442c <rt_hw_interrupt_disable>
    48015c00:	f90023e0 	str	x0, [sp, #64]
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
    48015c04:	f94027e0 	ldr	x0, [sp, #72]
    48015c08:	79401001 	ldrh	w1, [x0, #8]
    48015c0c:	f94027e0 	ldr	x0, [sp, #72]
    48015c10:	79401400 	ldrh	w0, [x0, #10]
    48015c14:	6b00003f 	cmp	w1, w0
    48015c18:	54000123 	b.cc	48015c3c <rt_hw_serial_isr+0x1dc>  // b.lo, b.ul, b.last
    48015c1c:	f94027e0 	ldr	x0, [sp, #72]
    48015c20:	79401000 	ldrh	w0, [x0, #8]
    48015c24:	2a0003e1 	mov	w1, w0
    48015c28:	f94027e0 	ldr	x0, [sp, #72]
    48015c2c:	79401400 	ldrh	w0, [x0, #10]
    48015c30:	4b000020 	sub	w0, w1, w0
    48015c34:	93407c00 	sxtw	x0, w0
    48015c38:	1400000e 	b	48015c70 <rt_hw_serial_isr+0x210>
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
    48015c3c:	f9400fe0 	ldr	x0, [sp, #24]
    48015c40:	f9405000 	ldr	x0, [x0, #160]
    48015c44:	d36ae400 	ubfx	x0, x0, #42, #16
    48015c48:	12003c00 	and	w0, w0, #0xffff
    48015c4c:	2a0003e1 	mov	w1, w0
    48015c50:	f94027e0 	ldr	x0, [sp, #72]
    48015c54:	79401400 	ldrh	w0, [x0, #10]
    48015c58:	2a0003e2 	mov	w2, w0
    48015c5c:	f94027e0 	ldr	x0, [sp, #72]
    48015c60:	79401000 	ldrh	w0, [x0, #8]
    48015c64:	4b000040 	sub	w0, w2, w0
    48015c68:	4b000020 	sub	w0, w1, w0
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
    48015c6c:	93407c00 	sxtw	x0, w0
    48015c70:	f9001fe0 	str	x0, [sp, #56]
                rt_hw_interrupt_enable(level);
    48015c74:	f94023e0 	ldr	x0, [sp, #64]
    48015c78:	97ffb9f1 	bl	4800443c <rt_hw_interrupt_enable>
                if (rx_length)
    48015c7c:	f9401fe0 	ldr	x0, [sp, #56]
    48015c80:	f100001f 	cmp	x0, #0x0
    48015c84:	54000e40 	b.eq	48015e4c <rt_hw_serial_isr+0x3ec>  // b.none
                    serial->parent.rx_indicate(&serial->parent, rx_length);
    48015c88:	f9400fe0 	ldr	x0, [sp, #24]
    48015c8c:	f9401802 	ldr	x2, [x0, #48]
    48015c90:	f9400fe0 	ldr	x0, [sp, #24]
    48015c94:	f9401fe1 	ldr	x1, [sp, #56]
    48015c98:	d63f0040 	blr	x2
            break;
    48015c9c:	1400006c 	b	48015e4c <rt_hw_serial_isr+0x3ec>
            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
    48015ca0:	f9400fe0 	ldr	x0, [sp, #24]
    48015ca4:	f9405800 	ldr	x0, [x0, #176]
    48015ca8:	f9002fe0 	str	x0, [sp, #88]
            rt_completion_done(&(tx_fifo->completion));
    48015cac:	f9402fe0 	ldr	x0, [sp, #88]
    48015cb0:	94000535 	bl	48017184 <rt_completion_done>
            break;
    48015cb4:	1400006b 	b	48015e60 <rt_hw_serial_isr+0x400>
            tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
    48015cb8:	f9400fe0 	ldr	x0, [sp, #24]
    48015cbc:	f9405800 	ldr	x0, [x0, #176]
    48015cc0:	f9003fe0 	str	x0, [sp, #120]
            rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
    48015cc4:	f9403fe0 	ldr	x0, [sp, #120]
    48015cc8:	91002000 	add	x0, x0, #0x8
    48015ccc:	9100a3e2 	add	x2, sp, #0x28
    48015cd0:	910083e1 	add	x1, sp, #0x20
    48015cd4:	52800003 	mov	w3, #0x0                   	// #0
    48015cd8:	94000292 	bl	48016720 <rt_data_queue_pop>
            if (rt_data_queue_peek(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
    48015cdc:	f9403fe0 	ldr	x0, [sp, #120]
    48015ce0:	91002000 	add	x0, x0, #0x8
    48015ce4:	9100a3e2 	add	x2, sp, #0x28
    48015ce8:	9100c3e1 	add	x1, sp, #0x30
    48015cec:	9400037a 	bl	48016ad4 <rt_data_queue_peek>
    48015cf0:	f100001f 	cmp	x0, #0x0
    48015cf4:	540001e1 	b.ne	48015d30 <rt_hw_serial_isr+0x2d0>  // b.any
                tx_dma->activated = RT_TRUE;
    48015cf8:	f9403fe0 	ldr	x0, [sp, #120]
    48015cfc:	52800021 	mov	w1, #0x1                   	// #1
    48015d00:	b9000001 	str	w1, [x0]
                serial->ops->dma_transmit(serial, (rt_uint8_t *)data_ptr, data_size, RT_SERIAL_DMA_TX);
    48015d04:	f9400fe0 	ldr	x0, [sp, #24]
    48015d08:	f9404c00 	ldr	x0, [x0, #152]
    48015d0c:	f9401004 	ldr	x4, [x0, #32]
    48015d10:	f9401be0 	ldr	x0, [sp, #48]
    48015d14:	f94017e1 	ldr	x1, [sp, #40]
    48015d18:	52800043 	mov	w3, #0x2                   	// #2
    48015d1c:	aa0103e2 	mov	x2, x1
    48015d20:	aa0003e1 	mov	x1, x0
    48015d24:	f9400fe0 	ldr	x0, [sp, #24]
    48015d28:	d63f0080 	blr	x4
    48015d2c:	14000003 	b	48015d38 <rt_hw_serial_isr+0x2d8>
                tx_dma->activated = RT_FALSE;
    48015d30:	f9403fe0 	ldr	x0, [sp, #120]
    48015d34:	b900001f 	str	wzr, [x0]
            if (serial->parent.tx_complete != RT_NULL)
    48015d38:	f9400fe0 	ldr	x0, [sp, #24]
    48015d3c:	f9401c00 	ldr	x0, [x0, #56]
    48015d40:	f100001f 	cmp	x0, #0x0
    48015d44:	54000880 	b.eq	48015e54 <rt_hw_serial_isr+0x3f4>  // b.none
                serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
    48015d48:	f9400fe0 	ldr	x0, [sp, #24]
    48015d4c:	f9401c02 	ldr	x2, [x0, #56]
    48015d50:	f9400fe0 	ldr	x0, [sp, #24]
    48015d54:	f94013e1 	ldr	x1, [sp, #32]
    48015d58:	d63f0040 	blr	x2
            break;
    48015d5c:	1400003e 	b	48015e54 <rt_hw_serial_isr+0x3f4>
            length = (event & (~0xff)) >> 8;
    48015d60:	b94017e0 	ldr	w0, [sp, #20]
    48015d64:	13087c00 	asr	w0, w0, #8
    48015d68:	b90077e0 	str	w0, [sp, #116]
            if (serial->config.bufsz == 0)
    48015d6c:	f9400fe0 	ldr	x0, [sp, #24]
    48015d70:	b940a400 	ldr	w0, [x0, #164]
    48015d74:	12163c00 	and	w0, w0, #0x3fffc00
    48015d78:	7100001f 	cmp	w0, #0x0
    48015d7c:	540003e1 	b.ne	48015df8 <rt_hw_serial_isr+0x398>  // b.any
                rx_dma = (struct rt_serial_rx_dma*) serial->serial_rx;
    48015d80:	f9400fe0 	ldr	x0, [sp, #24]
    48015d84:	f9405400 	ldr	x0, [x0, #168]
    48015d88:	f90033e0 	str	x0, [sp, #96]
                RT_ASSERT(rx_dma != RT_NULL);
    48015d8c:	f94033e0 	ldr	x0, [sp, #96]
    48015d90:	f100001f 	cmp	x0, #0x0
    48015d94:	540000e1 	b.ne	48015db0 <rt_hw_serial_isr+0x350>  // b.any
    48015d98:	d280ade2 	mov	x2, #0x56f                 	// #1391
    48015d9c:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015da0:	91180001 	add	x1, x0, #0x600
    48015da4:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015da8:	910f6000 	add	x0, x0, #0x3d8
    48015dac:	97ffe8af 	bl	48010068 <rt_assert_handler>
                RT_ASSERT(serial->parent.rx_indicate != RT_NULL);
    48015db0:	f9400fe0 	ldr	x0, [sp, #24]
    48015db4:	f9401800 	ldr	x0, [x0, #48]
    48015db8:	f100001f 	cmp	x0, #0x0
    48015dbc:	540000e1 	b.ne	48015dd8 <rt_hw_serial_isr+0x378>  // b.any
    48015dc0:	d280ae22 	mov	x2, #0x571                 	// #1393
    48015dc4:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015dc8:	91180001 	add	x1, x0, #0x600
    48015dcc:	f0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48015dd0:	9111e000 	add	x0, x0, #0x478
    48015dd4:	97ffe8a5 	bl	48010068 <rt_assert_handler>
                serial->parent.rx_indicate(&(serial->parent), length);
    48015dd8:	f9400fe0 	ldr	x0, [sp, #24]
    48015ddc:	f9401802 	ldr	x2, [x0, #48]
    48015de0:	f9400fe0 	ldr	x0, [sp, #24]
    48015de4:	b98077e1 	ldrsw	x1, [sp, #116]
    48015de8:	d63f0040 	blr	x2
                rx_dma->activated = RT_FALSE;
    48015dec:	f94033e0 	ldr	x0, [sp, #96]
    48015df0:	b900001f 	str	wzr, [x0]
            break;
    48015df4:	1400001a 	b	48015e5c <rt_hw_serial_isr+0x3fc>
                level = rt_hw_interrupt_disable();
    48015df8:	97ffb98d 	bl	4800442c <rt_hw_interrupt_disable>
    48015dfc:	f90037e0 	str	x0, [sp, #104]
                rt_dma_recv_update_put_index(serial, length);
    48015e00:	b98077e0 	ldrsw	x0, [sp, #116]
    48015e04:	aa0003e1 	mov	x1, x0
    48015e08:	f9400fe0 	ldr	x0, [sp, #24]
    48015e0c:	97fff99c 	bl	4801447c <rt_dma_recv_update_put_index>
                length = rt_dma_calc_recved_len(serial);
    48015e10:	f9400fe0 	ldr	x0, [sp, #24]
    48015e14:	97fff94f 	bl	48014350 <rt_dma_calc_recved_len>
    48015e18:	b90077e0 	str	w0, [sp, #116]
                rt_hw_interrupt_enable(level);
    48015e1c:	f94037e0 	ldr	x0, [sp, #104]
    48015e20:	97ffb987 	bl	4800443c <rt_hw_interrupt_enable>
                if (serial->parent.rx_indicate != RT_NULL)
    48015e24:	f9400fe0 	ldr	x0, [sp, #24]
    48015e28:	f9401800 	ldr	x0, [x0, #48]
    48015e2c:	f100001f 	cmp	x0, #0x0
    48015e30:	54000160 	b.eq	48015e5c <rt_hw_serial_isr+0x3fc>  // b.none
                    serial->parent.rx_indicate(&(serial->parent), length);
    48015e34:	f9400fe0 	ldr	x0, [sp, #24]
    48015e38:	f9401802 	ldr	x2, [x0, #48]
    48015e3c:	f9400fe0 	ldr	x0, [sp, #24]
    48015e40:	b98077e1 	ldrsw	x1, [sp, #116]
    48015e44:	d63f0040 	blr	x2
            break;
    48015e48:	14000005 	b	48015e5c <rt_hw_serial_isr+0x3fc>
            break;
    48015e4c:	d503201f 	nop
    48015e50:	14000004 	b	48015e60 <rt_hw_serial_isr+0x400>
            break;
    48015e54:	d503201f 	nop
    48015e58:	14000002 	b	48015e60 <rt_hw_serial_isr+0x400>
            break;
    48015e5c:	d503201f 	nop
}
    48015e60:	d503201f 	nop
    48015e64:	a8c87bfd 	ldp	x29, x30, [sp], #128
    48015e68:	d65f03c0 	ret

0000000048015e6c <rt_list_init>:
{
    48015e6c:	d10043ff 	sub	sp, sp, #0x10
    48015e70:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    48015e74:	f94007e0 	ldr	x0, [sp, #8]
    48015e78:	f94007e1 	ldr	x1, [sp, #8]
    48015e7c:	f9000401 	str	x1, [x0, #8]
    48015e80:	f94007e0 	ldr	x0, [sp, #8]
    48015e84:	f9400401 	ldr	x1, [x0, #8]
    48015e88:	f94007e0 	ldr	x0, [sp, #8]
    48015e8c:	f9000001 	str	x1, [x0]
}
    48015e90:	d503201f 	nop
    48015e94:	910043ff 	add	sp, sp, #0x10
    48015e98:	d65f03c0 	ret

0000000048015e9c <rt_list_insert_before>:
{
    48015e9c:	d10043ff 	sub	sp, sp, #0x10
    48015ea0:	f90007e0 	str	x0, [sp, #8]
    48015ea4:	f90003e1 	str	x1, [sp]
    l->prev->next = n;
    48015ea8:	f94007e0 	ldr	x0, [sp, #8]
    48015eac:	f9400400 	ldr	x0, [x0, #8]
    48015eb0:	f94003e1 	ldr	x1, [sp]
    48015eb4:	f9000001 	str	x1, [x0]
    n->prev = l->prev;
    48015eb8:	f94007e0 	ldr	x0, [sp, #8]
    48015ebc:	f9400401 	ldr	x1, [x0, #8]
    48015ec0:	f94003e0 	ldr	x0, [sp]
    48015ec4:	f9000401 	str	x1, [x0, #8]
    l->prev = n;
    48015ec8:	f94007e0 	ldr	x0, [sp, #8]
    48015ecc:	f94003e1 	ldr	x1, [sp]
    48015ed0:	f9000401 	str	x1, [x0, #8]
    n->next = l;
    48015ed4:	f94003e0 	ldr	x0, [sp]
    48015ed8:	f94007e1 	ldr	x1, [sp, #8]
    48015edc:	f9000001 	str	x1, [x0]
}
    48015ee0:	d503201f 	nop
    48015ee4:	910043ff 	add	sp, sp, #0x10
    48015ee8:	d65f03c0 	ret

0000000048015eec <rt_list_remove>:
{
    48015eec:	d10043ff 	sub	sp, sp, #0x10
    48015ef0:	f90007e0 	str	x0, [sp, #8]
    n->next->prev = n->prev;
    48015ef4:	f94007e0 	ldr	x0, [sp, #8]
    48015ef8:	f9400000 	ldr	x0, [x0]
    48015efc:	f94007e1 	ldr	x1, [sp, #8]
    48015f00:	f9400421 	ldr	x1, [x1, #8]
    48015f04:	f9000401 	str	x1, [x0, #8]
    n->prev->next = n->next;
    48015f08:	f94007e0 	ldr	x0, [sp, #8]
    48015f0c:	f9400400 	ldr	x0, [x0, #8]
    48015f10:	f94007e1 	ldr	x1, [sp, #8]
    48015f14:	f9400021 	ldr	x1, [x1]
    48015f18:	f9000001 	str	x1, [x0]
    n->next = n->prev = n;
    48015f1c:	f94007e0 	ldr	x0, [sp, #8]
    48015f20:	f94007e1 	ldr	x1, [sp, #8]
    48015f24:	f9000401 	str	x1, [x0, #8]
    48015f28:	f94007e0 	ldr	x0, [sp, #8]
    48015f2c:	f9400401 	ldr	x1, [x0, #8]
    48015f30:	f94007e0 	ldr	x0, [sp, #8]
    48015f34:	f9000001 	str	x1, [x0]
}
    48015f38:	d503201f 	nop
    48015f3c:	910043ff 	add	sp, sp, #0x10
    48015f40:	d65f03c0 	ret

0000000048015f44 <rt_list_isempty>:
{
    48015f44:	d10043ff 	sub	sp, sp, #0x10
    48015f48:	f90007e0 	str	x0, [sp, #8]
    return l->next == l;
    48015f4c:	f94007e0 	ldr	x0, [sp, #8]
    48015f50:	f9400000 	ldr	x0, [x0]
    48015f54:	f94007e1 	ldr	x1, [sp, #8]
    48015f58:	eb00003f 	cmp	x1, x0
    48015f5c:	1a9f17e0 	cset	w0, eq  // eq = none
    48015f60:	12001c00 	and	w0, w0, #0xff
}
    48015f64:	910043ff 	add	sp, sp, #0x10
    48015f68:	d65f03c0 	ret

0000000048015f6c <rt_wqueue_add>:
#include <rthw.h>
#include <rtdevice.h>
#include <rtservice.h>

void rt_wqueue_add(rt_wqueue_t *queue, struct rt_wqueue_node *node)
{
    48015f6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48015f70:	910003fd 	mov	x29, sp
    48015f74:	f9000fe0 	str	x0, [sp, #24]
    48015f78:	f9000be1 	str	x1, [sp, #16]
    rt_base_t level;

    level = rt_hw_interrupt_disable();
    48015f7c:	97ffb92c 	bl	4800442c <rt_hw_interrupt_disable>
    48015f80:	f90017e0 	str	x0, [sp, #40]
    rt_list_insert_before(&(queue->waiting_list), &(node->list));
    48015f84:	f9400fe0 	ldr	x0, [sp, #24]
    48015f88:	91002002 	add	x2, x0, #0x8
    48015f8c:	f9400be0 	ldr	x0, [sp, #16]
    48015f90:	91002000 	add	x0, x0, #0x8
    48015f94:	aa0003e1 	mov	x1, x0
    48015f98:	aa0203e0 	mov	x0, x2
    48015f9c:	97ffffc0 	bl	48015e9c <rt_list_insert_before>
    rt_hw_interrupt_enable(level);
    48015fa0:	f94017e0 	ldr	x0, [sp, #40]
    48015fa4:	97ffb926 	bl	4800443c <rt_hw_interrupt_enable>
}
    48015fa8:	d503201f 	nop
    48015fac:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48015fb0:	d65f03c0 	ret

0000000048015fb4 <rt_wqueue_remove>:

void rt_wqueue_remove(struct rt_wqueue_node *node)
{
    48015fb4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48015fb8:	910003fd 	mov	x29, sp
    48015fbc:	f9000fe0 	str	x0, [sp, #24]
    rt_base_t level;

    level = rt_hw_interrupt_disable();
    48015fc0:	97ffb91b 	bl	4800442c <rt_hw_interrupt_disable>
    48015fc4:	f90017e0 	str	x0, [sp, #40]
    rt_list_remove(&(node->list));
    48015fc8:	f9400fe0 	ldr	x0, [sp, #24]
    48015fcc:	91002000 	add	x0, x0, #0x8
    48015fd0:	97ffffc7 	bl	48015eec <rt_list_remove>
    rt_hw_interrupt_enable(level);
    48015fd4:	f94017e0 	ldr	x0, [sp, #40]
    48015fd8:	97ffb919 	bl	4800443c <rt_hw_interrupt_enable>
}
    48015fdc:	d503201f 	nop
    48015fe0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48015fe4:	d65f03c0 	ret

0000000048015fe8 <__wqueue_default_wake>:

int __wqueue_default_wake(struct rt_wqueue_node *wait, void *key)
{
    48015fe8:	d10043ff 	sub	sp, sp, #0x10
    48015fec:	f90007e0 	str	x0, [sp, #8]
    48015ff0:	f90003e1 	str	x1, [sp]
    return 0;
    48015ff4:	52800000 	mov	w0, #0x0                   	// #0
}
    48015ff8:	910043ff 	add	sp, sp, #0x10
    48015ffc:	d65f03c0 	ret

0000000048016000 <rt_wqueue_wakeup>:

void rt_wqueue_wakeup(rt_wqueue_t *queue, void *key)
{
    48016000:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48016004:	910003fd 	mov	x29, sp
    48016008:	f9000bf3 	str	x19, [sp, #16]
    4801600c:	f90017e0 	str	x0, [sp, #40]
    48016010:	f90013e1 	str	x1, [sp, #32]
    rt_base_t level;
    register int need_schedule = 0;
    48016014:	52800013 	mov	w19, #0x0                   	// #0

    rt_list_t *queue_list;
    struct rt_list_node *node;
    struct rt_wqueue_node *entry;

    queue_list = &(queue->waiting_list);
    48016018:	f94017e0 	ldr	x0, [sp, #40]
    4801601c:	91002000 	add	x0, x0, #0x8
    48016020:	f90023e0 	str	x0, [sp, #64]

    level = rt_hw_interrupt_disable();
    48016024:	97ffb902 	bl	4800442c <rt_hw_interrupt_disable>
    48016028:	f9001fe0 	str	x0, [sp, #56]
    /* set wakeup flag in the queue */
    queue->flag = RT_WQ_FLAG_WAKEUP;
    4801602c:	f94017e0 	ldr	x0, [sp, #40]
    48016030:	52800021 	mov	w1, #0x1                   	// #1
    48016034:	b9000001 	str	w1, [x0]

    if (!(rt_list_isempty(queue_list)))
    48016038:	f94023e0 	ldr	x0, [sp, #64]
    4801603c:	97ffffc2 	bl	48015f44 <rt_list_isempty>
    48016040:	7100001f 	cmp	w0, #0x0
    48016044:	540003a1 	b.ne	480160b8 <rt_wqueue_wakeup+0xb8>  // b.any
    {
        for (node = queue_list->next; node != queue_list; node = node->next)
    48016048:	f94023e0 	ldr	x0, [sp, #64]
    4801604c:	f9400000 	ldr	x0, [x0]
    48016050:	f90027e0 	str	x0, [sp, #72]
    48016054:	14000015 	b	480160a8 <rt_wqueue_wakeup+0xa8>
        {
            entry = rt_list_entry(node, struct rt_wqueue_node, list);
    48016058:	f94027e0 	ldr	x0, [sp, #72]
    4801605c:	d1002000 	sub	x0, x0, #0x8
    48016060:	f9001be0 	str	x0, [sp, #48]
            if (entry->wakeup(entry, key) == 0)
    48016064:	f9401be0 	ldr	x0, [sp, #48]
    48016068:	f9400c02 	ldr	x2, [x0, #24]
    4801606c:	f94013e1 	ldr	x1, [sp, #32]
    48016070:	f9401be0 	ldr	x0, [sp, #48]
    48016074:	d63f0040 	blr	x2
    48016078:	7100001f 	cmp	w0, #0x0
    4801607c:	54000101 	b.ne	4801609c <rt_wqueue_wakeup+0x9c>  // b.any
            {
                rt_thread_resume(entry->polling_thread);
    48016080:	f9401be0 	ldr	x0, [sp, #48]
    48016084:	f9400000 	ldr	x0, [x0]
    48016088:	97ffd918 	bl	4800c4e8 <rt_thread_resume>
                need_schedule = 1;
    4801608c:	52800033 	mov	w19, #0x1                   	// #1

                rt_wqueue_remove(entry);
    48016090:	f9401be0 	ldr	x0, [sp, #48]
    48016094:	97ffffc8 	bl	48015fb4 <rt_wqueue_remove>
                break;
    48016098:	14000008 	b	480160b8 <rt_wqueue_wakeup+0xb8>
        for (node = queue_list->next; node != queue_list; node = node->next)
    4801609c:	f94027e0 	ldr	x0, [sp, #72]
    480160a0:	f9400000 	ldr	x0, [x0]
    480160a4:	f90027e0 	str	x0, [sp, #72]
    480160a8:	f94027e1 	ldr	x1, [sp, #72]
    480160ac:	f94023e0 	ldr	x0, [sp, #64]
    480160b0:	eb00003f 	cmp	x1, x0
    480160b4:	54fffd21 	b.ne	48016058 <rt_wqueue_wakeup+0x58>  // b.any
            }
        }
    }
    rt_hw_interrupt_enable(level);
    480160b8:	f9401fe0 	ldr	x0, [sp, #56]
    480160bc:	97ffb8e0 	bl	4800443c <rt_hw_interrupt_enable>

    if (need_schedule)
    480160c0:	7100027f 	cmp	w19, #0x0
    480160c4:	54000040 	b.eq	480160cc <rt_wqueue_wakeup+0xcc>  // b.none
        rt_schedule();
    480160c8:	97ffdcb1 	bl	4800d38c <rt_schedule>
}
    480160cc:	d503201f 	nop
    480160d0:	f9400bf3 	ldr	x19, [sp, #16]
    480160d4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480160d8:	d65f03c0 	ret

00000000480160dc <rt_wqueue_wait>:

int rt_wqueue_wait(rt_wqueue_t *queue, int condition, int msec)
{
    480160dc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    480160e0:	910003fd 	mov	x29, sp
    480160e4:	f9000fe0 	str	x0, [sp, #24]
    480160e8:	b90017e1 	str	w1, [sp, #20]
    480160ec:	b90013e2 	str	w2, [sp, #16]
    int tick;
    rt_thread_t tid = rt_thread_self();
    480160f0:	97ffd6ab 	bl	4800bb9c <rt_thread_self>
    480160f4:	f90033e0 	str	x0, [sp, #96]
    rt_timer_t  tmr = &(tid->thread_timer);
    480160f8:	f94033e0 	ldr	x0, [sp, #96]
    480160fc:	91020000 	add	x0, x0, #0x80
    48016100:	f9002fe0 	str	x0, [sp, #88]
    struct rt_wqueue_node __wait;
    rt_base_t level;

    /* current context checking */
    RT_DEBUG_NOT_IN_INTERRUPT;
    48016104:	97ffb8ca 	bl	4800442c <rt_hw_interrupt_disable>
    48016108:	f9002be0 	str	x0, [sp, #80]
    4801610c:	97ffcd81 	bl	48009710 <rt_interrupt_get_nest>
    48016110:	12001c00 	and	w0, w0, #0xff
    48016114:	7100001f 	cmp	w0, #0x0
    48016118:	54000180 	b.eq	48016148 <rt_wqueue_wait+0x6c>  // b.none
    4801611c:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016120:	91192001 	add	x1, x0, #0x648
    48016124:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016128:	91186000 	add	x0, x0, #0x618
    4801612c:	97ffe701 	bl	4800fd30 <rt_kprintf>
    48016130:	d2800ac2 	mov	x2, #0x56                  	// #86
    48016134:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016138:	91192001 	add	x1, x0, #0x648
    4801613c:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016140:	91190000 	add	x0, x0, #0x640
    48016144:	97ffe7c9 	bl	48010068 <rt_assert_handler>
    48016148:	f9402be0 	ldr	x0, [sp, #80]
    4801614c:	97ffb8bc 	bl	4800443c <rt_hw_interrupt_enable>

    tick = rt_tick_from_millisecond(msec);
    48016150:	b94013e0 	ldr	w0, [sp, #16]
    48016154:	97ffe822 	bl	480101dc <rt_tick_from_millisecond>
    48016158:	b9004fe0 	str	w0, [sp, #76]

    if ((condition) || (tick == 0))
    4801615c:	b94017e0 	ldr	w0, [sp, #20]
    48016160:	7100001f 	cmp	w0, #0x0
    48016164:	54000081 	b.ne	48016174 <rt_wqueue_wait+0x98>  // b.any
    48016168:	b9404fe0 	ldr	w0, [sp, #76]
    4801616c:	7100001f 	cmp	w0, #0x0
    48016170:	54000061 	b.ne	4801617c <rt_wqueue_wait+0xa0>  // b.any
        return 0;
    48016174:	52800000 	mov	w0, #0x0                   	// #0
    48016178:	1400002e 	b	48016230 <rt_wqueue_wait+0x154>

    __wait.polling_thread = rt_thread_self();
    4801617c:	97ffd688 	bl	4800bb9c <rt_thread_self>
    48016180:	f90013e0 	str	x0, [sp, #32]
    __wait.key = 0;
    48016184:	b90043ff 	str	wzr, [sp, #64]
    __wait.wakeup = __wqueue_default_wake;
    48016188:	f0ffffe0 	adrp	x0, 48015000 <rt_serial_close+0xc>
    4801618c:	913fa000 	add	x0, x0, #0xfe8
    48016190:	f9001fe0 	str	x0, [sp, #56]
    rt_list_init(&__wait.list);
    48016194:	910083e0 	add	x0, sp, #0x20
    48016198:	91002000 	add	x0, x0, #0x8
    4801619c:	97ffff34 	bl	48015e6c <rt_list_init>

    level = rt_hw_interrupt_disable();
    480161a0:	97ffb8a3 	bl	4800442c <rt_hw_interrupt_disable>
    480161a4:	f90037e0 	str	x0, [sp, #104]
    if (queue->flag == RT_WQ_FLAG_WAKEUP)
    480161a8:	f9400fe0 	ldr	x0, [sp, #24]
    480161ac:	b9400000 	ldr	w0, [x0]
    480161b0:	7100041f 	cmp	w0, #0x1
    480161b4:	540002e0 	b.eq	48016210 <rt_wqueue_wait+0x134>  // b.none
    {
        /* already wakeup */
        goto __exit_wakeup;
    }

    rt_wqueue_add(queue, &__wait);
    480161b8:	910083e0 	add	x0, sp, #0x20
    480161bc:	aa0003e1 	mov	x1, x0
    480161c0:	f9400fe0 	ldr	x0, [sp, #24]
    480161c4:	97ffff6a 	bl	48015f6c <rt_wqueue_add>
    rt_thread_suspend(tid);
    480161c8:	f94033e0 	ldr	x0, [sp, #96]
    480161cc:	97ffd877 	bl	4800c3a8 <rt_thread_suspend>

    /* start timer */
    if (tick != RT_WAITING_FOREVER)
    480161d0:	b9404fe0 	ldr	w0, [sp, #76]
    480161d4:	3100041f 	cmn	w0, #0x1
    480161d8:	54000100 	b.eq	480161f8 <rt_wqueue_wait+0x11c>  // b.none
    {
        rt_timer_control(tmr,
    480161dc:	910133e0 	add	x0, sp, #0x4c
    480161e0:	aa0003e2 	mov	x2, x0
    480161e4:	52800001 	mov	w1, #0x0                   	// #0
    480161e8:	f9402fe0 	ldr	x0, [sp, #88]
    480161ec:	97ffd3cd 	bl	4800b120 <rt_timer_control>
                         RT_TIMER_CTRL_SET_TIME,
                         &tick);

        rt_timer_start(tmr);
    480161f0:	f9402fe0 	ldr	x0, [sp, #88]
    480161f4:	97ffd2a4 	bl	4800ac84 <rt_timer_start>
    }
    rt_hw_interrupt_enable(level);
    480161f8:	f94037e0 	ldr	x0, [sp, #104]
    480161fc:	97ffb890 	bl	4800443c <rt_hw_interrupt_enable>

    rt_schedule();
    48016200:	97ffdc63 	bl	4800d38c <rt_schedule>

    level = rt_hw_interrupt_disable();
    48016204:	97ffb88a 	bl	4800442c <rt_hw_interrupt_disable>
    48016208:	f90037e0 	str	x0, [sp, #104]
    4801620c:	14000002 	b	48016214 <rt_wqueue_wait+0x138>
        goto __exit_wakeup;
    48016210:	d503201f 	nop

__exit_wakeup:
    queue->flag = RT_WQ_FLAG_CLEAN;
    48016214:	f9400fe0 	ldr	x0, [sp, #24]
    48016218:	b900001f 	str	wzr, [x0]
    rt_hw_interrupt_enable(level);
    4801621c:	f94037e0 	ldr	x0, [sp, #104]
    48016220:	97ffb887 	bl	4800443c <rt_hw_interrupt_enable>

    rt_wqueue_remove(&__wait);
    48016224:	910083e0 	add	x0, sp, #0x20
    48016228:	97ffff63 	bl	48015fb4 <rt_wqueue_remove>

    return 0;
    4801622c:	52800000 	mov	w0, #0x0                   	// #0
}
    48016230:	a8c77bfd 	ldp	x29, x30, [sp], #112
    48016234:	d65f03c0 	ret

0000000048016238 <rt_list_init>:
{
    48016238:	d10043ff 	sub	sp, sp, #0x10
    4801623c:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    48016240:	f94007e0 	ldr	x0, [sp, #8]
    48016244:	f94007e1 	ldr	x1, [sp, #8]
    48016248:	f9000401 	str	x1, [x0, #8]
    4801624c:	f94007e0 	ldr	x0, [sp, #8]
    48016250:	f9400401 	ldr	x1, [x0, #8]
    48016254:	f94007e0 	ldr	x0, [sp, #8]
    48016258:	f9000001 	str	x1, [x0]
}
    4801625c:	d503201f 	nop
    48016260:	910043ff 	add	sp, sp, #0x10
    48016264:	d65f03c0 	ret

0000000048016268 <rt_list_insert_before>:
{
    48016268:	d10043ff 	sub	sp, sp, #0x10
    4801626c:	f90007e0 	str	x0, [sp, #8]
    48016270:	f90003e1 	str	x1, [sp]
    l->prev->next = n;
    48016274:	f94007e0 	ldr	x0, [sp, #8]
    48016278:	f9400400 	ldr	x0, [x0, #8]
    4801627c:	f94003e1 	ldr	x1, [sp]
    48016280:	f9000001 	str	x1, [x0]
    n->prev = l->prev;
    48016284:	f94007e0 	ldr	x0, [sp, #8]
    48016288:	f9400401 	ldr	x1, [x0, #8]
    4801628c:	f94003e0 	ldr	x0, [sp]
    48016290:	f9000401 	str	x1, [x0, #8]
    l->prev = n;
    48016294:	f94007e0 	ldr	x0, [sp, #8]
    48016298:	f94003e1 	ldr	x1, [sp]
    4801629c:	f9000401 	str	x1, [x0, #8]
    n->next = l;
    480162a0:	f94003e0 	ldr	x0, [sp]
    480162a4:	f94007e1 	ldr	x1, [sp, #8]
    480162a8:	f9000001 	str	x1, [x0]
}
    480162ac:	d503201f 	nop
    480162b0:	910043ff 	add	sp, sp, #0x10
    480162b4:	d65f03c0 	ret

00000000480162b8 <rt_list_isempty>:
{
    480162b8:	d10043ff 	sub	sp, sp, #0x10
    480162bc:	f90007e0 	str	x0, [sp, #8]
    return l->next == l;
    480162c0:	f94007e0 	ldr	x0, [sp, #8]
    480162c4:	f9400000 	ldr	x0, [x0]
    480162c8:	f94007e1 	ldr	x1, [sp, #8]
    480162cc:	eb00003f 	cmp	x1, x0
    480162d0:	1a9f17e0 	cset	w0, eq  // eq = none
    480162d4:	12001c00 	and	w0, w0, #0xff
}
    480162d8:	910043ff 	add	sp, sp, #0x10
    480162dc:	d65f03c0 	ret

00000000480162e0 <rt_data_queue_init>:
rt_err_t
rt_data_queue_init(struct rt_data_queue *queue,
                   rt_uint16_t size,
                   rt_uint16_t lwm,
                   void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
{
    480162e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480162e4:	910003fd 	mov	x29, sp
    480162e8:	f90017e0 	str	x0, [sp, #40]
    480162ec:	79004fe1 	strh	w1, [sp, #38]
    480162f0:	79004be2 	strh	w2, [sp, #36]
    480162f4:	f9000fe3 	str	x3, [sp, #24]
    RT_ASSERT(queue != RT_NULL);
    480162f8:	f94017e0 	ldr	x0, [sp, #40]
    480162fc:	f100001f 	cmp	x0, #0x0
    48016300:	540000e1 	b.ne	4801631c <rt_data_queue_init+0x3c>  // b.any
    48016304:	d28003c2 	mov	x2, #0x1e                  	// #30
    48016308:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801630c:	911be001 	add	x1, x0, #0x6f8
    48016310:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016314:	91196000 	add	x0, x0, #0x658
    48016318:	97ffe754 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(size > 0);
    4801631c:	79404fe0 	ldrh	w0, [sp, #38]
    48016320:	7100001f 	cmp	w0, #0x0
    48016324:	540000e1 	b.ne	48016340 <rt_data_queue_init+0x60>  // b.any
    48016328:	d28003e2 	mov	x2, #0x1f                  	// #31
    4801632c:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016330:	911be001 	add	x1, x0, #0x6f8
    48016334:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016338:	9119c000 	add	x0, x0, #0x670
    4801633c:	97ffe74b 	bl	48010068 <rt_assert_handler>

    queue->evt_notify = evt_notify;
    48016340:	f94017e0 	ldr	x0, [sp, #40]
    48016344:	f9400fe1 	ldr	x1, [sp, #24]
    48016348:	f9001c01 	str	x1, [x0, #56]

    queue->magic = DATAQUEUE_MAGIC;
    4801634c:	f94017e0 	ldr	x0, [sp, #40]
    48016350:	5281c1c1 	mov	w1, #0xe0e                 	// #3598
    48016354:	72b7d5a1 	movk	w1, #0xbead, lsl #16
    48016358:	b9000001 	str	w1, [x0]
    queue->size = size;
    4801635c:	f94017e0 	ldr	x0, [sp, #40]
    48016360:	79404fe1 	ldrh	w1, [sp, #38]
    48016364:	79000801 	strh	w1, [x0, #4]
    queue->lwm = lwm;
    48016368:	f94017e0 	ldr	x0, [sp, #40]
    4801636c:	79404be1 	ldrh	w1, [sp, #36]
    48016370:	79000c01 	strh	w1, [x0, #6]

    queue->get_index = 0;
    48016374:	f94017e0 	ldr	x0, [sp, #40]
    48016378:	b9400801 	ldr	w1, [x0, #8]
    4801637c:	12114021 	and	w1, w1, #0xffff8000
    48016380:	b9000801 	str	w1, [x0, #8]
    queue->put_index = 0;
    48016384:	f94017e0 	ldr	x0, [sp, #40]
    48016388:	b9400801 	ldr	w1, [x0, #8]
    4801638c:	12014021 	and	w1, w1, #0x8000ffff
    48016390:	b9000801 	str	w1, [x0, #8]
    queue->is_empty = 1;
    48016394:	f94017e0 	ldr	x0, [sp, #40]
    48016398:	b9400801 	ldr	w1, [x0, #8]
    4801639c:	32110021 	orr	w1, w1, #0x8000
    480163a0:	b9000801 	str	w1, [x0, #8]
    queue->is_full = 0;
    480163a4:	f94017e0 	ldr	x0, [sp, #40]
    480163a8:	b9400801 	ldr	w1, [x0, #8]
    480163ac:	12007821 	and	w1, w1, #0x7fffffff
    480163b0:	b9000801 	str	w1, [x0, #8]

    rt_list_init(&(queue->suspended_push_list));
    480163b4:	f94017e0 	ldr	x0, [sp, #40]
    480163b8:	91006000 	add	x0, x0, #0x18
    480163bc:	97ffff9f 	bl	48016238 <rt_list_init>
    rt_list_init(&(queue->suspended_pop_list));
    480163c0:	f94017e0 	ldr	x0, [sp, #40]
    480163c4:	9100a000 	add	x0, x0, #0x28
    480163c8:	97ffff9c 	bl	48016238 <rt_list_init>

    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
    480163cc:	79404fe0 	ldrh	w0, [sp, #38]
    480163d0:	d37cec00 	lsl	x0, x0, #4
    480163d4:	97ffcded 	bl	48009b88 <rt_malloc>
    480163d8:	aa0003e1 	mov	x1, x0
    480163dc:	f94017e0 	ldr	x0, [sp, #40]
    480163e0:	f9000801 	str	x1, [x0, #16]
    if (queue->queue == RT_NULL)
    480163e4:	f94017e0 	ldr	x0, [sp, #40]
    480163e8:	f9400800 	ldr	x0, [x0, #16]
    480163ec:	f100001f 	cmp	x0, #0x0
    480163f0:	54000061 	b.ne	480163fc <rt_data_queue_init+0x11c>  // b.any
    {
        return -RT_ENOMEM;
    480163f4:	92800080 	mov	x0, #0xfffffffffffffffb    	// #-5
    480163f8:	14000002 	b	48016400 <rt_data_queue_init+0x120>
    }

    return RT_EOK;
    480163fc:	d2800000 	mov	x0, #0x0                   	// #0
}
    48016400:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48016404:	d65f03c0 	ret

0000000048016408 <rt_data_queue_push>:

rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
                            const void *data_ptr,
                            rt_size_t data_size,
                            rt_int32_t timeout)
{
    48016408:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4801640c:	910003fd 	mov	x29, sp
    48016410:	f90017e0 	str	x0, [sp, #40]
    48016414:	f90013e1 	str	x1, [sp, #32]
    48016418:	f9000fe2 	str	x2, [sp, #24]
    4801641c:	b90017e3 	str	w3, [sp, #20]
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;

    RT_ASSERT(queue != RT_NULL);
    48016420:	f94017e0 	ldr	x0, [sp, #40]
    48016424:	f100001f 	cmp	x0, #0x0
    48016428:	540000e1 	b.ne	48016444 <rt_data_queue_push+0x3c>  // b.any
    4801642c:	d2800842 	mov	x2, #0x42                  	// #66
    48016430:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016434:	911c4001 	add	x1, x0, #0x710
    48016438:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801643c:	91196000 	add	x0, x0, #0x658
    48016440:	97ffe70a 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(queue->magic == DATAQUEUE_MAGIC);
    48016444:	f94017e0 	ldr	x0, [sp, #40]
    48016448:	b9400001 	ldr	w1, [x0]
    4801644c:	5281c1c0 	mov	w0, #0xe0e                 	// #3598
    48016450:	72b7d5a0 	movk	w0, #0xbead, lsl #16
    48016454:	6b00003f 	cmp	w1, w0
    48016458:	540000e0 	b.eq	48016474 <rt_data_queue_push+0x6c>  // b.none
    4801645c:	d2800862 	mov	x2, #0x43                  	// #67
    48016460:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016464:	911c4001 	add	x1, x0, #0x710
    48016468:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801646c:	911a0000 	add	x0, x0, #0x680
    48016470:	97ffe6fe 	bl	48010068 <rt_assert_handler>

    result = RT_EOK;
    48016474:	f90023ff 	str	xzr, [sp, #64]
    thread = rt_thread_self();
    48016478:	97ffd5c9 	bl	4800bb9c <rt_thread_self>
    4801647c:	f9001fe0 	str	x0, [sp, #56]

    level = rt_hw_interrupt_disable();
    48016480:	97ffb7eb 	bl	4800442c <rt_hw_interrupt_disable>
    48016484:	f90027e0 	str	x0, [sp, #72]
    while (queue->is_full)
    48016488:	1400003c 	b	48016578 <rt_data_queue_push+0x170>
    {
        /* queue is full */
        if (timeout == 0)
    4801648c:	b94017e0 	ldr	w0, [sp, #20]
    48016490:	7100001f 	cmp	w0, #0x0
    48016494:	54000081 	b.ne	480164a4 <rt_data_queue_push+0x9c>  // b.any
        {
            result = -RT_ETIMEOUT;
    48016498:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    4801649c:	f90023e0 	str	x0, [sp, #64]

            goto __exit;
    480164a0:	1400008f 	b	480166dc <rt_data_queue_push+0x2d4>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
    480164a4:	97ffb7e2 	bl	4800442c <rt_hw_interrupt_disable>
    480164a8:	f9001be0 	str	x0, [sp, #48]
    480164ac:	97ffcc99 	bl	48009710 <rt_interrupt_get_nest>
    480164b0:	12001c00 	and	w0, w0, #0xff
    480164b4:	7100001f 	cmp	w0, #0x0
    480164b8:	54000180 	b.eq	480164e8 <rt_data_queue_push+0xe0>  // b.none
    480164bc:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480164c0:	911c4001 	add	x1, x0, #0x710
    480164c4:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480164c8:	911a8000 	add	x0, x0, #0x6a0
    480164cc:	97ffe619 	bl	4800fd30 <rt_kprintf>
    480164d0:	d2800a82 	mov	x2, #0x54                  	// #84
    480164d4:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480164d8:	911c4001 	add	x1, x0, #0x710
    480164dc:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480164e0:	911b2000 	add	x0, x0, #0x6c8
    480164e4:	97ffe6e1 	bl	48010068 <rt_assert_handler>
    480164e8:	f9401be0 	ldr	x0, [sp, #48]
    480164ec:	97ffb7d4 	bl	4800443c <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
    480164f0:	f9401fe0 	ldr	x0, [sp, #56]
    480164f4:	f9002c1f 	str	xzr, [x0, #88]

        /* suspend thread on the push list */
        rt_thread_suspend(thread);
    480164f8:	f9401fe0 	ldr	x0, [sp, #56]
    480164fc:	97ffd7ab 	bl	4800c3a8 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
    48016500:	f94017e0 	ldr	x0, [sp, #40]
    48016504:	91006002 	add	x2, x0, #0x18
    48016508:	f9401fe0 	ldr	x0, [sp, #56]
    4801650c:	91008000 	add	x0, x0, #0x20
    48016510:	aa0003e1 	mov	x1, x0
    48016514:	aa0203e0 	mov	x0, x2
    48016518:	97ffff54 	bl	48016268 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
    4801651c:	b94017e0 	ldr	w0, [sp, #20]
    48016520:	7100001f 	cmp	w0, #0x0
    48016524:	5400014d 	b.le	4801654c <rt_data_queue_push+0x144>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
    48016528:	f9401fe0 	ldr	x0, [sp, #56]
    4801652c:	91020000 	add	x0, x0, #0x80
    48016530:	910053e1 	add	x1, sp, #0x14
    48016534:	aa0103e2 	mov	x2, x1
    48016538:	52800001 	mov	w1, #0x0                   	// #0
    4801653c:	97ffd2f9 	bl	4800b120 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
    48016540:	f9401fe0 	ldr	x0, [sp, #56]
    48016544:	91020000 	add	x0, x0, #0x80
    48016548:	97ffd1cf 	bl	4800ac84 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    4801654c:	f94027e0 	ldr	x0, [sp, #72]
    48016550:	97ffb7bb 	bl	4800443c <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
    48016554:	97ffdb8e 	bl	4800d38c <rt_schedule>

        /* thread is waked up */
        result = thread->error;
    48016558:	f9401fe0 	ldr	x0, [sp, #56]
    4801655c:	f9402c00 	ldr	x0, [x0, #88]
    48016560:	f90023e0 	str	x0, [sp, #64]
        level = rt_hw_interrupt_disable();
    48016564:	97ffb7b2 	bl	4800442c <rt_hw_interrupt_disable>
    48016568:	f90027e0 	str	x0, [sp, #72]
        if (result != RT_EOK) goto __exit;
    4801656c:	f94023e0 	ldr	x0, [sp, #64]
    48016570:	f100001f 	cmp	x0, #0x0
    48016574:	54000ae1 	b.ne	480166d0 <rt_data_queue_push+0x2c8>  // b.any
    while (queue->is_full)
    48016578:	f94017e0 	ldr	x0, [sp, #40]
    4801657c:	b9400800 	ldr	w0, [x0, #8]
    48016580:	12010000 	and	w0, w0, #0x80000000
    48016584:	7100001f 	cmp	w0, #0x0
    48016588:	54fff821 	b.ne	4801648c <rt_data_queue_push+0x84>  // b.any
    }

    queue->queue[queue->put_index].data_ptr  = data_ptr;
    4801658c:	f94017e0 	ldr	x0, [sp, #40]
    48016590:	f9400801 	ldr	x1, [x0, #16]
    48016594:	f94017e0 	ldr	x0, [sp, #40]
    48016598:	f9400400 	ldr	x0, [x0, #8]
    4801659c:	d3507800 	ubfx	x0, x0, #16, #15
    480165a0:	12003c00 	and	w0, w0, #0xffff
    480165a4:	92403c00 	and	x0, x0, #0xffff
    480165a8:	d37cec00 	lsl	x0, x0, #4
    480165ac:	8b000020 	add	x0, x1, x0
    480165b0:	f94013e1 	ldr	x1, [sp, #32]
    480165b4:	f9000001 	str	x1, [x0]
    queue->queue[queue->put_index].data_size = data_size;
    480165b8:	f94017e0 	ldr	x0, [sp, #40]
    480165bc:	f9400801 	ldr	x1, [x0, #16]
    480165c0:	f94017e0 	ldr	x0, [sp, #40]
    480165c4:	f9400400 	ldr	x0, [x0, #8]
    480165c8:	d3507800 	ubfx	x0, x0, #16, #15
    480165cc:	12003c00 	and	w0, w0, #0xffff
    480165d0:	92403c00 	and	x0, x0, #0xffff
    480165d4:	d37cec00 	lsl	x0, x0, #4
    480165d8:	8b000020 	add	x0, x1, x0
    480165dc:	f9400fe1 	ldr	x1, [sp, #24]
    480165e0:	f9000401 	str	x1, [x0, #8]
    queue->put_index += 1;
    480165e4:	f94017e0 	ldr	x0, [sp, #40]
    480165e8:	f9400400 	ldr	x0, [x0, #8]
    480165ec:	d3507800 	ubfx	x0, x0, #16, #15
    480165f0:	12003c00 	and	w0, w0, #0xffff
    480165f4:	11000400 	add	w0, w0, #0x1
    480165f8:	12003c00 	and	w0, w0, #0xffff
    480165fc:	12003800 	and	w0, w0, #0x7fff
    48016600:	12003c02 	and	w2, w0, #0xffff
    48016604:	f94017e1 	ldr	x1, [sp, #40]
    48016608:	b9400820 	ldr	w0, [x1, #8]
    4801660c:	33103840 	bfi	w0, w2, #16, #15
    48016610:	b9000820 	str	w0, [x1, #8]
    if (queue->put_index == queue->size)
    48016614:	f94017e0 	ldr	x0, [sp, #40]
    48016618:	f9400400 	ldr	x0, [x0, #8]
    4801661c:	d3507800 	ubfx	x0, x0, #16, #15
    48016620:	12003c00 	and	w0, w0, #0xffff
    48016624:	2a0003e1 	mov	w1, w0
    48016628:	f94017e0 	ldr	x0, [sp, #40]
    4801662c:	79400800 	ldrh	w0, [x0, #4]
    48016630:	6b00003f 	cmp	w1, w0
    48016634:	540000a1 	b.ne	48016648 <rt_data_queue_push+0x240>  // b.any
    {
        queue->put_index = 0;
    48016638:	f94017e0 	ldr	x0, [sp, #40]
    4801663c:	b9400801 	ldr	w1, [x0, #8]
    48016640:	12014021 	and	w1, w1, #0x8000ffff
    48016644:	b9000801 	str	w1, [x0, #8]
    }
    queue->is_empty = 0;
    48016648:	f94017e0 	ldr	x0, [sp, #40]
    4801664c:	b9400801 	ldr	w1, [x0, #8]
    48016650:	12107821 	and	w1, w1, #0xffff7fff
    48016654:	b9000801 	str	w1, [x0, #8]
    if (queue->put_index == queue->get_index)
    48016658:	f94017e0 	ldr	x0, [sp, #40]
    4801665c:	f9400400 	ldr	x0, [x0, #8]
    48016660:	d3507800 	ubfx	x0, x0, #16, #15
    48016664:	12003c01 	and	w1, w0, #0xffff
    48016668:	f94017e0 	ldr	x0, [sp, #40]
    4801666c:	f9400400 	ldr	x0, [x0, #8]
    48016670:	d3403800 	ubfx	x0, x0, #0, #15
    48016674:	12003c00 	and	w0, w0, #0xffff
    48016678:	6b00003f 	cmp	w1, w0
    4801667c:	540000a1 	b.ne	48016690 <rt_data_queue_push+0x288>  // b.any
    {
        queue->is_full = 1;
    48016680:	f94017e0 	ldr	x0, [sp, #40]
    48016684:	b9400801 	ldr	w1, [x0, #8]
    48016688:	32010021 	orr	w1, w1, #0x80000000
    4801668c:	b9000801 	str	w1, [x0, #8]
    }

    /* there is at least one thread in suspended list */
    if (!rt_list_isempty(&(queue->suspended_pop_list)))
    48016690:	f94017e0 	ldr	x0, [sp, #40]
    48016694:	9100a000 	add	x0, x0, #0x28
    48016698:	97ffff08 	bl	480162b8 <rt_list_isempty>
    4801669c:	7100001f 	cmp	w0, #0x0
    480166a0:	540001c1 	b.ne	480166d8 <rt_data_queue_push+0x2d0>  // b.any
    {
        /* get thread entry */
        thread = rt_list_entry(queue->suspended_pop_list.next,
    480166a4:	f94017e0 	ldr	x0, [sp, #40]
    480166a8:	f9401400 	ldr	x0, [x0, #40]
    480166ac:	d1008000 	sub	x0, x0, #0x20
    480166b0:	f9001fe0 	str	x0, [sp, #56]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
    480166b4:	f9401fe0 	ldr	x0, [sp, #56]
    480166b8:	97ffd78c 	bl	4800c4e8 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
    480166bc:	f94027e0 	ldr	x0, [sp, #72]
    480166c0:	97ffb75f 	bl	4800443c <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
    480166c4:	97ffdb32 	bl	4800d38c <rt_schedule>

        return result;
    480166c8:	f94023e0 	ldr	x0, [sp, #64]
    480166cc:	14000013 	b	48016718 <rt_data_queue_push+0x310>
        if (result != RT_EOK) goto __exit;
    480166d0:	d503201f 	nop
    480166d4:	14000002 	b	480166dc <rt_data_queue_push+0x2d4>
    }

__exit:
    480166d8:	d503201f 	nop
    rt_hw_interrupt_enable(level);
    480166dc:	f94027e0 	ldr	x0, [sp, #72]
    480166e0:	97ffb757 	bl	4800443c <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
    480166e4:	f94023e0 	ldr	x0, [sp, #64]
    480166e8:	f100001f 	cmp	x0, #0x0
    480166ec:	54000141 	b.ne	48016714 <rt_data_queue_push+0x30c>  // b.any
    480166f0:	f94017e0 	ldr	x0, [sp, #40]
    480166f4:	f9401c00 	ldr	x0, [x0, #56]
    480166f8:	f100001f 	cmp	x0, #0x0
    480166fc:	540000c0 	b.eq	48016714 <rt_data_queue_push+0x30c>  // b.none
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
    48016700:	f94017e0 	ldr	x0, [sp, #40]
    48016704:	f9401c02 	ldr	x2, [x0, #56]
    48016708:	52800041 	mov	w1, #0x2                   	// #2
    4801670c:	f94017e0 	ldr	x0, [sp, #40]
    48016710:	d63f0040 	blr	x2
    }

    return result;
    48016714:	f94023e0 	ldr	x0, [sp, #64]
}
    48016718:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4801671c:	d65f03c0 	ret

0000000048016720 <rt_data_queue_pop>:

rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
                           const void** data_ptr,
                           rt_size_t *size,
                           rt_int32_t timeout)
{
    48016720:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48016724:	910003fd 	mov	x29, sp
    48016728:	f90017e0 	str	x0, [sp, #40]
    4801672c:	f90013e1 	str	x1, [sp, #32]
    48016730:	f9000fe2 	str	x2, [sp, #24]
    48016734:	b90017e3 	str	w3, [sp, #20]
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;

    RT_ASSERT(queue != RT_NULL);
    48016738:	f94017e0 	ldr	x0, [sp, #40]
    4801673c:	f100001f 	cmp	x0, #0x0
    48016740:	540000e1 	b.ne	4801675c <rt_data_queue_pop+0x3c>  // b.any
    48016744:	d28014a2 	mov	x2, #0xa5                  	// #165
    48016748:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801674c:	911ca001 	add	x1, x0, #0x728
    48016750:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016754:	91196000 	add	x0, x0, #0x658
    48016758:	97ffe644 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(queue->magic == DATAQUEUE_MAGIC);
    4801675c:	f94017e0 	ldr	x0, [sp, #40]
    48016760:	b9400001 	ldr	w1, [x0]
    48016764:	5281c1c0 	mov	w0, #0xe0e                 	// #3598
    48016768:	72b7d5a0 	movk	w0, #0xbead, lsl #16
    4801676c:	6b00003f 	cmp	w1, w0
    48016770:	540000e0 	b.eq	4801678c <rt_data_queue_pop+0x6c>  // b.none
    48016774:	d28014c2 	mov	x2, #0xa6                  	// #166
    48016778:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801677c:	911ca001 	add	x1, x0, #0x728
    48016780:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016784:	911a0000 	add	x0, x0, #0x680
    48016788:	97ffe638 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(data_ptr != RT_NULL);
    4801678c:	f94013e0 	ldr	x0, [sp, #32]
    48016790:	f100001f 	cmp	x0, #0x0
    48016794:	540000e1 	b.ne	480167b0 <rt_data_queue_pop+0x90>  // b.any
    48016798:	d28014e2 	mov	x2, #0xa7                  	// #167
    4801679c:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480167a0:	911ca001 	add	x1, x0, #0x728
    480167a4:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480167a8:	911b4000 	add	x0, x0, #0x6d0
    480167ac:	97ffe62f 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(size != RT_NULL);
    480167b0:	f9400fe0 	ldr	x0, [sp, #24]
    480167b4:	f100001f 	cmp	x0, #0x0
    480167b8:	540000e1 	b.ne	480167d4 <rt_data_queue_pop+0xb4>  // b.any
    480167bc:	d2801502 	mov	x2, #0xa8                  	// #168
    480167c0:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480167c4:	911ca001 	add	x1, x0, #0x728
    480167c8:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480167cc:	911ba000 	add	x0, x0, #0x6e8
    480167d0:	97ffe626 	bl	48010068 <rt_assert_handler>

    result = RT_EOK;
    480167d4:	f90023ff 	str	xzr, [sp, #64]
    thread = rt_thread_self();
    480167d8:	97ffd4f1 	bl	4800bb9c <rt_thread_self>
    480167dc:	f9001fe0 	str	x0, [sp, #56]

    level = rt_hw_interrupt_disable();
    480167e0:	97ffb713 	bl	4800442c <rt_hw_interrupt_disable>
    480167e4:	f90027e0 	str	x0, [sp, #72]
    while (queue->is_empty)
    480167e8:	1400003c 	b	480168d8 <rt_data_queue_pop+0x1b8>
    {
        /* queue is empty */
        if (timeout == 0)
    480167ec:	b94017e0 	ldr	w0, [sp, #20]
    480167f0:	7100001f 	cmp	w0, #0x0
    480167f4:	54000081 	b.ne	48016804 <rt_data_queue_pop+0xe4>  // b.any
        {
            result = -RT_ETIMEOUT;
    480167f8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    480167fc:	f90023e0 	str	x0, [sp, #64]
            goto __exit;
    48016800:	140000a4 	b	48016a90 <rt_data_queue_pop+0x370>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
    48016804:	97ffb70a 	bl	4800442c <rt_hw_interrupt_disable>
    48016808:	f9001be0 	str	x0, [sp, #48]
    4801680c:	97ffcbc1 	bl	48009710 <rt_interrupt_get_nest>
    48016810:	12001c00 	and	w0, w0, #0xff
    48016814:	7100001f 	cmp	w0, #0x0
    48016818:	54000180 	b.eq	48016848 <rt_data_queue_pop+0x128>  // b.none
    4801681c:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016820:	911ca001 	add	x1, x0, #0x728
    48016824:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016828:	911a8000 	add	x0, x0, #0x6a0
    4801682c:	97ffe541 	bl	4800fd30 <rt_kprintf>
    48016830:	d2801702 	mov	x2, #0xb8                  	// #184
    48016834:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016838:	911ca001 	add	x1, x0, #0x728
    4801683c:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016840:	911b2000 	add	x0, x0, #0x6c8
    48016844:	97ffe609 	bl	48010068 <rt_assert_handler>
    48016848:	f9401be0 	ldr	x0, [sp, #48]
    4801684c:	97ffb6fc 	bl	4800443c <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
    48016850:	f9401fe0 	ldr	x0, [sp, #56]
    48016854:	f9002c1f 	str	xzr, [x0, #88]

        /* suspend thread on the pop list */
        rt_thread_suspend(thread);
    48016858:	f9401fe0 	ldr	x0, [sp, #56]
    4801685c:	97ffd6d3 	bl	4800c3a8 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
    48016860:	f94017e0 	ldr	x0, [sp, #40]
    48016864:	9100a002 	add	x2, x0, #0x28
    48016868:	f9401fe0 	ldr	x0, [sp, #56]
    4801686c:	91008000 	add	x0, x0, #0x20
    48016870:	aa0003e1 	mov	x1, x0
    48016874:	aa0203e0 	mov	x0, x2
    48016878:	97fffe7c 	bl	48016268 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
    4801687c:	b94017e0 	ldr	w0, [sp, #20]
    48016880:	7100001f 	cmp	w0, #0x0
    48016884:	5400014d 	b.le	480168ac <rt_data_queue_pop+0x18c>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
    48016888:	f9401fe0 	ldr	x0, [sp, #56]
    4801688c:	91020000 	add	x0, x0, #0x80
    48016890:	910053e1 	add	x1, sp, #0x14
    48016894:	aa0103e2 	mov	x2, x1
    48016898:	52800001 	mov	w1, #0x0                   	// #0
    4801689c:	97ffd221 	bl	4800b120 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
    480168a0:	f9401fe0 	ldr	x0, [sp, #56]
    480168a4:	91020000 	add	x0, x0, #0x80
    480168a8:	97ffd0f7 	bl	4800ac84 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    480168ac:	f94027e0 	ldr	x0, [sp, #72]
    480168b0:	97ffb6e3 	bl	4800443c <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
    480168b4:	97ffdab6 	bl	4800d38c <rt_schedule>

        /* thread is waked up */
        result = thread->error;
    480168b8:	f9401fe0 	ldr	x0, [sp, #56]
    480168bc:	f9402c00 	ldr	x0, [x0, #88]
    480168c0:	f90023e0 	str	x0, [sp, #64]
        level  = rt_hw_interrupt_disable();
    480168c4:	97ffb6da 	bl	4800442c <rt_hw_interrupt_disable>
    480168c8:	f90027e0 	str	x0, [sp, #72]
        if (result != RT_EOK)
    480168cc:	f94023e0 	ldr	x0, [sp, #64]
    480168d0:	f100001f 	cmp	x0, #0x0
    480168d4:	54000d81 	b.ne	48016a84 <rt_data_queue_pop+0x364>  // b.any
    while (queue->is_empty)
    480168d8:	f94017e0 	ldr	x0, [sp, #40]
    480168dc:	b9400800 	ldr	w0, [x0, #8]
    480168e0:	12110000 	and	w0, w0, #0x8000
    480168e4:	7100001f 	cmp	w0, #0x0
    480168e8:	54fff821 	b.ne	480167ec <rt_data_queue_pop+0xcc>  // b.any
            goto __exit;
    }

    *data_ptr = queue->queue[queue->get_index].data_ptr;
    480168ec:	f94017e0 	ldr	x0, [sp, #40]
    480168f0:	f9400801 	ldr	x1, [x0, #16]
    480168f4:	f94017e0 	ldr	x0, [sp, #40]
    480168f8:	f9400400 	ldr	x0, [x0, #8]
    480168fc:	d3403800 	ubfx	x0, x0, #0, #15
    48016900:	12003c00 	and	w0, w0, #0xffff
    48016904:	92403c00 	and	x0, x0, #0xffff
    48016908:	d37cec00 	lsl	x0, x0, #4
    4801690c:	8b000020 	add	x0, x1, x0
    48016910:	f9400001 	ldr	x1, [x0]
    48016914:	f94013e0 	ldr	x0, [sp, #32]
    48016918:	f9000001 	str	x1, [x0]
    *size     = queue->queue[queue->get_index].data_size;
    4801691c:	f94017e0 	ldr	x0, [sp, #40]
    48016920:	f9400801 	ldr	x1, [x0, #16]
    48016924:	f94017e0 	ldr	x0, [sp, #40]
    48016928:	f9400400 	ldr	x0, [x0, #8]
    4801692c:	d3403800 	ubfx	x0, x0, #0, #15
    48016930:	12003c00 	and	w0, w0, #0xffff
    48016934:	92403c00 	and	x0, x0, #0xffff
    48016938:	d37cec00 	lsl	x0, x0, #4
    4801693c:	8b000020 	add	x0, x1, x0
    48016940:	f9400401 	ldr	x1, [x0, #8]
    48016944:	f9400fe0 	ldr	x0, [sp, #24]
    48016948:	f9000001 	str	x1, [x0]
    queue->get_index += 1;
    4801694c:	f94017e0 	ldr	x0, [sp, #40]
    48016950:	f9400400 	ldr	x0, [x0, #8]
    48016954:	d3403800 	ubfx	x0, x0, #0, #15
    48016958:	12003c00 	and	w0, w0, #0xffff
    4801695c:	11000400 	add	w0, w0, #0x1
    48016960:	12003c00 	and	w0, w0, #0xffff
    48016964:	12003800 	and	w0, w0, #0x7fff
    48016968:	12003c02 	and	w2, w0, #0xffff
    4801696c:	f94017e1 	ldr	x1, [sp, #40]
    48016970:	b9400820 	ldr	w0, [x1, #8]
    48016974:	33003840 	bfxil	w0, w2, #0, #15
    48016978:	b9000820 	str	w0, [x1, #8]
    if (queue->get_index == queue->size)
    4801697c:	f94017e0 	ldr	x0, [sp, #40]
    48016980:	f9400400 	ldr	x0, [x0, #8]
    48016984:	d3403800 	ubfx	x0, x0, #0, #15
    48016988:	12003c00 	and	w0, w0, #0xffff
    4801698c:	2a0003e1 	mov	w1, w0
    48016990:	f94017e0 	ldr	x0, [sp, #40]
    48016994:	79400800 	ldrh	w0, [x0, #4]
    48016998:	6b00003f 	cmp	w1, w0
    4801699c:	540000a1 	b.ne	480169b0 <rt_data_queue_pop+0x290>  // b.any
    {
        queue->get_index = 0;
    480169a0:	f94017e0 	ldr	x0, [sp, #40]
    480169a4:	b9400801 	ldr	w1, [x0, #8]
    480169a8:	12114021 	and	w1, w1, #0xffff8000
    480169ac:	b9000801 	str	w1, [x0, #8]
    }
    queue->is_full = 0;
    480169b0:	f94017e0 	ldr	x0, [sp, #40]
    480169b4:	b9400801 	ldr	w1, [x0, #8]
    480169b8:	12007821 	and	w1, w1, #0x7fffffff
    480169bc:	b9000801 	str	w1, [x0, #8]
    if (queue->put_index == queue->get_index)
    480169c0:	f94017e0 	ldr	x0, [sp, #40]
    480169c4:	f9400400 	ldr	x0, [x0, #8]
    480169c8:	d3507800 	ubfx	x0, x0, #16, #15
    480169cc:	12003c01 	and	w1, w0, #0xffff
    480169d0:	f94017e0 	ldr	x0, [sp, #40]
    480169d4:	f9400400 	ldr	x0, [x0, #8]
    480169d8:	d3403800 	ubfx	x0, x0, #0, #15
    480169dc:	12003c00 	and	w0, w0, #0xffff
    480169e0:	6b00003f 	cmp	w1, w0
    480169e4:	540000a1 	b.ne	480169f8 <rt_data_queue_pop+0x2d8>  // b.any
    {
        queue->is_empty = 1;
    480169e8:	f94017e0 	ldr	x0, [sp, #40]
    480169ec:	b9400801 	ldr	w1, [x0, #8]
    480169f0:	32110021 	orr	w1, w1, #0x8000
    480169f4:	b9000801 	str	w1, [x0, #8]
    }

    if (rt_data_queue_len(queue) <= queue->lwm)
    480169f8:	f94017e0 	ldr	x0, [sp, #40]
    480169fc:	940000f4 	bl	48016dcc <rt_data_queue_len>
    48016a00:	12003c01 	and	w1, w0, #0xffff
    48016a04:	f94017e0 	ldr	x0, [sp, #40]
    48016a08:	79400c00 	ldrh	w0, [x0, #6]
    48016a0c:	6b00003f 	cmp	w1, w0
    48016a10:	540003e8 	b.hi	48016a8c <rt_data_queue_pop+0x36c>  // b.pmore
    {
        /* there is at least one thread in suspended list */
        if (!rt_list_isempty(&(queue->suspended_push_list)))
    48016a14:	f94017e0 	ldr	x0, [sp, #40]
    48016a18:	91006000 	add	x0, x0, #0x18
    48016a1c:	97fffe27 	bl	480162b8 <rt_list_isempty>
    48016a20:	7100001f 	cmp	w0, #0x0
    48016a24:	54000161 	b.ne	48016a50 <rt_data_queue_pop+0x330>  // b.any
        {
            /* get thread entry */
            thread = rt_list_entry(queue->suspended_push_list.next,
    48016a28:	f94017e0 	ldr	x0, [sp, #40]
    48016a2c:	f9400c00 	ldr	x0, [x0, #24]
    48016a30:	d1008000 	sub	x0, x0, #0x20
    48016a34:	f9001fe0 	str	x0, [sp, #56]
                                   struct rt_thread,
                                   tlist);

            /* resume it */
            rt_thread_resume(thread);
    48016a38:	f9401fe0 	ldr	x0, [sp, #56]
    48016a3c:	97ffd6ab 	bl	4800c4e8 <rt_thread_resume>
            rt_hw_interrupt_enable(level);
    48016a40:	f94027e0 	ldr	x0, [sp, #72]
    48016a44:	97ffb67e 	bl	4800443c <rt_hw_interrupt_enable>

            /* perform a schedule */
            rt_schedule();
    48016a48:	97ffda51 	bl	4800d38c <rt_schedule>
    48016a4c:	14000003 	b	48016a58 <rt_data_queue_pop+0x338>
        }
        else
        {
            rt_hw_interrupt_enable(level);
    48016a50:	f94027e0 	ldr	x0, [sp, #72]
    48016a54:	97ffb67a 	bl	4800443c <rt_hw_interrupt_enable>
        }

        if (queue->evt_notify != RT_NULL)
    48016a58:	f94017e0 	ldr	x0, [sp, #40]
    48016a5c:	f9401c00 	ldr	x0, [x0, #56]
    48016a60:	f100001f 	cmp	x0, #0x0
    48016a64:	540000c0 	b.eq	48016a7c <rt_data_queue_pop+0x35c>  // b.none
            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
    48016a68:	f94017e0 	ldr	x0, [sp, #40]
    48016a6c:	f9401c02 	ldr	x2, [x0, #56]
    48016a70:	52800061 	mov	w1, #0x3                   	// #3
    48016a74:	f94017e0 	ldr	x0, [sp, #40]
    48016a78:	d63f0040 	blr	x2

        return result;
    48016a7c:	f94023e0 	ldr	x0, [sp, #64]
    48016a80:	14000013 	b	48016acc <rt_data_queue_pop+0x3ac>
            goto __exit;
    48016a84:	d503201f 	nop
    48016a88:	14000002 	b	48016a90 <rt_data_queue_pop+0x370>
    }

__exit:
    48016a8c:	d503201f 	nop
    rt_hw_interrupt_enable(level);
    48016a90:	f94027e0 	ldr	x0, [sp, #72]
    48016a94:	97ffb66a 	bl	4800443c <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
    48016a98:	f94023e0 	ldr	x0, [sp, #64]
    48016a9c:	f100001f 	cmp	x0, #0x0
    48016aa0:	54000141 	b.ne	48016ac8 <rt_data_queue_pop+0x3a8>  // b.any
    48016aa4:	f94017e0 	ldr	x0, [sp, #40]
    48016aa8:	f9401c00 	ldr	x0, [x0, #56]
    48016aac:	f100001f 	cmp	x0, #0x0
    48016ab0:	540000c0 	b.eq	48016ac8 <rt_data_queue_pop+0x3a8>  // b.none
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
    48016ab4:	f94017e0 	ldr	x0, [sp, #40]
    48016ab8:	f9401c02 	ldr	x2, [x0, #56]
    48016abc:	52800021 	mov	w1, #0x1                   	// #1
    48016ac0:	f94017e0 	ldr	x0, [sp, #40]
    48016ac4:	d63f0040 	blr	x2
    }

    return result;
    48016ac8:	f94023e0 	ldr	x0, [sp, #64]
}
    48016acc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48016ad0:	d65f03c0 	ret

0000000048016ad4 <rt_data_queue_peek>:
RTM_EXPORT(rt_data_queue_pop);

rt_err_t rt_data_queue_peek(struct rt_data_queue *queue,
                            const void** data_ptr,
                            rt_size_t *size)
{
    48016ad4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48016ad8:	910003fd 	mov	x29, sp
    48016adc:	f90017e0 	str	x0, [sp, #40]
    48016ae0:	f90013e1 	str	x1, [sp, #32]
    48016ae4:	f9000fe2 	str	x2, [sp, #24]
    rt_ubase_t  level;

    RT_ASSERT(queue != RT_NULL);
    48016ae8:	f94017e0 	ldr	x0, [sp, #40]
    48016aec:	f100001f 	cmp	x0, #0x0
    48016af0:	540000e1 	b.ne	48016b0c <rt_data_queue_peek+0x38>  // b.any
    48016af4:	d2802222 	mov	x2, #0x111                 	// #273
    48016af8:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016afc:	911d0001 	add	x1, x0, #0x740
    48016b00:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016b04:	91196000 	add	x0, x0, #0x658
    48016b08:	97ffe558 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(queue->magic == DATAQUEUE_MAGIC);
    48016b0c:	f94017e0 	ldr	x0, [sp, #40]
    48016b10:	b9400001 	ldr	w1, [x0]
    48016b14:	5281c1c0 	mov	w0, #0xe0e                 	// #3598
    48016b18:	72b7d5a0 	movk	w0, #0xbead, lsl #16
    48016b1c:	6b00003f 	cmp	w1, w0
    48016b20:	540000e0 	b.eq	48016b3c <rt_data_queue_peek+0x68>  // b.none
    48016b24:	d2802242 	mov	x2, #0x112                 	// #274
    48016b28:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016b2c:	911d0001 	add	x1, x0, #0x740
    48016b30:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016b34:	911a0000 	add	x0, x0, #0x680
    48016b38:	97ffe54c 	bl	48010068 <rt_assert_handler>

    if (queue->is_empty)
    48016b3c:	f94017e0 	ldr	x0, [sp, #40]
    48016b40:	b9400800 	ldr	w0, [x0, #8]
    48016b44:	12110000 	and	w0, w0, #0x8000
    48016b48:	7100001f 	cmp	w0, #0x0
    48016b4c:	54000060 	b.eq	48016b58 <rt_data_queue_peek+0x84>  // b.none
    {
        return -RT_EEMPTY;
    48016b50:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
    48016b54:	1400001e 	b	48016bcc <rt_data_queue_peek+0xf8>
    }

    level = rt_hw_interrupt_disable();
    48016b58:	97ffb635 	bl	4800442c <rt_hw_interrupt_disable>
    48016b5c:	f9001fe0 	str	x0, [sp, #56]

    *data_ptr = queue->queue[queue->get_index].data_ptr;
    48016b60:	f94017e0 	ldr	x0, [sp, #40]
    48016b64:	f9400801 	ldr	x1, [x0, #16]
    48016b68:	f94017e0 	ldr	x0, [sp, #40]
    48016b6c:	f9400400 	ldr	x0, [x0, #8]
    48016b70:	d3403800 	ubfx	x0, x0, #0, #15
    48016b74:	12003c00 	and	w0, w0, #0xffff
    48016b78:	92403c00 	and	x0, x0, #0xffff
    48016b7c:	d37cec00 	lsl	x0, x0, #4
    48016b80:	8b000020 	add	x0, x1, x0
    48016b84:	f9400001 	ldr	x1, [x0]
    48016b88:	f94013e0 	ldr	x0, [sp, #32]
    48016b8c:	f9000001 	str	x1, [x0]
    *size     = queue->queue[queue->get_index].data_size;
    48016b90:	f94017e0 	ldr	x0, [sp, #40]
    48016b94:	f9400801 	ldr	x1, [x0, #16]
    48016b98:	f94017e0 	ldr	x0, [sp, #40]
    48016b9c:	f9400400 	ldr	x0, [x0, #8]
    48016ba0:	d3403800 	ubfx	x0, x0, #0, #15
    48016ba4:	12003c00 	and	w0, w0, #0xffff
    48016ba8:	92403c00 	and	x0, x0, #0xffff
    48016bac:	d37cec00 	lsl	x0, x0, #4
    48016bb0:	8b000020 	add	x0, x1, x0
    48016bb4:	f9400401 	ldr	x1, [x0, #8]
    48016bb8:	f9400fe0 	ldr	x0, [sp, #24]
    48016bbc:	f9000001 	str	x1, [x0]

    rt_hw_interrupt_enable(level);
    48016bc0:	f9401fe0 	ldr	x0, [sp, #56]
    48016bc4:	97ffb61e 	bl	4800443c <rt_hw_interrupt_enable>

    return RT_EOK;
    48016bc8:	d2800000 	mov	x0, #0x0                   	// #0
}
    48016bcc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48016bd0:	d65f03c0 	ret

0000000048016bd4 <rt_data_queue_reset>:
RTM_EXPORT(rt_data_queue_peek);

void rt_data_queue_reset(struct rt_data_queue *queue)
{
    48016bd4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48016bd8:	910003fd 	mov	x29, sp
    48016bdc:	f9000fe0 	str	x0, [sp, #24]
    rt_ubase_t  level;
    struct rt_thread *thread;

    RT_ASSERT(queue != RT_NULL);
    48016be0:	f9400fe0 	ldr	x0, [sp, #24]
    48016be4:	f100001f 	cmp	x0, #0x0
    48016be8:	540000e1 	b.ne	48016c04 <rt_data_queue_reset+0x30>  // b.any
    48016bec:	d2802522 	mov	x2, #0x129                 	// #297
    48016bf0:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016bf4:	911d6001 	add	x1, x0, #0x758
    48016bf8:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016bfc:	91196000 	add	x0, x0, #0x658
    48016c00:	97ffe51a 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(queue->magic == DATAQUEUE_MAGIC);
    48016c04:	f9400fe0 	ldr	x0, [sp, #24]
    48016c08:	b9400001 	ldr	w1, [x0]
    48016c0c:	5281c1c0 	mov	w0, #0xe0e                 	// #3598
    48016c10:	72b7d5a0 	movk	w0, #0xbead, lsl #16
    48016c14:	6b00003f 	cmp	w1, w0
    48016c18:	540000e0 	b.eq	48016c34 <rt_data_queue_reset+0x60>  // b.none
    48016c1c:	d2802542 	mov	x2, #0x12a                 	// #298
    48016c20:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016c24:	911d6001 	add	x1, x0, #0x758
    48016c28:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016c2c:	911a0000 	add	x0, x0, #0x680
    48016c30:	97ffe50e 	bl	48010068 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
    48016c34:	97ffb5fe 	bl	4800442c <rt_hw_interrupt_disable>
    48016c38:	f90017e0 	str	x0, [sp, #40]

    queue->get_index = 0;
    48016c3c:	f9400fe0 	ldr	x0, [sp, #24]
    48016c40:	b9400801 	ldr	w1, [x0, #8]
    48016c44:	12114021 	and	w1, w1, #0xffff8000
    48016c48:	b9000801 	str	w1, [x0, #8]
    queue->put_index = 0;
    48016c4c:	f9400fe0 	ldr	x0, [sp, #24]
    48016c50:	b9400801 	ldr	w1, [x0, #8]
    48016c54:	12014021 	and	w1, w1, #0x8000ffff
    48016c58:	b9000801 	str	w1, [x0, #8]
    queue->is_empty = 1;
    48016c5c:	f9400fe0 	ldr	x0, [sp, #24]
    48016c60:	b9400801 	ldr	w1, [x0, #8]
    48016c64:	32110021 	orr	w1, w1, #0x8000
    48016c68:	b9000801 	str	w1, [x0, #8]
    queue->is_full = 0;
    48016c6c:	f9400fe0 	ldr	x0, [sp, #24]
    48016c70:	b9400801 	ldr	w1, [x0, #8]
    48016c74:	12007821 	and	w1, w1, #0x7fffffff
    48016c78:	b9000801 	str	w1, [x0, #8]

    rt_hw_interrupt_enable(level);
    48016c7c:	f94017e0 	ldr	x0, [sp, #40]
    48016c80:	97ffb5ef 	bl	4800443c <rt_hw_interrupt_enable>

    rt_enter_critical();
    48016c84:	97ffdae5 	bl	4800d818 <rt_enter_critical>
    /* wakeup all suspend threads */

    /* resume on pop list */
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
    48016c88:	1400000e 	b	48016cc0 <rt_data_queue_reset+0xec>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    48016c8c:	97ffb5e8 	bl	4800442c <rt_hw_interrupt_disable>
    48016c90:	f90017e0 	str	x0, [sp, #40]

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_pop_list.next,
    48016c94:	f9400fe0 	ldr	x0, [sp, #24]
    48016c98:	f9401400 	ldr	x0, [x0, #40]
    48016c9c:	d1008000 	sub	x0, x0, #0x20
    48016ca0:	f90013e0 	str	x0, [sp, #32]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
    48016ca4:	f94013e0 	ldr	x0, [sp, #32]
    48016ca8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    48016cac:	f9002c01 	str	x1, [x0, #88]
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
    48016cb0:	f94013e0 	ldr	x0, [sp, #32]
    48016cb4:	97ffd60d 	bl	4800c4e8 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    48016cb8:	f94017e0 	ldr	x0, [sp, #40]
    48016cbc:	97ffb5e0 	bl	4800443c <rt_hw_interrupt_enable>
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
    48016cc0:	f9400fe0 	ldr	x0, [sp, #24]
    48016cc4:	9100a000 	add	x0, x0, #0x28
    48016cc8:	97fffd7c 	bl	480162b8 <rt_list_isempty>
    48016ccc:	7100001f 	cmp	w0, #0x0
    48016cd0:	54fffde0 	b.eq	48016c8c <rt_data_queue_reset+0xb8>  // b.none
    }

    /* resume on push list */
    while (!rt_list_isempty(&(queue->suspended_push_list)))
    48016cd4:	1400000e 	b	48016d0c <rt_data_queue_reset+0x138>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
    48016cd8:	97ffb5d5 	bl	4800442c <rt_hw_interrupt_disable>
    48016cdc:	f90017e0 	str	x0, [sp, #40]

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_push_list.next,
    48016ce0:	f9400fe0 	ldr	x0, [sp, #24]
    48016ce4:	f9400c00 	ldr	x0, [x0, #24]
    48016ce8:	d1008000 	sub	x0, x0, #0x20
    48016cec:	f90013e0 	str	x0, [sp, #32]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
    48016cf0:	f94013e0 	ldr	x0, [sp, #32]
    48016cf4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    48016cf8:	f9002c01 	str	x1, [x0, #88]
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
    48016cfc:	f94013e0 	ldr	x0, [sp, #32]
    48016d00:	97ffd5fa 	bl	4800c4e8 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
    48016d04:	f94017e0 	ldr	x0, [sp, #40]
    48016d08:	97ffb5cd 	bl	4800443c <rt_hw_interrupt_enable>
    while (!rt_list_isempty(&(queue->suspended_push_list)))
    48016d0c:	f9400fe0 	ldr	x0, [sp, #24]
    48016d10:	91006000 	add	x0, x0, #0x18
    48016d14:	97fffd69 	bl	480162b8 <rt_list_isempty>
    48016d18:	7100001f 	cmp	w0, #0x0
    48016d1c:	54fffde0 	b.eq	48016cd8 <rt_data_queue_reset+0x104>  // b.none
    }
    rt_exit_critical();
    48016d20:	97ffdad3 	bl	4800d86c <rt_exit_critical>

    rt_schedule();
    48016d24:	97ffd99a 	bl	4800d38c <rt_schedule>
}
    48016d28:	d503201f 	nop
    48016d2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48016d30:	d65f03c0 	ret

0000000048016d34 <rt_data_queue_deinit>:
RTM_EXPORT(rt_data_queue_reset);

rt_err_t rt_data_queue_deinit(struct rt_data_queue *queue)
{
    48016d34:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48016d38:	910003fd 	mov	x29, sp
    48016d3c:	f9000fe0 	str	x0, [sp, #24]
    rt_ubase_t level;

    RT_ASSERT(queue != RT_NULL);
    48016d40:	f9400fe0 	ldr	x0, [sp, #24]
    48016d44:	f100001f 	cmp	x0, #0x0
    48016d48:	540000e1 	b.ne	48016d64 <rt_data_queue_deinit+0x30>  // b.any
    48016d4c:	d2802e22 	mov	x2, #0x171                 	// #369
    48016d50:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016d54:	911dc001 	add	x1, x0, #0x770
    48016d58:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016d5c:	91196000 	add	x0, x0, #0x658
    48016d60:	97ffe4c2 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(queue->magic == DATAQUEUE_MAGIC);
    48016d64:	f9400fe0 	ldr	x0, [sp, #24]
    48016d68:	b9400001 	ldr	w1, [x0]
    48016d6c:	5281c1c0 	mov	w0, #0xe0e                 	// #3598
    48016d70:	72b7d5a0 	movk	w0, #0xbead, lsl #16
    48016d74:	6b00003f 	cmp	w1, w0
    48016d78:	540000e0 	b.eq	48016d94 <rt_data_queue_deinit+0x60>  // b.none
    48016d7c:	d2802e42 	mov	x2, #0x172                 	// #370
    48016d80:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016d84:	911dc001 	add	x1, x0, #0x770
    48016d88:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016d8c:	911a0000 	add	x0, x0, #0x680
    48016d90:	97ffe4b6 	bl	48010068 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_data_queue_reset(queue);
    48016d94:	f9400fe0 	ldr	x0, [sp, #24]
    48016d98:	97ffff8f 	bl	48016bd4 <rt_data_queue_reset>

    level = rt_hw_interrupt_disable();
    48016d9c:	97ffb5a4 	bl	4800442c <rt_hw_interrupt_disable>
    48016da0:	f90017e0 	str	x0, [sp, #40]
    queue->magic = 0;
    48016da4:	f9400fe0 	ldr	x0, [sp, #24]
    48016da8:	b900001f 	str	wzr, [x0]
    rt_hw_interrupt_enable(level);
    48016dac:	f94017e0 	ldr	x0, [sp, #40]
    48016db0:	97ffb5a3 	bl	4800443c <rt_hw_interrupt_enable>

    rt_free(queue->queue);
    48016db4:	f9400fe0 	ldr	x0, [sp, #24]
    48016db8:	f9400800 	ldr	x0, [x0, #16]
    48016dbc:	97ffcd82 	bl	4800a3c4 <rt_free>

    return RT_EOK;
    48016dc0:	d2800000 	mov	x0, #0x0                   	// #0
}
    48016dc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48016dc8:	d65f03c0 	ret

0000000048016dcc <rt_data_queue_len>:
RTM_EXPORT(rt_data_queue_deinit);

rt_uint16_t rt_data_queue_len(struct rt_data_queue *queue)
{
    48016dcc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48016dd0:	910003fd 	mov	x29, sp
    48016dd4:	f9000fe0 	str	x0, [sp, #24]
    rt_ubase_t level;
    rt_int16_t len;

    RT_ASSERT(queue != RT_NULL);
    48016dd8:	f9400fe0 	ldr	x0, [sp, #24]
    48016ddc:	f100001f 	cmp	x0, #0x0
    48016de0:	540000e1 	b.ne	48016dfc <rt_data_queue_len+0x30>  // b.any
    48016de4:	d28030c2 	mov	x2, #0x186                 	// #390
    48016de8:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016dec:	911e2001 	add	x1, x0, #0x788
    48016df0:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016df4:	91196000 	add	x0, x0, #0x658
    48016df8:	97ffe49c 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(queue->magic == DATAQUEUE_MAGIC);
    48016dfc:	f9400fe0 	ldr	x0, [sp, #24]
    48016e00:	b9400001 	ldr	w1, [x0]
    48016e04:	5281c1c0 	mov	w0, #0xe0e                 	// #3598
    48016e08:	72b7d5a0 	movk	w0, #0xbead, lsl #16
    48016e0c:	6b00003f 	cmp	w1, w0
    48016e10:	540000e0 	b.eq	48016e2c <rt_data_queue_len+0x60>  // b.none
    48016e14:	d28030e2 	mov	x2, #0x187                 	// #391
    48016e18:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016e1c:	911e2001 	add	x1, x0, #0x788
    48016e20:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016e24:	911a0000 	add	x0, x0, #0x680
    48016e28:	97ffe490 	bl	48010068 <rt_assert_handler>

    if (queue->is_empty)
    48016e2c:	f9400fe0 	ldr	x0, [sp, #24]
    48016e30:	b9400800 	ldr	w0, [x0, #8]
    48016e34:	12110000 	and	w0, w0, #0x8000
    48016e38:	7100001f 	cmp	w0, #0x0
    48016e3c:	54000060 	b.eq	48016e48 <rt_data_queue_len+0x7c>  // b.none
    {
        return 0;
    48016e40:	52800000 	mov	w0, #0x0                   	// #0
    48016e44:	1400002c 	b	48016ef4 <rt_data_queue_len+0x128>
    }

    level = rt_hw_interrupt_disable();
    48016e48:	97ffb579 	bl	4800442c <rt_hw_interrupt_disable>
    48016e4c:	f90013e0 	str	x0, [sp, #32]

    if (queue->put_index > queue->get_index)
    48016e50:	f9400fe0 	ldr	x0, [sp, #24]
    48016e54:	f9400400 	ldr	x0, [x0, #8]
    48016e58:	d3507800 	ubfx	x0, x0, #16, #15
    48016e5c:	12003c01 	and	w1, w0, #0xffff
    48016e60:	f9400fe0 	ldr	x0, [sp, #24]
    48016e64:	f9400400 	ldr	x0, [x0, #8]
    48016e68:	d3403800 	ubfx	x0, x0, #0, #15
    48016e6c:	12003c00 	and	w0, w0, #0xffff
    48016e70:	6b00003f 	cmp	w1, w0
    48016e74:	540001c9 	b.ls	48016eac <rt_data_queue_len+0xe0>  // b.plast
    {
        len = queue->put_index - queue->get_index;
    48016e78:	f9400fe0 	ldr	x0, [sp, #24]
    48016e7c:	f9400400 	ldr	x0, [x0, #8]
    48016e80:	d3507800 	ubfx	x0, x0, #16, #15
    48016e84:	12003c00 	and	w0, w0, #0xffff
    48016e88:	2a0003e1 	mov	w1, w0
    48016e8c:	f9400fe0 	ldr	x0, [sp, #24]
    48016e90:	f9400400 	ldr	x0, [x0, #8]
    48016e94:	d3403800 	ubfx	x0, x0, #0, #15
    48016e98:	12003c00 	and	w0, w0, #0xffff
    48016e9c:	4b000020 	sub	w0, w1, w0
    48016ea0:	12003c00 	and	w0, w0, #0xffff
    48016ea4:	79005fe0 	strh	w0, [sp, #46]
    48016ea8:	14000010 	b	48016ee8 <rt_data_queue_len+0x11c>
    }
    else
    {
        len = queue->size + queue->put_index - queue->get_index;
    48016eac:	f9400fe0 	ldr	x0, [sp, #24]
    48016eb0:	79400800 	ldrh	w0, [x0, #4]
    48016eb4:	f9400fe1 	ldr	x1, [sp, #24]
    48016eb8:	f9400421 	ldr	x1, [x1, #8]
    48016ebc:	d3507821 	ubfx	x1, x1, #16, #15
    48016ec0:	12003c21 	and	w1, w1, #0xffff
    48016ec4:	0b010000 	add	w0, w0, w1
    48016ec8:	12003c00 	and	w0, w0, #0xffff
    48016ecc:	f9400fe1 	ldr	x1, [sp, #24]
    48016ed0:	f9400421 	ldr	x1, [x1, #8]
    48016ed4:	d3403821 	ubfx	x1, x1, #0, #15
    48016ed8:	12003c21 	and	w1, w1, #0xffff
    48016edc:	4b010000 	sub	w0, w0, w1
    48016ee0:	12003c00 	and	w0, w0, #0xffff
    48016ee4:	79005fe0 	strh	w0, [sp, #46]
    }

    rt_hw_interrupt_enable(level);
    48016ee8:	f94013e0 	ldr	x0, [sp, #32]
    48016eec:	97ffb554 	bl	4800443c <rt_hw_interrupt_enable>

    return len;
    48016ef0:	79405fe0 	ldrh	w0, [sp, #46]
}
    48016ef4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48016ef8:	d65f03c0 	ret

0000000048016efc <rt_list_init>:
{
    48016efc:	d10043ff 	sub	sp, sp, #0x10
    48016f00:	f90007e0 	str	x0, [sp, #8]
    l->next = l->prev = l;
    48016f04:	f94007e0 	ldr	x0, [sp, #8]
    48016f08:	f94007e1 	ldr	x1, [sp, #8]
    48016f0c:	f9000401 	str	x1, [x0, #8]
    48016f10:	f94007e0 	ldr	x0, [sp, #8]
    48016f14:	f9400401 	ldr	x1, [x0, #8]
    48016f18:	f94007e0 	ldr	x0, [sp, #8]
    48016f1c:	f9000001 	str	x1, [x0]
}
    48016f20:	d503201f 	nop
    48016f24:	910043ff 	add	sp, sp, #0x10
    48016f28:	d65f03c0 	ret

0000000048016f2c <rt_list_insert_before>:
{
    48016f2c:	d10043ff 	sub	sp, sp, #0x10
    48016f30:	f90007e0 	str	x0, [sp, #8]
    48016f34:	f90003e1 	str	x1, [sp]
    l->prev->next = n;
    48016f38:	f94007e0 	ldr	x0, [sp, #8]
    48016f3c:	f9400400 	ldr	x0, [x0, #8]
    48016f40:	f94003e1 	ldr	x1, [sp]
    48016f44:	f9000001 	str	x1, [x0]
    n->prev = l->prev;
    48016f48:	f94007e0 	ldr	x0, [sp, #8]
    48016f4c:	f9400401 	ldr	x1, [x0, #8]
    48016f50:	f94003e0 	ldr	x0, [sp]
    48016f54:	f9000401 	str	x1, [x0, #8]
    l->prev = n;
    48016f58:	f94007e0 	ldr	x0, [sp, #8]
    48016f5c:	f94003e1 	ldr	x1, [sp]
    48016f60:	f9000401 	str	x1, [x0, #8]
    n->next = l;
    48016f64:	f94003e0 	ldr	x0, [sp]
    48016f68:	f94007e1 	ldr	x1, [sp, #8]
    48016f6c:	f9000001 	str	x1, [x0]
}
    48016f70:	d503201f 	nop
    48016f74:	910043ff 	add	sp, sp, #0x10
    48016f78:	d65f03c0 	ret

0000000048016f7c <rt_list_isempty>:
{
    48016f7c:	d10043ff 	sub	sp, sp, #0x10
    48016f80:	f90007e0 	str	x0, [sp, #8]
    return l->next == l;
    48016f84:	f94007e0 	ldr	x0, [sp, #8]
    48016f88:	f9400000 	ldr	x0, [x0]
    48016f8c:	f94007e1 	ldr	x1, [sp, #8]
    48016f90:	eb00003f 	cmp	x1, x0
    48016f94:	1a9f17e0 	cset	w0, eq  // eq = none
    48016f98:	12001c00 	and	w0, w0, #0xff
}
    48016f9c:	910043ff 	add	sp, sp, #0x10
    48016fa0:	d65f03c0 	ret

0000000048016fa4 <rt_completion_init>:
 * @brief This function will initialize a completion object.
 *
 * @param completion is a pointer to a completion object.
 */
void rt_completion_init(struct rt_completion *completion)
{
    48016fa4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48016fa8:	910003fd 	mov	x29, sp
    48016fac:	f9000fe0 	str	x0, [sp, #24]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
    48016fb0:	f9400fe0 	ldr	x0, [sp, #24]
    48016fb4:	f100001f 	cmp	x0, #0x0
    48016fb8:	540000e1 	b.ne	48016fd4 <rt_completion_init+0x30>  // b.any
    48016fbc:	d2800362 	mov	x2, #0x1b                  	// #27
    48016fc0:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016fc4:	91206001 	add	x1, x0, #0x818
    48016fc8:	d0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48016fcc:	911e8000 	add	x0, x0, #0x7a0
    48016fd0:	97ffe426 	bl	48010068 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
    48016fd4:	97ffb516 	bl	4800442c <rt_hw_interrupt_disable>
    48016fd8:	f90017e0 	str	x0, [sp, #40]
    completion->flag = RT_UNCOMPLETED;
    48016fdc:	f9400fe0 	ldr	x0, [sp, #24]
    48016fe0:	b900001f 	str	wzr, [x0]
    rt_list_init(&completion->suspended_list);
    48016fe4:	f9400fe0 	ldr	x0, [sp, #24]
    48016fe8:	91002000 	add	x0, x0, #0x8
    48016fec:	97ffffc4 	bl	48016efc <rt_list_init>
    rt_hw_interrupt_enable(level);
    48016ff0:	f94017e0 	ldr	x0, [sp, #40]
    48016ff4:	97ffb512 	bl	4800443c <rt_hw_interrupt_enable>
}
    48016ff8:	d503201f 	nop
    48016ffc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48017000:	d65f03c0 	ret

0000000048017004 <rt_completion_wait>:
 *
 * @warning This function can ONLY be called in the thread context. It MUST NOT be called in interrupt context.
 */
rt_err_t rt_completion_wait(struct rt_completion *completion,
                            rt_int32_t            timeout)
{
    48017004:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48017008:	910003fd 	mov	x29, sp
    4801700c:	f9000fe0 	str	x0, [sp, #24]
    48017010:	b90017e1 	str	w1, [sp, #20]
    rt_err_t result;
    rt_base_t level;
    rt_thread_t thread;
    RT_ASSERT(completion != RT_NULL);
    48017014:	f9400fe0 	ldr	x0, [sp, #24]
    48017018:	f100001f 	cmp	x0, #0x0
    4801701c:	540000e1 	b.ne	48017038 <rt_completion_wait+0x34>  // b.any
    48017020:	d2800742 	mov	x2, #0x3a                  	// #58
    48017024:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017028:	9120c001 	add	x1, x0, #0x830
    4801702c:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017030:	911e8000 	add	x0, x0, #0x7a0
    48017034:	97ffe40d 	bl	48010068 <rt_assert_handler>

    result = RT_EOK;
    48017038:	f9001fff 	str	xzr, [sp, #56]
    thread = rt_thread_self();
    4801703c:	97ffd2d8 	bl	4800bb9c <rt_thread_self>
    48017040:	f90017e0 	str	x0, [sp, #40]

    level = rt_hw_interrupt_disable();
    48017044:	97ffb4fa 	bl	4800442c <rt_hw_interrupt_disable>
    48017048:	f9001be0 	str	x0, [sp, #48]
    if (completion->flag != RT_COMPLETED)
    4801704c:	f9400fe0 	ldr	x0, [sp, #24]
    48017050:	b9400000 	ldr	w0, [x0]
    48017054:	7100041f 	cmp	w0, #0x1
    48017058:	54000880 	b.eq	48017168 <rt_completion_wait+0x164>  // b.none
    {
        /* only one thread can suspend on complete */
        RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
    4801705c:	f9400fe0 	ldr	x0, [sp, #24]
    48017060:	91002000 	add	x0, x0, #0x8
    48017064:	97ffffc6 	bl	48016f7c <rt_list_isempty>
    48017068:	7100001f 	cmp	w0, #0x0
    4801706c:	540000e1 	b.ne	48017088 <rt_completion_wait+0x84>  // b.any
    48017070:	d2800862 	mov	x2, #0x43                  	// #67
    48017074:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017078:	9120c001 	add	x1, x0, #0x830
    4801707c:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017080:	911ee000 	add	x0, x0, #0x7b8
    48017084:	97ffe3f9 	bl	48010068 <rt_assert_handler>

        if (timeout == 0)
    48017088:	b94017e0 	ldr	w0, [sp, #20]
    4801708c:	7100001f 	cmp	w0, #0x0
    48017090:	54000081 	b.ne	480170a0 <rt_completion_wait+0x9c>  // b.any
        {
            result = -RT_ETIMEOUT;
    48017094:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    48017098:	f9001fe0 	str	x0, [sp, #56]
            goto __exit;
    4801709c:	14000035 	b	48017170 <rt_completion_wait+0x16c>
        }
        else
        {
            /* reset thread error number */
            thread->error = RT_EOK;
    480170a0:	f94017e0 	ldr	x0, [sp, #40]
    480170a4:	f9002c1f 	str	xzr, [x0, #88]

            /* suspend thread */
            rt_thread_suspend(thread);
    480170a8:	f94017e0 	ldr	x0, [sp, #40]
    480170ac:	97ffd4bf 	bl	4800c3a8 <rt_thread_suspend>
            /* add to suspended list */
            rt_list_insert_before(&(completion->suspended_list),
    480170b0:	f9400fe0 	ldr	x0, [sp, #24]
    480170b4:	91002002 	add	x2, x0, #0x8
    480170b8:	f94017e0 	ldr	x0, [sp, #40]
    480170bc:	91008000 	add	x0, x0, #0x20
    480170c0:	aa0003e1 	mov	x1, x0
    480170c4:	aa0203e0 	mov	x0, x2
    480170c8:	97ffff99 	bl	48016f2c <rt_list_insert_before>
                                  &(thread->tlist));

            /* current context checking */
            RT_DEBUG_NOT_IN_INTERRUPT;
    480170cc:	97ffb4d8 	bl	4800442c <rt_hw_interrupt_disable>
    480170d0:	f90013e0 	str	x0, [sp, #32]
    480170d4:	97ffc98f 	bl	48009710 <rt_interrupt_get_nest>
    480170d8:	12001c00 	and	w0, w0, #0xff
    480170dc:	7100001f 	cmp	w0, #0x0
    480170e0:	54000180 	b.eq	48017110 <rt_completion_wait+0x10c>  // b.none
    480170e4:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480170e8:	9120c001 	add	x1, x0, #0x830
    480170ec:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480170f0:	911fa000 	add	x0, x0, #0x7e8
    480170f4:	97ffe30f 	bl	4800fd30 <rt_kprintf>
    480170f8:	d2800ac2 	mov	x2, #0x56                  	// #86
    480170fc:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017100:	9120c001 	add	x1, x0, #0x830
    48017104:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017108:	91204000 	add	x0, x0, #0x810
    4801710c:	97ffe3d7 	bl	48010068 <rt_assert_handler>
    48017110:	f94013e0 	ldr	x0, [sp, #32]
    48017114:	97ffb4ca 	bl	4800443c <rt_hw_interrupt_enable>

            /* start timer */
            if (timeout > 0)
    48017118:	b94017e0 	ldr	w0, [sp, #20]
    4801711c:	7100001f 	cmp	w0, #0x0
    48017120:	5400014d 	b.le	48017148 <rt_completion_wait+0x144>
            {
                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
    48017124:	f94017e0 	ldr	x0, [sp, #40]
    48017128:	91020000 	add	x0, x0, #0x80
    4801712c:	910053e1 	add	x1, sp, #0x14
    48017130:	aa0103e2 	mov	x2, x1
    48017134:	52800001 	mov	w1, #0x0                   	// #0
    48017138:	97ffcffa 	bl	4800b120 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &timeout);
                rt_timer_start(&(thread->thread_timer));
    4801713c:	f94017e0 	ldr	x0, [sp, #40]
    48017140:	91020000 	add	x0, x0, #0x80
    48017144:	97ffced0 	bl	4800ac84 <rt_timer_start>
            }
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
    48017148:	f9401be0 	ldr	x0, [sp, #48]
    4801714c:	97ffb4bc 	bl	4800443c <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
    48017150:	97ffd88f 	bl	4800d38c <rt_schedule>

            /* thread is waked up */
            result = thread->error;
    48017154:	f94017e0 	ldr	x0, [sp, #40]
    48017158:	f9402c00 	ldr	x0, [x0, #88]
    4801715c:	f9001fe0 	str	x0, [sp, #56]

            level = rt_hw_interrupt_disable();
    48017160:	97ffb4b3 	bl	4800442c <rt_hw_interrupt_disable>
    48017164:	f9001be0 	str	x0, [sp, #48]
        }
    }
    /* clean completed flag */
    completion->flag = RT_UNCOMPLETED;
    48017168:	f9400fe0 	ldr	x0, [sp, #24]
    4801716c:	b900001f 	str	wzr, [x0]

__exit:
    rt_hw_interrupt_enable(level);
    48017170:	f9401be0 	ldr	x0, [sp, #48]
    48017174:	97ffb4b2 	bl	4800443c <rt_hw_interrupt_enable>

    return result;
    48017178:	f9401fe0 	ldr	x0, [sp, #56]
}
    4801717c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48017180:	d65f03c0 	ret

0000000048017184 <rt_completion_done>:
 * @brief This function indicates a completion has done.
 *
 * @param completion is a pointer to a completion object.
 */
void rt_completion_done(struct rt_completion *completion)
{
    48017184:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48017188:	910003fd 	mov	x29, sp
    4801718c:	f9000fe0 	str	x0, [sp, #24]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
    48017190:	f9400fe0 	ldr	x0, [sp, #24]
    48017194:	f100001f 	cmp	x0, #0x0
    48017198:	540000e1 	b.ne	480171b4 <rt_completion_done+0x30>  // b.any
    4801719c:	d2800fe2 	mov	x2, #0x7f                  	// #127
    480171a0:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480171a4:	91212001 	add	x1, x0, #0x848
    480171a8:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480171ac:	911e8000 	add	x0, x0, #0x7a0
    480171b0:	97ffe3ae 	bl	48010068 <rt_assert_handler>

    if (completion->flag == RT_COMPLETED)
    480171b4:	f9400fe0 	ldr	x0, [sp, #24]
    480171b8:	b9400000 	ldr	w0, [x0]
    480171bc:	7100041f 	cmp	w0, #0x1
    480171c0:	54000300 	b.eq	48017220 <rt_completion_done+0x9c>  // b.none
        return;

    level = rt_hw_interrupt_disable();
    480171c4:	97ffb49a 	bl	4800442c <rt_hw_interrupt_disable>
    480171c8:	f90017e0 	str	x0, [sp, #40]
    completion->flag = RT_COMPLETED;
    480171cc:	f9400fe0 	ldr	x0, [sp, #24]
    480171d0:	52800021 	mov	w1, #0x1                   	// #1
    480171d4:	b9000001 	str	w1, [x0]

    if (!rt_list_isempty(&(completion->suspended_list)))
    480171d8:	f9400fe0 	ldr	x0, [sp, #24]
    480171dc:	91002000 	add	x0, x0, #0x8
    480171e0:	97ffff67 	bl	48016f7c <rt_list_isempty>
    480171e4:	7100001f 	cmp	w0, #0x0
    480171e8:	54000161 	b.ne	48017214 <rt_completion_done+0x90>  // b.any
    {
        /* there is one thread in suspended list */
        struct rt_thread *thread;

        /* get thread entry */
        thread = rt_list_entry(completion->suspended_list.next,
    480171ec:	f9400fe0 	ldr	x0, [sp, #24]
    480171f0:	f9400400 	ldr	x0, [x0, #8]
    480171f4:	d1008000 	sub	x0, x0, #0x20
    480171f8:	f90013e0 	str	x0, [sp, #32]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
    480171fc:	f94013e0 	ldr	x0, [sp, #32]
    48017200:	97ffd4ba 	bl	4800c4e8 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
    48017204:	f94017e0 	ldr	x0, [sp, #40]
    48017208:	97ffb48d 	bl	4800443c <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
    4801720c:	97ffd860 	bl	4800d38c <rt_schedule>
    48017210:	14000005 	b	48017224 <rt_completion_done+0xa0>
    }
    else
    {
        rt_hw_interrupt_enable(level);
    48017214:	f94017e0 	ldr	x0, [sp, #40]
    48017218:	97ffb489 	bl	4800443c <rt_hw_interrupt_enable>
    4801721c:	14000002 	b	48017224 <rt_completion_done+0xa0>
        return;
    48017220:	d503201f 	nop
    }
}
    48017224:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48017228:	d65f03c0 	ret

000000004801722c <finsh_set_prompt>:

#endif /* defined(_MSC_VER) || (defined(__GNUC__) && defined(__x86_64__)) */

#ifdef RT_USING_HEAP
int finsh_set_prompt(const char *prompt)
{
    4801722c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48017230:	910003fd 	mov	x29, sp
    48017234:	f9000fe0 	str	x0, [sp, #24]
    if (finsh_prompt_custom)
    48017238:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801723c:	9122c000 	add	x0, x0, #0x8b0
    48017240:	f9400000 	ldr	x0, [x0]
    48017244:	f100001f 	cmp	x0, #0x0
    48017248:	54000100 	b.eq	48017268 <finsh_set_prompt+0x3c>  // b.none
    {
        rt_free(finsh_prompt_custom);
    4801724c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017250:	9122c000 	add	x0, x0, #0x8b0
    48017254:	f9400000 	ldr	x0, [x0]
    48017258:	97ffcc5b 	bl	4800a3c4 <rt_free>
        finsh_prompt_custom = RT_NULL;
    4801725c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017260:	9122c000 	add	x0, x0, #0x8b0
    48017264:	f900001f 	str	xzr, [x0]
    }

    /* strdup */
    if (prompt)
    48017268:	f9400fe0 	ldr	x0, [sp, #24]
    4801726c:	f100001f 	cmp	x0, #0x0
    48017270:	54000260 	b.eq	480172bc <finsh_set_prompt+0x90>  // b.none
    {
        finsh_prompt_custom = (char *)rt_malloc(strlen(prompt) + 1);
    48017274:	f9400fe0 	ldr	x0, [sp, #24]
    48017278:	940013c2 	bl	4801c180 <strlen>
    4801727c:	91000400 	add	x0, x0, #0x1
    48017280:	97ffca42 	bl	48009b88 <rt_malloc>
    48017284:	aa0003e1 	mov	x1, x0
    48017288:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801728c:	9122c000 	add	x0, x0, #0x8b0
    48017290:	f9000001 	str	x1, [x0]
        if (finsh_prompt_custom)
    48017294:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017298:	9122c000 	add	x0, x0, #0x8b0
    4801729c:	f9400000 	ldr	x0, [x0]
    480172a0:	f100001f 	cmp	x0, #0x0
    480172a4:	540000c0 	b.eq	480172bc <finsh_set_prompt+0x90>  // b.none
        {
            strcpy(finsh_prompt_custom, prompt);
    480172a8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480172ac:	9122c000 	add	x0, x0, #0x8b0
    480172b0:	f9400000 	ldr	x0, [x0]
    480172b4:	f9400fe1 	ldr	x1, [sp, #24]
    480172b8:	94001342 	bl	4801bfc0 <strcpy>
        }
    }

    return 0;
    480172bc:	52800000 	mov	w0, #0x0                   	// #0
}
    480172c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480172c4:	d65f03c0 	ret

00000000480172c8 <finsh_get_prompt>:
#endif /* RT_USING_HEAP */

#define _MSH_PROMPT "msh "

const char *finsh_get_prompt(void)
{
    480172c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480172cc:	910003fd 	mov	x29, sp
    480172d0:	f9000bf3 	str	x19, [sp, #16]
    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};

    /* check prompt mode */
    if (!shell->prompt_mode)
    480172d4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480172d8:	9122a000 	add	x0, x0, #0x8a8
    480172dc:	f9400000 	ldr	x0, [x0]
    480172e0:	3940f000 	ldrb	w0, [x0, #60]
    480172e4:	121f0000 	and	w0, w0, #0x2
    480172e8:	12001c00 	and	w0, w0, #0xff
    480172ec:	7100001f 	cmp	w0, #0x0
    480172f0:	540000e1 	b.ne	4801730c <finsh_get_prompt+0x44>  // b.any
    {
        finsh_prompt[0] = '\0';
    480172f4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480172f8:	9122e000 	add	x0, x0, #0x8b8
    480172fc:	3900001f 	strb	wzr, [x0]
        return finsh_prompt;
    48017300:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017304:	9122e000 	add	x0, x0, #0x8b8
    48017308:	14000035 	b	480173dc <finsh_get_prompt+0x114>
    }

    if (finsh_prompt_custom)
    4801730c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017310:	9122c000 	add	x0, x0, #0x8b0
    48017314:	f9400000 	ldr	x0, [x0]
    48017318:	f100001f 	cmp	x0, #0x0
    4801731c:	54000180 	b.eq	4801734c <finsh_get_prompt+0x84>  // b.none
    {
        strncpy(finsh_prompt, finsh_prompt_custom, sizeof(finsh_prompt) - 1);
    48017320:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017324:	9122c000 	add	x0, x0, #0x8b0
    48017328:	f9400000 	ldr	x0, [x0]
    4801732c:	d2801002 	mov	x2, #0x80                  	// #128
    48017330:	aa0003e1 	mov	x1, x0
    48017334:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017338:	9122e000 	add	x0, x0, #0x8b8
    4801733c:	94001551 	bl	4801c880 <strncpy>
        return finsh_prompt;
    48017340:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017344:	9122e000 	add	x0, x0, #0x8b8
    48017348:	14000025 	b	480173dc <finsh_get_prompt+0x114>
    }
    strcpy(finsh_prompt, _MSH_PROMPT);
    4801734c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017350:	9122e002 	add	x2, x0, #0x8b8
    48017354:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017358:	91218001 	add	x1, x0, #0x860
    4801735c:	aa0203e0 	mov	x0, x2
    48017360:	b9400022 	ldr	w2, [x1]
    48017364:	b9000002 	str	w2, [x0]
    48017368:	39401021 	ldrb	w1, [x1, #4]
    4801736c:	39001001 	strb	w1, [x0, #4]

#if defined(RT_USING_POSIX) && defined(DFS_USING_WORKDIR)
    /* get current working directory */
    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
    48017370:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017374:	9122e000 	add	x0, x0, #0x8b8
    48017378:	97ffddbf 	bl	4800ea74 <rt_strlen>
    4801737c:	aa0003e1 	mov	x1, x0
    48017380:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017384:	9122e000 	add	x0, x0, #0x8b8
    48017388:	8b000033 	add	x19, x1, x0
    4801738c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017390:	9122e000 	add	x0, x0, #0x8b8
    48017394:	97ffddb8 	bl	4800ea74 <rt_strlen>
    48017398:	aa0003e1 	mov	x1, x0
    4801739c:	d2801000 	mov	x0, #0x80                  	// #128
    480173a0:	cb010000 	sub	x0, x0, x1
    480173a4:	aa0003e1 	mov	x1, x0
    480173a8:	aa1303e0 	mov	x0, x19
    480173ac:	94001170 	bl	4801b96c <getcwd>
#endif

    strcat(finsh_prompt, ">");
    480173b0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480173b4:	9122e000 	add	x0, x0, #0x8b8
    480173b8:	94001372 	bl	4801c180 <strlen>
    480173bc:	aa0003e1 	mov	x1, x0
    480173c0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480173c4:	9122e000 	add	x0, x0, #0x8b8
    480173c8:	8b000020 	add	x0, x1, x0
    480173cc:	528007c1 	mov	w1, #0x3e                  	// #62
    480173d0:	79000001 	strh	w1, [x0]

    return finsh_prompt;
    480173d4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480173d8:	9122e000 	add	x0, x0, #0x8b8
}
    480173dc:	f9400bf3 	ldr	x19, [sp, #16]
    480173e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480173e4:	d65f03c0 	ret

00000000480173e8 <finsh_get_prompt_mode>:
 * This function get the prompt mode of finsh shell.
 *
 * @return prompt the prompt mode, 0 disable prompt mode, other values enable prompt mode.
 */
rt_uint32_t finsh_get_prompt_mode(void)
{
    480173e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    480173ec:	910003fd 	mov	x29, sp
    RT_ASSERT(shell != RT_NULL);
    480173f0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480173f4:	9122a000 	add	x0, x0, #0x8a8
    480173f8:	f9400000 	ldr	x0, [x0]
    480173fc:	f100001f 	cmp	x0, #0x0
    48017400:	540000e1 	b.ne	4801741c <finsh_get_prompt_mode+0x34>  // b.any
    48017404:	d2800fc2 	mov	x2, #0x7e                  	// #126
    48017408:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801740c:	91242001 	add	x1, x0, #0x908
    48017410:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017414:	9121a000 	add	x0, x0, #0x868
    48017418:	97ffe314 	bl	48010068 <rt_assert_handler>
    return shell->prompt_mode;
    4801741c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017420:	9122a000 	add	x0, x0, #0x8a8
    48017424:	f9400000 	ldr	x0, [x0]
    48017428:	f9401c00 	ldr	x0, [x0, #56]
    4801742c:	d3618400 	ubfx	x0, x0, #33, #1
    48017430:	12001c00 	and	w0, w0, #0xff
}
    48017434:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48017438:	d65f03c0 	ret

000000004801743c <finsh_set_prompt_mode>:
 * The parameter 0 disable prompt mode, other values enable prompt mode.
 *
 * @param prompt the prompt mode
 */
void finsh_set_prompt_mode(rt_uint32_t prompt_mode)
{
    4801743c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48017440:	910003fd 	mov	x29, sp
    48017444:	b9001fe0 	str	w0, [sp, #28]
    RT_ASSERT(shell != RT_NULL);
    48017448:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801744c:	9122a000 	add	x0, x0, #0x8a8
    48017450:	f9400000 	ldr	x0, [x0]
    48017454:	f100001f 	cmp	x0, #0x0
    48017458:	540000e1 	b.ne	48017474 <finsh_set_prompt_mode+0x38>  // b.any
    4801745c:	d28011a2 	mov	x2, #0x8d                  	// #141
    48017460:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017464:	91248001 	add	x1, x0, #0x920
    48017468:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801746c:	9121a000 	add	x0, x0, #0x868
    48017470:	97ffe2fe 	bl	48010068 <rt_assert_handler>
    shell->prompt_mode = prompt_mode;
    48017474:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017478:	9122a000 	add	x0, x0, #0x8a8
    4801747c:	f9400001 	ldr	x1, [x0]
    48017480:	b9401fe0 	ldr	w0, [sp, #28]
    48017484:	12000000 	and	w0, w0, #0x1
    48017488:	12001c02 	and	w2, w0, #0xff
    4801748c:	3940f020 	ldrb	w0, [x1, #60]
    48017490:	331f0040 	bfi	w0, w2, #1, #1
    48017494:	3900f020 	strb	w0, [x1, #60]
}
    48017498:	d503201f 	nop
    4801749c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480174a0:	d65f03c0 	ret

00000000480174a4 <finsh_getchar>:

int finsh_getchar(void)
{
    480174a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480174a8:	910003fd 	mov	x29, sp
#ifdef RT_USING_DEVICE
    char ch = 0;
    480174ac:	39005fff 	strb	wzr, [sp, #23]
        return -1; /* EOF */
    }
#else
    rt_device_t device;

    RT_ASSERT(shell != RT_NULL);
    480174b0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480174b4:	9122a000 	add	x0, x0, #0x8a8
    480174b8:	f9400000 	ldr	x0, [x0]
    480174bc:	f100001f 	cmp	x0, #0x0
    480174c0:	540000e1 	b.ne	480174dc <finsh_getchar+0x38>  // b.any
    480174c4:	d2801422 	mov	x2, #0xa1                  	// #161
    480174c8:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480174cc:	9124e001 	add	x1, x0, #0x938
    480174d0:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480174d4:	9121a000 	add	x0, x0, #0x868
    480174d8:	97ffe2e4 	bl	48010068 <rt_assert_handler>

    device = shell->device;
    480174dc:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480174e0:	9122a000 	add	x0, x0, #0x8a8
    480174e4:	f9400000 	ldr	x0, [x0]
    480174e8:	f9411400 	ldr	x0, [x0, #552]
    480174ec:	f9000fe0 	str	x0, [sp, #24]
    if (device == RT_NULL)
    480174f0:	f9400fe0 	ldr	x0, [sp, #24]
    480174f4:	f100001f 	cmp	x0, #0x0
    480174f8:	54000101 	b.ne	48017518 <finsh_getchar+0x74>  // b.any
    {
        return -1; /* EOF */
    480174fc:	12800000 	mov	w0, #0xffffffff            	// #-1
    48017500:	1400000f 	b	4801753c <finsh_getchar+0x98>
    }

    while (rt_device_read(device, -1, &ch, 1) != 1)
        rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER);
    48017504:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017508:	9122a000 	add	x0, x0, #0x8a8
    4801750c:	f9400000 	ldr	x0, [x0]
    48017510:	12800001 	mov	w1, #0xffffffff            	// #-1
    48017514:	97ffbaf7 	bl	480060f0 <rt_sem_take>
    while (rt_device_read(device, -1, &ch, 1) != 1)
    48017518:	91005fe0 	add	x0, sp, #0x17
    4801751c:	d2800023 	mov	x3, #0x1                   	// #1
    48017520:	aa0003e2 	mov	x2, x0
    48017524:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    48017528:	f9400fe0 	ldr	x0, [sp, #24]
    4801752c:	97ffd5fd 	bl	4800cd20 <rt_device_read>
    48017530:	f100041f 	cmp	x0, #0x1
    48017534:	54fffe81 	b.ne	48017504 <finsh_getchar+0x60>  // b.any

    return ch;
    48017538:	39405fe0 	ldrb	w0, [sp, #23]
#endif /* RT_USING_POSIX_STDIO */
#else
    extern char rt_hw_console_getchar(void);
    return rt_hw_console_getchar();
#endif /* RT_USING_DEVICE */
}
    4801753c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48017540:	d65f03c0 	ret

0000000048017544 <finsh_rx_ind>:

#if !defined(RT_USING_POSIX_STDIO) && defined(RT_USING_DEVICE)
static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
{
    48017544:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48017548:	910003fd 	mov	x29, sp
    4801754c:	f9000fe0 	str	x0, [sp, #24]
    48017550:	f9000be1 	str	x1, [sp, #16]
    RT_ASSERT(shell != RT_NULL);
    48017554:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017558:	9122a000 	add	x0, x0, #0x8a8
    4801755c:	f9400000 	ldr	x0, [x0]
    48017560:	f100001f 	cmp	x0, #0x0
    48017564:	540000e1 	b.ne	48017580 <finsh_rx_ind+0x3c>  // b.any
    48017568:	d28016e2 	mov	x2, #0xb7                  	// #183
    4801756c:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017570:	91252001 	add	x1, x0, #0x948
    48017574:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017578:	9121a000 	add	x0, x0, #0x868
    4801757c:	97ffe2bb 	bl	48010068 <rt_assert_handler>

    /* release semaphore to let finsh thread rx data */
    rt_sem_release(&shell->rx_sem);
    48017580:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017584:	9122a000 	add	x0, x0, #0x8a8
    48017588:	f9400000 	ldr	x0, [x0]
    4801758c:	97ffbb6f 	bl	48006348 <rt_sem_release>

    return RT_EOK;
    48017590:	d2800000 	mov	x0, #0x0                   	// #0
}
    48017594:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48017598:	d65f03c0 	ret

000000004801759c <finsh_set_device>:
 * This function sets the input device of finsh shell.
 *
 * @param device_name the name of new input device.
 */
void finsh_set_device(const char *device_name)
{
    4801759c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480175a0:	910003fd 	mov	x29, sp
    480175a4:	f9000fe0 	str	x0, [sp, #24]
    rt_device_t dev = RT_NULL;
    480175a8:	f90017ff 	str	xzr, [sp, #40]

    RT_ASSERT(shell != RT_NULL);
    480175ac:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480175b0:	9122a000 	add	x0, x0, #0x8a8
    480175b4:	f9400000 	ldr	x0, [x0]
    480175b8:	f100001f 	cmp	x0, #0x0
    480175bc:	540000e1 	b.ne	480175d8 <finsh_set_device+0x3c>  // b.any
    480175c0:	d2801942 	mov	x2, #0xca                  	// #202
    480175c4:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480175c8:	91256001 	add	x1, x0, #0x958
    480175cc:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480175d0:	9121a000 	add	x0, x0, #0x868
    480175d4:	97ffe2a5 	bl	48010068 <rt_assert_handler>
    dev = rt_device_find(device_name);
    480175d8:	f9400fe0 	ldr	x0, [sp, #24]
    480175dc:	97ffd4a3 	bl	4800c868 <rt_device_find>
    480175e0:	f90017e0 	str	x0, [sp, #40]
    if (dev == RT_NULL)
    480175e4:	f94017e0 	ldr	x0, [sp, #40]
    480175e8:	f100001f 	cmp	x0, #0x0
    480175ec:	540000c1 	b.ne	48017604 <finsh_set_device+0x68>  // b.any
    {
        rt_kprintf("finsh: can not find device: %s\n", device_name);
    480175f0:	f9400fe1 	ldr	x1, [sp, #24]
    480175f4:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480175f8:	91220000 	add	x0, x0, #0x880
    480175fc:	97ffe1cd 	bl	4800fd30 <rt_kprintf>
        return;
    48017600:	14000039 	b	480176e4 <finsh_set_device+0x148>
    }

    /* check whether it's a same device */
    if (dev == shell->device) return;
    48017604:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017608:	9122a000 	add	x0, x0, #0x8a8
    4801760c:	f9400000 	ldr	x0, [x0]
    48017610:	f9411400 	ldr	x0, [x0, #552]
    48017614:	f94017e1 	ldr	x1, [sp, #40]
    48017618:	eb00003f 	cmp	x1, x0
    4801761c:	54000620 	b.eq	480176e0 <finsh_set_device+0x144>  // b.none
    /* open this device and set the new device in finsh shell */
    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX | \
    48017620:	52802861 	mov	w1, #0x143                 	// #323
    48017624:	f94017e0 	ldr	x0, [sp, #40]
    48017628:	97ffd50c 	bl	4800ca58 <rt_device_open>
    4801762c:	f100001f 	cmp	x0, #0x0
    48017630:	540005a1 	b.ne	480176e4 <finsh_set_device+0x148>  // b.any
                       RT_DEVICE_FLAG_STREAM) == RT_EOK)
    {
        if (shell->device != RT_NULL)
    48017634:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017638:	9122a000 	add	x0, x0, #0x8a8
    4801763c:	f9400000 	ldr	x0, [x0]
    48017640:	f9411400 	ldr	x0, [x0, #552]
    48017644:	f100001f 	cmp	x0, #0x0
    48017648:	54000180 	b.eq	48017678 <finsh_set_device+0xdc>  // b.none
        {
            /* close old finsh device */
            rt_device_close(shell->device);
    4801764c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017650:	9122a000 	add	x0, x0, #0x8a8
    48017654:	f9400000 	ldr	x0, [x0]
    48017658:	f9411400 	ldr	x0, [x0, #552]
    4801765c:	97ffd573 	bl	4800cc28 <rt_device_close>
            rt_device_set_rx_indicate(shell->device, RT_NULL);
    48017660:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017664:	9122a000 	add	x0, x0, #0x8a8
    48017668:	f9400000 	ldr	x0, [x0]
    4801766c:	f9411400 	ldr	x0, [x0, #552]
    48017670:	d2800001 	mov	x1, #0x0                   	// #0
    48017674:	97ffd638 	bl	4800cf54 <rt_device_set_rx_indicate>
        }

        /* clear line buffer before switch to new device */
        memset(shell->line, 0, sizeof(shell->line));
    48017678:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801767c:	9122a000 	add	x0, x0, #0x8a8
    48017680:	f9400000 	ldr	x0, [x0]
    48017684:	91074800 	add	x0, x0, #0x1d2
    48017688:	d2800a22 	mov	x2, #0x51                  	// #81
    4801768c:	52800001 	mov	w1, #0x0                   	// #0
    48017690:	9400118c 	bl	4801bcc0 <memset>
        shell->line_curpos = shell->line_position = 0;
    48017694:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017698:	9122a000 	add	x0, x0, #0x8a8
    4801769c:	f9400000 	ldr	x0, [x0]
    480176a0:	7904481f 	strh	wzr, [x0, #548]
    480176a4:	d0000101 	adrp	x1, 48039000 <_timer_thread_stack+0x480>
    480176a8:	9122a021 	add	x1, x1, #0x8a8
    480176ac:	f9400021 	ldr	x1, [x1]
    480176b0:	79444800 	ldrh	w0, [x0, #548]
    480176b4:	79044c20 	strh	w0, [x1, #550]

        shell->device = dev;
    480176b8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480176bc:	9122a000 	add	x0, x0, #0x8a8
    480176c0:	f9400000 	ldr	x0, [x0]
    480176c4:	f94017e1 	ldr	x1, [sp, #40]
    480176c8:	f9011401 	str	x1, [x0, #552]
        rt_device_set_rx_indicate(dev, finsh_rx_ind);
    480176cc:	90000000 	adrp	x0, 48017000 <rt_completion_init+0x5c>
    480176d0:	91151001 	add	x1, x0, #0x544
    480176d4:	f94017e0 	ldr	x0, [sp, #40]
    480176d8:	97ffd61f 	bl	4800cf54 <rt_device_set_rx_indicate>
    480176dc:	14000002 	b	480176e4 <finsh_set_device+0x148>
    if (dev == shell->device) return;
    480176e0:	d503201f 	nop
    }
}
    480176e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480176e8:	d65f03c0 	ret

00000000480176ec <finsh_get_device>:
 * This function returns current finsh shell input device.
 *
 * @return the finsh shell input device name is returned.
 */
const char *finsh_get_device()
{
    480176ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    480176f0:	910003fd 	mov	x29, sp
    RT_ASSERT(shell != RT_NULL);
    480176f4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480176f8:	9122a000 	add	x0, x0, #0x8a8
    480176fc:	f9400000 	ldr	x0, [x0]
    48017700:	f100001f 	cmp	x0, #0x0
    48017704:	540000e1 	b.ne	48017720 <finsh_get_device+0x34>  // b.any
    48017708:	d2801e22 	mov	x2, #0xf1                  	// #241
    4801770c:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017710:	9125c001 	add	x1, x0, #0x970
    48017714:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017718:	9121a000 	add	x0, x0, #0x868
    4801771c:	97ffe253 	bl	48010068 <rt_assert_handler>
    return shell->device->parent.name;
    48017720:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017724:	9122a000 	add	x0, x0, #0x8a8
    48017728:	f9400000 	ldr	x0, [x0]
    4801772c:	f9411400 	ldr	x0, [x0, #552]
}
    48017730:	a8c17bfd 	ldp	x29, x30, [sp], #16
    48017734:	d65f03c0 	ret

0000000048017738 <finsh_set_echo>:
 * FINSH_OPTION_ECHO=0x01 is echo mode, other values are none-echo mode.
 *
 * @param echo the echo mode
 */
void finsh_set_echo(rt_uint32_t echo)
{
    48017738:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801773c:	910003fd 	mov	x29, sp
    48017740:	b9001fe0 	str	w0, [sp, #28]
    RT_ASSERT(shell != RT_NULL);
    48017744:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017748:	9122a000 	add	x0, x0, #0x8a8
    4801774c:	f9400000 	ldr	x0, [x0]
    48017750:	f100001f 	cmp	x0, #0x0
    48017754:	540000e1 	b.ne	48017770 <finsh_set_echo+0x38>  // b.any
    48017758:	d2802022 	mov	x2, #0x101                 	// #257
    4801775c:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017760:	91262001 	add	x1, x0, #0x988
    48017764:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017768:	9121a000 	add	x0, x0, #0x868
    4801776c:	97ffe23f 	bl	48010068 <rt_assert_handler>
    shell->echo_mode = (rt_uint8_t)echo;
    48017770:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017774:	9122a000 	add	x0, x0, #0x8a8
    48017778:	f9400001 	ldr	x1, [x0]
    4801777c:	b9401fe0 	ldr	w0, [sp, #28]
    48017780:	12000000 	and	w0, w0, #0x1
    48017784:	12001c02 	and	w2, w0, #0xff
    48017788:	3940f020 	ldrb	w0, [x1, #60]
    4801778c:	33000040 	bfxil	w0, w2, #0, #1
    48017790:	3900f020 	strb	w0, [x1, #60]
}
    48017794:	d503201f 	nop
    48017798:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801779c:	d65f03c0 	ret

00000000480177a0 <finsh_get_echo>:
 * This function gets the echo mode of finsh shell.
 *
 * @return the echo mode
 */
rt_uint32_t finsh_get_echo()
{
    480177a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    480177a4:	910003fd 	mov	x29, sp
    RT_ASSERT(shell != RT_NULL);
    480177a8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480177ac:	9122a000 	add	x0, x0, #0x8a8
    480177b0:	f9400000 	ldr	x0, [x0]
    480177b4:	f100001f 	cmp	x0, #0x0
    480177b8:	540000e1 	b.ne	480177d4 <finsh_get_echo+0x34>  // b.any
    480177bc:	d28021c2 	mov	x2, #0x10e                 	// #270
    480177c0:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480177c4:	91266001 	add	x1, x0, #0x998
    480177c8:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480177cc:	9121a000 	add	x0, x0, #0x868
    480177d0:	97ffe226 	bl	48010068 <rt_assert_handler>

    return shell->echo_mode;
    480177d4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480177d8:	9122a000 	add	x0, x0, #0x8a8
    480177dc:	f9400000 	ldr	x0, [x0]
    480177e0:	f9401c00 	ldr	x0, [x0, #56]
    480177e4:	d3608000 	ubfx	x0, x0, #32, #1
    480177e8:	12001c00 	and	w0, w0, #0xff
}
    480177ec:	a8c17bfd 	ldp	x29, x30, [sp], #16
    480177f0:	d65f03c0 	ret

00000000480177f4 <shell_auto_complete>:
    }
}
#endif /* FINSH_USING_AUTH */

static void shell_auto_complete(char *prefix)
{
    480177f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480177f8:	910003fd 	mov	x29, sp
    480177fc:	f9000fe0 	str	x0, [sp, #24]
    rt_kprintf("\n");
    48017800:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017804:	91228000 	add	x0, x0, #0x8a0
    48017808:	97ffe14a 	bl	4800fd30 <rt_kprintf>
    msh_auto_complete(prefix);
    4801780c:	f9400fe0 	ldr	x0, [sp, #24]
    48017810:	94000630 	bl	480190d0 <msh_auto_complete>

    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
    48017814:	97fffead 	bl	480172c8 <finsh_get_prompt>
    48017818:	f9400fe2 	ldr	x2, [sp, #24]
    4801781c:	aa0003e1 	mov	x1, x0
    48017820:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017824:	9122a000 	add	x0, x0, #0x8a8
    48017828:	97ffe142 	bl	4800fd30 <rt_kprintf>
}
    4801782c:	d503201f 	nop
    48017830:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48017834:	d65f03c0 	ret

0000000048017838 <shell_handle_history>:

#ifdef FINSH_USING_HISTORY
static rt_bool_t shell_handle_history(struct finsh_shell *shell)
{
    48017838:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801783c:	910003fd 	mov	x29, sp
    48017840:	f9000fe0 	str	x0, [sp, #24]
    for (i = 0; i <= 60; i++)
        putchar(' ');
    rt_kprintf("\r");

#else
    rt_kprintf("\033[2K\r");
    48017844:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017848:	9122c000 	add	x0, x0, #0x8b0
    4801784c:	97ffe139 	bl	4800fd30 <rt_kprintf>
#endif
    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
    48017850:	97fffe9e 	bl	480172c8 <finsh_get_prompt>
    48017854:	aa0003e1 	mov	x1, x0
    48017858:	f9400fe0 	ldr	x0, [sp, #24]
    4801785c:	91074800 	add	x0, x0, #0x1d2
    48017860:	aa0003e2 	mov	x2, x0
    48017864:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017868:	9122a000 	add	x0, x0, #0x8a8
    4801786c:	97ffe131 	bl	4800fd30 <rt_kprintf>
    return RT_FALSE;
    48017870:	52800000 	mov	w0, #0x0                   	// #0
}
    48017874:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48017878:	d65f03c0 	ret

000000004801787c <shell_push_history>:

static void shell_push_history(struct finsh_shell *shell)
{
    4801787c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48017880:	910003fd 	mov	x29, sp
    48017884:	f9000fe0 	str	x0, [sp, #24]
    if (shell->line_position != 0)
    48017888:	f9400fe0 	ldr	x0, [sp, #24]
    4801788c:	79444800 	ldrh	w0, [x0, #548]
    48017890:	7100001f 	cmp	w0, #0x0
    48017894:	540010a0 	b.eq	48017aa8 <shell_push_history+0x22c>  // b.none
    {
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
    48017898:	f9400fe0 	ldr	x0, [sp, #24]
    4801789c:	79408000 	ldrh	w0, [x0, #64]
    480178a0:	7100101f 	cmp	w0, #0x4
    480178a4:	54000889 	b.ls	480179b4 <shell_push_history+0x138>  // b.plast
        {
            /* if current cmd is same as last cmd, don't push */
            if (memcmp(&shell->cmd_history[FINSH_HISTORY_LINES - 1], shell->line, FINSH_CMD_SIZE))
    480178a8:	f9400fe0 	ldr	x0, [sp, #24]
    480178ac:	91060803 	add	x3, x0, #0x182
    480178b0:	f9400fe0 	ldr	x0, [sp, #24]
    480178b4:	91074800 	add	x0, x0, #0x1d2
    480178b8:	d2800a02 	mov	x2, #0x50                  	// #80
    480178bc:	aa0003e1 	mov	x1, x0
    480178c0:	aa0303e0 	mov	x0, x3
    480178c4:	9400104f 	bl	4801ba00 <memcmp>
    480178c8:	7100001f 	cmp	w0, #0x0
    480178cc:	54000ee0 	b.eq	48017aa8 <shell_push_history+0x22c>  // b.none
            {
                /* move history */
                int index;
                for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
    480178d0:	b9002fff 	str	wzr, [sp, #44]
    480178d4:	14000018 	b	48017934 <shell_push_history+0xb8>
                {
                    memcpy(&shell->cmd_history[index][0],
    480178d8:	b9802fe1 	ldrsw	x1, [sp, #44]
    480178dc:	d2800a00 	mov	x0, #0x50                  	// #80
    480178e0:	9b007c20 	mul	x0, x1, x0
    480178e4:	91010000 	add	x0, x0, #0x40
    480178e8:	f9400fe1 	ldr	x1, [sp, #24]
    480178ec:	8b000020 	add	x0, x1, x0
    480178f0:	91000803 	add	x3, x0, #0x2
                           &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
    480178f4:	b9402fe0 	ldr	w0, [sp, #44]
    480178f8:	11000400 	add	w0, w0, #0x1
    480178fc:	93407c01 	sxtw	x1, w0
    48017900:	d2800a00 	mov	x0, #0x50                  	// #80
    48017904:	9b007c20 	mul	x0, x1, x0
    48017908:	91010000 	add	x0, x0, #0x40
    4801790c:	f9400fe1 	ldr	x1, [sp, #24]
    48017910:	8b000020 	add	x0, x1, x0
    48017914:	91000800 	add	x0, x0, #0x2
                    memcpy(&shell->cmd_history[index][0],
    48017918:	d2800a02 	mov	x2, #0x50                  	// #80
    4801791c:	aa0003e1 	mov	x1, x0
    48017920:	aa0303e0 	mov	x0, x3
    48017924:	94001087 	bl	4801bb40 <memcpy>
                for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
    48017928:	b9402fe0 	ldr	w0, [sp, #44]
    4801792c:	11000400 	add	w0, w0, #0x1
    48017930:	b9002fe0 	str	w0, [sp, #44]
    48017934:	b9402fe0 	ldr	w0, [sp, #44]
    48017938:	71000c1f 	cmp	w0, #0x3
    4801793c:	54fffced 	b.le	480178d8 <shell_push_history+0x5c>
                }
                memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
    48017940:	b9802fe1 	ldrsw	x1, [sp, #44]
    48017944:	d2800a00 	mov	x0, #0x50                  	// #80
    48017948:	9b007c20 	mul	x0, x1, x0
    4801794c:	91010000 	add	x0, x0, #0x40
    48017950:	f9400fe1 	ldr	x1, [sp, #24]
    48017954:	8b000020 	add	x0, x1, x0
    48017958:	91000800 	add	x0, x0, #0x2
    4801795c:	d2800a02 	mov	x2, #0x50                  	// #80
    48017960:	52800001 	mov	w1, #0x0                   	// #0
    48017964:	940010d7 	bl	4801bcc0 <memset>
                memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
    48017968:	b9802fe1 	ldrsw	x1, [sp, #44]
    4801796c:	d2800a00 	mov	x0, #0x50                  	// #80
    48017970:	9b007c20 	mul	x0, x1, x0
    48017974:	91010000 	add	x0, x0, #0x40
    48017978:	f9400fe1 	ldr	x1, [sp, #24]
    4801797c:	8b000020 	add	x0, x1, x0
    48017980:	91000803 	add	x3, x0, #0x2
    48017984:	f9400fe0 	ldr	x0, [sp, #24]
    48017988:	91074801 	add	x1, x0, #0x1d2
    4801798c:	f9400fe0 	ldr	x0, [sp, #24]
    48017990:	79444800 	ldrh	w0, [x0, #548]
    48017994:	92403c00 	and	x0, x0, #0xffff
    48017998:	aa0003e2 	mov	x2, x0
    4801799c:	aa0303e0 	mov	x0, x3
    480179a0:	94001068 	bl	4801bb40 <memcpy>

                /* it's the maximum history */
                shell->history_count = FINSH_HISTORY_LINES;
    480179a4:	f9400fe0 	ldr	x0, [sp, #24]
    480179a8:	528000a1 	mov	w1, #0x5                   	// #5
    480179ac:	79008001 	strh	w1, [x0, #64]
    480179b0:	1400003e 	b	48017aa8 <shell_push_history+0x22c>
            }
        }
        else
        {
            /* if current cmd is same as last cmd, don't push */
            if (shell->history_count == 0 || memcmp(&shell->cmd_history[shell->history_count - 1], shell->line, FINSH_CMD_SIZE))
    480179b4:	f9400fe0 	ldr	x0, [sp, #24]
    480179b8:	79408000 	ldrh	w0, [x0, #64]
    480179bc:	7100001f 	cmp	w0, #0x0
    480179c0:	54000260 	b.eq	48017a0c <shell_push_history+0x190>  // b.none
    480179c4:	f9400fe0 	ldr	x0, [sp, #24]
    480179c8:	79408000 	ldrh	w0, [x0, #64]
    480179cc:	51000400 	sub	w0, w0, #0x1
    480179d0:	93407c01 	sxtw	x1, w0
    480179d4:	d2800a00 	mov	x0, #0x50                  	// #80
    480179d8:	9b007c20 	mul	x0, x1, x0
    480179dc:	91010000 	add	x0, x0, #0x40
    480179e0:	f9400fe1 	ldr	x1, [sp, #24]
    480179e4:	8b000020 	add	x0, x1, x0
    480179e8:	91000803 	add	x3, x0, #0x2
    480179ec:	f9400fe0 	ldr	x0, [sp, #24]
    480179f0:	91074800 	add	x0, x0, #0x1d2
    480179f4:	d2800a02 	mov	x2, #0x50                  	// #80
    480179f8:	aa0003e1 	mov	x1, x0
    480179fc:	aa0303e0 	mov	x0, x3
    48017a00:	94001000 	bl	4801ba00 <memcmp>
    48017a04:	7100001f 	cmp	w0, #0x0
    48017a08:	54000500 	b.eq	48017aa8 <shell_push_history+0x22c>  // b.none
            {
                shell->current_history = shell->history_count;
    48017a0c:	f9400fe0 	ldr	x0, [sp, #24]
    48017a10:	79408001 	ldrh	w1, [x0, #64]
    48017a14:	f9400fe0 	ldr	x0, [sp, #24]
    48017a18:	79007c01 	strh	w1, [x0, #62]
                memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
    48017a1c:	f9400fe0 	ldr	x0, [sp, #24]
    48017a20:	79408000 	ldrh	w0, [x0, #64]
    48017a24:	93407c01 	sxtw	x1, w0
    48017a28:	d2800a00 	mov	x0, #0x50                  	// #80
    48017a2c:	9b007c20 	mul	x0, x1, x0
    48017a30:	91010000 	add	x0, x0, #0x40
    48017a34:	f9400fe1 	ldr	x1, [sp, #24]
    48017a38:	8b000020 	add	x0, x1, x0
    48017a3c:	91000800 	add	x0, x0, #0x2
    48017a40:	d2800a02 	mov	x2, #0x50                  	// #80
    48017a44:	52800001 	mov	w1, #0x0                   	// #0
    48017a48:	9400109e 	bl	4801bcc0 <memset>
                memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
    48017a4c:	f9400fe0 	ldr	x0, [sp, #24]
    48017a50:	79408000 	ldrh	w0, [x0, #64]
    48017a54:	93407c01 	sxtw	x1, w0
    48017a58:	d2800a00 	mov	x0, #0x50                  	// #80
    48017a5c:	9b007c20 	mul	x0, x1, x0
    48017a60:	91010000 	add	x0, x0, #0x40
    48017a64:	f9400fe1 	ldr	x1, [sp, #24]
    48017a68:	8b000020 	add	x0, x1, x0
    48017a6c:	91000803 	add	x3, x0, #0x2
    48017a70:	f9400fe0 	ldr	x0, [sp, #24]
    48017a74:	91074801 	add	x1, x0, #0x1d2
    48017a78:	f9400fe0 	ldr	x0, [sp, #24]
    48017a7c:	79444800 	ldrh	w0, [x0, #548]
    48017a80:	92403c00 	and	x0, x0, #0xffff
    48017a84:	aa0003e2 	mov	x2, x0
    48017a88:	aa0303e0 	mov	x0, x3
    48017a8c:	9400102d 	bl	4801bb40 <memcpy>

                /* increase count and set current history position */
                shell->history_count ++;
    48017a90:	f9400fe0 	ldr	x0, [sp, #24]
    48017a94:	79408000 	ldrh	w0, [x0, #64]
    48017a98:	11000400 	add	w0, w0, #0x1
    48017a9c:	12003c01 	and	w1, w0, #0xffff
    48017aa0:	f9400fe0 	ldr	x0, [sp, #24]
    48017aa4:	79008001 	strh	w1, [x0, #64]
            }
        }
    }
    shell->current_history = shell->history_count;
    48017aa8:	f9400fe0 	ldr	x0, [sp, #24]
    48017aac:	79408001 	ldrh	w1, [x0, #64]
    48017ab0:	f9400fe0 	ldr	x0, [sp, #24]
    48017ab4:	79007c01 	strh	w1, [x0, #62]
}
    48017ab8:	d503201f 	nop
    48017abc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48017ac0:	d65f03c0 	ret

0000000048017ac4 <finsh_thread_entry>:
#endif

void finsh_thread_entry(void *parameter)
{
    48017ac4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48017ac8:	910003fd 	mov	x29, sp
    48017acc:	f9000fe0 	str	x0, [sp, #24]
    int ch;

    /* normal is echo mode */
#ifndef FINSH_ECHO_DISABLE_DEFAULT
    shell->echo_mode = 1;
    48017ad0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017ad4:	9122a000 	add	x0, x0, #0x8a8
    48017ad8:	f9400000 	ldr	x0, [x0]
    48017adc:	3940f001 	ldrb	w1, [x0, #60]
    48017ae0:	32000021 	orr	w1, w1, #0x1
    48017ae4:	3900f001 	strb	w1, [x0, #60]
    shell->echo_mode = 0;
#endif

#if !defined(RT_USING_POSIX_STDIO) && defined(RT_USING_DEVICE)
    /* set console device as shell device */
    if (shell->device == RT_NULL)
    48017ae8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017aec:	9122a000 	add	x0, x0, #0x8a8
    48017af0:	f9400000 	ldr	x0, [x0]
    48017af4:	f9411400 	ldr	x0, [x0, #552]
    48017af8:	f100001f 	cmp	x0, #0x0
    48017afc:	54000101 	b.ne	48017b1c <finsh_thread_entry+0x58>  // b.any
    {
        rt_device_t console = rt_console_get_device();
    48017b00:	97ffe03f 	bl	4800fbfc <rt_console_get_device>
    48017b04:	f90017e0 	str	x0, [sp, #40]
        if (console)
    48017b08:	f94017e0 	ldr	x0, [sp, #40]
    48017b0c:	f100001f 	cmp	x0, #0x0
    48017b10:	54000060 	b.eq	48017b1c <finsh_thread_entry+0x58>  // b.none
        {
            finsh_set_device(console->parent.name);
    48017b14:	f94017e0 	ldr	x0, [sp, #40]
    48017b18:	97fffea1 	bl	4801759c <finsh_set_device>
    }
    /* waiting authenticate success */
    finsh_wait_auth();
#endif

    rt_kprintf(FINSH_PROMPT);
    48017b1c:	97fffdeb 	bl	480172c8 <finsh_get_prompt>
    48017b20:	97ffe084 	bl	4800fd30 <rt_kprintf>

    while (1)
    {
        ch = (int)finsh_getchar();
    48017b24:	97fffe60 	bl	480174a4 <finsh_getchar>
    48017b28:	b90027e0 	str	w0, [sp, #36]
        if (ch < 0)
    48017b2c:	b94027e0 	ldr	w0, [sp, #36]
    48017b30:	7100001f 	cmp	w0, #0x0
    48017b34:	5400504b 	b.lt	4801853c <finsh_thread_entry+0xa78>  // b.tstop
         * up key  : 0x1b 0x5b 0x41
         * down key: 0x1b 0x5b 0x42
         * right key:0x1b 0x5b 0x43
         * left key: 0x1b 0x5b 0x44
         */
        if (ch == 0x1b)
    48017b38:	b94027e0 	ldr	w0, [sp, #36]
    48017b3c:	71006c1f 	cmp	w0, #0x1b
    48017b40:	540000e1 	b.ne	48017b5c <finsh_thread_entry+0x98>  // b.any
        {
            shell->stat = WAIT_SPEC_KEY;
    48017b44:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017b48:	9122a000 	add	x0, x0, #0x8a8
    48017b4c:	f9400000 	ldr	x0, [x0]
    48017b50:	52800021 	mov	w1, #0x1                   	// #1
    48017b54:	b9003801 	str	w1, [x0, #56]
            continue;
    48017b58:	14000284 	b	48018568 <finsh_thread_entry+0xaa4>
        }
        else if (shell->stat == WAIT_SPEC_KEY)
    48017b5c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017b60:	9122a000 	add	x0, x0, #0x8a8
    48017b64:	f9400000 	ldr	x0, [x0]
    48017b68:	b9403800 	ldr	w0, [x0, #56]
    48017b6c:	7100041f 	cmp	w0, #0x1
    48017b70:	540001e1 	b.ne	48017bac <finsh_thread_entry+0xe8>  // b.any
        {
            if (ch == 0x5b)
    48017b74:	b94027e0 	ldr	w0, [sp, #36]
    48017b78:	71016c1f 	cmp	w0, #0x5b
    48017b7c:	540000e1 	b.ne	48017b98 <finsh_thread_entry+0xd4>  // b.any
            {
                shell->stat = WAIT_FUNC_KEY;
    48017b80:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017b84:	9122a000 	add	x0, x0, #0x8a8
    48017b88:	f9400000 	ldr	x0, [x0]
    48017b8c:	52800041 	mov	w1, #0x2                   	// #2
    48017b90:	b9003801 	str	w1, [x0, #56]
                continue;
    48017b94:	14000275 	b	48018568 <finsh_thread_entry+0xaa4>
            }

            shell->stat = WAIT_NORMAL;
    48017b98:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017b9c:	9122a000 	add	x0, x0, #0x8a8
    48017ba0:	f9400000 	ldr	x0, [x0]
    48017ba4:	b900381f 	str	wzr, [x0, #56]
    48017ba8:	140000d2 	b	48017ef0 <finsh_thread_entry+0x42c>
        }
        else if (shell->stat == WAIT_FUNC_KEY)
    48017bac:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017bb0:	9122a000 	add	x0, x0, #0x8a8
    48017bb4:	f9400000 	ldr	x0, [x0]
    48017bb8:	b9403800 	ldr	w0, [x0, #56]
    48017bbc:	7100081f 	cmp	w0, #0x2
    48017bc0:	54001981 	b.ne	48017ef0 <finsh_thread_entry+0x42c>  // b.any
        {
            shell->stat = WAIT_NORMAL;
    48017bc4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017bc8:	9122a000 	add	x0, x0, #0x8a8
    48017bcc:	f9400000 	ldr	x0, [x0]
    48017bd0:	b900381f 	str	wzr, [x0, #56]

            if (ch == 0x41) /* up key */
    48017bd4:	b94027e0 	ldr	w0, [sp, #36]
    48017bd8:	7101041f 	cmp	w0, #0x41
    48017bdc:	540007a1 	b.ne	48017cd0 <finsh_thread_entry+0x20c>  // b.any
            {
#ifdef FINSH_USING_HISTORY
                /* prev history */
                if (shell->current_history > 0)
    48017be0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017be4:	9122a000 	add	x0, x0, #0x8a8
    48017be8:	f9400000 	ldr	x0, [x0]
    48017bec:	79407c00 	ldrh	w0, [x0, #62]
    48017bf0:	7100001f 	cmp	w0, #0x0
    48017bf4:	54000640 	b.eq	48017cbc <finsh_thread_entry+0x1f8>  // b.none
                    shell->current_history --;
    48017bf8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017bfc:	9122a000 	add	x0, x0, #0x8a8
    48017c00:	f9400000 	ldr	x0, [x0]
    48017c04:	79407c01 	ldrh	w1, [x0, #62]
    48017c08:	51000421 	sub	w1, w1, #0x1
    48017c0c:	12003c21 	and	w1, w1, #0xffff
    48017c10:	79007c01 	strh	w1, [x0, #62]
                    shell->current_history = 0;
                    continue;
                }

                /* copy the history command */
                memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
    48017c14:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017c18:	9122a000 	add	x0, x0, #0x8a8
    48017c1c:	f9400000 	ldr	x0, [x0]
    48017c20:	91074803 	add	x3, x0, #0x1d2
    48017c24:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017c28:	9122a000 	add	x0, x0, #0x8a8
    48017c2c:	f9400001 	ldr	x1, [x0]
    48017c30:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017c34:	9122a000 	add	x0, x0, #0x8a8
    48017c38:	f9400000 	ldr	x0, [x0]
    48017c3c:	79407c00 	ldrh	w0, [x0, #62]
    48017c40:	93407c02 	sxtw	x2, w0
    48017c44:	d2800a00 	mov	x0, #0x50                  	// #80
    48017c48:	9b007c40 	mul	x0, x2, x0
    48017c4c:	91010000 	add	x0, x0, #0x40
    48017c50:	8b000020 	add	x0, x1, x0
    48017c54:	91000800 	add	x0, x0, #0x2
    48017c58:	d2800a02 	mov	x2, #0x50                  	// #80
    48017c5c:	aa0003e1 	mov	x1, x0
    48017c60:	aa0303e0 	mov	x0, x3
    48017c64:	94000fb7 	bl	4801bb40 <memcpy>
                       FINSH_CMD_SIZE);
                shell->line_curpos = shell->line_position = strlen(shell->line);
    48017c68:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017c6c:	9122a000 	add	x0, x0, #0x8a8
    48017c70:	f9400000 	ldr	x0, [x0]
    48017c74:	91074800 	add	x0, x0, #0x1d2
    48017c78:	94001142 	bl	4801c180 <strlen>
    48017c7c:	aa0003e1 	mov	x1, x0
    48017c80:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017c84:	9122a000 	add	x0, x0, #0x8a8
    48017c88:	f9400000 	ldr	x0, [x0]
    48017c8c:	12003c21 	and	w1, w1, #0xffff
    48017c90:	79044801 	strh	w1, [x0, #548]
    48017c94:	d0000101 	adrp	x1, 48039000 <_timer_thread_stack+0x480>
    48017c98:	9122a021 	add	x1, x1, #0x8a8
    48017c9c:	f9400021 	ldr	x1, [x1]
    48017ca0:	79444800 	ldrh	w0, [x0, #548]
    48017ca4:	79044c20 	strh	w0, [x1, #550]
                shell_handle_history(shell);
    48017ca8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017cac:	9122a000 	add	x0, x0, #0x8a8
    48017cb0:	f9400000 	ldr	x0, [x0]
    48017cb4:	97fffee1 	bl	48017838 <shell_handle_history>
#endif
                continue;
    48017cb8:	1400022c 	b	48018568 <finsh_thread_entry+0xaa4>
                    shell->current_history = 0;
    48017cbc:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017cc0:	9122a000 	add	x0, x0, #0x8a8
    48017cc4:	f9400000 	ldr	x0, [x0]
    48017cc8:	79007c1f 	strh	wzr, [x0, #62]
                    continue;
    48017ccc:	14000227 	b	48018568 <finsh_thread_entry+0xaa4>
            }
            else if (ch == 0x42) /* down key */
    48017cd0:	b94027e0 	ldr	w0, [sp, #36]
    48017cd4:	7101081f 	cmp	w0, #0x42
    48017cd8:	540009e1 	b.ne	48017e14 <finsh_thread_entry+0x350>  // b.any
            {
#ifdef FINSH_USING_HISTORY
                /* next history */
                if (shell->current_history < shell->history_count - 1)
    48017cdc:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017ce0:	9122a000 	add	x0, x0, #0x8a8
    48017ce4:	f9400000 	ldr	x0, [x0]
    48017ce8:	79407c00 	ldrh	w0, [x0, #62]
    48017cec:	2a0003e1 	mov	w1, w0
    48017cf0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017cf4:	9122a000 	add	x0, x0, #0x8a8
    48017cf8:	f9400000 	ldr	x0, [x0]
    48017cfc:	79408000 	ldrh	w0, [x0, #64]
    48017d00:	51000400 	sub	w0, w0, #0x1
    48017d04:	6b00003f 	cmp	w1, w0
    48017d08:	5400012a 	b.ge	48017d2c <finsh_thread_entry+0x268>  // b.tcont
                    shell->current_history ++;
    48017d0c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017d10:	9122a000 	add	x0, x0, #0x8a8
    48017d14:	f9400000 	ldr	x0, [x0]
    48017d18:	79407c01 	ldrh	w1, [x0, #62]
    48017d1c:	11000421 	add	w1, w1, #0x1
    48017d20:	12003c21 	and	w1, w1, #0xffff
    48017d24:	79007c01 	strh	w1, [x0, #62]
    48017d28:	14000011 	b	48017d6c <finsh_thread_entry+0x2a8>
                else
                {
                    /* set to the end of history */
                    if (shell->history_count != 0)
    48017d2c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017d30:	9122a000 	add	x0, x0, #0x8a8
    48017d34:	f9400000 	ldr	x0, [x0]
    48017d38:	79408000 	ldrh	w0, [x0, #64]
    48017d3c:	7100001f 	cmp	w0, #0x0
    48017d40:	54004020 	b.eq	48018544 <finsh_thread_entry+0xa80>  // b.none
                        shell->current_history = shell->history_count - 1;
    48017d44:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017d48:	9122a000 	add	x0, x0, #0x8a8
    48017d4c:	f9400000 	ldr	x0, [x0]
    48017d50:	79408001 	ldrh	w1, [x0, #64]
    48017d54:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017d58:	9122a000 	add	x0, x0, #0x8a8
    48017d5c:	f9400000 	ldr	x0, [x0]
    48017d60:	51000421 	sub	w1, w1, #0x1
    48017d64:	12003c21 	and	w1, w1, #0xffff
    48017d68:	79007c01 	strh	w1, [x0, #62]
                    else
                        continue;
                }

                memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
    48017d6c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017d70:	9122a000 	add	x0, x0, #0x8a8
    48017d74:	f9400000 	ldr	x0, [x0]
    48017d78:	91074803 	add	x3, x0, #0x1d2
    48017d7c:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017d80:	9122a000 	add	x0, x0, #0x8a8
    48017d84:	f9400001 	ldr	x1, [x0]
    48017d88:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017d8c:	9122a000 	add	x0, x0, #0x8a8
    48017d90:	f9400000 	ldr	x0, [x0]
    48017d94:	79407c00 	ldrh	w0, [x0, #62]
    48017d98:	93407c02 	sxtw	x2, w0
    48017d9c:	d2800a00 	mov	x0, #0x50                  	// #80
    48017da0:	9b007c40 	mul	x0, x2, x0
    48017da4:	91010000 	add	x0, x0, #0x40
    48017da8:	8b000020 	add	x0, x1, x0
    48017dac:	91000800 	add	x0, x0, #0x2
    48017db0:	d2800a02 	mov	x2, #0x50                  	// #80
    48017db4:	aa0003e1 	mov	x1, x0
    48017db8:	aa0303e0 	mov	x0, x3
    48017dbc:	94000f61 	bl	4801bb40 <memcpy>
                       FINSH_CMD_SIZE);
                shell->line_curpos = shell->line_position = strlen(shell->line);
    48017dc0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017dc4:	9122a000 	add	x0, x0, #0x8a8
    48017dc8:	f9400000 	ldr	x0, [x0]
    48017dcc:	91074800 	add	x0, x0, #0x1d2
    48017dd0:	940010ec 	bl	4801c180 <strlen>
    48017dd4:	aa0003e1 	mov	x1, x0
    48017dd8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017ddc:	9122a000 	add	x0, x0, #0x8a8
    48017de0:	f9400000 	ldr	x0, [x0]
    48017de4:	12003c21 	and	w1, w1, #0xffff
    48017de8:	79044801 	strh	w1, [x0, #548]
    48017dec:	d0000101 	adrp	x1, 48039000 <_timer_thread_stack+0x480>
    48017df0:	9122a021 	add	x1, x1, #0x8a8
    48017df4:	f9400021 	ldr	x1, [x1]
    48017df8:	79444800 	ldrh	w0, [x0, #548]
    48017dfc:	79044c20 	strh	w0, [x1, #550]
                shell_handle_history(shell);
    48017e00:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017e04:	9122a000 	add	x0, x0, #0x8a8
    48017e08:	f9400000 	ldr	x0, [x0]
    48017e0c:	97fffe8b 	bl	48017838 <shell_handle_history>
#endif
                continue;
    48017e10:	140001d6 	b	48018568 <finsh_thread_entry+0xaa4>
            }
            else if (ch == 0x44) /* left key */
    48017e14:	b94027e0 	ldr	w0, [sp, #36]
    48017e18:	7101101f 	cmp	w0, #0x44
    48017e1c:	54000241 	b.ne	48017e64 <finsh_thread_entry+0x3a0>  // b.any
            {
                if (shell->line_curpos)
    48017e20:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017e24:	9122a000 	add	x0, x0, #0x8a8
    48017e28:	f9400000 	ldr	x0, [x0]
    48017e2c:	79444c00 	ldrh	w0, [x0, #550]
    48017e30:	7100001f 	cmp	w0, #0x0
    48017e34:	540038c0 	b.eq	4801854c <finsh_thread_entry+0xa88>  // b.none
                {
                    rt_kprintf("\b");
    48017e38:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017e3c:	9122e000 	add	x0, x0, #0x8b8
    48017e40:	97ffdfbc 	bl	4800fd30 <rt_kprintf>
                    shell->line_curpos --;
    48017e44:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017e48:	9122a000 	add	x0, x0, #0x8a8
    48017e4c:	f9400000 	ldr	x0, [x0]
    48017e50:	79444c01 	ldrh	w1, [x0, #550]
    48017e54:	51000421 	sub	w1, w1, #0x1
    48017e58:	12003c21 	and	w1, w1, #0xffff
    48017e5c:	79044c01 	strh	w1, [x0, #550]
                }

                continue;
    48017e60:	140001bb 	b	4801854c <finsh_thread_entry+0xa88>
            }
            else if (ch == 0x43) /* right key */
    48017e64:	b94027e0 	ldr	w0, [sp, #36]
    48017e68:	71010c1f 	cmp	w0, #0x43
    48017e6c:	54000421 	b.ne	48017ef0 <finsh_thread_entry+0x42c>  // b.any
            {
                if (shell->line_curpos < shell->line_position)
    48017e70:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017e74:	9122a000 	add	x0, x0, #0x8a8
    48017e78:	f9400000 	ldr	x0, [x0]
    48017e7c:	79444c01 	ldrh	w1, [x0, #550]
    48017e80:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017e84:	9122a000 	add	x0, x0, #0x8a8
    48017e88:	f9400000 	ldr	x0, [x0]
    48017e8c:	79444800 	ldrh	w0, [x0, #548]
    48017e90:	6b00003f 	cmp	w1, w0
    48017e94:	54003602 	b.cs	48018554 <finsh_thread_entry+0xa90>  // b.hs, b.nlast
                {
                    rt_kprintf("%c", shell->line[shell->line_curpos]);
    48017e98:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017e9c:	9122a000 	add	x0, x0, #0x8a8
    48017ea0:	f9400001 	ldr	x1, [x0]
    48017ea4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017ea8:	9122a000 	add	x0, x0, #0x8a8
    48017eac:	f9400000 	ldr	x0, [x0]
    48017eb0:	79444c00 	ldrh	w0, [x0, #550]
    48017eb4:	93407c00 	sxtw	x0, w0
    48017eb8:	8b000020 	add	x0, x1, x0
    48017ebc:	39474800 	ldrb	w0, [x0, #466]
    48017ec0:	2a0003e1 	mov	w1, w0
    48017ec4:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017ec8:	91230000 	add	x0, x0, #0x8c0
    48017ecc:	97ffdf99 	bl	4800fd30 <rt_kprintf>
                    shell->line_curpos ++;
    48017ed0:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017ed4:	9122a000 	add	x0, x0, #0x8a8
    48017ed8:	f9400000 	ldr	x0, [x0]
    48017edc:	79444c01 	ldrh	w1, [x0, #550]
    48017ee0:	11000421 	add	w1, w1, #0x1
    48017ee4:	12003c21 	and	w1, w1, #0xffff
    48017ee8:	79044c01 	strh	w1, [x0, #550]
                }

                continue;
    48017eec:	1400019a 	b	48018554 <finsh_thread_entry+0xa90>
            }
        }

        /* received null or error */
        if (ch == '\0' || ch == 0xFF) continue;
    48017ef0:	b94027e0 	ldr	w0, [sp, #36]
    48017ef4:	7100001f 	cmp	w0, #0x0
    48017ef8:	54003320 	b.eq	4801855c <finsh_thread_entry+0xa98>  // b.none
    48017efc:	b94027e0 	ldr	w0, [sp, #36]
    48017f00:	7103fc1f 	cmp	w0, #0xff
    48017f04:	540032c0 	b.eq	4801855c <finsh_thread_entry+0xa98>  // b.none
        /* handle tab key */
        else if (ch == '\t')
    48017f08:	b94027e0 	ldr	w0, [sp, #36]
    48017f0c:	7100241f 	cmp	w0, #0x9
    48017f10:	540004e1 	b.ne	48017fac <finsh_thread_entry+0x4e8>  // b.any
        {
            int i;
            /* move the cursor to the beginning of line */
            for (i = 0; i < shell->line_curpos; i++)
    48017f14:	b9003fff 	str	wzr, [sp, #60]
    48017f18:	14000007 	b	48017f34 <finsh_thread_entry+0x470>
                rt_kprintf("\b");
    48017f1c:	b0000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48017f20:	9122e000 	add	x0, x0, #0x8b8
    48017f24:	97ffdf83 	bl	4800fd30 <rt_kprintf>
            for (i = 0; i < shell->line_curpos; i++)
    48017f28:	b9403fe0 	ldr	w0, [sp, #60]
    48017f2c:	11000400 	add	w0, w0, #0x1
    48017f30:	b9003fe0 	str	w0, [sp, #60]
    48017f34:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017f38:	9122a000 	add	x0, x0, #0x8a8
    48017f3c:	f9400000 	ldr	x0, [x0]
    48017f40:	79444c00 	ldrh	w0, [x0, #550]
    48017f44:	2a0003e1 	mov	w1, w0
    48017f48:	b9403fe0 	ldr	w0, [sp, #60]
    48017f4c:	6b01001f 	cmp	w0, w1
    48017f50:	54fffe6b 	b.lt	48017f1c <finsh_thread_entry+0x458>  // b.tstop

            /* auto complete */
            shell_auto_complete(&shell->line[0]);
    48017f54:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017f58:	9122a000 	add	x0, x0, #0x8a8
    48017f5c:	f9400000 	ldr	x0, [x0]
    48017f60:	91074800 	add	x0, x0, #0x1d2
    48017f64:	97fffe24 	bl	480177f4 <shell_auto_complete>
            /* re-calculate position */
            shell->line_curpos = shell->line_position = strlen(shell->line);
    48017f68:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017f6c:	9122a000 	add	x0, x0, #0x8a8
    48017f70:	f9400000 	ldr	x0, [x0]
    48017f74:	91074800 	add	x0, x0, #0x1d2
    48017f78:	94001082 	bl	4801c180 <strlen>
    48017f7c:	aa0003e1 	mov	x1, x0
    48017f80:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017f84:	9122a000 	add	x0, x0, #0x8a8
    48017f88:	f9400000 	ldr	x0, [x0]
    48017f8c:	12003c21 	and	w1, w1, #0xffff
    48017f90:	79044801 	strh	w1, [x0, #548]
    48017f94:	d0000101 	adrp	x1, 48039000 <_timer_thread_stack+0x480>
    48017f98:	9122a021 	add	x1, x1, #0x8a8
    48017f9c:	f9400021 	ldr	x1, [x1]
    48017fa0:	79444800 	ldrh	w0, [x0, #548]
    48017fa4:	79044c20 	strh	w0, [x1, #550]

            continue;
    48017fa8:	14000170 	b	48018568 <finsh_thread_entry+0xaa4>
        }
        /* handle backspace key */
        else if (ch == 0x7f || ch == 0x08)
    48017fac:	b94027e0 	ldr	w0, [sp, #36]
    48017fb0:	7101fc1f 	cmp	w0, #0x7f
    48017fb4:	54000080 	b.eq	48017fc4 <finsh_thread_entry+0x500>  // b.none
    48017fb8:	b94027e0 	ldr	w0, [sp, #36]
    48017fbc:	7100201f 	cmp	w0, #0x8
    48017fc0:	54001001 	b.ne	480181c0 <finsh_thread_entry+0x6fc>  // b.any
        {
            /* note that shell->line_curpos >= 0 */
            if (shell->line_curpos == 0)
    48017fc4:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017fc8:	9122a000 	add	x0, x0, #0x8a8
    48017fcc:	f9400000 	ldr	x0, [x0]
    48017fd0:	79444c00 	ldrh	w0, [x0, #550]
    48017fd4:	7100001f 	cmp	w0, #0x0
    48017fd8:	54002c60 	b.eq	48018564 <finsh_thread_entry+0xaa0>  // b.none
                continue;

            shell->line_position--;
    48017fdc:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017fe0:	9122a000 	add	x0, x0, #0x8a8
    48017fe4:	f9400000 	ldr	x0, [x0]
    48017fe8:	79444801 	ldrh	w1, [x0, #548]
    48017fec:	51000421 	sub	w1, w1, #0x1
    48017ff0:	12003c21 	and	w1, w1, #0xffff
    48017ff4:	79044801 	strh	w1, [x0, #548]
            shell->line_curpos--;
    48017ff8:	d0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48017ffc:	9122a000 	add	x0, x0, #0x8a8
    48018000:	f9400000 	ldr	x0, [x0]
    48018004:	79444c01 	ldrh	w1, [x0, #550]
    48018008:	51000421 	sub	w1, w1, #0x1
    4801800c:	12003c21 	and	w1, w1, #0xffff
    48018010:	79044c01 	strh	w1, [x0, #550]

            if (shell->line_position > shell->line_curpos)
    48018014:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018018:	9122a000 	add	x0, x0, #0x8a8
    4801801c:	f9400000 	ldr	x0, [x0]
    48018020:	79444801 	ldrh	w1, [x0, #548]
    48018024:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018028:	9122a000 	add	x0, x0, #0x8a8
    4801802c:	f9400000 	ldr	x0, [x0]
    48018030:	79444c00 	ldrh	w0, [x0, #550]
    48018034:	6b00003f 	cmp	w1, w0
    48018038:	54000a89 	b.ls	48018188 <finsh_thread_entry+0x6c4>  // b.plast
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos],
    4801803c:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018040:	9122a000 	add	x0, x0, #0x8a8
    48018044:	f9400001 	ldr	x1, [x0]
    48018048:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801804c:	9122a000 	add	x0, x0, #0x8a8
    48018050:	f9400000 	ldr	x0, [x0]
    48018054:	79444c00 	ldrh	w0, [x0, #550]
    48018058:	93407c00 	sxtw	x0, w0
    4801805c:	91074000 	add	x0, x0, #0x1d0
    48018060:	8b000020 	add	x0, x1, x0
    48018064:	91000803 	add	x3, x0, #0x2
                           &shell->line[shell->line_curpos + 1],
    48018068:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801806c:	9122a000 	add	x0, x0, #0x8a8
    48018070:	f9400001 	ldr	x1, [x0]
    48018074:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018078:	9122a000 	add	x0, x0, #0x8a8
    4801807c:	f9400000 	ldr	x0, [x0]
    48018080:	79444c00 	ldrh	w0, [x0, #550]
    48018084:	11000400 	add	w0, w0, #0x1
    48018088:	93407c00 	sxtw	x0, w0
    4801808c:	91074000 	add	x0, x0, #0x1d0
    48018090:	8b000020 	add	x0, x1, x0
    48018094:	91000801 	add	x1, x0, #0x2
                           shell->line_position - shell->line_curpos);
    48018098:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801809c:	9122a000 	add	x0, x0, #0x8a8
    480180a0:	f9400000 	ldr	x0, [x0]
    480180a4:	79444800 	ldrh	w0, [x0, #548]
    480180a8:	2a0003e2 	mov	w2, w0
    480180ac:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480180b0:	9122a000 	add	x0, x0, #0x8a8
    480180b4:	f9400000 	ldr	x0, [x0]
    480180b8:	79444c00 	ldrh	w0, [x0, #550]
    480180bc:	4b000040 	sub	w0, w2, w0
                rt_memmove(&shell->line[shell->line_curpos],
    480180c0:	93407c00 	sxtw	x0, w0
    480180c4:	aa0003e2 	mov	x2, x0
    480180c8:	aa0303e0 	mov	x0, x3
    480180cc:	97ffd952 	bl	4800e614 <rt_memmove>
                shell->line[shell->line_position] = 0;
    480180d0:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480180d4:	9122a000 	add	x0, x0, #0x8a8
    480180d8:	f9400001 	ldr	x1, [x0]
    480180dc:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480180e0:	9122a000 	add	x0, x0, #0x8a8
    480180e4:	f9400000 	ldr	x0, [x0]
    480180e8:	79444800 	ldrh	w0, [x0, #548]
    480180ec:	93407c00 	sxtw	x0, w0
    480180f0:	8b000020 	add	x0, x1, x0
    480180f4:	3907481f 	strb	wzr, [x0, #466]

                rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
    480180f8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480180fc:	9122a000 	add	x0, x0, #0x8a8
    48018100:	f9400001 	ldr	x1, [x0]
    48018104:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018108:	9122a000 	add	x0, x0, #0x8a8
    4801810c:	f9400000 	ldr	x0, [x0]
    48018110:	79444c00 	ldrh	w0, [x0, #550]
    48018114:	93407c00 	sxtw	x0, w0
    48018118:	91074000 	add	x0, x0, #0x1d0
    4801811c:	8b000020 	add	x0, x1, x0
    48018120:	91000800 	add	x0, x0, #0x2
    48018124:	aa0003e1 	mov	x1, x0
    48018128:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801812c:	91232000 	add	x0, x0, #0x8c8
    48018130:	97ffdf00 	bl	4800fd30 <rt_kprintf>

                /* move the cursor to the origin position */
                for (i = shell->line_curpos; i <= shell->line_position; i++)
    48018134:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018138:	9122a000 	add	x0, x0, #0x8a8
    4801813c:	f9400000 	ldr	x0, [x0]
    48018140:	79444c00 	ldrh	w0, [x0, #550]
    48018144:	b9003be0 	str	w0, [sp, #56]
    48018148:	14000007 	b	48018164 <finsh_thread_entry+0x6a0>
                    rt_kprintf("\b");
    4801814c:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018150:	9122e000 	add	x0, x0, #0x8b8
    48018154:	97ffdef7 	bl	4800fd30 <rt_kprintf>
                for (i = shell->line_curpos; i <= shell->line_position; i++)
    48018158:	b9403be0 	ldr	w0, [sp, #56]
    4801815c:	11000400 	add	w0, w0, #0x1
    48018160:	b9003be0 	str	w0, [sp, #56]
    48018164:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018168:	9122a000 	add	x0, x0, #0x8a8
    4801816c:	f9400000 	ldr	x0, [x0]
    48018170:	79444800 	ldrh	w0, [x0, #548]
    48018174:	2a0003e1 	mov	w1, w0
    48018178:	b9403be0 	ldr	w0, [sp, #56]
    4801817c:	6b01001f 	cmp	w0, w1
    48018180:	54fffe6d 	b.le	4801814c <finsh_thread_entry+0x688>
            {
                rt_kprintf("\b \b");
                shell->line[shell->line_position] = 0;
            }

            continue;
    48018184:	140000f9 	b	48018568 <finsh_thread_entry+0xaa4>
                rt_kprintf("\b \b");
    48018188:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801818c:	91234000 	add	x0, x0, #0x8d0
    48018190:	97ffdee8 	bl	4800fd30 <rt_kprintf>
                shell->line[shell->line_position] = 0;
    48018194:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018198:	9122a000 	add	x0, x0, #0x8a8
    4801819c:	f9400001 	ldr	x1, [x0]
    480181a0:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480181a4:	9122a000 	add	x0, x0, #0x8a8
    480181a8:	f9400000 	ldr	x0, [x0]
    480181ac:	79444800 	ldrh	w0, [x0, #548]
    480181b0:	93407c00 	sxtw	x0, w0
    480181b4:	8b000020 	add	x0, x1, x0
    480181b8:	3907481f 	strb	wzr, [x0, #466]
            continue;
    480181bc:	140000eb 	b	48018568 <finsh_thread_entry+0xaa4>
        }

        /* handle end of line, break */
        if (ch == '\r' || ch == '\n')
    480181c0:	b94027e0 	ldr	w0, [sp, #36]
    480181c4:	7100341f 	cmp	w0, #0xd
    480181c8:	54000080 	b.eq	480181d8 <finsh_thread_entry+0x714>  // b.none
    480181cc:	b94027e0 	ldr	w0, [sp, #36]
    480181d0:	7100281f 	cmp	w0, #0xa
    480181d4:	540005e1 	b.ne	48018290 <finsh_thread_entry+0x7cc>  // b.any
        {
#ifdef FINSH_USING_HISTORY
            shell_push_history(shell);
    480181d8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480181dc:	9122a000 	add	x0, x0, #0x8a8
    480181e0:	f9400000 	ldr	x0, [x0]
    480181e4:	97fffda6 	bl	4801787c <shell_push_history>
#endif
            if (shell->echo_mode)
    480181e8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480181ec:	9122a000 	add	x0, x0, #0x8a8
    480181f0:	f9400000 	ldr	x0, [x0]
    480181f4:	3940f000 	ldrb	w0, [x0, #60]
    480181f8:	12000000 	and	w0, w0, #0x1
    480181fc:	12001c00 	and	w0, w0, #0xff
    48018200:	7100001f 	cmp	w0, #0x0
    48018204:	54000080 	b.eq	48018214 <finsh_thread_entry+0x750>  // b.none
                rt_kprintf("\n");
    48018208:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801820c:	91228000 	add	x0, x0, #0x8a0
    48018210:	97ffdec8 	bl	4800fd30 <rt_kprintf>
            msh_exec(shell->line, shell->line_position);
    48018214:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018218:	9122a000 	add	x0, x0, #0x8a8
    4801821c:	f9400000 	ldr	x0, [x0]
    48018220:	91074802 	add	x2, x0, #0x1d2
    48018224:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018228:	9122a000 	add	x0, x0, #0x8a8
    4801822c:	f9400000 	ldr	x0, [x0]
    48018230:	79444800 	ldrh	w0, [x0, #548]
    48018234:	92403c00 	and	x0, x0, #0xffff
    48018238:	aa0003e1 	mov	x1, x0
    4801823c:	aa0203e0 	mov	x0, x2
    48018240:	9400025d 	bl	48018bb4 <msh_exec>

            rt_kprintf(FINSH_PROMPT);
    48018244:	97fffc21 	bl	480172c8 <finsh_get_prompt>
    48018248:	97ffdeba 	bl	4800fd30 <rt_kprintf>
            memset(shell->line, 0, sizeof(shell->line));
    4801824c:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018250:	9122a000 	add	x0, x0, #0x8a8
    48018254:	f9400000 	ldr	x0, [x0]
    48018258:	91074800 	add	x0, x0, #0x1d2
    4801825c:	d2800a22 	mov	x2, #0x51                  	// #81
    48018260:	52800001 	mov	w1, #0x0                   	// #0
    48018264:	94000e97 	bl	4801bcc0 <memset>
            shell->line_curpos = shell->line_position = 0;
    48018268:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801826c:	9122a000 	add	x0, x0, #0x8a8
    48018270:	f9400000 	ldr	x0, [x0]
    48018274:	7904481f 	strh	wzr, [x0, #548]
    48018278:	b0000101 	adrp	x1, 48039000 <_timer_thread_stack+0x480>
    4801827c:	9122a021 	add	x1, x1, #0x8a8
    48018280:	f9400021 	ldr	x1, [x1]
    48018284:	79444800 	ldrh	w0, [x0, #548]
    48018288:	79044c20 	strh	w0, [x1, #550]
            continue;
    4801828c:	140000b7 	b	48018568 <finsh_thread_entry+0xaa4>
        }

        /* it's a large line, discard it */
        if (shell->line_position >= FINSH_CMD_SIZE)
    48018290:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018294:	9122a000 	add	x0, x0, #0x8a8
    48018298:	f9400000 	ldr	x0, [x0]
    4801829c:	79444800 	ldrh	w0, [x0, #548]
    480182a0:	71013c1f 	cmp	w0, #0x4f
    480182a4:	540000a9 	b.ls	480182b8 <finsh_thread_entry+0x7f4>  // b.plast
            shell->line_position = 0;
    480182a8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480182ac:	9122a000 	add	x0, x0, #0x8a8
    480182b0:	f9400000 	ldr	x0, [x0]
    480182b4:	7904481f 	strh	wzr, [x0, #548]

        /* normal character */
        if (shell->line_curpos < shell->line_position)
    480182b8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480182bc:	9122a000 	add	x0, x0, #0x8a8
    480182c0:	f9400000 	ldr	x0, [x0]
    480182c4:	79444c01 	ldrh	w1, [x0, #550]
    480182c8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480182cc:	9122a000 	add	x0, x0, #0x8a8
    480182d0:	f9400000 	ldr	x0, [x0]
    480182d4:	79444800 	ldrh	w0, [x0, #548]
    480182d8:	6b00003f 	cmp	w1, w0
    480182dc:	54000c02 	b.cs	4801845c <finsh_thread_entry+0x998>  // b.hs, b.nlast
        {
            int i;

            rt_memmove(&shell->line[shell->line_curpos + 1],
    480182e0:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480182e4:	9122a000 	add	x0, x0, #0x8a8
    480182e8:	f9400001 	ldr	x1, [x0]
    480182ec:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480182f0:	9122a000 	add	x0, x0, #0x8a8
    480182f4:	f9400000 	ldr	x0, [x0]
    480182f8:	79444c00 	ldrh	w0, [x0, #550]
    480182fc:	11000400 	add	w0, w0, #0x1
    48018300:	93407c00 	sxtw	x0, w0
    48018304:	91074000 	add	x0, x0, #0x1d0
    48018308:	8b000020 	add	x0, x1, x0
    4801830c:	91000803 	add	x3, x0, #0x2
                       &shell->line[shell->line_curpos],
    48018310:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018314:	9122a000 	add	x0, x0, #0x8a8
    48018318:	f9400001 	ldr	x1, [x0]
    4801831c:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018320:	9122a000 	add	x0, x0, #0x8a8
    48018324:	f9400000 	ldr	x0, [x0]
    48018328:	79444c00 	ldrh	w0, [x0, #550]
    4801832c:	93407c00 	sxtw	x0, w0
    48018330:	91074000 	add	x0, x0, #0x1d0
    48018334:	8b000020 	add	x0, x1, x0
    48018338:	91000801 	add	x1, x0, #0x2
                       shell->line_position - shell->line_curpos);
    4801833c:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018340:	9122a000 	add	x0, x0, #0x8a8
    48018344:	f9400000 	ldr	x0, [x0]
    48018348:	79444800 	ldrh	w0, [x0, #548]
    4801834c:	2a0003e2 	mov	w2, w0
    48018350:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018354:	9122a000 	add	x0, x0, #0x8a8
    48018358:	f9400000 	ldr	x0, [x0]
    4801835c:	79444c00 	ldrh	w0, [x0, #550]
    48018360:	4b000040 	sub	w0, w2, w0
            rt_memmove(&shell->line[shell->line_curpos + 1],
    48018364:	93407c00 	sxtw	x0, w0
    48018368:	aa0003e2 	mov	x2, x0
    4801836c:	aa0303e0 	mov	x0, x3
    48018370:	97ffd8a9 	bl	4800e614 <rt_memmove>
            shell->line[shell->line_curpos] = ch;
    48018374:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018378:	9122a000 	add	x0, x0, #0x8a8
    4801837c:	f9400001 	ldr	x1, [x0]
    48018380:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018384:	9122a000 	add	x0, x0, #0x8a8
    48018388:	f9400000 	ldr	x0, [x0]
    4801838c:	79444c00 	ldrh	w0, [x0, #550]
    48018390:	2a0003e3 	mov	w3, w0
    48018394:	b94027e0 	ldr	w0, [sp, #36]
    48018398:	12001c02 	and	w2, w0, #0xff
    4801839c:	93407c60 	sxtw	x0, w3
    480183a0:	8b000020 	add	x0, x1, x0
    480183a4:	2a0203e1 	mov	w1, w2
    480183a8:	39074801 	strb	w1, [x0, #466]
            if (shell->echo_mode)
    480183ac:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480183b0:	9122a000 	add	x0, x0, #0x8a8
    480183b4:	f9400000 	ldr	x0, [x0]
    480183b8:	3940f000 	ldrb	w0, [x0, #60]
    480183bc:	12000000 	and	w0, w0, #0x1
    480183c0:	12001c00 	and	w0, w0, #0xff
    480183c4:	7100001f 	cmp	w0, #0x0
    480183c8:	54000200 	b.eq	48018408 <finsh_thread_entry+0x944>  // b.none
                rt_kprintf("%s", &shell->line[shell->line_curpos]);
    480183cc:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480183d0:	9122a000 	add	x0, x0, #0x8a8
    480183d4:	f9400001 	ldr	x1, [x0]
    480183d8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480183dc:	9122a000 	add	x0, x0, #0x8a8
    480183e0:	f9400000 	ldr	x0, [x0]
    480183e4:	79444c00 	ldrh	w0, [x0, #550]
    480183e8:	93407c00 	sxtw	x0, w0
    480183ec:	91074000 	add	x0, x0, #0x1d0
    480183f0:	8b000020 	add	x0, x1, x0
    480183f4:	91000800 	add	x0, x0, #0x2
    480183f8:	aa0003e1 	mov	x1, x0
    480183fc:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018400:	91236000 	add	x0, x0, #0x8d8
    48018404:	97ffde4b 	bl	4800fd30 <rt_kprintf>

            /* move the cursor to new position */
            for (i = shell->line_curpos; i < shell->line_position; i++)
    48018408:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801840c:	9122a000 	add	x0, x0, #0x8a8
    48018410:	f9400000 	ldr	x0, [x0]
    48018414:	79444c00 	ldrh	w0, [x0, #550]
    48018418:	b90037e0 	str	w0, [sp, #52]
    4801841c:	14000007 	b	48018438 <finsh_thread_entry+0x974>
                rt_kprintf("\b");
    48018420:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018424:	9122e000 	add	x0, x0, #0x8b8
    48018428:	97ffde42 	bl	4800fd30 <rt_kprintf>
            for (i = shell->line_curpos; i < shell->line_position; i++)
    4801842c:	b94037e0 	ldr	w0, [sp, #52]
    48018430:	11000400 	add	w0, w0, #0x1
    48018434:	b90037e0 	str	w0, [sp, #52]
    48018438:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801843c:	9122a000 	add	x0, x0, #0x8a8
    48018440:	f9400000 	ldr	x0, [x0]
    48018444:	79444800 	ldrh	w0, [x0, #548]
    48018448:	2a0003e1 	mov	w1, w0
    4801844c:	b94037e0 	ldr	w0, [sp, #52]
    48018450:	6b01001f 	cmp	w0, w1
    48018454:	54fffe6b 	b.lt	48018420 <finsh_thread_entry+0x95c>  // b.tstop
    48018458:	1400001b 	b	480184c4 <finsh_thread_entry+0xa00>
        }
        else
        {
            shell->line[shell->line_position] = ch;
    4801845c:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018460:	9122a000 	add	x0, x0, #0x8a8
    48018464:	f9400001 	ldr	x1, [x0]
    48018468:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801846c:	9122a000 	add	x0, x0, #0x8a8
    48018470:	f9400000 	ldr	x0, [x0]
    48018474:	79444800 	ldrh	w0, [x0, #548]
    48018478:	2a0003e3 	mov	w3, w0
    4801847c:	b94027e0 	ldr	w0, [sp, #36]
    48018480:	12001c02 	and	w2, w0, #0xff
    48018484:	93407c60 	sxtw	x0, w3
    48018488:	8b000020 	add	x0, x1, x0
    4801848c:	2a0203e1 	mov	w1, w2
    48018490:	39074801 	strb	w1, [x0, #466]
            if (shell->echo_mode)
    48018494:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018498:	9122a000 	add	x0, x0, #0x8a8
    4801849c:	f9400000 	ldr	x0, [x0]
    480184a0:	3940f000 	ldrb	w0, [x0, #60]
    480184a4:	12000000 	and	w0, w0, #0x1
    480184a8:	12001c00 	and	w0, w0, #0xff
    480184ac:	7100001f 	cmp	w0, #0x0
    480184b0:	540000a0 	b.eq	480184c4 <finsh_thread_entry+0xa00>  // b.none
                rt_kprintf("%c", ch);
    480184b4:	b94027e1 	ldr	w1, [sp, #36]
    480184b8:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480184bc:	91230000 	add	x0, x0, #0x8c0
    480184c0:	97ffde1c 	bl	4800fd30 <rt_kprintf>
        }

        ch = 0;
    480184c4:	b90027ff 	str	wzr, [sp, #36]
        shell->line_position ++;
    480184c8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480184cc:	9122a000 	add	x0, x0, #0x8a8
    480184d0:	f9400000 	ldr	x0, [x0]
    480184d4:	79444801 	ldrh	w1, [x0, #548]
    480184d8:	11000421 	add	w1, w1, #0x1
    480184dc:	12003c21 	and	w1, w1, #0xffff
    480184e0:	79044801 	strh	w1, [x0, #548]
        shell->line_curpos++;
    480184e4:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480184e8:	9122a000 	add	x0, x0, #0x8a8
    480184ec:	f9400000 	ldr	x0, [x0]
    480184f0:	79444c01 	ldrh	w1, [x0, #550]
    480184f4:	11000421 	add	w1, w1, #0x1
    480184f8:	12003c21 	and	w1, w1, #0xffff
    480184fc:	79044c01 	strh	w1, [x0, #550]
        if (shell->line_position >= FINSH_CMD_SIZE)
    48018500:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018504:	9122a000 	add	x0, x0, #0x8a8
    48018508:	f9400000 	ldr	x0, [x0]
    4801850c:	79444800 	ldrh	w0, [x0, #548]
    48018510:	71013c1f 	cmp	w0, #0x4f
    48018514:	54ffb089 	b.ls	48017b24 <finsh_thread_entry+0x60>  // b.plast
        {
            /* clear command line */
            shell->line_position = 0;
    48018518:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801851c:	9122a000 	add	x0, x0, #0x8a8
    48018520:	f9400000 	ldr	x0, [x0]
    48018524:	7904481f 	strh	wzr, [x0, #548]
            shell->line_curpos = 0;
    48018528:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801852c:	9122a000 	add	x0, x0, #0x8a8
    48018530:	f9400000 	ldr	x0, [x0]
    48018534:	79044c1f 	strh	wzr, [x0, #550]
    48018538:	17fffd7b 	b	48017b24 <finsh_thread_entry+0x60>
            continue;
    4801853c:	d503201f 	nop
    48018540:	17fffd79 	b	48017b24 <finsh_thread_entry+0x60>
                        continue;
    48018544:	d503201f 	nop
    48018548:	17fffd77 	b	48017b24 <finsh_thread_entry+0x60>
                continue;
    4801854c:	d503201f 	nop
    48018550:	17fffd75 	b	48017b24 <finsh_thread_entry+0x60>
                continue;
    48018554:	d503201f 	nop
    48018558:	17fffd73 	b	48017b24 <finsh_thread_entry+0x60>
        if (ch == '\0' || ch == 0xFF) continue;
    4801855c:	d503201f 	nop
    48018560:	17fffd71 	b	48017b24 <finsh_thread_entry+0x60>
                continue;
    48018564:	d503201f 	nop
        ch = (int)finsh_getchar();
    48018568:	17fffd6f 	b	48017b24 <finsh_thread_entry+0x60>

000000004801856c <finsh_system_function_init>:
        }
    } /* end of device read */
}

void finsh_system_function_init(const void *begin, const void *end)
{
    4801856c:	d10043ff 	sub	sp, sp, #0x10
    48018570:	f90007e0 	str	x0, [sp, #8]
    48018574:	f90003e1 	str	x1, [sp]
    _syscall_table_begin = (struct finsh_syscall *) begin;
    48018578:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801857c:	91226000 	add	x0, x0, #0x898
    48018580:	f94007e1 	ldr	x1, [sp, #8]
    48018584:	f9000001 	str	x1, [x0]
    _syscall_table_end = (struct finsh_syscall *) end;
    48018588:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801858c:	91228000 	add	x0, x0, #0x8a0
    48018590:	f94003e1 	ldr	x1, [sp]
    48018594:	f9000001 	str	x1, [x0]
}
    48018598:	d503201f 	nop
    4801859c:	910043ff 	add	sp, sp, #0x10
    480185a0:	d65f03c0 	ret

00000000480185a4 <finsh_system_init>:
 * @ingroup finsh
 *
 * This function will initialize finsh shell
 */
int finsh_system_init(void)
{
    480185a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480185a8:	910003fd 	mov	x29, sp
    rt_err_t result = RT_EOK;
    480185ac:	f9000fff 	str	xzr, [sp, #24]
                               __section_end("FSymTab"));
#elif defined (__GNUC__) || defined(__TI_COMPILER_VERSION__) || defined(__TASKING__)
    /* GNU GCC Compiler and TI CCS */
    extern const int __fsymtab_start;
    extern const int __fsymtab_end;
    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
    480185b0:	b0000040 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480185b4:	91144001 	add	x1, x0, #0x510
    480185b8:	b0000040 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480185bc:	910d8000 	add	x0, x0, #0x360
    480185c0:	97ffffeb 	bl	4801856c <finsh_system_function_init>
#endif
#endif

#ifdef RT_USING_HEAP
    /* create or set shell structure */
    shell = (struct finsh_shell *)rt_calloc(1, sizeof(struct finsh_shell));
    480185c4:	d2804601 	mov	x1, #0x230                 	// #560
    480185c8:	d2800020 	mov	x0, #0x1                   	// #1
    480185cc:	97ffc768 	bl	4800a36c <rt_calloc>
    480185d0:	aa0003e1 	mov	x1, x0
    480185d4:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480185d8:	9122a000 	add	x0, x0, #0x8a8
    480185dc:	f9000001 	str	x1, [x0]
    if (shell == RT_NULL)
    480185e0:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480185e4:	9122a000 	add	x0, x0, #0x8a8
    480185e8:	f9400000 	ldr	x0, [x0]
    480185ec:	f100001f 	cmp	x0, #0x0
    480185f0:	540000c1 	b.ne	48018608 <finsh_system_init+0x64>  // b.any
    {
        rt_kprintf("no memory for shell\n");
    480185f4:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480185f8:	91238000 	add	x0, x0, #0x8e0
    480185fc:	97ffddcd 	bl	4800fd30 <rt_kprintf>
        return -1;
    48018600:	12800000 	mov	w0, #0xffffffff            	// #-1
    48018604:	14000020 	b	48018684 <finsh_system_init+0xe0>
    }
    tid = rt_thread_create(FINSH_THREAD_NAME,
    48018608:	52800145 	mov	w5, #0xa                   	// #10
    4801860c:	52800284 	mov	w4, #0x14                  	// #20
    48018610:	52820003 	mov	w3, #0x1000                	// #4096
    48018614:	d2800002 	mov	x2, #0x0                   	// #0
    48018618:	f0ffffe0 	adrp	x0, 48017000 <rt_completion_init+0x5c>
    4801861c:	912b1001 	add	x1, x0, #0xac4
    48018620:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018624:	9123e000 	add	x0, x0, #0x8f8
    48018628:	97ffcde2 	bl	4800bdb0 <rt_thread_create>
    4801862c:	f9000be0 	str	x0, [sp, #16]
                            finsh_thread_entry, RT_NULL,
                            &finsh_thread_stack[0], sizeof(finsh_thread_stack),
                            FINSH_THREAD_PRIORITY, 10);
#endif /* RT_USING_HEAP */

    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
    48018630:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018634:	9122a000 	add	x0, x0, #0x8a8
    48018638:	f9400000 	ldr	x0, [x0]
    4801863c:	aa0003e4 	mov	x4, x0
    48018640:	52800003 	mov	w3, #0x0                   	// #0
    48018644:	52800002 	mov	w2, #0x0                   	// #0
    48018648:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801864c:	91240001 	add	x1, x0, #0x900
    48018650:	aa0403e0 	mov	x0, x4
    48018654:	97ffb5ca 	bl	48005d7c <rt_sem_init>
    finsh_set_prompt_mode(1);
    48018658:	52800020 	mov	w0, #0x1                   	// #1
    4801865c:	97fffb78 	bl	4801743c <finsh_set_prompt_mode>

    if (tid != NULL && result == RT_EOK)
    48018660:	f9400be0 	ldr	x0, [sp, #16]
    48018664:	f100001f 	cmp	x0, #0x0
    48018668:	540000c0 	b.eq	48018680 <finsh_system_init+0xdc>  // b.none
    4801866c:	f9400fe0 	ldr	x0, [sp, #24]
    48018670:	f100001f 	cmp	x0, #0x0
    48018674:	54000061 	b.ne	48018680 <finsh_system_init+0xdc>  // b.any
        rt_thread_startup(tid);
    48018678:	f9400be0 	ldr	x0, [sp, #16]
    4801867c:	97ffcd4c 	bl	4800bbac <rt_thread_startup>
    return 0;
    48018680:	52800000 	mov	w0, #0x0                   	// #0
}
    48018684:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48018688:	d65f03c0 	ret

000000004801868c <msh_help>:
#endif

typedef int (*cmd_function_t)(int argc, char **argv);

int msh_help(int argc, char **argv)
{
    4801868c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48018690:	910003fd 	mov	x29, sp
    48018694:	b9001fe0 	str	w0, [sp, #28]
    48018698:	f9000be1 	str	x1, [sp, #16]
    rt_kprintf("RT-Thread shell commands:\n");
    4801869c:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480186a0:	9126a000 	add	x0, x0, #0x9a8
    480186a4:	97ffdda3 	bl	4800fd30 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
    480186a8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480186ac:	91226000 	add	x0, x0, #0x898
    480186b0:	f9400000 	ldr	x0, [x0]
    480186b4:	f90017e0 	str	x0, [sp, #40]
    480186b8:	1400000c 	b	480186e8 <msh_help+0x5c>
                index < _syscall_table_end;
                FINSH_NEXT_SYSCALL(index))
        {
#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
            rt_kprintf("%-16s - %s\n", index->name, index->desc);
    480186bc:	f94017e0 	ldr	x0, [sp, #40]
    480186c0:	f9400001 	ldr	x1, [x0]
    480186c4:	f94017e0 	ldr	x0, [sp, #40]
    480186c8:	f9400400 	ldr	x0, [x0, #8]
    480186cc:	aa0003e2 	mov	x2, x0
    480186d0:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480186d4:	91272000 	add	x0, x0, #0x9c8
    480186d8:	97ffdd96 	bl	4800fd30 <rt_kprintf>
                FINSH_NEXT_SYSCALL(index))
    480186dc:	f94017e0 	ldr	x0, [sp, #40]
    480186e0:	91006000 	add	x0, x0, #0x18
    480186e4:	f90017e0 	str	x0, [sp, #40]
                index < _syscall_table_end;
    480186e8:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480186ec:	91228000 	add	x0, x0, #0x8a0
    480186f0:	f9400000 	ldr	x0, [x0]
        for (index = _syscall_table_begin;
    480186f4:	f94017e1 	ldr	x1, [sp, #40]
    480186f8:	eb00003f 	cmp	x1, x0
    480186fc:	54fffe03 	b.cc	480186bc <msh_help+0x30>  // b.lo, b.ul, b.last
#else
            rt_kprintf("%s ", index->name);
#endif
        }
    }
    rt_kprintf("\n");
    48018700:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018704:	91276000 	add	x0, x0, #0x9d8
    48018708:	97ffdd8a 	bl	4800fd30 <rt_kprintf>

    return 0;
    4801870c:	52800000 	mov	w0, #0x0                   	// #0
}
    48018710:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48018714:	d65f03c0 	ret

0000000048018718 <msh_split>:
MSH_CMD_EXPORT_ALIAS(cmd_free, free, Show the memory usage in the system.);
#endif /* RT_USING_HEAP */
#endif /* MSH_USING_BUILT_IN_COMMANDS */

static int msh_split(char *cmd, rt_size_t length, char *argv[FINSH_ARG_MAX])
{
    48018718:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4801871c:	910003fd 	mov	x29, sp
    48018720:	f90017e0 	str	x0, [sp, #40]
    48018724:	f90013e1 	str	x1, [sp, #32]
    48018728:	f9000fe2 	str	x2, [sp, #24]
    char *ptr;
    rt_size_t position;
    rt_size_t argc;
    rt_size_t i;

    ptr = cmd;
    4801872c:	f94017e0 	ldr	x0, [sp, #40]
    48018730:	f90027e0 	str	x0, [sp, #72]
    position = 0;
    48018734:	f90023ff 	str	xzr, [sp, #64]
    argc = 0;
    48018738:	f9001fff 	str	xzr, [sp, #56]

    while (position < length)
    4801873c:	14000093 	b	48018988 <msh_split+0x270>
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
        {
            *ptr = '\0';
    48018740:	f94027e0 	ldr	x0, [sp, #72]
    48018744:	3900001f 	strb	wzr, [x0]
            ptr ++;
    48018748:	f94027e0 	ldr	x0, [sp, #72]
    4801874c:	91000400 	add	x0, x0, #0x1
    48018750:	f90027e0 	str	x0, [sp, #72]
            position ++;
    48018754:	f94023e0 	ldr	x0, [sp, #64]
    48018758:	91000400 	add	x0, x0, #0x1
    4801875c:	f90023e0 	str	x0, [sp, #64]
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
    48018760:	f94027e0 	ldr	x0, [sp, #72]
    48018764:	39400000 	ldrb	w0, [x0]
    48018768:	7100801f 	cmp	w0, #0x20
    4801876c:	540000a0 	b.eq	48018780 <msh_split+0x68>  // b.none
    48018770:	f94027e0 	ldr	x0, [sp, #72]
    48018774:	39400000 	ldrb	w0, [x0]
    48018778:	7100241f 	cmp	w0, #0x9
    4801877c:	540000a1 	b.ne	48018790 <msh_split+0x78>  // b.any
    48018780:	f94023e1 	ldr	x1, [sp, #64]
    48018784:	f94013e0 	ldr	x0, [sp, #32]
    48018788:	eb00003f 	cmp	x1, x0
    4801878c:	54fffda3 	b.cc	48018740 <msh_split+0x28>  // b.lo, b.ul, b.last
        }

        if (argc >= FINSH_ARG_MAX)
    48018790:	f9401fe0 	ldr	x0, [sp, #56]
    48018794:	f100241f 	cmp	x0, #0x9
    48018798:	54000349 	b.ls	48018800 <msh_split+0xe8>  // b.plast
        {
            rt_kprintf("Too many args ! We only Use:\n");
    4801879c:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480187a0:	91278000 	add	x0, x0, #0x9e0
    480187a4:	97ffdd63 	bl	4800fd30 <rt_kprintf>
            for (i = 0; i < argc; i++)
    480187a8:	f9001bff 	str	xzr, [sp, #48]
    480187ac:	1400000d 	b	480187e0 <msh_split+0xc8>
            {
                rt_kprintf("%s ", argv[i]);
    480187b0:	f9401be0 	ldr	x0, [sp, #48]
    480187b4:	d37df000 	lsl	x0, x0, #3
    480187b8:	f9400fe1 	ldr	x1, [sp, #24]
    480187bc:	8b000020 	add	x0, x1, x0
    480187c0:	f9400000 	ldr	x0, [x0]
    480187c4:	aa0003e1 	mov	x1, x0
    480187c8:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480187cc:	91280000 	add	x0, x0, #0xa00
    480187d0:	97ffdd58 	bl	4800fd30 <rt_kprintf>
            for (i = 0; i < argc; i++)
    480187d4:	f9401be0 	ldr	x0, [sp, #48]
    480187d8:	91000400 	add	x0, x0, #0x1
    480187dc:	f9001be0 	str	x0, [sp, #48]
    480187e0:	f9401be1 	ldr	x1, [sp, #48]
    480187e4:	f9401fe0 	ldr	x0, [sp, #56]
    480187e8:	eb00003f 	cmp	x1, x0
    480187ec:	54fffe23 	b.cc	480187b0 <msh_split+0x98>  // b.lo, b.ul, b.last
            }
            rt_kprintf("\n");
    480187f0:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480187f4:	91276000 	add	x0, x0, #0x9d8
    480187f8:	97ffdd4e 	bl	4800fd30 <rt_kprintf>
            break;
    480187fc:	1400006d 	b	480189b0 <msh_split+0x298>
        }

        if (position >= length) break;
    48018800:	f94023e1 	ldr	x1, [sp, #64]
    48018804:	f94013e0 	ldr	x0, [sp, #32]
    48018808:	eb00003f 	cmp	x1, x0
    4801880c:	54000c82 	b.cs	4801899c <msh_split+0x284>  // b.hs, b.nlast

        /* handle string */
        if (*ptr == '"')
    48018810:	f94027e0 	ldr	x0, [sp, #72]
    48018814:	39400000 	ldrb	w0, [x0]
    48018818:	7100881f 	cmp	w0, #0x22
    4801881c:	54000761 	b.ne	48018908 <msh_split+0x1f0>  // b.any
        {
            ptr ++;
    48018820:	f94027e0 	ldr	x0, [sp, #72]
    48018824:	91000400 	add	x0, x0, #0x1
    48018828:	f90027e0 	str	x0, [sp, #72]
            position ++;
    4801882c:	f94023e0 	ldr	x0, [sp, #64]
    48018830:	91000400 	add	x0, x0, #0x1
    48018834:	f90023e0 	str	x0, [sp, #64]
            argv[argc] = ptr;
    48018838:	f9401fe0 	ldr	x0, [sp, #56]
    4801883c:	d37df000 	lsl	x0, x0, #3
    48018840:	f9400fe1 	ldr	x1, [sp, #24]
    48018844:	8b000020 	add	x0, x1, x0
    48018848:	f94027e1 	ldr	x1, [sp, #72]
    4801884c:	f9000001 	str	x1, [x0]
            argc ++;
    48018850:	f9401fe0 	ldr	x0, [sp, #56]
    48018854:	91000400 	add	x0, x0, #0x1
    48018858:	f9001fe0 	str	x0, [sp, #56]

            /* skip this string */
            while (*ptr != '"' && position < length)
    4801885c:	14000016 	b	480188b4 <msh_split+0x19c>
            {
                if (*ptr == '\\')
    48018860:	f94027e0 	ldr	x0, [sp, #72]
    48018864:	39400000 	ldrb	w0, [x0]
    48018868:	7101701f 	cmp	w0, #0x5c
    4801886c:	54000181 	b.ne	4801889c <msh_split+0x184>  // b.any
                {
                    if (*(ptr + 1) == '"')
    48018870:	f94027e0 	ldr	x0, [sp, #72]
    48018874:	91000400 	add	x0, x0, #0x1
    48018878:	39400000 	ldrb	w0, [x0]
    4801887c:	7100881f 	cmp	w0, #0x22
    48018880:	540000e1 	b.ne	4801889c <msh_split+0x184>  // b.any
                    {
                        ptr ++;
    48018884:	f94027e0 	ldr	x0, [sp, #72]
    48018888:	91000400 	add	x0, x0, #0x1
    4801888c:	f90027e0 	str	x0, [sp, #72]
                        position ++;
    48018890:	f94023e0 	ldr	x0, [sp, #64]
    48018894:	91000400 	add	x0, x0, #0x1
    48018898:	f90023e0 	str	x0, [sp, #64]
                    }
                }
                ptr ++;
    4801889c:	f94027e0 	ldr	x0, [sp, #72]
    480188a0:	91000400 	add	x0, x0, #0x1
    480188a4:	f90027e0 	str	x0, [sp, #72]
                position ++;
    480188a8:	f94023e0 	ldr	x0, [sp, #64]
    480188ac:	91000400 	add	x0, x0, #0x1
    480188b0:	f90023e0 	str	x0, [sp, #64]
            while (*ptr != '"' && position < length)
    480188b4:	f94027e0 	ldr	x0, [sp, #72]
    480188b8:	39400000 	ldrb	w0, [x0]
    480188bc:	7100881f 	cmp	w0, #0x22
    480188c0:	540000a0 	b.eq	480188d4 <msh_split+0x1bc>  // b.none
    480188c4:	f94023e1 	ldr	x1, [sp, #64]
    480188c8:	f94013e0 	ldr	x0, [sp, #32]
    480188cc:	eb00003f 	cmp	x1, x0
    480188d0:	54fffc83 	b.cc	48018860 <msh_split+0x148>  // b.lo, b.ul, b.last
            }
            if (position >= length) break;
    480188d4:	f94023e1 	ldr	x1, [sp, #64]
    480188d8:	f94013e0 	ldr	x0, [sp, #32]
    480188dc:	eb00003f 	cmp	x1, x0
    480188e0:	54000622 	b.cs	480189a4 <msh_split+0x28c>  // b.hs, b.nlast

            /* skip '"' */
            *ptr = '\0';
    480188e4:	f94027e0 	ldr	x0, [sp, #72]
    480188e8:	3900001f 	strb	wzr, [x0]
            ptr ++;
    480188ec:	f94027e0 	ldr	x0, [sp, #72]
    480188f0:	91000400 	add	x0, x0, #0x1
    480188f4:	f90027e0 	str	x0, [sp, #72]
            position ++;
    480188f8:	f94023e0 	ldr	x0, [sp, #64]
    480188fc:	91000400 	add	x0, x0, #0x1
    48018900:	f90023e0 	str	x0, [sp, #64]
    48018904:	14000021 	b	48018988 <msh_split+0x270>
        }
        else
        {
            argv[argc] = ptr;
    48018908:	f9401fe0 	ldr	x0, [sp, #56]
    4801890c:	d37df000 	lsl	x0, x0, #3
    48018910:	f9400fe1 	ldr	x1, [sp, #24]
    48018914:	8b000020 	add	x0, x1, x0
    48018918:	f94027e1 	ldr	x1, [sp, #72]
    4801891c:	f9000001 	str	x1, [x0]
            argc ++;
    48018920:	f9401fe0 	ldr	x0, [sp, #56]
    48018924:	91000400 	add	x0, x0, #0x1
    48018928:	f9001fe0 	str	x0, [sp, #56]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
    4801892c:	14000007 	b	48018948 <msh_split+0x230>
            {
                ptr ++;
    48018930:	f94027e0 	ldr	x0, [sp, #72]
    48018934:	91000400 	add	x0, x0, #0x1
    48018938:	f90027e0 	str	x0, [sp, #72]
                position ++;
    4801893c:	f94023e0 	ldr	x0, [sp, #64]
    48018940:	91000400 	add	x0, x0, #0x1
    48018944:	f90023e0 	str	x0, [sp, #64]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
    48018948:	f94027e0 	ldr	x0, [sp, #72]
    4801894c:	39400000 	ldrb	w0, [x0]
    48018950:	7100801f 	cmp	w0, #0x20
    48018954:	54000120 	b.eq	48018978 <msh_split+0x260>  // b.none
    48018958:	f94027e0 	ldr	x0, [sp, #72]
    4801895c:	39400000 	ldrb	w0, [x0]
    48018960:	7100241f 	cmp	w0, #0x9
    48018964:	540000a0 	b.eq	48018978 <msh_split+0x260>  // b.none
    48018968:	f94023e1 	ldr	x1, [sp, #64]
    4801896c:	f94013e0 	ldr	x0, [sp, #32]
    48018970:	eb00003f 	cmp	x1, x0
    48018974:	54fffde3 	b.cc	48018930 <msh_split+0x218>  // b.lo, b.ul, b.last
            }
            if (position >= length) break;
    48018978:	f94023e1 	ldr	x1, [sp, #64]
    4801897c:	f94013e0 	ldr	x0, [sp, #32]
    48018980:	eb00003f 	cmp	x1, x0
    48018984:	54000142 	b.cs	480189ac <msh_split+0x294>  // b.hs, b.nlast
    while (position < length)
    48018988:	f94023e1 	ldr	x1, [sp, #64]
    4801898c:	f94013e0 	ldr	x0, [sp, #32]
    48018990:	eb00003f 	cmp	x1, x0
    48018994:	54ffee63 	b.cc	48018760 <msh_split+0x48>  // b.lo, b.ul, b.last
    48018998:	14000006 	b	480189b0 <msh_split+0x298>
        if (position >= length) break;
    4801899c:	d503201f 	nop
    480189a0:	14000004 	b	480189b0 <msh_split+0x298>
            if (position >= length) break;
    480189a4:	d503201f 	nop
    480189a8:	14000002 	b	480189b0 <msh_split+0x298>
            if (position >= length) break;
    480189ac:	d503201f 	nop
        }
    }

    return argc;
    480189b0:	f9401fe0 	ldr	x0, [sp, #56]
}
    480189b4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480189b8:	d65f03c0 	ret

00000000480189bc <msh_get_cmd>:

static cmd_function_t msh_get_cmd(char *cmd, int size)
{
    480189bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    480189c0:	910003fd 	mov	x29, sp
    480189c4:	f9000fe0 	str	x0, [sp, #24]
    480189c8:	b90017e1 	str	w1, [sp, #20]
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;
    480189cc:	f90013ff 	str	xzr, [sp, #32]

    for (index = _syscall_table_begin;
    480189d0:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    480189d4:	91226000 	add	x0, x0, #0x898
    480189d8:	f9400000 	ldr	x0, [x0]
    480189dc:	f90017e0 	str	x0, [sp, #40]
    480189e0:	14000017 	b	48018a3c <msh_get_cmd+0x80>
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, cmd, size) == 0 &&
    480189e4:	f94017e0 	ldr	x0, [sp, #40]
    480189e8:	f9400000 	ldr	x0, [x0]
    480189ec:	b98017e1 	ldrsw	x1, [sp, #20]
    480189f0:	aa0103e2 	mov	x2, x1
    480189f4:	f9400fe1 	ldr	x1, [sp, #24]
    480189f8:	94000e39 	bl	4801c2dc <strncmp>
    480189fc:	7100001f 	cmp	w0, #0x0
    48018a00:	54000181 	b.ne	48018a30 <msh_get_cmd+0x74>  // b.any
                index->name[size] == '\0')
    48018a04:	f94017e0 	ldr	x0, [sp, #40]
    48018a08:	f9400001 	ldr	x1, [x0]
    48018a0c:	b98017e0 	ldrsw	x0, [sp, #20]
    48018a10:	8b000020 	add	x0, x1, x0
    48018a14:	39400000 	ldrb	w0, [x0]
        if (strncmp(index->name, cmd, size) == 0 &&
    48018a18:	7100001f 	cmp	w0, #0x0
    48018a1c:	540000a1 	b.ne	48018a30 <msh_get_cmd+0x74>  // b.any
        {
            cmd_func = (cmd_function_t)index->func;
    48018a20:	f94017e0 	ldr	x0, [sp, #40]
    48018a24:	f9400800 	ldr	x0, [x0, #16]
    48018a28:	f90013e0 	str	x0, [sp, #32]
            break;
    48018a2c:	1400000a 	b	48018a54 <msh_get_cmd+0x98>
            FINSH_NEXT_SYSCALL(index))
    48018a30:	f94017e0 	ldr	x0, [sp, #40]
    48018a34:	91006000 	add	x0, x0, #0x18
    48018a38:	f90017e0 	str	x0, [sp, #40]
            index < _syscall_table_end;
    48018a3c:	b0000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48018a40:	91228000 	add	x0, x0, #0x8a0
    48018a44:	f9400000 	ldr	x0, [x0]
    for (index = _syscall_table_begin;
    48018a48:	f94017e1 	ldr	x1, [sp, #40]
    48018a4c:	eb00003f 	cmp	x1, x0
    48018a50:	54fffca3 	b.cc	480189e4 <msh_get_cmd+0x28>  // b.lo, b.ul, b.last
        }
    }

    return cmd_func;
    48018a54:	f94013e0 	ldr	x0, [sp, #32]
}
    48018a58:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48018a5c:	d65f03c0 	ret

0000000048018a60 <_msh_exec_cmd>:
    return ret;
}
#endif /* defined(RT_USING_MODULE) && defined(RT_USING_POSIX) */

static int _msh_exec_cmd(char *cmd, rt_size_t length, int *retp)
{
    48018a60:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    48018a64:	910003fd 	mov	x29, sp
    48018a68:	f90017e0 	str	x0, [sp, #40]
    48018a6c:	f90013e1 	str	x1, [sp, #32]
    48018a70:	f9000fe2 	str	x2, [sp, #24]
    int argc;
    rt_size_t cmd0_size = 0;
    48018a74:	f9004fff 	str	xzr, [sp, #152]
    cmd_function_t cmd_func;
    char *argv[FINSH_ARG_MAX];

    RT_ASSERT(cmd);
    48018a78:	f94017e0 	ldr	x0, [sp, #40]
    48018a7c:	f100001f 	cmp	x0, #0x0
    48018a80:	540000e1 	b.ne	48018a9c <_msh_exec_cmd+0x3c>  // b.any
    48018a84:	d28021a2 	mov	x2, #0x10d                 	// #269
    48018a88:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018a8c:	9128e001 	add	x1, x0, #0xa38
    48018a90:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018a94:	91282000 	add	x0, x0, #0xa08
    48018a98:	97ffdd74 	bl	48010068 <rt_assert_handler>
    RT_ASSERT(retp);
    48018a9c:	f9400fe0 	ldr	x0, [sp, #24]
    48018aa0:	f100001f 	cmp	x0, #0x0
    48018aa4:	54000161 	b.ne	48018ad0 <_msh_exec_cmd+0x70>  // b.any
    48018aa8:	d28021c2 	mov	x2, #0x10e                 	// #270
    48018aac:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018ab0:	9128e001 	add	x1, x0, #0xa38
    48018ab4:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018ab8:	91284000 	add	x0, x0, #0xa10
    48018abc:	97ffdd6b 	bl	48010068 <rt_assert_handler>

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
    48018ac0:	14000004 	b	48018ad0 <_msh_exec_cmd+0x70>
        cmd0_size ++;
    48018ac4:	f9404fe0 	ldr	x0, [sp, #152]
    48018ac8:	91000400 	add	x0, x0, #0x1
    48018acc:	f9004fe0 	str	x0, [sp, #152]
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
    48018ad0:	f94017e1 	ldr	x1, [sp, #40]
    48018ad4:	f9404fe0 	ldr	x0, [sp, #152]
    48018ad8:	8b000020 	add	x0, x1, x0
    48018adc:	39400000 	ldrb	w0, [x0]
    48018ae0:	7100801f 	cmp	w0, #0x20
    48018ae4:	54000160 	b.eq	48018b10 <_msh_exec_cmd+0xb0>  // b.none
    48018ae8:	f94017e1 	ldr	x1, [sp, #40]
    48018aec:	f9404fe0 	ldr	x0, [sp, #152]
    48018af0:	8b000020 	add	x0, x1, x0
    48018af4:	39400000 	ldrb	w0, [x0]
    48018af8:	7100241f 	cmp	w0, #0x9
    48018afc:	540000a0 	b.eq	48018b10 <_msh_exec_cmd+0xb0>  // b.none
    48018b00:	f9404fe1 	ldr	x1, [sp, #152]
    48018b04:	f94013e0 	ldr	x0, [sp, #32]
    48018b08:	eb00003f 	cmp	x1, x0
    48018b0c:	54fffdc3 	b.cc	48018ac4 <_msh_exec_cmd+0x64>  // b.lo, b.ul, b.last
    if (cmd0_size == 0)
    48018b10:	f9404fe0 	ldr	x0, [sp, #152]
    48018b14:	f100001f 	cmp	x0, #0x0
    48018b18:	54000061 	b.ne	48018b24 <_msh_exec_cmd+0xc4>  // b.any
        return -RT_ERROR;
    48018b1c:	12800000 	mov	w0, #0xffffffff            	// #-1
    48018b20:	14000023 	b	48018bac <_msh_exec_cmd+0x14c>

    cmd_func = msh_get_cmd(cmd, cmd0_size);
    48018b24:	f9404fe0 	ldr	x0, [sp, #152]
    48018b28:	2a0003e1 	mov	w1, w0
    48018b2c:	f94017e0 	ldr	x0, [sp, #40]
    48018b30:	97ffffa3 	bl	480189bc <msh_get_cmd>
    48018b34:	f9004be0 	str	x0, [sp, #144]
    if (cmd_func == RT_NULL)
    48018b38:	f9404be0 	ldr	x0, [sp, #144]
    48018b3c:	f100001f 	cmp	x0, #0x0
    48018b40:	54000061 	b.ne	48018b4c <_msh_exec_cmd+0xec>  // b.any
        return -RT_ERROR;
    48018b44:	12800000 	mov	w0, #0xffffffff            	// #-1
    48018b48:	14000019 	b	48018bac <_msh_exec_cmd+0x14c>

    /* split arguments */
    memset(argv, 0x00, sizeof(argv));
    48018b4c:	9100e3e0 	add	x0, sp, #0x38
    48018b50:	d2800a02 	mov	x2, #0x50                  	// #80
    48018b54:	52800001 	mov	w1, #0x0                   	// #0
    48018b58:	94000c5a 	bl	4801bcc0 <memset>
    argc = msh_split(cmd, length, argv);
    48018b5c:	9100e3e0 	add	x0, sp, #0x38
    48018b60:	aa0003e2 	mov	x2, x0
    48018b64:	f94013e1 	ldr	x1, [sp, #32]
    48018b68:	f94017e0 	ldr	x0, [sp, #40]
    48018b6c:	97fffeeb 	bl	48018718 <msh_split>
    48018b70:	b9008fe0 	str	w0, [sp, #140]
    if (argc == 0)
    48018b74:	b9408fe0 	ldr	w0, [sp, #140]
    48018b78:	7100001f 	cmp	w0, #0x0
    48018b7c:	54000061 	b.ne	48018b88 <_msh_exec_cmd+0x128>  // b.any
        return -RT_ERROR;
    48018b80:	12800000 	mov	w0, #0xffffffff            	// #-1
    48018b84:	1400000a 	b	48018bac <_msh_exec_cmd+0x14c>

    /* exec this command */
    *retp = cmd_func(argc, argv);
    48018b88:	9100e3e0 	add	x0, sp, #0x38
    48018b8c:	f9404be2 	ldr	x2, [sp, #144]
    48018b90:	aa0003e1 	mov	x1, x0
    48018b94:	b9408fe0 	ldr	w0, [sp, #140]
    48018b98:	d63f0040 	blr	x2
    48018b9c:	2a0003e1 	mov	w1, w0
    48018ba0:	f9400fe0 	ldr	x0, [sp, #24]
    48018ba4:	b9000001 	str	w1, [x0]
    return 0;
    48018ba8:	52800000 	mov	w0, #0x0                   	// #0
}
    48018bac:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    48018bb0:	d65f03c0 	ret

0000000048018bb4 <msh_exec>:
    return 0;
}
#endif /* defined(RT_USING_LWP) && defined(RT_USING_DFS) */

int msh_exec(char *cmd, rt_size_t length)
{
    48018bb4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48018bb8:	910003fd 	mov	x29, sp
    48018bbc:	f9000fe0 	str	x0, [sp, #24]
    48018bc0:	f9000be1 	str	x1, [sp, #16]
    int cmd_ret;

    /* strim the beginning of command */
    while ((length > 0) && (*cmd  == ' ' || *cmd == '\t'))
    48018bc4:	14000007 	b	48018be0 <msh_exec+0x2c>
    {
        cmd++;
    48018bc8:	f9400fe0 	ldr	x0, [sp, #24]
    48018bcc:	91000400 	add	x0, x0, #0x1
    48018bd0:	f9000fe0 	str	x0, [sp, #24]
        length--;
    48018bd4:	f9400be0 	ldr	x0, [sp, #16]
    48018bd8:	d1000400 	sub	x0, x0, #0x1
    48018bdc:	f9000be0 	str	x0, [sp, #16]
    while ((length > 0) && (*cmd  == ' ' || *cmd == '\t'))
    48018be0:	f9400be0 	ldr	x0, [sp, #16]
    48018be4:	f100001f 	cmp	x0, #0x0
    48018be8:	54000120 	b.eq	48018c0c <msh_exec+0x58>  // b.none
    48018bec:	f9400fe0 	ldr	x0, [sp, #24]
    48018bf0:	39400000 	ldrb	w0, [x0]
    48018bf4:	7100801f 	cmp	w0, #0x20
    48018bf8:	54fffe80 	b.eq	48018bc8 <msh_exec+0x14>  // b.none
    48018bfc:	f9400fe0 	ldr	x0, [sp, #24]
    48018c00:	39400000 	ldrb	w0, [x0]
    48018c04:	7100241f 	cmp	w0, #0x9
    48018c08:	54fffe00 	b.eq	48018bc8 <msh_exec+0x14>  // b.none
    }

    if (length == 0)
    48018c0c:	f9400be0 	ldr	x0, [sp, #16]
    48018c10:	f100001f 	cmp	x0, #0x0
    48018c14:	54000061 	b.ne	48018c20 <msh_exec+0x6c>  // b.any
        return 0;
    48018c18:	52800000 	mov	w0, #0x0                   	// #0
    48018c1c:	14000027 	b	48018cb8 <msh_exec+0x104>

    /* Exec sequence:
     * 1. built-in command
     * 2. module(if enabled)
     */
    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
    48018c20:	910093e0 	add	x0, sp, #0x24
    48018c24:	aa0003e2 	mov	x2, x0
    48018c28:	f9400be1 	ldr	x1, [sp, #16]
    48018c2c:	f9400fe0 	ldr	x0, [sp, #24]
    48018c30:	97ffff8c 	bl	48018a60 <_msh_exec_cmd>
    48018c34:	7100001f 	cmp	w0, #0x0
    48018c38:	54000061 	b.ne	48018c44 <msh_exec+0x90>  // b.any
    {
        return cmd_ret;
    48018c3c:	b94027e0 	ldr	w0, [sp, #36]
    48018c40:	1400001e 	b	48018cb8 <msh_exec+0x104>
    }
#ifdef RT_USING_POSIX
#ifdef DFS_USING_WORKDIR
    if (msh_exec_script(cmd, length) == 0)
    48018c44:	f9400be0 	ldr	x0, [sp, #16]
    48018c48:	2a0003e1 	mov	w1, w0
    48018c4c:	f9400fe0 	ldr	x0, [sp, #24]
    48018c50:	940001c2 	bl	48019358 <msh_exec_script>
    48018c54:	7100001f 	cmp	w0, #0x0
    48018c58:	54000061 	b.ne	48018c64 <msh_exec+0xb0>  // b.any
    {
        return 0;
    48018c5c:	52800000 	mov	w0, #0x0                   	// #0
    48018c60:	14000016 	b	48018cb8 <msh_exec+0x104>
#endif /* RT_USING_POSIX */

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
    48018c64:	f9400fe0 	ldr	x0, [sp, #24]
    48018c68:	f90017e0 	str	x0, [sp, #40]
        while (*tcmd != ' ' && *tcmd != '\0')
    48018c6c:	14000004 	b	48018c7c <msh_exec+0xc8>
        {
            tcmd++;
    48018c70:	f94017e0 	ldr	x0, [sp, #40]
    48018c74:	91000400 	add	x0, x0, #0x1
    48018c78:	f90017e0 	str	x0, [sp, #40]
        while (*tcmd != ' ' && *tcmd != '\0')
    48018c7c:	f94017e0 	ldr	x0, [sp, #40]
    48018c80:	39400000 	ldrb	w0, [x0]
    48018c84:	7100801f 	cmp	w0, #0x20
    48018c88:	540000a0 	b.eq	48018c9c <msh_exec+0xe8>  // b.none
    48018c8c:	f94017e0 	ldr	x0, [sp, #40]
    48018c90:	39400000 	ldrb	w0, [x0]
    48018c94:	7100001f 	cmp	w0, #0x0
    48018c98:	54fffec1 	b.ne	48018c70 <msh_exec+0xbc>  // b.any
        }
        *tcmd = '\0';
    48018c9c:	f94017e0 	ldr	x0, [sp, #40]
    48018ca0:	3900001f 	strb	wzr, [x0]
    }
    rt_kprintf("%s: command not found.\n", cmd);
    48018ca4:	f9400fe1 	ldr	x1, [sp, #24]
    48018ca8:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018cac:	91286000 	add	x0, x0, #0xa18
    48018cb0:	97ffdc20 	bl	4800fd30 <rt_kprintf>
    return -1;
    48018cb4:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    48018cb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48018cbc:	d65f03c0 	ret

0000000048018cc0 <str_common>:

static int str_common(const char *str1, const char *str2)
{
    48018cc0:	d10083ff 	sub	sp, sp, #0x20
    48018cc4:	f90007e0 	str	x0, [sp, #8]
    48018cc8:	f90003e1 	str	x1, [sp]
    const char *str = str1;
    48018ccc:	f94007e0 	ldr	x0, [sp, #8]
    48018cd0:	f9000fe0 	str	x0, [sp, #24]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
    48018cd4:	14000007 	b	48018cf0 <str_common+0x30>
    {
        str ++;
    48018cd8:	f9400fe0 	ldr	x0, [sp, #24]
    48018cdc:	91000400 	add	x0, x0, #0x1
    48018ce0:	f9000fe0 	str	x0, [sp, #24]
        str2 ++;
    48018ce4:	f94003e0 	ldr	x0, [sp]
    48018ce8:	91000400 	add	x0, x0, #0x1
    48018cec:	f90003e0 	str	x0, [sp]
    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
    48018cf0:	f9400fe0 	ldr	x0, [sp, #24]
    48018cf4:	39400000 	ldrb	w0, [x0]
    48018cf8:	7100001f 	cmp	w0, #0x0
    48018cfc:	54000160 	b.eq	48018d28 <str_common+0x68>  // b.none
    48018d00:	f94003e0 	ldr	x0, [sp]
    48018d04:	39400000 	ldrb	w0, [x0]
    48018d08:	7100001f 	cmp	w0, #0x0
    48018d0c:	540000e0 	b.eq	48018d28 <str_common+0x68>  // b.none
    48018d10:	f9400fe0 	ldr	x0, [sp, #24]
    48018d14:	39400001 	ldrb	w1, [x0]
    48018d18:	f94003e0 	ldr	x0, [sp]
    48018d1c:	39400000 	ldrb	w0, [x0]
    48018d20:	6b00003f 	cmp	w1, w0
    48018d24:	54fffda0 	b.eq	48018cd8 <str_common+0x18>  // b.none
    }

    return (str - str1);
    48018d28:	f9400fe1 	ldr	x1, [sp, #24]
    48018d2c:	f94007e0 	ldr	x0, [sp, #8]
    48018d30:	cb000020 	sub	x0, x1, x0
}
    48018d34:	910083ff 	add	sp, sp, #0x20
    48018d38:	d65f03c0 	ret

0000000048018d3c <msh_auto_complete_path>:

#ifdef RT_USING_POSIX
void msh_auto_complete_path(char *path)
{
    48018d3c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    48018d40:	910003fd 	mov	x29, sp
    48018d44:	f9000bf3 	str	x19, [sp, #16]
    48018d48:	f90017e0 	str	x0, [sp, #40]
    DIR *dir = RT_NULL;
    48018d4c:	f90037ff 	str	xzr, [sp, #104]
    struct dirent *dirent = RT_NULL;
    48018d50:	f90027ff 	str	xzr, [sp, #72]
    char *full_path, *ptr, *index;

    if (!path)
    48018d54:	f94017e0 	ldr	x0, [sp, #40]
    48018d58:	f100001f 	cmp	x0, #0x0
    48018d5c:	54001ae0 	b.eq	480190b8 <msh_auto_complete_path+0x37c>  // b.none
        return;

    full_path = (char *)rt_malloc(256);
    48018d60:	d2802000 	mov	x0, #0x100                 	// #256
    48018d64:	97ffc389 	bl	48009b88 <rt_malloc>
    48018d68:	f90023e0 	str	x0, [sp, #64]
    if (full_path == RT_NULL) return; /* out of memory */
    48018d6c:	f94023e0 	ldr	x0, [sp, #64]
    48018d70:	f100001f 	cmp	x0, #0x0
    48018d74:	54001a60 	b.eq	480190c0 <msh_auto_complete_path+0x384>  // b.none

    if (*path != '/')
    48018d78:	f94017e0 	ldr	x0, [sp, #40]
    48018d7c:	39400000 	ldrb	w0, [x0]
    48018d80:	7100bc1f 	cmp	w0, #0x2f
    48018d84:	54000280 	b.eq	48018dd4 <msh_auto_complete_path+0x98>  // b.none
    {
        getcwd(full_path, 256);
    48018d88:	d2802001 	mov	x1, #0x100                 	// #256
    48018d8c:	f94023e0 	ldr	x0, [sp, #64]
    48018d90:	94000af7 	bl	4801b96c <getcwd>
        if (full_path[rt_strlen(full_path) - 1]  != '/')
    48018d94:	f94023e0 	ldr	x0, [sp, #64]
    48018d98:	97ffd737 	bl	4800ea74 <rt_strlen>
    48018d9c:	d1000400 	sub	x0, x0, #0x1
    48018da0:	f94023e1 	ldr	x1, [sp, #64]
    48018da4:	8b000020 	add	x0, x1, x0
    48018da8:	39400000 	ldrb	w0, [x0]
    48018dac:	7100bc1f 	cmp	w0, #0x2f
    48018db0:	54000160 	b.eq	48018ddc <msh_auto_complete_path+0xa0>  // b.none
            strcat(full_path, "/");
    48018db4:	f94023e0 	ldr	x0, [sp, #64]
    48018db8:	94000cf2 	bl	4801c180 <strlen>
    48018dbc:	aa0003e1 	mov	x1, x0
    48018dc0:	f94023e0 	ldr	x0, [sp, #64]
    48018dc4:	8b010000 	add	x0, x0, x1
    48018dc8:	528005e1 	mov	w1, #0x2f                  	// #47
    48018dcc:	79000001 	strh	w1, [x0]
    48018dd0:	14000003 	b	48018ddc <msh_auto_complete_path+0xa0>
    }
    else *full_path = '\0';
    48018dd4:	f94023e0 	ldr	x0, [sp, #64]
    48018dd8:	3900001f 	strb	wzr, [x0]

    index = RT_NULL;
    48018ddc:	f9002fff 	str	xzr, [sp, #88]
    ptr = path;
    48018de0:	f94017e0 	ldr	x0, [sp, #40]
    48018de4:	f90033e0 	str	x0, [sp, #96]
    for (;;)
    {
        if (*ptr == '/') index = ptr + 1;
    48018de8:	f94033e0 	ldr	x0, [sp, #96]
    48018dec:	39400000 	ldrb	w0, [x0]
    48018df0:	7100bc1f 	cmp	w0, #0x2f
    48018df4:	54000081 	b.ne	48018e04 <msh_auto_complete_path+0xc8>  // b.any
    48018df8:	f94033e0 	ldr	x0, [sp, #96]
    48018dfc:	91000400 	add	x0, x0, #0x1
    48018e00:	f9002fe0 	str	x0, [sp, #88]
        if (!*ptr) break;
    48018e04:	f94033e0 	ldr	x0, [sp, #96]
    48018e08:	39400000 	ldrb	w0, [x0]
    48018e0c:	7100001f 	cmp	w0, #0x0
    48018e10:	540000a0 	b.eq	48018e24 <msh_auto_complete_path+0xe8>  // b.none

        ptr ++;
    48018e14:	f94033e0 	ldr	x0, [sp, #96]
    48018e18:	91000400 	add	x0, x0, #0x1
    48018e1c:	f90033e0 	str	x0, [sp, #96]
        if (*ptr == '/') index = ptr + 1;
    48018e20:	17fffff2 	b	48018de8 <msh_auto_complete_path+0xac>
        if (!*ptr) break;
    48018e24:	d503201f 	nop
    }
    if (index == RT_NULL) index = path;
    48018e28:	f9402fe0 	ldr	x0, [sp, #88]
    48018e2c:	f100001f 	cmp	x0, #0x0
    48018e30:	54000061 	b.ne	48018e3c <msh_auto_complete_path+0x100>  // b.any
    48018e34:	f94017e0 	ldr	x0, [sp, #40]
    48018e38:	f9002fe0 	str	x0, [sp, #88]

    if (index != RT_NULL)
    48018e3c:	f9402fe0 	ldr	x0, [sp, #88]
    48018e40:	f100001f 	cmp	x0, #0x0
    48018e44:	54000520 	b.eq	48018ee8 <msh_auto_complete_path+0x1ac>  // b.none
    {
        char *dest = index;
    48018e48:	f9402fe0 	ldr	x0, [sp, #88]
    48018e4c:	f9001fe0 	str	x0, [sp, #56]

        /* fill the parent path */
        ptr = full_path;
    48018e50:	f94023e0 	ldr	x0, [sp, #64]
    48018e54:	f90033e0 	str	x0, [sp, #96]
        while (*ptr) ptr ++;
    48018e58:	14000004 	b	48018e68 <msh_auto_complete_path+0x12c>
    48018e5c:	f94033e0 	ldr	x0, [sp, #96]
    48018e60:	91000400 	add	x0, x0, #0x1
    48018e64:	f90033e0 	str	x0, [sp, #96]
    48018e68:	f94033e0 	ldr	x0, [sp, #96]
    48018e6c:	39400000 	ldrb	w0, [x0]
    48018e70:	7100001f 	cmp	w0, #0x0
    48018e74:	54ffff41 	b.ne	48018e5c <msh_auto_complete_path+0x120>  // b.any

        for (index = path; index != dest;)
    48018e78:	f94017e0 	ldr	x0, [sp, #40]
    48018e7c:	f9002fe0 	str	x0, [sp, #88]
    48018e80:	14000009 	b	48018ea4 <msh_auto_complete_path+0x168>
            *ptr++ = *index++;
    48018e84:	f9402fe1 	ldr	x1, [sp, #88]
    48018e88:	91000420 	add	x0, x1, #0x1
    48018e8c:	f9002fe0 	str	x0, [sp, #88]
    48018e90:	f94033e0 	ldr	x0, [sp, #96]
    48018e94:	91000402 	add	x2, x0, #0x1
    48018e98:	f90033e2 	str	x2, [sp, #96]
    48018e9c:	39400021 	ldrb	w1, [x1]
    48018ea0:	39000001 	strb	w1, [x0]
        for (index = path; index != dest;)
    48018ea4:	f9402fe1 	ldr	x1, [sp, #88]
    48018ea8:	f9401fe0 	ldr	x0, [sp, #56]
    48018eac:	eb00003f 	cmp	x1, x0
    48018eb0:	54fffea1 	b.ne	48018e84 <msh_auto_complete_path+0x148>  // b.any
        *ptr = '\0';
    48018eb4:	f94033e0 	ldr	x0, [sp, #96]
    48018eb8:	3900001f 	strb	wzr, [x0]

        dir = opendir(full_path);
    48018ebc:	f94023e0 	ldr	x0, [sp, #64]
    48018ec0:	94000969 	bl	4801b464 <opendir>
    48018ec4:	f90037e0 	str	x0, [sp, #104]
        if (dir == RT_NULL) /* open directory failed! */
    48018ec8:	f94037e0 	ldr	x0, [sp, #104]
    48018ecc:	f100001f 	cmp	x0, #0x0
    48018ed0:	54000081 	b.ne	48018ee0 <msh_auto_complete_path+0x1a4>  // b.any
        {
            rt_free(full_path);
    48018ed4:	f94023e0 	ldr	x0, [sp, #64]
    48018ed8:	97ffc53b 	bl	4800a3c4 <rt_free>
            return;
    48018edc:	1400007a 	b	480190c4 <msh_auto_complete_path+0x388>
        }

        /* restore the index position */
        index = dest;
    48018ee0:	f9401fe0 	ldr	x0, [sp, #56]
    48018ee4:	f9002fe0 	str	x0, [sp, #88]
    }

    /* auto complete the file or directory name */
    if (*index == '\0') /* display all of files and directories */
    48018ee8:	f9402fe0 	ldr	x0, [sp, #88]
    48018eec:	39400000 	ldrb	w0, [x0]
    48018ef0:	7100001f 	cmp	w0, #0x0
    48018ef4:	540001c1 	b.ne	48018f2c <msh_auto_complete_path+0x1f0>  // b.any
    {
        for (;;)
        {
            dirent = readdir(dir);
    48018ef8:	f94037e0 	ldr	x0, [sp, #104]
    48018efc:	94000991 	bl	4801b540 <readdir>
    48018f00:	f90027e0 	str	x0, [sp, #72]
            if (dirent == RT_NULL) break;
    48018f04:	f94027e0 	ldr	x0, [sp, #72]
    48018f08:	f100001f 	cmp	x0, #0x0
    48018f0c:	54000ca0 	b.eq	480190a0 <msh_auto_complete_path+0x364>  // b.none

            rt_kprintf("%s\n", dirent->d_name);
    48018f10:	f94027e0 	ldr	x0, [sp, #72]
    48018f14:	91001000 	add	x0, x0, #0x4
    48018f18:	aa0003e1 	mov	x1, x0
    48018f1c:	90000040 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48018f20:	9128c000 	add	x0, x0, #0xa30
    48018f24:	97ffdb83 	bl	4800fd30 <rt_kprintf>
            dirent = readdir(dir);
    48018f28:	17fffff4 	b	48018ef8 <msh_auto_complete_path+0x1bc>
    }
    else
    {
        rt_size_t length, min_length;

        min_length = 0;
    48018f2c:	f9002bff 	str	xzr, [sp, #80]
        for (;;)
        {
            dirent = readdir(dir);
    48018f30:	f94037e0 	ldr	x0, [sp, #104]
    48018f34:	94000983 	bl	4801b540 <readdir>
    48018f38:	f90027e0 	str	x0, [sp, #72]
            if (dirent == RT_NULL) break;
    48018f3c:	f94027e0 	ldr	x0, [sp, #72]
    48018f40:	f100001f 	cmp	x0, #0x0
    48018f44:	54000480 	b.eq	48018fd4 <msh_auto_complete_path+0x298>  // b.none

            /* matched the prefix string */
            if (strncmp(index, dirent->d_name, rt_strlen(index)) == 0)
    48018f48:	f94027e0 	ldr	x0, [sp, #72]
    48018f4c:	91001013 	add	x19, x0, #0x4
    48018f50:	f9402fe0 	ldr	x0, [sp, #88]
    48018f54:	97ffd6c8 	bl	4800ea74 <rt_strlen>
    48018f58:	aa0003e2 	mov	x2, x0
    48018f5c:	aa1303e1 	mov	x1, x19
    48018f60:	f9402fe0 	ldr	x0, [sp, #88]
    48018f64:	94000cde 	bl	4801c2dc <strncmp>
    48018f68:	7100001f 	cmp	w0, #0x0
    48018f6c:	54fffe21 	b.ne	48018f30 <msh_auto_complete_path+0x1f4>  // b.any
            {
                if (min_length == 0)
    48018f70:	f9402be0 	ldr	x0, [sp, #80]
    48018f74:	f100001f 	cmp	x0, #0x0
    48018f78:	54000141 	b.ne	48018fa0 <msh_auto_complete_path+0x264>  // b.any
                {
                    min_length = rt_strlen(dirent->d_name);
    48018f7c:	f94027e0 	ldr	x0, [sp, #72]
    48018f80:	91001000 	add	x0, x0, #0x4
    48018f84:	97ffd6bc 	bl	4800ea74 <rt_strlen>
    48018f88:	f9002be0 	str	x0, [sp, #80]
                    /* save dirent name */
                    strcpy(full_path, dirent->d_name);
    48018f8c:	f94027e0 	ldr	x0, [sp, #72]
    48018f90:	91001000 	add	x0, x0, #0x4
    48018f94:	aa0003e1 	mov	x1, x0
    48018f98:	f94023e0 	ldr	x0, [sp, #64]
    48018f9c:	94000c09 	bl	4801bfc0 <strcpy>
                }

                length = str_common(dirent->d_name, full_path);
    48018fa0:	f94027e0 	ldr	x0, [sp, #72]
    48018fa4:	91001000 	add	x0, x0, #0x4
    48018fa8:	f94023e1 	ldr	x1, [sp, #64]
    48018fac:	97ffff45 	bl	48018cc0 <str_common>
    48018fb0:	93407c00 	sxtw	x0, w0
    48018fb4:	f9001be0 	str	x0, [sp, #48]

                if (length < min_length)
    48018fb8:	f9401be1 	ldr	x1, [sp, #48]
    48018fbc:	f9402be0 	ldr	x0, [sp, #80]
    48018fc0:	eb00003f 	cmp	x1, x0
    48018fc4:	54fffb62 	b.cs	48018f30 <msh_auto_complete_path+0x1f4>  // b.hs, b.nlast
                {
                    min_length = length;
    48018fc8:	f9401be0 	ldr	x0, [sp, #48]
    48018fcc:	f9002be0 	str	x0, [sp, #80]
            dirent = readdir(dir);
    48018fd0:	17ffffd8 	b	48018f30 <msh_auto_complete_path+0x1f4>
            if (dirent == RT_NULL) break;
    48018fd4:	d503201f 	nop
                }
            }
        }

        if (min_length)
    48018fd8:	f9402be0 	ldr	x0, [sp, #80]
    48018fdc:	f100001f 	cmp	x0, #0x0
    48018fe0:	54000620 	b.eq	480190a4 <msh_auto_complete_path+0x368>  // b.none
        {
            if (min_length < rt_strlen(full_path))
    48018fe4:	f94023e0 	ldr	x0, [sp, #64]
    48018fe8:	97ffd6a3 	bl	4800ea74 <rt_strlen>
    48018fec:	aa0003e1 	mov	x1, x0
    48018ff0:	f9402be0 	ldr	x0, [sp, #80]
    48018ff4:	eb01001f 	cmp	x0, x1
    48018ff8:	54000362 	b.cs	48019064 <msh_auto_complete_path+0x328>  // b.hs, b.nlast
            {
                /* list the candidate */
                rewinddir(dir);
    48018ffc:	f94037e0 	ldr	x0, [sp, #104]
    48019000:	940009d4 	bl	4801b750 <rewinddir>

                for (;;)
                {
                    dirent = readdir(dir);
    48019004:	f94037e0 	ldr	x0, [sp, #104]
    48019008:	9400094e 	bl	4801b540 <readdir>
    4801900c:	f90027e0 	str	x0, [sp, #72]
                    if (dirent == RT_NULL) break;
    48019010:	f94027e0 	ldr	x0, [sp, #72]
    48019014:	f100001f 	cmp	x0, #0x0
    48019018:	54000240 	b.eq	48019060 <msh_auto_complete_path+0x324>  // b.none

                    if (strncmp(index, dirent->d_name, rt_strlen(index)) == 0)
    4801901c:	f94027e0 	ldr	x0, [sp, #72]
    48019020:	91001013 	add	x19, x0, #0x4
    48019024:	f9402fe0 	ldr	x0, [sp, #88]
    48019028:	97ffd693 	bl	4800ea74 <rt_strlen>
    4801902c:	aa0003e2 	mov	x2, x0
    48019030:	aa1303e1 	mov	x1, x19
    48019034:	f9402fe0 	ldr	x0, [sp, #88]
    48019038:	94000ca9 	bl	4801c2dc <strncmp>
    4801903c:	7100001f 	cmp	w0, #0x0
    48019040:	54fffe21 	b.ne	48019004 <msh_auto_complete_path+0x2c8>  // b.any
                        rt_kprintf("%s\n", dirent->d_name);
    48019044:	f94027e0 	ldr	x0, [sp, #72]
    48019048:	91001000 	add	x0, x0, #0x4
    4801904c:	aa0003e1 	mov	x1, x0
    48019050:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019054:	9128c000 	add	x0, x0, #0xa30
    48019058:	97ffdb36 	bl	4800fd30 <rt_kprintf>
                    dirent = readdir(dir);
    4801905c:	17ffffea 	b	48019004 <msh_auto_complete_path+0x2c8>
                    if (dirent == RT_NULL) break;
    48019060:	d503201f 	nop
                }
            }

            length = index - path;
    48019064:	f9402fe1 	ldr	x1, [sp, #88]
    48019068:	f94017e0 	ldr	x0, [sp, #40]
    4801906c:	cb000020 	sub	x0, x1, x0
    48019070:	f9001be0 	str	x0, [sp, #48]
            memcpy(index, full_path, min_length);
    48019074:	f9402be2 	ldr	x2, [sp, #80]
    48019078:	f94023e1 	ldr	x1, [sp, #64]
    4801907c:	f9402fe0 	ldr	x0, [sp, #88]
    48019080:	94000ab0 	bl	4801bb40 <memcpy>
            path[length + min_length] = '\0';
    48019084:	f9401be1 	ldr	x1, [sp, #48]
    48019088:	f9402be0 	ldr	x0, [sp, #80]
    4801908c:	8b000020 	add	x0, x1, x0
    48019090:	f94017e1 	ldr	x1, [sp, #40]
    48019094:	8b000020 	add	x0, x1, x0
    48019098:	3900001f 	strb	wzr, [x0]
    4801909c:	14000002 	b	480190a4 <msh_auto_complete_path+0x368>
            if (dirent == RT_NULL) break;
    480190a0:	d503201f 	nop
        }
    }

    closedir(dir);
    480190a4:	f94037e0 	ldr	x0, [sp, #104]
    480190a8:	940009c6 	bl	4801b7c0 <closedir>
    rt_free(full_path);
    480190ac:	f94023e0 	ldr	x0, [sp, #64]
    480190b0:	97ffc4c5 	bl	4800a3c4 <rt_free>
    480190b4:	14000004 	b	480190c4 <msh_auto_complete_path+0x388>
        return;
    480190b8:	d503201f 	nop
    480190bc:	14000002 	b	480190c4 <msh_auto_complete_path+0x388>
    if (full_path == RT_NULL) return; /* out of memory */
    480190c0:	d503201f 	nop
}
    480190c4:	f9400bf3 	ldr	x19, [sp, #16]
    480190c8:	a8c77bfd 	ldp	x29, x30, [sp], #112
    480190cc:	d65f03c0 	ret

00000000480190d0 <msh_auto_complete>:
#endif /* RT_USING_POSIX */

void msh_auto_complete(char *prefix)
{
    480190d0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    480190d4:	910003fd 	mov	x29, sp
    480190d8:	f9000fe0 	str	x0, [sp, #24]
    int length, min_length;
    const char *name_ptr, *cmd_name;
    struct finsh_syscall *index;

    min_length = 0;
    480190dc:	b9004fff 	str	wzr, [sp, #76]
    name_ptr = RT_NULL;
    480190e0:	f90023ff 	str	xzr, [sp, #64]

    if (*prefix == '\0')
    480190e4:	f9400fe0 	ldr	x0, [sp, #24]
    480190e8:	39400000 	ldrb	w0, [x0]
    480190ec:	7100001f 	cmp	w0, #0x0
    480190f0:	540000a1 	b.ne	48019104 <msh_auto_complete+0x34>  // b.any
    {
        msh_help(0, RT_NULL);
    480190f4:	d2800001 	mov	x1, #0x0                   	// #0
    480190f8:	52800000 	mov	w0, #0x0                   	// #0
    480190fc:	97fffd64 	bl	4801868c <msh_help>
        return;
    48019100:	1400004f 	b	4801923c <msh_auto_complete+0x16c>
#ifdef RT_USING_POSIX
    /* check whether a spare in the command */
    {
        char *ptr;

        ptr = prefix + rt_strlen(prefix);
    48019104:	f9400fe0 	ldr	x0, [sp, #24]
    48019108:	97ffd65b 	bl	4800ea74 <rt_strlen>
    4801910c:	aa0003e1 	mov	x1, x0
    48019110:	f9400fe0 	ldr	x0, [sp, #24]
    48019114:	8b010000 	add	x0, x0, x1
    48019118:	f9001be0 	str	x0, [sp, #48]
        while (ptr != prefix)
    4801911c:	1400000c 	b	4801914c <msh_auto_complete+0x7c>
        {
            if (*ptr == ' ')
    48019120:	f9401be0 	ldr	x0, [sp, #48]
    48019124:	39400000 	ldrb	w0, [x0]
    48019128:	7100801f 	cmp	w0, #0x20
    4801912c:	540000a1 	b.ne	48019140 <msh_auto_complete+0x70>  // b.any
            {
                msh_auto_complete_path(ptr + 1);
    48019130:	f9401be0 	ldr	x0, [sp, #48]
    48019134:	91000400 	add	x0, x0, #0x1
    48019138:	97ffff01 	bl	48018d3c <msh_auto_complete_path>
                break;
    4801913c:	14000008 	b	4801915c <msh_auto_complete+0x8c>
            }

            ptr --;
    48019140:	f9401be0 	ldr	x0, [sp, #48]
    48019144:	d1000400 	sub	x0, x0, #0x1
    48019148:	f9001be0 	str	x0, [sp, #48]
        while (ptr != prefix)
    4801914c:	f9401be1 	ldr	x1, [sp, #48]
    48019150:	f9400fe0 	ldr	x0, [sp, #24]
    48019154:	eb00003f 	cmp	x1, x0
    48019158:	54fffe41 	b.ne	48019120 <msh_auto_complete+0x50>  // b.any
    }
#endif /* RT_USING_DFS */

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
    4801915c:	90000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48019160:	91226000 	add	x0, x0, #0x898
    48019164:	f9400000 	ldr	x0, [x0]
    48019168:	f9001fe0 	str	x0, [sp, #56]
    4801916c:	14000025 	b	48019200 <msh_auto_complete+0x130>
        {
            /* skip finsh shell function */
            cmd_name = (const char *) index->name;
    48019170:	f9401fe0 	ldr	x0, [sp, #56]
    48019174:	f9400000 	ldr	x0, [x0]
    48019178:	f90017e0 	str	x0, [sp, #40]
            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
    4801917c:	f9400fe0 	ldr	x0, [sp, #24]
    48019180:	94000c00 	bl	4801c180 <strlen>
    48019184:	aa0003e2 	mov	x2, x0
    48019188:	f94017e1 	ldr	x1, [sp, #40]
    4801918c:	f9400fe0 	ldr	x0, [sp, #24]
    48019190:	94000c53 	bl	4801c2dc <strncmp>
    48019194:	7100001f 	cmp	w0, #0x0
    48019198:	540002e1 	b.ne	480191f4 <msh_auto_complete+0x124>  // b.any
            {
                if (min_length == 0)
    4801919c:	b9404fe0 	ldr	w0, [sp, #76]
    480191a0:	7100001f 	cmp	w0, #0x0
    480191a4:	540000c1 	b.ne	480191bc <msh_auto_complete+0xec>  // b.any
                {
                    /* set name_ptr */
                    name_ptr = cmd_name;
    480191a8:	f94017e0 	ldr	x0, [sp, #40]
    480191ac:	f90023e0 	str	x0, [sp, #64]
                    /* set initial length */
                    min_length = strlen(name_ptr);
    480191b0:	f94023e0 	ldr	x0, [sp, #64]
    480191b4:	94000bf3 	bl	4801c180 <strlen>
    480191b8:	b9004fe0 	str	w0, [sp, #76]
                }

                length = str_common(name_ptr, cmd_name);
    480191bc:	f94017e1 	ldr	x1, [sp, #40]
    480191c0:	f94023e0 	ldr	x0, [sp, #64]
    480191c4:	97fffebf 	bl	48018cc0 <str_common>
    480191c8:	b90027e0 	str	w0, [sp, #36]
                if (length < min_length)
    480191cc:	b94027e1 	ldr	w1, [sp, #36]
    480191d0:	b9404fe0 	ldr	w0, [sp, #76]
    480191d4:	6b00003f 	cmp	w1, w0
    480191d8:	5400006a 	b.ge	480191e4 <msh_auto_complete+0x114>  // b.tcont
                    min_length = length;
    480191dc:	b94027e0 	ldr	w0, [sp, #36]
    480191e0:	b9004fe0 	str	w0, [sp, #76]

                rt_kprintf("%s\n", cmd_name);
    480191e4:	f94017e1 	ldr	x1, [sp, #40]
    480191e8:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480191ec:	9128c000 	add	x0, x0, #0xa30
    480191f0:	97ffdad0 	bl	4800fd30 <rt_kprintf>
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
    480191f4:	f9401fe0 	ldr	x0, [sp, #56]
    480191f8:	91006000 	add	x0, x0, #0x18
    480191fc:	f9001fe0 	str	x0, [sp, #56]
    48019200:	90000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48019204:	91228000 	add	x0, x0, #0x8a0
    48019208:	f9400000 	ldr	x0, [x0]
    4801920c:	f9401fe1 	ldr	x1, [sp, #56]
    48019210:	eb00003f 	cmp	x1, x0
    48019214:	54fffae3 	b.cc	48019170 <msh_auto_complete+0xa0>  // b.lo, b.ul, b.last
            }
        }
    }

    /* auto complete string */
    if (name_ptr != NULL)
    48019218:	f94023e0 	ldr	x0, [sp, #64]
    4801921c:	f100001f 	cmp	x0, #0x0
    48019220:	540000c0 	b.eq	48019238 <msh_auto_complete+0x168>  // b.none
    {
        rt_strncpy(prefix, name_ptr, min_length);
    48019224:	b9804fe0 	ldrsw	x0, [sp, #76]
    48019228:	aa0003e2 	mov	x2, x0
    4801922c:	f94023e1 	ldr	x1, [sp, #64]
    48019230:	f9400fe0 	ldr	x0, [sp, #24]
    48019234:	97ffd5a9 	bl	4800e8d8 <rt_strncpy>
    }

    return ;
    48019238:	d503201f 	nop
}
    4801923c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    48019240:	d65f03c0 	ret

0000000048019244 <msh_readline>:
#include <finsh.h>
#include "msh.h"
#include <dfs_posix.h>

static int msh_readline(int fd, char *line_buf, int size)
{
    48019244:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48019248:	910003fd 	mov	x29, sp
    4801924c:	b9001fe0 	str	w0, [sp, #28]
    48019250:	f9000be1 	str	x1, [sp, #16]
    48019254:	b9001be2 	str	w2, [sp, #24]
    char ch;
    int index = 0;
    48019258:	b9002fff 	str	wzr, [sp, #44]

    do
    {
        if (read(fd, &ch, 1) != 1)
    4801925c:	9100afe0 	add	x0, sp, #0x2b
    48019260:	d2800022 	mov	x2, #0x1                   	// #1
    48019264:	aa0003e1 	mov	x1, x0
    48019268:	b9401fe0 	ldr	w0, [sp, #28]
    4801926c:	9400067f 	bl	4801ac68 <read>
    48019270:	7100041f 	cmp	w0, #0x1
    48019274:	54000060 	b.eq	48019280 <msh_readline+0x3c>  // b.none
        {
            /* nothing in this file */
            return 0;
    48019278:	52800000 	mov	w0, #0x0                   	// #0
    4801927c:	14000035 	b	48019350 <msh_readline+0x10c>
        }
    }
    while (ch == '\n' || ch == '\r');
    48019280:	3940afe0 	ldrb	w0, [sp, #43]
    48019284:	7100281f 	cmp	w0, #0xa
    48019288:	54fffea0 	b.eq	4801925c <msh_readline+0x18>  // b.none
    4801928c:	3940afe0 	ldrb	w0, [sp, #43]
    48019290:	7100341f 	cmp	w0, #0xd
    48019294:	54fffe40 	b.eq	4801925c <msh_readline+0x18>  // b.none

    /* set the first character */
    line_buf[index ++] = ch;
    48019298:	b9402fe0 	ldr	w0, [sp, #44]
    4801929c:	11000401 	add	w1, w0, #0x1
    480192a0:	b9002fe1 	str	w1, [sp, #44]
    480192a4:	93407c00 	sxtw	x0, w0
    480192a8:	f9400be1 	ldr	x1, [sp, #16]
    480192ac:	8b000020 	add	x0, x1, x0
    480192b0:	3940afe1 	ldrb	w1, [sp, #43]
    480192b4:	39000001 	strb	w1, [x0]

    while (index < size)
    480192b8:	14000021 	b	4801933c <msh_readline+0xf8>
    {
        if (read(fd, &ch, 1) == 1)
    480192bc:	9100afe0 	add	x0, sp, #0x2b
    480192c0:	d2800022 	mov	x2, #0x1                   	// #1
    480192c4:	aa0003e1 	mov	x1, x0
    480192c8:	b9401fe0 	ldr	w0, [sp, #28]
    480192cc:	94000667 	bl	4801ac68 <read>
    480192d0:	7100041f 	cmp	w0, #0x1
    480192d4:	540002a1 	b.ne	48019328 <msh_readline+0xe4>  // b.any
        {
            if (ch == '\n' || ch == '\r')
    480192d8:	3940afe0 	ldrb	w0, [sp, #43]
    480192dc:	7100281f 	cmp	w0, #0xa
    480192e0:	54000080 	b.eq	480192f0 <msh_readline+0xac>  // b.none
    480192e4:	3940afe0 	ldrb	w0, [sp, #43]
    480192e8:	7100341f 	cmp	w0, #0xd
    480192ec:	540000c1 	b.ne	48019304 <msh_readline+0xc0>  // b.any
            {
                line_buf[index] = '\0';
    480192f0:	b9802fe0 	ldrsw	x0, [sp, #44]
    480192f4:	f9400be1 	ldr	x1, [sp, #16]
    480192f8:	8b000020 	add	x0, x1, x0
    480192fc:	3900001f 	strb	wzr, [x0]
                break;
    48019300:	14000013 	b	4801934c <msh_readline+0x108>
            }

            line_buf[index++] = ch;
    48019304:	b9402fe0 	ldr	w0, [sp, #44]
    48019308:	11000401 	add	w1, w0, #0x1
    4801930c:	b9002fe1 	str	w1, [sp, #44]
    48019310:	93407c00 	sxtw	x0, w0
    48019314:	f9400be1 	ldr	x1, [sp, #16]
    48019318:	8b000020 	add	x0, x1, x0
    4801931c:	3940afe1 	ldrb	w1, [sp, #43]
    48019320:	39000001 	strb	w1, [x0]
    48019324:	14000006 	b	4801933c <msh_readline+0xf8>
        }
        else
        {
            line_buf[index] = '\0';
    48019328:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801932c:	f9400be1 	ldr	x1, [sp, #16]
    48019330:	8b000020 	add	x0, x1, x0
    48019334:	3900001f 	strb	wzr, [x0]
            break;
    48019338:	14000005 	b	4801934c <msh_readline+0x108>
    while (index < size)
    4801933c:	b9402fe1 	ldr	w1, [sp, #44]
    48019340:	b9401be0 	ldr	w0, [sp, #24]
    48019344:	6b00003f 	cmp	w1, w0
    48019348:	54fffbab 	b.lt	480192bc <msh_readline+0x78>  // b.tstop
        }
    }

    return index;
    4801934c:	b9402fe0 	ldr	w0, [sp, #44]
}
    48019350:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48019354:	d65f03c0 	ret

0000000048019358 <msh_exec_script>:

int msh_exec_script(const char *cmd_line, int size)
{
    48019358:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4801935c:	910003fd 	mov	x29, sp
    48019360:	f9000fe0 	str	x0, [sp, #24]
    48019364:	b90017e1 	str	w1, [sp, #20]
    int ret;
    int fd = -1;
    48019368:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801936c:	b9004be0 	str	w0, [sp, #72]
    char *pg_name;
    int length, cmd_length = 0;
    48019370:	b90047ff 	str	wzr, [sp, #68]

    if (size == 0) return -RT_ERROR;
    48019374:	b94017e0 	ldr	w0, [sp, #20]
    48019378:	7100001f 	cmp	w0, #0x0
    4801937c:	540000c1 	b.ne	48019394 <msh_exec_script+0x3c>  // b.any
    48019380:	12800000 	mov	w0, #0xffffffff            	// #-1
    48019384:	14000089 	b	480195a8 <msh_exec_script+0x250>

    /* get the length of command0 */
    while ((cmd_line[cmd_length] != ' ' && cmd_line[cmd_length] != '\t') && cmd_length < size)
        cmd_length ++;
    48019388:	b94047e0 	ldr	w0, [sp, #68]
    4801938c:	11000400 	add	w0, w0, #0x1
    48019390:	b90047e0 	str	w0, [sp, #68]
    while ((cmd_line[cmd_length] != ' ' && cmd_line[cmd_length] != '\t') && cmd_length < size)
    48019394:	b98047e0 	ldrsw	x0, [sp, #68]
    48019398:	f9400fe1 	ldr	x1, [sp, #24]
    4801939c:	8b000020 	add	x0, x1, x0
    480193a0:	39400000 	ldrb	w0, [x0]
    480193a4:	7100801f 	cmp	w0, #0x20
    480193a8:	54000160 	b.eq	480193d4 <msh_exec_script+0x7c>  // b.none
    480193ac:	b98047e0 	ldrsw	x0, [sp, #68]
    480193b0:	f9400fe1 	ldr	x1, [sp, #24]
    480193b4:	8b000020 	add	x0, x1, x0
    480193b8:	39400000 	ldrb	w0, [x0]
    480193bc:	7100241f 	cmp	w0, #0x9
    480193c0:	540000a0 	b.eq	480193d4 <msh_exec_script+0x7c>  // b.none
    480193c4:	b94047e1 	ldr	w1, [sp, #68]
    480193c8:	b94017e0 	ldr	w0, [sp, #20]
    480193cc:	6b00003f 	cmp	w1, w0
    480193d0:	54fffdcb 	b.lt	48019388 <msh_exec_script+0x30>  // b.tstop

    /* get name length */
    length = cmd_length + 32;
    480193d4:	b94047e0 	ldr	w0, [sp, #68]
    480193d8:	11008000 	add	w0, w0, #0x20
    480193dc:	b9003be0 	str	w0, [sp, #56]

    /* allocate program name memory */
    pg_name = (char *) rt_malloc(length);
    480193e0:	b9803be0 	ldrsw	x0, [sp, #56]
    480193e4:	97ffc1e9 	bl	48009b88 <rt_malloc>
    480193e8:	f9001be0 	str	x0, [sp, #48]
    if (pg_name == RT_NULL) return -RT_ENOMEM;
    480193ec:	f9401be0 	ldr	x0, [sp, #48]
    480193f0:	f100001f 	cmp	x0, #0x0
    480193f4:	54000061 	b.ne	48019400 <msh_exec_script+0xa8>  // b.any
    480193f8:	12800080 	mov	w0, #0xfffffffb            	// #-5
    480193fc:	1400006b 	b	480195a8 <msh_exec_script+0x250>

    /* copy command0 */
    memcpy(pg_name, cmd_line, cmd_length);
    48019400:	b98047e0 	ldrsw	x0, [sp, #68]
    48019404:	aa0003e2 	mov	x2, x0
    48019408:	f9400fe1 	ldr	x1, [sp, #24]
    4801940c:	f9401be0 	ldr	x0, [sp, #48]
    48019410:	940009cc 	bl	4801bb40 <memcpy>
    pg_name[cmd_length] = '\0';
    48019414:	b98047e0 	ldrsw	x0, [sp, #68]
    48019418:	f9401be1 	ldr	x1, [sp, #48]
    4801941c:	8b000020 	add	x0, x1, x0
    48019420:	3900001f 	strb	wzr, [x0]

    if (strstr(pg_name, ".sh") != RT_NULL || strstr(pg_name, ".SH") != RT_NULL)
    48019424:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019428:	91292001 	add	x1, x0, #0xa48
    4801942c:	f9401be0 	ldr	x0, [sp, #48]
    48019430:	94000e44 	bl	4801cd40 <strstr>
    48019434:	f100001f 	cmp	x0, #0x0
    48019438:	540000e1 	b.ne	48019454 <msh_exec_script+0xfc>  // b.any
    4801943c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019440:	91294001 	add	x1, x0, #0xa50
    48019444:	f9401be0 	ldr	x0, [sp, #48]
    48019448:	94000e3e 	bl	4801cd40 <strstr>
    4801944c:	f100001f 	cmp	x0, #0x0
    48019450:	540002e0 	b.eq	480194ac <msh_exec_script+0x154>  // b.none
    {
        /* try to open program */
        fd = open(pg_name, O_RDONLY, 0);
    48019454:	52800002 	mov	w2, #0x0                   	// #0
    48019458:	52800001 	mov	w1, #0x0                   	// #0
    4801945c:	f9401be0 	ldr	x0, [sp, #48]
    48019460:	940005b1 	bl	4801ab24 <open>
    48019464:	b9004be0 	str	w0, [sp, #72]

        /* search in /bin path */
        if (fd < 0)
    48019468:	b9404be0 	ldr	w0, [sp, #72]
    4801946c:	7100001f 	cmp	w0, #0x0
    48019470:	540001ea 	b.ge	480194ac <msh_exec_script+0x154>  // b.tcont
        {
            rt_snprintf(pg_name, length - 1, "/bin/%.*s", cmd_length, cmd_line);
    48019474:	b9403be0 	ldr	w0, [sp, #56]
    48019478:	51000400 	sub	w0, w0, #0x1
    4801947c:	93407c01 	sxtw	x1, w0
    48019480:	f9400fe4 	ldr	x4, [sp, #24]
    48019484:	b94047e3 	ldr	w3, [sp, #68]
    48019488:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801948c:	91296002 	add	x2, x0, #0xa58
    48019490:	f9401be0 	ldr	x0, [sp, #48]
    48019494:	97ffd96e 	bl	4800fa4c <rt_snprintf>
            fd = open(pg_name, O_RDONLY, 0);
    48019498:	52800002 	mov	w2, #0x0                   	// #0
    4801949c:	52800001 	mov	w1, #0x0                   	// #0
    480194a0:	f9401be0 	ldr	x0, [sp, #48]
    480194a4:	940005a0 	bl	4801ab24 <open>
    480194a8:	b9004be0 	str	w0, [sp, #72]
        }
    }

    rt_free(pg_name);
    480194ac:	f9401be0 	ldr	x0, [sp, #48]
    480194b0:	97ffc3c5 	bl	4800a3c4 <rt_free>
    if (fd >= 0)
    480194b4:	b9404be0 	ldr	w0, [sp, #72]
    480194b8:	7100001f 	cmp	w0, #0x0
    480194bc:	5400070b 	b.lt	4801959c <msh_exec_script+0x244>  // b.tstop
    {
        /* found script */
        char *line_buf;
        int length;

        line_buf = (char *) rt_malloc(RT_CONSOLEBUF_SIZE);
    480194c0:	d2801000 	mov	x0, #0x80                  	// #128
    480194c4:	97ffc1b1 	bl	48009b88 <rt_malloc>
    480194c8:	f90017e0 	str	x0, [sp, #40]
        if (line_buf == RT_NULL)
    480194cc:	f94017e0 	ldr	x0, [sp, #40]
    480194d0:	f100001f 	cmp	x0, #0x0
    480194d4:	540000a1 	b.ne	480194e8 <msh_exec_script+0x190>  // b.any
        {
            close(fd);
    480194d8:	b9404be0 	ldr	w0, [sp, #72]
    480194dc:	940005c5 	bl	4801abf0 <close>
            return -RT_ENOMEM;
    480194e0:	12800080 	mov	w0, #0xfffffffb            	// #-5
    480194e4:	14000031 	b	480195a8 <msh_exec_script+0x250>
        }

        /* read line by line and then exec it */
        do
        {
            length = msh_readline(fd, line_buf, RT_CONSOLEBUF_SIZE);
    480194e8:	52801002 	mov	w2, #0x80                  	// #128
    480194ec:	f94017e1 	ldr	x1, [sp, #40]
    480194f0:	b9404be0 	ldr	w0, [sp, #72]
    480194f4:	97ffff54 	bl	48019244 <msh_readline>
    480194f8:	b90027e0 	str	w0, [sp, #36]
            if (length > 0)
    480194fc:	b94027e0 	ldr	w0, [sp, #36]
    48019500:	7100001f 	cmp	w0, #0x0
    48019504:	540003ad 	b.le	48019578 <msh_exec_script+0x220>
            {
                char ch = '\0';
    48019508:	39010fff 	strb	wzr, [sp, #67]
                int index;

                for (index = 0; index < length; index ++)
    4801950c:	b9003fff 	str	wzr, [sp, #60]
    48019510:	1400000f 	b	4801954c <msh_exec_script+0x1f4>
                {
                    ch = line_buf[index];
    48019514:	b9803fe0 	ldrsw	x0, [sp, #60]
    48019518:	f94017e1 	ldr	x1, [sp, #40]
    4801951c:	8b000020 	add	x0, x1, x0
    48019520:	39400000 	ldrb	w0, [x0]
    48019524:	39010fe0 	strb	w0, [sp, #67]
                    if (ch == ' ' || ch == '\t') continue;
    48019528:	39410fe0 	ldrb	w0, [sp, #67]
    4801952c:	7100801f 	cmp	w0, #0x20
    48019530:	54000080 	b.eq	48019540 <msh_exec_script+0x1e8>  // b.none
    48019534:	39410fe0 	ldrb	w0, [sp, #67]
    48019538:	7100241f 	cmp	w0, #0x9
    4801953c:	54000101 	b.ne	4801955c <msh_exec_script+0x204>  // b.any
                for (index = 0; index < length; index ++)
    48019540:	b9403fe0 	ldr	w0, [sp, #60]
    48019544:	11000400 	add	w0, w0, #0x1
    48019548:	b9003fe0 	str	w0, [sp, #60]
    4801954c:	b9403fe1 	ldr	w1, [sp, #60]
    48019550:	b94027e0 	ldr	w0, [sp, #36]
    48019554:	6b00003f 	cmp	w1, w0
    48019558:	54fffdeb 	b.lt	48019514 <msh_exec_script+0x1bc>  // b.tstop
                    else break;
                }

                if (ch != '#') /* not a comment */
    4801955c:	39410fe0 	ldrb	w0, [sp, #67]
    48019560:	71008c1f 	cmp	w0, #0x23
    48019564:	540000a0 	b.eq	48019578 <msh_exec_script+0x220>  // b.none
                    msh_exec(line_buf, length);
    48019568:	b98027e0 	ldrsw	x0, [sp, #36]
    4801956c:	aa0003e1 	mov	x1, x0
    48019570:	f94017e0 	ldr	x0, [sp, #40]
    48019574:	97fffd90 	bl	48018bb4 <msh_exec>
            }
        }
        while (length > 0);
    48019578:	b94027e0 	ldr	w0, [sp, #36]
    4801957c:	7100001f 	cmp	w0, #0x0
    48019580:	54fffb4c 	b.gt	480194e8 <msh_exec_script+0x190>

        close(fd);
    48019584:	b9404be0 	ldr	w0, [sp, #72]
    48019588:	9400059a 	bl	4801abf0 <close>
        rt_free(line_buf);
    4801958c:	f94017e0 	ldr	x0, [sp, #40]
    48019590:	97ffc38d 	bl	4800a3c4 <rt_free>

        ret = 0;
    48019594:	b9004fff 	str	wzr, [sp, #76]
    48019598:	14000003 	b	480195a4 <msh_exec_script+0x24c>
    }
    else
    {
        ret = -1;
    4801959c:	12800000 	mov	w0, #0xffffffff            	// #-1
    480195a0:	b9004fe0 	str	w0, [sp, #76]
    }

    return ret;
    480195a4:	b9404fe0 	ldr	w0, [sp, #76]
}
    480195a8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    480195ac:	d65f03c0 	ret

00000000480195b0 <cmd_ls>:
#ifdef DFS_USING_WORKDIR
    extern char working_directory[];
#endif

static int cmd_ls(int argc, char **argv)
{
    480195b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480195b4:	910003fd 	mov	x29, sp
    480195b8:	b9001fe0 	str	w0, [sp, #28]
    480195bc:	f9000be1 	str	x1, [sp, #16]
    extern void ls(const char *pathname);

    if (argc == 1)
    480195c0:	b9401fe0 	ldr	w0, [sp, #28]
    480195c4:	7100041f 	cmp	w0, #0x1
    480195c8:	540000a1 	b.ne	480195dc <cmd_ls+0x2c>  // b.any
    {
#ifdef DFS_USING_WORKDIR
        ls(working_directory);
    480195cc:	90000040 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    480195d0:	911a6000 	add	x0, x0, #0x698
    480195d4:	97ffe4c5 	bl	480128e8 <ls>
    480195d8:	14000005 	b	480195ec <cmd_ls+0x3c>
        ls("/");
#endif
    }
    else
    {
        ls(argv[1]);
    480195dc:	f9400be0 	ldr	x0, [sp, #16]
    480195e0:	91002000 	add	x0, x0, #0x8
    480195e4:	f9400000 	ldr	x0, [x0]
    480195e8:	97ffe4c0 	bl	480128e8 <ls>
    }

    return 0;
    480195ec:	52800000 	mov	w0, #0x0                   	// #0
}
    480195f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    480195f4:	d65f03c0 	ret

00000000480195f8 <cmd_cp>:
MSH_CMD_EXPORT_ALIAS(cmd_ls, ls, List information about the FILEs.);

static int cmd_cp(int argc, char **argv)
{
    480195f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    480195fc:	910003fd 	mov	x29, sp
    48019600:	b9001fe0 	str	w0, [sp, #28]
    48019604:	f9000be1 	str	x1, [sp, #16]
    void copy(const char *src, const char *dst);

    if (argc != 3)
    48019608:	b9401fe0 	ldr	w0, [sp, #28]
    4801960c:	71000c1f 	cmp	w0, #0x3
    48019610:	54000100 	b.eq	48019630 <cmd_cp+0x38>  // b.none
    {
        rt_kprintf("Usage: cp SOURCE DEST\n");
    48019614:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019618:	9129a000 	add	x0, x0, #0xa68
    4801961c:	97ffd9c5 	bl	4800fd30 <rt_kprintf>
        rt_kprintf("Copy SOURCE to DEST.\n");
    48019620:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019624:	912a0000 	add	x0, x0, #0xa80
    48019628:	97ffd9c2 	bl	4800fd30 <rt_kprintf>
    4801962c:	1400000a 	b	48019654 <cmd_cp+0x5c>
    }
    else
    {
        copy(argv[1], argv[2]);
    48019630:	f9400be0 	ldr	x0, [sp, #16]
    48019634:	91002000 	add	x0, x0, #0x8
    48019638:	f9400002 	ldr	x2, [x0]
    4801963c:	f9400be0 	ldr	x0, [sp, #16]
    48019640:	91004000 	add	x0, x0, #0x10
    48019644:	f9400000 	ldr	x0, [x0]
    48019648:	aa0003e1 	mov	x1, x0
    4801964c:	aa0203e0 	mov	x0, x2
    48019650:	97ffe623 	bl	48012edc <copy>
    }

    return 0;
    48019654:	52800000 	mov	w0, #0x0                   	// #0
}
    48019658:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801965c:	d65f03c0 	ret

0000000048019660 <cmd_mv>:
MSH_CMD_EXPORT_ALIAS(cmd_cp, cp, Copy SOURCE to DEST.);

static int cmd_mv(int argc, char **argv)
{
    48019660:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    48019664:	910003fd 	mov	x29, sp
    48019668:	f9000bf3 	str	x19, [sp, #16]
    4801966c:	b9002fe0 	str	w0, [sp, #44]
    48019670:	f90013e1 	str	x1, [sp, #32]
    if (argc != 3)
    48019674:	b9402fe0 	ldr	w0, [sp, #44]
    48019678:	71000c1f 	cmp	w0, #0x3
    4801967c:	54000100 	b.eq	4801969c <cmd_mv+0x3c>  // b.none
    {
        rt_kprintf("Usage: mv SOURCE DEST\n");
    48019680:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019684:	912a6000 	add	x0, x0, #0xa98
    48019688:	97ffd9aa 	bl	4800fd30 <rt_kprintf>
        rt_kprintf("Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n");
    4801968c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019690:	912ac000 	add	x0, x0, #0xab0
    48019694:	97ffd9a7 	bl	4800fd30 <rt_kprintf>
    48019698:	1400006a 	b	48019840 <cmd_mv+0x1e0>
    }
    else
    {
        int fd;
        char *dest = RT_NULL;
    4801969c:	f90027ff 	str	xzr, [sp, #72]

        rt_kprintf("%s => %s\n", argv[1], argv[2]);
    480196a0:	f94013e0 	ldr	x0, [sp, #32]
    480196a4:	91002000 	add	x0, x0, #0x8
    480196a8:	f9400001 	ldr	x1, [x0]
    480196ac:	f94013e0 	ldr	x0, [sp, #32]
    480196b0:	91004000 	add	x0, x0, #0x10
    480196b4:	f9400000 	ldr	x0, [x0]
    480196b8:	aa0003e2 	mov	x2, x0
    480196bc:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480196c0:	912ba000 	add	x0, x0, #0xae8
    480196c4:	97ffd99b 	bl	4800fd30 <rt_kprintf>

        fd = open(argv[2], O_DIRECTORY, 0);
    480196c8:	f94013e0 	ldr	x0, [sp, #32]
    480196cc:	91004000 	add	x0, x0, #0x10
    480196d0:	f9400000 	ldr	x0, [x0]
    480196d4:	52800002 	mov	w2, #0x0                   	// #0
    480196d8:	52a00401 	mov	w1, #0x200000              	// #2097152
    480196dc:	94000512 	bl	4801ab24 <open>
    480196e0:	b9003fe0 	str	w0, [sp, #60]
        if (fd >= 0)
    480196e4:	b9403fe0 	ldr	w0, [sp, #60]
    480196e8:	7100001f 	cmp	w0, #0x0
    480196ec:	5400064b 	b.lt	480197b4 <cmd_mv+0x154>  // b.tstop
        {
            char *src;

            close(fd);
    480196f0:	b9403fe0 	ldr	w0, [sp, #60]
    480196f4:	9400053f 	bl	4801abf0 <close>

            /* it's a directory */
            dest = (char *)rt_malloc(DFS_PATH_MAX);
    480196f8:	d2802000 	mov	x0, #0x100                 	// #256
    480196fc:	97ffc123 	bl	48009b88 <rt_malloc>
    48019700:	f90027e0 	str	x0, [sp, #72]
            if (dest == RT_NULL)
    48019704:	f94027e0 	ldr	x0, [sp, #72]
    48019708:	f100001f 	cmp	x0, #0x0
    4801970c:	540000c1 	b.ne	48019724 <cmd_mv+0xc4>  // b.any
            {
                rt_kprintf("out of memory\n");
    48019710:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019714:	912be000 	add	x0, x0, #0xaf8
    48019718:	97ffd986 	bl	4800fd30 <rt_kprintf>
                return -RT_ENOMEM;
    4801971c:	12800080 	mov	w0, #0xfffffffb            	// #-5
    48019720:	14000049 	b	48019844 <cmd_mv+0x1e4>
            }

            src = argv[1] + rt_strlen(argv[1]);
    48019724:	f94013e0 	ldr	x0, [sp, #32]
    48019728:	91002000 	add	x0, x0, #0x8
    4801972c:	f9400013 	ldr	x19, [x0]
    48019730:	f94013e0 	ldr	x0, [sp, #32]
    48019734:	91002000 	add	x0, x0, #0x8
    48019738:	f9400000 	ldr	x0, [x0]
    4801973c:	97ffd4ce 	bl	4800ea74 <rt_strlen>
    48019740:	8b000260 	add	x0, x19, x0
    48019744:	f90023e0 	str	x0, [sp, #64]
            while (src != argv[1])
    48019748:	14000008 	b	48019768 <cmd_mv+0x108>
            {
                if (*src == '/') break;
    4801974c:	f94023e0 	ldr	x0, [sp, #64]
    48019750:	39400000 	ldrb	w0, [x0]
    48019754:	7100bc1f 	cmp	w0, #0x2f
    48019758:	54000160 	b.eq	48019784 <cmd_mv+0x124>  // b.none
                src --;
    4801975c:	f94023e0 	ldr	x0, [sp, #64]
    48019760:	d1000400 	sub	x0, x0, #0x1
    48019764:	f90023e0 	str	x0, [sp, #64]
            while (src != argv[1])
    48019768:	f94013e0 	ldr	x0, [sp, #32]
    4801976c:	91002000 	add	x0, x0, #0x8
    48019770:	f9400000 	ldr	x0, [x0]
    48019774:	f94023e1 	ldr	x1, [sp, #64]
    48019778:	eb00003f 	cmp	x1, x0
    4801977c:	54fffe81 	b.ne	4801974c <cmd_mv+0xec>  // b.any
    48019780:	14000002 	b	48019788 <cmd_mv+0x128>
                if (*src == '/') break;
    48019784:	d503201f 	nop
            }

            rt_snprintf(dest, DFS_PATH_MAX - 1, "%s/%s", argv[2], src);
    48019788:	f94013e0 	ldr	x0, [sp, #32]
    4801978c:	91004000 	add	x0, x0, #0x10
    48019790:	f9400000 	ldr	x0, [x0]
    48019794:	f94023e4 	ldr	x4, [sp, #64]
    48019798:	aa0003e3 	mov	x3, x0
    4801979c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480197a0:	912c2002 	add	x2, x0, #0xb08
    480197a4:	d2801fe1 	mov	x1, #0xff                  	// #255
    480197a8:	f94027e0 	ldr	x0, [sp, #72]
    480197ac:	97ffd8a8 	bl	4800fa4c <rt_snprintf>
    480197b0:	14000014 	b	48019800 <cmd_mv+0x1a0>
        }
        else
        {
            fd = open(argv[2], O_RDONLY, 0);
    480197b4:	f94013e0 	ldr	x0, [sp, #32]
    480197b8:	91004000 	add	x0, x0, #0x10
    480197bc:	f9400000 	ldr	x0, [x0]
    480197c0:	52800002 	mov	w2, #0x0                   	// #0
    480197c4:	52800001 	mov	w1, #0x0                   	// #0
    480197c8:	940004d7 	bl	4801ab24 <open>
    480197cc:	b9003fe0 	str	w0, [sp, #60]
            if (fd >= 0)
    480197d0:	b9403fe0 	ldr	w0, [sp, #60]
    480197d4:	7100001f 	cmp	w0, #0x0
    480197d8:	540000eb 	b.lt	480197f4 <cmd_mv+0x194>  // b.tstop
            {
                close(fd);
    480197dc:	b9403fe0 	ldr	w0, [sp, #60]
    480197e0:	94000504 	bl	4801abf0 <close>

                unlink(argv[2]);
    480197e4:	f94013e0 	ldr	x0, [sp, #32]
    480197e8:	91004000 	add	x0, x0, #0x10
    480197ec:	f9400000 	ldr	x0, [x0]
    480197f0:	940005bd 	bl	4801aee4 <unlink>
            }

            dest = argv[2];
    480197f4:	f94013e0 	ldr	x0, [sp, #32]
    480197f8:	f9400800 	ldr	x0, [x0, #16]
    480197fc:	f90027e0 	str	x0, [sp, #72]
        }

        rename(argv[1], dest);
    48019800:	f94013e0 	ldr	x0, [sp, #32]
    48019804:	91002000 	add	x0, x0, #0x8
    48019808:	f9400000 	ldr	x0, [x0]
    4801980c:	f94027e1 	ldr	x1, [sp, #72]
    48019810:	940005a3 	bl	4801ae9c <rename>
        if (dest != RT_NULL && dest != argv[2]) rt_free(dest);
    48019814:	f94027e0 	ldr	x0, [sp, #72]
    48019818:	f100001f 	cmp	x0, #0x0
    4801981c:	54000120 	b.eq	48019840 <cmd_mv+0x1e0>  // b.none
    48019820:	f94013e0 	ldr	x0, [sp, #32]
    48019824:	91004000 	add	x0, x0, #0x10
    48019828:	f9400000 	ldr	x0, [x0]
    4801982c:	f94027e1 	ldr	x1, [sp, #72]
    48019830:	eb00003f 	cmp	x1, x0
    48019834:	54000060 	b.eq	48019840 <cmd_mv+0x1e0>  // b.none
    48019838:	f94027e0 	ldr	x0, [sp, #72]
    4801983c:	97ffc2e2 	bl	4800a3c4 <rt_free>
    }

    return 0;
    48019840:	52800000 	mov	w0, #0x0                   	// #0
}
    48019844:	f9400bf3 	ldr	x19, [sp, #16]
    48019848:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4801984c:	d65f03c0 	ret

0000000048019850 <cmd_cat>:
MSH_CMD_EXPORT_ALIAS(cmd_mv, mv, Rename SOURCE to DEST.);

static int cmd_cat(int argc, char **argv)
{
    48019850:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48019854:	910003fd 	mov	x29, sp
    48019858:	b9001fe0 	str	w0, [sp, #28]
    4801985c:	f9000be1 	str	x1, [sp, #16]
    int index;
    extern void cat(const char *filename);

    if (argc == 1)
    48019860:	b9401fe0 	ldr	w0, [sp, #28]
    48019864:	7100041f 	cmp	w0, #0x1
    48019868:	54000121 	b.ne	4801988c <cmd_cat+0x3c>  // b.any
    {
        rt_kprintf("Usage: cat [FILE]...\n");
    4801986c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019870:	912c4000 	add	x0, x0, #0xb10
    48019874:	97ffd92f 	bl	4800fd30 <rt_kprintf>
        rt_kprintf("Concatenate FILE(s)\n");
    48019878:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801987c:	912ca000 	add	x0, x0, #0xb28
    48019880:	97ffd92c 	bl	4800fd30 <rt_kprintf>
        return 0;
    48019884:	52800000 	mov	w0, #0x0                   	// #0
    48019888:	14000012 	b	480198d0 <cmd_cat+0x80>
    }

    for (index = 1; index < argc; index ++)
    4801988c:	52800020 	mov	w0, #0x1                   	// #1
    48019890:	b9002fe0 	str	w0, [sp, #44]
    48019894:	1400000a 	b	480198bc <cmd_cat+0x6c>
    {
        cat(argv[index]);
    48019898:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801989c:	d37df000 	lsl	x0, x0, #3
    480198a0:	f9400be1 	ldr	x1, [sp, #16]
    480198a4:	8b000020 	add	x0, x1, x0
    480198a8:	f9400000 	ldr	x0, [x0]
    480198ac:	97ffe489 	bl	48012ad0 <cat>
    for (index = 1; index < argc; index ++)
    480198b0:	b9402fe0 	ldr	w0, [sp, #44]
    480198b4:	11000400 	add	w0, w0, #0x1
    480198b8:	b9002fe0 	str	w0, [sp, #44]
    480198bc:	b9402fe1 	ldr	w1, [sp, #44]
    480198c0:	b9401fe0 	ldr	w0, [sp, #28]
    480198c4:	6b00003f 	cmp	w1, w0
    480198c8:	54fffe8b 	b.lt	48019898 <cmd_cat+0x48>  // b.tstop
    }

    return 0;
    480198cc:	52800000 	mov	w0, #0x0                   	// #0
}
    480198d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    480198d4:	d65f03c0 	ret

00000000480198d8 <directory_delete_for_msh>:
MSH_CMD_EXPORT_ALIAS(cmd_cat, cat, Concatenate FILE(s));

static void directory_delete_for_msh(const char *pathname, char f, char v)
{
    480198d8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    480198dc:	910003fd 	mov	x29, sp
    480198e0:	f9000fe0 	str	x0, [sp, #24]
    480198e4:	39005fe1 	strb	w1, [sp, #23]
    480198e8:	39005be2 	strb	w2, [sp, #22]
    DIR *dir = NULL;
    480198ec:	f9001fff 	str	xzr, [sp, #56]
    struct dirent *dirent = NULL;
    480198f0:	f9001bff 	str	xzr, [sp, #48]
    char *full_path;

    if (pathname == RT_NULL)
    480198f4:	f9400fe0 	ldr	x0, [sp, #24]
    480198f8:	f100001f 	cmp	x0, #0x0
    480198fc:	54000de0 	b.eq	48019ab8 <directory_delete_for_msh+0x1e0>  // b.none
        return;

    full_path = (char *)rt_malloc(DFS_PATH_MAX);
    48019900:	d2802000 	mov	x0, #0x100                 	// #256
    48019904:	97ffc0a1 	bl	48009b88 <rt_malloc>
    48019908:	f90017e0 	str	x0, [sp, #40]
    if (full_path == RT_NULL)
    4801990c:	f94017e0 	ldr	x0, [sp, #40]
    48019910:	f100001f 	cmp	x0, #0x0
    48019914:	54000d60 	b.eq	48019ac0 <directory_delete_for_msh+0x1e8>  // b.none
        return;

    dir = opendir(pathname);
    48019918:	f9400fe0 	ldr	x0, [sp, #24]
    4801991c:	940006d2 	bl	4801b464 <opendir>
    48019920:	f9001fe0 	str	x0, [sp, #56]
    if (dir == RT_NULL)
    48019924:	f9401fe0 	ldr	x0, [sp, #56]
    48019928:	f100001f 	cmp	x0, #0x0
    4801992c:	54000161 	b.ne	48019958 <directory_delete_for_msh+0x80>  // b.any
    {
        if (f == 0)
    48019930:	39405fe0 	ldrb	w0, [sp, #23]
    48019934:	7100001f 	cmp	w0, #0x0
    48019938:	540000a1 	b.ne	4801994c <directory_delete_for_msh+0x74>  // b.any
        {
            rt_kprintf("cannot remove '%s'\n", pathname);
    4801993c:	f9400fe1 	ldr	x1, [sp, #24]
    48019940:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019944:	912d0000 	add	x0, x0, #0xb40
    48019948:	97ffd8fa 	bl	4800fd30 <rt_kprintf>
        }
        rt_free(full_path);
    4801994c:	f94017e0 	ldr	x0, [sp, #40]
    48019950:	97ffc29d 	bl	4800a3c4 <rt_free>
        return;
    48019954:	1400005c 	b	48019ac4 <directory_delete_for_msh+0x1ec>
    }

    while (1)
    {
        dirent = readdir(dir);
    48019958:	f9401fe0 	ldr	x0, [sp, #56]
    4801995c:	940006f9 	bl	4801b540 <readdir>
    48019960:	f9001be0 	str	x0, [sp, #48]
        if (dirent == RT_NULL)
    48019964:	f9401be0 	ldr	x0, [sp, #48]
    48019968:	f100001f 	cmp	x0, #0x0
    4801996c:	54000740 	b.eq	48019a54 <directory_delete_for_msh+0x17c>  // b.none
            break;
        if (rt_strcmp(".", dirent->d_name) != 0 &&
    48019970:	f9401be0 	ldr	x0, [sp, #48]
    48019974:	91001000 	add	x0, x0, #0x4
    48019978:	aa0003e1 	mov	x1, x0
    4801997c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019980:	912d6000 	add	x0, x0, #0xb58
    48019984:	97ffd420 	bl	4800ea04 <rt_strcmp>
    48019988:	7100001f 	cmp	w0, #0x0
    4801998c:	54fffe60 	b.eq	48019958 <directory_delete_for_msh+0x80>  // b.none
                rt_strcmp("..", dirent->d_name) != 0)
    48019990:	f9401be0 	ldr	x0, [sp, #48]
    48019994:	91001000 	add	x0, x0, #0x4
    48019998:	aa0003e1 	mov	x1, x0
    4801999c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480199a0:	912d8000 	add	x0, x0, #0xb60
    480199a4:	97ffd418 	bl	4800ea04 <rt_strcmp>
        if (rt_strcmp(".", dirent->d_name) != 0 &&
    480199a8:	7100001f 	cmp	w0, #0x0
    480199ac:	54fffd60 	b.eq	48019958 <directory_delete_for_msh+0x80>  // b.none
        {
            rt_sprintf(full_path, "%s/%s", pathname, dirent->d_name);
    480199b0:	f9401be0 	ldr	x0, [sp, #48]
    480199b4:	91001000 	add	x0, x0, #0x4
    480199b8:	aa0003e3 	mov	x3, x0
    480199bc:	f9400fe2 	ldr	x2, [sp, #24]
    480199c0:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    480199c4:	912c2001 	add	x1, x0, #0xb08
    480199c8:	f94017e0 	ldr	x0, [sp, #40]
    480199cc:	97ffd861 	bl	4800fb50 <rt_sprintf>
            if (dirent->d_type == DT_REG)
    480199d0:	f9401be0 	ldr	x0, [sp, #48]
    480199d4:	39400000 	ldrb	w0, [x0]
    480199d8:	7100041f 	cmp	w0, #0x1
    480199dc:	540002a1 	b.ne	48019a30 <directory_delete_for_msh+0x158>  // b.any
            {
                if (unlink(full_path) != 0)
    480199e0:	f94017e0 	ldr	x0, [sp, #40]
    480199e4:	94000540 	bl	4801aee4 <unlink>
    480199e8:	7100001f 	cmp	w0, #0x0
    480199ec:	54000120 	b.eq	48019a10 <directory_delete_for_msh+0x138>  // b.none
                {
                    if (f == 0)
    480199f0:	39405fe0 	ldrb	w0, [sp, #23]
    480199f4:	7100001f 	cmp	w0, #0x0
    480199f8:	54fffb01 	b.ne	48019958 <directory_delete_for_msh+0x80>  // b.any
                        rt_kprintf("cannot remove '%s'\n", full_path);
    480199fc:	f94017e1 	ldr	x1, [sp, #40]
    48019a00:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019a04:	912d0000 	add	x0, x0, #0xb40
    48019a08:	97ffd8ca 	bl	4800fd30 <rt_kprintf>
    48019a0c:	17ffffd3 	b	48019958 <directory_delete_for_msh+0x80>
                }
                else if (v)
    48019a10:	39405be0 	ldrb	w0, [sp, #22]
    48019a14:	7100001f 	cmp	w0, #0x0
    48019a18:	54fffa00 	b.eq	48019958 <directory_delete_for_msh+0x80>  // b.none
                {
                    rt_kprintf("removed '%s'\n", full_path);
    48019a1c:	f94017e1 	ldr	x1, [sp, #40]
    48019a20:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019a24:	912da000 	add	x0, x0, #0xb68
    48019a28:	97ffd8c2 	bl	4800fd30 <rt_kprintf>
    48019a2c:	17ffffcb 	b	48019958 <directory_delete_for_msh+0x80>
                }
            }
            else if (dirent->d_type == DT_DIR)
    48019a30:	f9401be0 	ldr	x0, [sp, #48]
    48019a34:	39400000 	ldrb	w0, [x0]
    48019a38:	7100081f 	cmp	w0, #0x2
    48019a3c:	54fff8e1 	b.ne	48019958 <directory_delete_for_msh+0x80>  // b.any
            {
                directory_delete_for_msh(full_path, f, v);
    48019a40:	39405be2 	ldrb	w2, [sp, #22]
    48019a44:	39405fe1 	ldrb	w1, [sp, #23]
    48019a48:	f94017e0 	ldr	x0, [sp, #40]
    48019a4c:	97ffffa3 	bl	480198d8 <directory_delete_for_msh>
        dirent = readdir(dir);
    48019a50:	17ffffc2 	b	48019958 <directory_delete_for_msh+0x80>
            break;
    48019a54:	d503201f 	nop
            }
        }
    }
    closedir(dir);
    48019a58:	f9401fe0 	ldr	x0, [sp, #56]
    48019a5c:	94000759 	bl	4801b7c0 <closedir>
    rt_free(full_path);
    48019a60:	f94017e0 	ldr	x0, [sp, #40]
    48019a64:	97ffc258 	bl	4800a3c4 <rt_free>
    if (unlink(pathname) != 0)
    48019a68:	f9400fe0 	ldr	x0, [sp, #24]
    48019a6c:	9400051e 	bl	4801aee4 <unlink>
    48019a70:	7100001f 	cmp	w0, #0x0
    48019a74:	54000120 	b.eq	48019a98 <directory_delete_for_msh+0x1c0>  // b.none
    {
        if (f == 0)
    48019a78:	39405fe0 	ldrb	w0, [sp, #23]
    48019a7c:	7100001f 	cmp	w0, #0x0
    48019a80:	54000221 	b.ne	48019ac4 <directory_delete_for_msh+0x1ec>  // b.any
            rt_kprintf("cannot remove '%s'\n", pathname);
    48019a84:	f9400fe1 	ldr	x1, [sp, #24]
    48019a88:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019a8c:	912d0000 	add	x0, x0, #0xb40
    48019a90:	97ffd8a8 	bl	4800fd30 <rt_kprintf>
    48019a94:	1400000c 	b	48019ac4 <directory_delete_for_msh+0x1ec>
    }
    else if (v)
    48019a98:	39405be0 	ldrb	w0, [sp, #22]
    48019a9c:	7100001f 	cmp	w0, #0x0
    48019aa0:	54000120 	b.eq	48019ac4 <directory_delete_for_msh+0x1ec>  // b.none
    {
        rt_kprintf("removed directory '%s'\n", pathname);
    48019aa4:	f9400fe1 	ldr	x1, [sp, #24]
    48019aa8:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019aac:	912de000 	add	x0, x0, #0xb78
    48019ab0:	97ffd8a0 	bl	4800fd30 <rt_kprintf>
    48019ab4:	14000004 	b	48019ac4 <directory_delete_for_msh+0x1ec>
        return;
    48019ab8:	d503201f 	nop
    48019abc:	14000002 	b	48019ac4 <directory_delete_for_msh+0x1ec>
        return;
    48019ac0:	d503201f 	nop
    }
}
    48019ac4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    48019ac8:	d65f03c0 	ret

0000000048019acc <cmd_rm>:

static int cmd_rm(int argc, char **argv)
{
    48019acc:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    48019ad0:	910003fd 	mov	x29, sp
    48019ad4:	b9001fe0 	str	w0, [sp, #28]
    48019ad8:	f9000be1 	str	x1, [sp, #16]
    int index, n;
    char f = 0, r = 0, v = 0;
    48019adc:	39025fff 	strb	wzr, [sp, #151]
    48019ae0:	39025bff 	strb	wzr, [sp, #150]
    48019ae4:	390257ff 	strb	wzr, [sp, #149]

    if (argc == 1)
    48019ae8:	b9401fe0 	ldr	w0, [sp, #28]
    48019aec:	7100041f 	cmp	w0, #0x1
    48019af0:	54000121 	b.ne	48019b14 <cmd_rm+0x48>  // b.any
    {
        rt_kprintf("Usage: rm option(s) FILE...\n");
    48019af4:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019af8:	912e4000 	add	x0, x0, #0xb90
    48019afc:	97ffd88d 	bl	4800fd30 <rt_kprintf>
        rt_kprintf("Remove (unlink) the FILE(s).\n");
    48019b00:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019b04:	912ec000 	add	x0, x0, #0xbb0
    48019b08:	97ffd88a 	bl	4800fd30 <rt_kprintf>
        return 0;
    48019b0c:	52800000 	mov	w0, #0x0                   	// #0
    48019b10:	140000a2 	b	48019d98 <cmd_rm+0x2cc>
    }

    if (argv[1][0] == '-')
    48019b14:	f9400be0 	ldr	x0, [sp, #16]
    48019b18:	91002000 	add	x0, x0, #0x8
    48019b1c:	f9400000 	ldr	x0, [x0]
    48019b20:	39400000 	ldrb	w0, [x0]
    48019b24:	7100b41f 	cmp	w0, #0x2d
    48019b28:	54000781 	b.ne	48019c18 <cmd_rm+0x14c>  // b.any
    {
        for (n = 0; argv[1][n]; n++)
    48019b2c:	b9009bff 	str	wzr, [sp, #152]
    48019b30:	1400002c 	b	48019be0 <cmd_rm+0x114>
        {
            switch (argv[1][n])
    48019b34:	f9400be0 	ldr	x0, [sp, #16]
    48019b38:	91002000 	add	x0, x0, #0x8
    48019b3c:	f9400001 	ldr	x1, [x0]
    48019b40:	b9809be0 	ldrsw	x0, [sp, #152]
    48019b44:	8b000020 	add	x0, x1, x0
    48019b48:	39400000 	ldrb	w0, [x0]
    48019b4c:	7101d81f 	cmp	w0, #0x76
    48019b50:	54000220 	b.eq	48019b94 <cmd_rm+0xc8>  // b.none
    48019b54:	7101d81f 	cmp	w0, #0x76
    48019b58:	5400024c 	b.gt	48019ba0 <cmd_rm+0xd4>
    48019b5c:	7101c81f 	cmp	w0, #0x72
    48019b60:	54000140 	b.eq	48019b88 <cmd_rm+0xbc>  // b.none
    48019b64:	7101c81f 	cmp	w0, #0x72
    48019b68:	540001cc 	b.gt	48019ba0 <cmd_rm+0xd4>
    48019b6c:	7100b41f 	cmp	w0, #0x2d
    48019b70:	54000300 	b.eq	48019bd0 <cmd_rm+0x104>  // b.none
    48019b74:	7101981f 	cmp	w0, #0x66
    48019b78:	54000141 	b.ne	48019ba0 <cmd_rm+0xd4>  // b.any
            {
            case 'f':
                f = 1;
    48019b7c:	52800020 	mov	w0, #0x1                   	// #1
    48019b80:	39025fe0 	strb	w0, [sp, #151]
                break;
    48019b84:	14000014 	b	48019bd4 <cmd_rm+0x108>
            case 'r':
                r = 1;
    48019b88:	52800020 	mov	w0, #0x1                   	// #1
    48019b8c:	39025be0 	strb	w0, [sp, #150]
                break;
    48019b90:	14000011 	b	48019bd4 <cmd_rm+0x108>
            case 'v':
                v = 1;
    48019b94:	52800020 	mov	w0, #0x1                   	// #1
    48019b98:	390257e0 	strb	w0, [sp, #149]
                break;
    48019b9c:	1400000e 	b	48019bd4 <cmd_rm+0x108>
            case '-':
                break;
            default:
                rt_kprintf("Error: Bad option: %c\n", argv[1][n]);
    48019ba0:	f9400be0 	ldr	x0, [sp, #16]
    48019ba4:	91002000 	add	x0, x0, #0x8
    48019ba8:	f9400001 	ldr	x1, [x0]
    48019bac:	b9809be0 	ldrsw	x0, [sp, #152]
    48019bb0:	8b000020 	add	x0, x1, x0
    48019bb4:	39400000 	ldrb	w0, [x0]
    48019bb8:	2a0003e1 	mov	w1, w0
    48019bbc:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019bc0:	912f4000 	add	x0, x0, #0xbd0
    48019bc4:	97ffd85b 	bl	4800fd30 <rt_kprintf>
                return 0;
    48019bc8:	52800000 	mov	w0, #0x0                   	// #0
    48019bcc:	14000073 	b	48019d98 <cmd_rm+0x2cc>
                break;
    48019bd0:	d503201f 	nop
        for (n = 0; argv[1][n]; n++)
    48019bd4:	b9409be0 	ldr	w0, [sp, #152]
    48019bd8:	11000400 	add	w0, w0, #0x1
    48019bdc:	b9009be0 	str	w0, [sp, #152]
    48019be0:	f9400be0 	ldr	x0, [sp, #16]
    48019be4:	91002000 	add	x0, x0, #0x8
    48019be8:	f9400001 	ldr	x1, [x0]
    48019bec:	b9809be0 	ldrsw	x0, [sp, #152]
    48019bf0:	8b000020 	add	x0, x1, x0
    48019bf4:	39400000 	ldrb	w0, [x0]
    48019bf8:	7100001f 	cmp	w0, #0x0
    48019bfc:	54fff9c1 	b.ne	48019b34 <cmd_rm+0x68>  // b.any
            }
        }
        argc -= 1;
    48019c00:	b9401fe0 	ldr	w0, [sp, #28]
    48019c04:	51000400 	sub	w0, w0, #0x1
    48019c08:	b9001fe0 	str	w0, [sp, #28]
        argv = argv + 1;
    48019c0c:	f9400be0 	ldr	x0, [sp, #16]
    48019c10:	91002000 	add	x0, x0, #0x8
    48019c14:	f9000be0 	str	x0, [sp, #16]
    }

    for (index = 1; index < argc; index ++)
    48019c18:	52800020 	mov	w0, #0x1                   	// #1
    48019c1c:	b9009fe0 	str	w0, [sp, #156]
    48019c20:	14000059 	b	48019d84 <cmd_rm+0x2b8>
    {
        struct stat s;
        if (stat(argv[index], &s) == 0)
    48019c24:	b9809fe0 	ldrsw	x0, [sp, #156]
    48019c28:	d37df000 	lsl	x0, x0, #3
    48019c2c:	f9400be1 	ldr	x1, [sp, #16]
    48019c30:	8b000020 	add	x0, x1, x0
    48019c34:	f9400000 	ldr	x0, [x0]
    48019c38:	9100a3e1 	add	x1, sp, #0x28
    48019c3c:	940004ba 	bl	4801af24 <stat>
    48019c40:	7100001f 	cmp	w0, #0x0
    48019c44:	54000821 	b.ne	48019d48 <cmd_rm+0x27c>  // b.any
        {
            if (s.st_mode & S_IFDIR)
    48019c48:	b9402fe0 	ldr	w0, [sp, #44]
    48019c4c:	12120000 	and	w0, w0, #0x4000
    48019c50:	7100001f 	cmp	w0, #0x0
    48019c54:	540002e0 	b.eq	48019cb0 <cmd_rm+0x1e4>  // b.none
            {
                if (r == 0)
    48019c58:	39425be0 	ldrb	w0, [sp, #150]
    48019c5c:	7100001f 	cmp	w0, #0x0
    48019c60:	54000161 	b.ne	48019c8c <cmd_rm+0x1c0>  // b.any
                    rt_kprintf("cannot remove '%s': Is a directory\n", argv[index]);
    48019c64:	b9809fe0 	ldrsw	x0, [sp, #156]
    48019c68:	d37df000 	lsl	x0, x0, #3
    48019c6c:	f9400be1 	ldr	x1, [sp, #16]
    48019c70:	8b000020 	add	x0, x1, x0
    48019c74:	f9400000 	ldr	x0, [x0]
    48019c78:	aa0003e1 	mov	x1, x0
    48019c7c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019c80:	912fa000 	add	x0, x0, #0xbe8
    48019c84:	97ffd82b 	bl	4800fd30 <rt_kprintf>
    48019c88:	1400003c 	b	48019d78 <cmd_rm+0x2ac>
                else
                    directory_delete_for_msh(argv[index], f, v);
    48019c8c:	b9809fe0 	ldrsw	x0, [sp, #156]
    48019c90:	d37df000 	lsl	x0, x0, #3
    48019c94:	f9400be1 	ldr	x1, [sp, #16]
    48019c98:	8b000020 	add	x0, x1, x0
    48019c9c:	f9400000 	ldr	x0, [x0]
    48019ca0:	394257e2 	ldrb	w2, [sp, #149]
    48019ca4:	39425fe1 	ldrb	w1, [sp, #151]
    48019ca8:	97ffff0c 	bl	480198d8 <directory_delete_for_msh>
    48019cac:	14000033 	b	48019d78 <cmd_rm+0x2ac>
            }
            else if (s.st_mode & S_IFREG)
    48019cb0:	b9402fe0 	ldr	w0, [sp, #44]
    48019cb4:	12110000 	and	w0, w0, #0x8000
    48019cb8:	7100001f 	cmp	w0, #0x0
    48019cbc:	540005e0 	b.eq	48019d78 <cmd_rm+0x2ac>  // b.none
            {
                if (unlink(argv[index]) != 0)
    48019cc0:	b9809fe0 	ldrsw	x0, [sp, #156]
    48019cc4:	d37df000 	lsl	x0, x0, #3
    48019cc8:	f9400be1 	ldr	x1, [sp, #16]
    48019ccc:	8b000020 	add	x0, x1, x0
    48019cd0:	f9400000 	ldr	x0, [x0]
    48019cd4:	94000484 	bl	4801aee4 <unlink>
    48019cd8:	7100001f 	cmp	w0, #0x0
    48019cdc:	540001c0 	b.eq	48019d14 <cmd_rm+0x248>  // b.none
                {
                    if (f == 0)
    48019ce0:	39425fe0 	ldrb	w0, [sp, #151]
    48019ce4:	7100001f 	cmp	w0, #0x0
    48019ce8:	54000481 	b.ne	48019d78 <cmd_rm+0x2ac>  // b.any
                        rt_kprintf("cannot remove '%s'\n", argv[index]);
    48019cec:	b9809fe0 	ldrsw	x0, [sp, #156]
    48019cf0:	d37df000 	lsl	x0, x0, #3
    48019cf4:	f9400be1 	ldr	x1, [sp, #16]
    48019cf8:	8b000020 	add	x0, x1, x0
    48019cfc:	f9400000 	ldr	x0, [x0]
    48019d00:	aa0003e1 	mov	x1, x0
    48019d04:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019d08:	912d0000 	add	x0, x0, #0xb40
    48019d0c:	97ffd809 	bl	4800fd30 <rt_kprintf>
    48019d10:	1400001a 	b	48019d78 <cmd_rm+0x2ac>
                }
                else if (v)
    48019d14:	394257e0 	ldrb	w0, [sp, #149]
    48019d18:	7100001f 	cmp	w0, #0x0
    48019d1c:	540002e0 	b.eq	48019d78 <cmd_rm+0x2ac>  // b.none
                {
                    rt_kprintf("removed '%s'\n", argv[index]);
    48019d20:	b9809fe0 	ldrsw	x0, [sp, #156]
    48019d24:	d37df000 	lsl	x0, x0, #3
    48019d28:	f9400be1 	ldr	x1, [sp, #16]
    48019d2c:	8b000020 	add	x0, x1, x0
    48019d30:	f9400000 	ldr	x0, [x0]
    48019d34:	aa0003e1 	mov	x1, x0
    48019d38:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019d3c:	912da000 	add	x0, x0, #0xb68
    48019d40:	97ffd7fc 	bl	4800fd30 <rt_kprintf>
    48019d44:	1400000d 	b	48019d78 <cmd_rm+0x2ac>
                }
            }
        }
        else if (f == 0)
    48019d48:	39425fe0 	ldrb	w0, [sp, #151]
    48019d4c:	7100001f 	cmp	w0, #0x0
    48019d50:	54000141 	b.ne	48019d78 <cmd_rm+0x2ac>  // b.any
        {
            rt_kprintf("cannot remove '%s': No such file or directory\n", argv[index]);
    48019d54:	b9809fe0 	ldrsw	x0, [sp, #156]
    48019d58:	d37df000 	lsl	x0, x0, #3
    48019d5c:	f9400be1 	ldr	x1, [sp, #16]
    48019d60:	8b000020 	add	x0, x1, x0
    48019d64:	f9400000 	ldr	x0, [x0]
    48019d68:	aa0003e1 	mov	x1, x0
    48019d6c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019d70:	91304000 	add	x0, x0, #0xc10
    48019d74:	97ffd7ef 	bl	4800fd30 <rt_kprintf>
    for (index = 1; index < argc; index ++)
    48019d78:	b9409fe0 	ldr	w0, [sp, #156]
    48019d7c:	11000400 	add	w0, w0, #0x1
    48019d80:	b9009fe0 	str	w0, [sp, #156]
    48019d84:	b9409fe1 	ldr	w1, [sp, #156]
    48019d88:	b9401fe0 	ldr	w0, [sp, #28]
    48019d8c:	6b00003f 	cmp	w1, w0
    48019d90:	54fff4ab 	b.lt	48019c24 <cmd_rm+0x158>  // b.tstop
        }
    }
    return 0;
    48019d94:	52800000 	mov	w0, #0x0                   	// #0
}
    48019d98:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    48019d9c:	d65f03c0 	ret

0000000048019da0 <cmd_cd>:
MSH_CMD_EXPORT_ALIAS(cmd_rm, rm, Remove(unlink) the FILE(s).);

#ifdef DFS_USING_WORKDIR
static int cmd_cd(int argc, char **argv)
{
    48019da0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48019da4:	910003fd 	mov	x29, sp
    48019da8:	b9001fe0 	str	w0, [sp, #28]
    48019dac:	f9000be1 	str	x1, [sp, #16]
    if (argc == 1)
    48019db0:	b9401fe0 	ldr	w0, [sp, #28]
    48019db4:	7100041f 	cmp	w0, #0x1
    48019db8:	540000e1 	b.ne	48019dd4 <cmd_cd+0x34>  // b.any
    {
        rt_kprintf("%s\n", working_directory);
    48019dbc:	90000040 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48019dc0:	911a6001 	add	x1, x0, #0x698
    48019dc4:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019dc8:	91310000 	add	x0, x0, #0xc40
    48019dcc:	97ffd7d9 	bl	4800fd30 <rt_kprintf>
    48019dd0:	14000011 	b	48019e14 <cmd_cd+0x74>
    }
    else if (argc == 2)
    48019dd4:	b9401fe0 	ldr	w0, [sp, #28]
    48019dd8:	7100081f 	cmp	w0, #0x2
    48019ddc:	540001c1 	b.ne	48019e14 <cmd_cd+0x74>  // b.any
    {
        if (chdir(argv[1]) != 0)
    48019de0:	f9400be0 	ldr	x0, [sp, #16]
    48019de4:	91002000 	add	x0, x0, #0x8
    48019de8:	f9400000 	ldr	x0, [x0]
    48019dec:	94000696 	bl	4801b844 <chdir>
    48019df0:	7100001f 	cmp	w0, #0x0
    48019df4:	54000100 	b.eq	48019e14 <cmd_cd+0x74>  // b.none
        {
            rt_kprintf("No such directory: %s\n", argv[1]);
    48019df8:	f9400be0 	ldr	x0, [sp, #16]
    48019dfc:	91002000 	add	x0, x0, #0x8
    48019e00:	f9400000 	ldr	x0, [x0]
    48019e04:	aa0003e1 	mov	x1, x0
    48019e08:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019e0c:	91312000 	add	x0, x0, #0xc48
    48019e10:	97ffd7c8 	bl	4800fd30 <rt_kprintf>
        }
    }

    return 0;
    48019e14:	52800000 	mov	w0, #0x0                   	// #0
}
    48019e18:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48019e1c:	d65f03c0 	ret

0000000048019e20 <cmd_pwd>:
MSH_CMD_EXPORT_ALIAS(cmd_cd, cd, Change the shell working directory.);

static int cmd_pwd(int argc, char **argv)
{
    48019e20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48019e24:	910003fd 	mov	x29, sp
    48019e28:	b9001fe0 	str	w0, [sp, #28]
    48019e2c:	f9000be1 	str	x1, [sp, #16]
    rt_kprintf("%s\n", working_directory);
    48019e30:	90000040 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    48019e34:	911a6001 	add	x1, x0, #0x698
    48019e38:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019e3c:	91310000 	add	x0, x0, #0xc40
    48019e40:	97ffd7bc 	bl	4800fd30 <rt_kprintf>
    return 0;
    48019e44:	52800000 	mov	w0, #0x0                   	// #0
}
    48019e48:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48019e4c:	d65f03c0 	ret

0000000048019e50 <cmd_mkdir>:
MSH_CMD_EXPORT_ALIAS(cmd_pwd, pwd, Print the name of the current working directory.);
#endif

static int cmd_mkdir(int argc, char **argv)
{
    48019e50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    48019e54:	910003fd 	mov	x29, sp
    48019e58:	b9001fe0 	str	w0, [sp, #28]
    48019e5c:	f9000be1 	str	x1, [sp, #16]
    if (argc == 1)
    48019e60:	b9401fe0 	ldr	w0, [sp, #28]
    48019e64:	7100041f 	cmp	w0, #0x1
    48019e68:	54000101 	b.ne	48019e88 <cmd_mkdir+0x38>  // b.any
    {
        rt_kprintf("Usage: mkdir [OPTION] DIRECTORY\n");
    48019e6c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019e70:	91318000 	add	x0, x0, #0xc60
    48019e74:	97ffd7af 	bl	4800fd30 <rt_kprintf>
        rt_kprintf("Create the DIRECTORY, if they do not already exist.\n");
    48019e78:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019e7c:	91322000 	add	x0, x0, #0xc88
    48019e80:	97ffd7ac 	bl	4800fd30 <rt_kprintf>
    48019e84:	14000006 	b	48019e9c <cmd_mkdir+0x4c>
    }
    else
    {
        mkdir(argv[1], 0);
    48019e88:	f9400be0 	ldr	x0, [sp, #16]
    48019e8c:	91002000 	add	x0, x0, #0x8
    48019e90:	f9400000 	ldr	x0, [x0]
    48019e94:	52800001 	mov	w1, #0x0                   	// #0
    48019e98:	94000539 	bl	4801b37c <mkdir>
    }

    return 0;
    48019e9c:	52800000 	mov	w0, #0x0                   	// #0
}
    48019ea0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    48019ea4:	d65f03c0 	ret

0000000048019ea8 <cmd_mkfs>:
MSH_CMD_EXPORT_ALIAS(cmd_mkdir, mkdir, Create the DIRECTORY.);

static int cmd_mkfs(int argc, char **argv)
{
    48019ea8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    48019eac:	910003fd 	mov	x29, sp
    48019eb0:	b9001fe0 	str	w0, [sp, #28]
    48019eb4:	f9000be1 	str	x1, [sp, #16]
    int result = 0;
    48019eb8:	b9002fff 	str	wzr, [sp, #44]
    char *type = "elm"; /* use the default file system type as 'fatfs' */
    48019ebc:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019ec0:	91330000 	add	x0, x0, #0xcc0
    48019ec4:	f90013e0 	str	x0, [sp, #32]

    if (argc == 2)
    48019ec8:	b9401fe0 	ldr	w0, [sp, #28]
    48019ecc:	7100081f 	cmp	w0, #0x2
    48019ed0:	54000121 	b.ne	48019ef4 <cmd_mkfs+0x4c>  // b.any
    {
        result = dfs_mkfs(type, argv[1]);
    48019ed4:	f9400be0 	ldr	x0, [sp, #16]
    48019ed8:	91002000 	add	x0, x0, #0x8
    48019edc:	f9400000 	ldr	x0, [x0]
    48019ee0:	aa0003e1 	mov	x1, x0
    48019ee4:	f94013e0 	ldr	x0, [sp, #32]
    48019ee8:	97ffdb75 	bl	48010cbc <dfs_mkfs>
    48019eec:	b9002fe0 	str	w0, [sp, #44]
    48019ef0:	1400001d 	b	48019f64 <cmd_mkfs+0xbc>
    }
    else if (argc == 4)
    48019ef4:	b9401fe0 	ldr	w0, [sp, #28]
    48019ef8:	7100101f 	cmp	w0, #0x4
    48019efc:	540002a1 	b.ne	48019f50 <cmd_mkfs+0xa8>  // b.any
    {
        if (strcmp(argv[1], "-t") == 0)
    48019f00:	f9400be0 	ldr	x0, [sp, #16]
    48019f04:	91002000 	add	x0, x0, #0x8
    48019f08:	f9400002 	ldr	x2, [x0]
    48019f0c:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019f10:	91332001 	add	x1, x0, #0xcc8
    48019f14:	aa0203e0 	mov	x0, x2
    48019f18:	940007ea 	bl	4801bec0 <strcmp>
    48019f1c:	7100001f 	cmp	w0, #0x0
    48019f20:	54000221 	b.ne	48019f64 <cmd_mkfs+0xbc>  // b.any
        {
            type = argv[2];
    48019f24:	f9400be0 	ldr	x0, [sp, #16]
    48019f28:	f9400800 	ldr	x0, [x0, #16]
    48019f2c:	f90013e0 	str	x0, [sp, #32]
            result = dfs_mkfs(type, argv[3]);
    48019f30:	f9400be0 	ldr	x0, [sp, #16]
    48019f34:	91006000 	add	x0, x0, #0x18
    48019f38:	f9400000 	ldr	x0, [x0]
    48019f3c:	aa0003e1 	mov	x1, x0
    48019f40:	f94013e0 	ldr	x0, [sp, #32]
    48019f44:	97ffdb5e 	bl	48010cbc <dfs_mkfs>
    48019f48:	b9002fe0 	str	w0, [sp, #44]
    48019f4c:	14000006 	b	48019f64 <cmd_mkfs+0xbc>
        }
    }
    else
    {
        rt_kprintf("Usage: mkfs [-t type] device\n");
    48019f50:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019f54:	91334000 	add	x0, x0, #0xcd0
    48019f58:	97ffd776 	bl	4800fd30 <rt_kprintf>
        return 0;
    48019f5c:	52800000 	mov	w0, #0x0                   	// #0
    48019f60:	14000009 	b	48019f84 <cmd_mkfs+0xdc>
    }

    if (result != RT_EOK)
    48019f64:	b9402fe0 	ldr	w0, [sp, #44]
    48019f68:	7100001f 	cmp	w0, #0x0
    48019f6c:	540000a0 	b.eq	48019f80 <cmd_mkfs+0xd8>  // b.none
    {
        rt_kprintf("mkfs failed, result=%d\n", result);
    48019f70:	b9402fe1 	ldr	w1, [sp, #44]
    48019f74:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019f78:	9133c000 	add	x0, x0, #0xcf0
    48019f7c:	97ffd76d 	bl	4800fd30 <rt_kprintf>
    }

    return 0;
    48019f80:	52800000 	mov	w0, #0x0                   	// #0
}
    48019f84:	a8c37bfd 	ldp	x29, x30, [sp], #48
    48019f88:	d65f03c0 	ret

0000000048019f8c <cmd_mount>:
MSH_CMD_EXPORT_ALIAS(cmd_mkfs, mkfs, format disk with file system);

extern struct dfs_filesystem filesystem_table[];
static int cmd_mount(int argc, char **argv)
{
    48019f8c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    48019f90:	910003fd 	mov	x29, sp
    48019f94:	b9001fe0 	str	w0, [sp, #28]
    48019f98:	f9000be1 	str	x1, [sp, #16]
    if (argc == 1)
    48019f9c:	b9401fe0 	ldr	w0, [sp, #28]
    48019fa0:	7100041f 	cmp	w0, #0x1
    48019fa4:	54000501 	b.ne	4801a044 <cmd_mount+0xb8>  // b.any
    {
        struct dfs_filesystem *iter;

        /* display the mount history */
        rt_kprintf("filesystem  device  mountpoint\n");
    48019fa8:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019fac:	91342000 	add	x0, x0, #0xd08
    48019fb0:	97ffd760 	bl	4800fd30 <rt_kprintf>
        rt_kprintf("----------  ------  ----------\n");
    48019fb4:	f0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    48019fb8:	9134a000 	add	x0, x0, #0xd28
    48019fbc:	97ffd75d 	bl	4800fd30 <rt_kprintf>
        for (iter = &filesystem_table[0];
    48019fc0:	90000100 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    48019fc4:	911ac000 	add	x0, x0, #0x6b0
    48019fc8:	f9001fe0 	str	x0, [sp, #56]
    48019fcc:	14000017 	b	4801a028 <cmd_mount+0x9c>
                iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
        {
            if ((iter != NULL) && (iter->path != NULL))
    48019fd0:	f9401fe0 	ldr	x0, [sp, #56]
    48019fd4:	f100001f 	cmp	x0, #0x0
    48019fd8:	54000220 	b.eq	4801a01c <cmd_mount+0x90>  // b.none
    48019fdc:	f9401fe0 	ldr	x0, [sp, #56]
    48019fe0:	f9400400 	ldr	x0, [x0, #8]
    48019fe4:	f100001f 	cmp	x0, #0x0
    48019fe8:	540001a0 	b.eq	4801a01c <cmd_mount+0x90>  // b.none
            {
                rt_kprintf("%-10s  %-6s  %-s\n",
                           iter->ops->name, iter->dev_id->parent.name, iter->path);
    48019fec:	f9401fe0 	ldr	x0, [sp, #56]
    48019ff0:	f9400800 	ldr	x0, [x0, #16]
                rt_kprintf("%-10s  %-6s  %-s\n",
    48019ff4:	f9400001 	ldr	x1, [x0]
                           iter->ops->name, iter->dev_id->parent.name, iter->path);
    48019ff8:	f9401fe0 	ldr	x0, [sp, #56]
    48019ffc:	f9400000 	ldr	x0, [x0]
    4801a000:	aa0003e2 	mov	x2, x0
                rt_kprintf("%-10s  %-6s  %-s\n",
    4801a004:	f9401fe0 	ldr	x0, [sp, #56]
    4801a008:	f9400400 	ldr	x0, [x0, #8]
    4801a00c:	aa0003e3 	mov	x3, x0
    4801a010:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a014:	91352000 	add	x0, x0, #0xd48
    4801a018:	97ffd746 	bl	4800fd30 <rt_kprintf>
                iter < &filesystem_table[DFS_FILESYSTEMS_MAX]; iter++)
    4801a01c:	f9401fe0 	ldr	x0, [sp, #56]
    4801a020:	91008000 	add	x0, x0, #0x20
    4801a024:	f9001fe0 	str	x0, [sp, #56]
        for (iter = &filesystem_table[0];
    4801a028:	f9401fe1 	ldr	x1, [sp, #56]
    4801a02c:	f00000e0 	adrp	x0, 48039000 <_timer_thread_stack+0x480>
    4801a030:	911bc000 	add	x0, x0, #0x6f0
    4801a034:	eb00003f 	cmp	x1, x0
    4801a038:	54fffcc3 	b.cc	48019fd0 <cmd_mount+0x44>  // b.lo, b.ul, b.last
            }
        }
        return 0;
    4801a03c:	52800000 	mov	w0, #0x0                   	// #0
    4801a040:	14000029 	b	4801a0e4 <cmd_mount+0x158>
    }
    else if (argc == 4)
    4801a044:	b9401fe0 	ldr	w0, [sp, #28]
    4801a048:	7100101f 	cmp	w0, #0x4
    4801a04c:	54000441 	b.ne	4801a0d4 <cmd_mount+0x148>  // b.any
    {
        char *device = argv[1];
    4801a050:	f9400be0 	ldr	x0, [sp, #16]
    4801a054:	f9400400 	ldr	x0, [x0, #8]
    4801a058:	f9001be0 	str	x0, [sp, #48]
        char *path = argv[2];
    4801a05c:	f9400be0 	ldr	x0, [sp, #16]
    4801a060:	f9400800 	ldr	x0, [x0, #16]
    4801a064:	f90017e0 	str	x0, [sp, #40]
        char *fstype = argv[3];
    4801a068:	f9400be0 	ldr	x0, [sp, #16]
    4801a06c:	f9400c00 	ldr	x0, [x0, #24]
    4801a070:	f90013e0 	str	x0, [sp, #32]

        /* mount a filesystem to the specified directory */
        rt_kprintf("mount device %s(%s) onto %s ... ", device, fstype, path);
    4801a074:	f94017e3 	ldr	x3, [sp, #40]
    4801a078:	f94013e2 	ldr	x2, [sp, #32]
    4801a07c:	f9401be1 	ldr	x1, [sp, #48]
    4801a080:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a084:	91358000 	add	x0, x0, #0xd60
    4801a088:	97ffd72a 	bl	4800fd30 <rt_kprintf>
        if (dfs_mount(device, path, fstype, 0, 0) == 0)
    4801a08c:	d2800004 	mov	x4, #0x0                   	// #0
    4801a090:	d2800003 	mov	x3, #0x0                   	// #0
    4801a094:	f94013e2 	ldr	x2, [sp, #32]
    4801a098:	f94017e1 	ldr	x1, [sp, #40]
    4801a09c:	f9401be0 	ldr	x0, [sp, #48]
    4801a0a0:	97ffd9d7 	bl	480107fc <dfs_mount>
    4801a0a4:	7100001f 	cmp	w0, #0x0
    4801a0a8:	540000c1 	b.ne	4801a0c0 <cmd_mount+0x134>  // b.any
        {
            rt_kprintf("succeed!\n");
    4801a0ac:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a0b0:	91362000 	add	x0, x0, #0xd88
    4801a0b4:	97ffd71f 	bl	4800fd30 <rt_kprintf>
            return 0;
    4801a0b8:	52800000 	mov	w0, #0x0                   	// #0
    4801a0bc:	1400000a 	b	4801a0e4 <cmd_mount+0x158>
        }
        else
        {
            rt_kprintf("failed!\n");
    4801a0c0:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a0c4:	91366000 	add	x0, x0, #0xd98
    4801a0c8:	97ffd71a 	bl	4800fd30 <rt_kprintf>
            return -1;
    4801a0cc:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a0d0:	14000005 	b	4801a0e4 <cmd_mount+0x158>
        }
    }
    else
    {
        rt_kprintf("Usage: mount <device> <mountpoint> <fstype>.\n");
    4801a0d4:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a0d8:	9136a000 	add	x0, x0, #0xda8
    4801a0dc:	97ffd715 	bl	4800fd30 <rt_kprintf>
        return -1;
    4801a0e0:	12800000 	mov	w0, #0xffffffff            	// #-1
    }
}
    4801a0e4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a0e8:	d65f03c0 	ret

000000004801a0ec <cmd_umount>:
MSH_CMD_EXPORT_ALIAS(cmd_mount, mount, mount <device> <mountpoint> <fstype>);

/* unmount the filesystem from the specified mountpoint */
static int cmd_umount(int argc, char **argv)
{
    4801a0ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801a0f0:	910003fd 	mov	x29, sp
    4801a0f4:	b9001fe0 	str	w0, [sp, #28]
    4801a0f8:	f9000be1 	str	x1, [sp, #16]
    char *path = argv[1];
    4801a0fc:	f9400be0 	ldr	x0, [sp, #16]
    4801a100:	f9400400 	ldr	x0, [x0, #8]
    4801a104:	f90017e0 	str	x0, [sp, #40]

    if (argc != 2)
    4801a108:	b9401fe0 	ldr	w0, [sp, #28]
    4801a10c:	7100081f 	cmp	w0, #0x2
    4801a110:	540000c0 	b.eq	4801a128 <cmd_umount+0x3c>  // b.none
    {
        rt_kprintf("Usage: unmount <mountpoint>.\n");
    4801a114:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a118:	91376000 	add	x0, x0, #0xdd8
    4801a11c:	97ffd705 	bl	4800fd30 <rt_kprintf>
        return -1;
    4801a120:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a124:	14000012 	b	4801a16c <cmd_umount+0x80>
    }

    rt_kprintf("unmount %s ... ", path);
    4801a128:	f94017e1 	ldr	x1, [sp, #40]
    4801a12c:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a130:	9137e000 	add	x0, x0, #0xdf8
    4801a134:	97ffd6ff 	bl	4800fd30 <rt_kprintf>
    if (dfs_unmount(path) < 0)
    4801a138:	f94017e0 	ldr	x0, [sp, #40]
    4801a13c:	97ffda8a 	bl	48010b64 <dfs_unmount>
    4801a140:	7100001f 	cmp	w0, #0x0
    4801a144:	540000ca 	b.ge	4801a15c <cmd_umount+0x70>  // b.tcont
    {
        rt_kprintf("failed!\n");
    4801a148:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a14c:	91366000 	add	x0, x0, #0xd98
    4801a150:	97ffd6f8 	bl	4800fd30 <rt_kprintf>
        return -1;
    4801a154:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a158:	14000005 	b	4801a16c <cmd_umount+0x80>
    }
    else
    {
        rt_kprintf("succeed!\n");
    4801a15c:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a160:	91362000 	add	x0, x0, #0xd88
    4801a164:	97ffd6f3 	bl	4800fd30 <rt_kprintf>
        return 0;
    4801a168:	52800000 	mov	w0, #0x0                   	// #0
    }
}
    4801a16c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801a170:	d65f03c0 	ret

000000004801a174 <cmd_df>:
MSH_CMD_EXPORT_ALIAS(cmd_umount, umount, Unmount device from file system);

extern int df(const char *path);
static int cmd_df(int argc, char **argv)
{
    4801a174:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801a178:	910003fd 	mov	x29, sp
    4801a17c:	b9001fe0 	str	w0, [sp, #28]
    4801a180:	f9000be1 	str	x1, [sp, #16]
    if (argc != 2)
    4801a184:	b9401fe0 	ldr	w0, [sp, #28]
    4801a188:	7100081f 	cmp	w0, #0x2
    4801a18c:	540000a0 	b.eq	4801a1a0 <cmd_df+0x2c>  // b.none
    {
        df("/");
    4801a190:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a194:	91382000 	add	x0, x0, #0xe08
    4801a198:	97ffdb4f 	bl	48010ed4 <df>
    4801a19c:	1400001b 	b	4801a208 <cmd_df+0x94>
    }
    else
    {
        if ((strcmp(argv[1], "--help") == 0) || (strcmp(argv[1], "-h") == 0))
    4801a1a0:	f9400be0 	ldr	x0, [sp, #16]
    4801a1a4:	91002000 	add	x0, x0, #0x8
    4801a1a8:	f9400002 	ldr	x2, [x0]
    4801a1ac:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a1b0:	91384001 	add	x1, x0, #0xe10
    4801a1b4:	aa0203e0 	mov	x0, x2
    4801a1b8:	94000742 	bl	4801bec0 <strcmp>
    4801a1bc:	7100001f 	cmp	w0, #0x0
    4801a1c0:	54000140 	b.eq	4801a1e8 <cmd_df+0x74>  // b.none
    4801a1c4:	f9400be0 	ldr	x0, [sp, #16]
    4801a1c8:	91002000 	add	x0, x0, #0x8
    4801a1cc:	f9400002 	ldr	x2, [x0]
    4801a1d0:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a1d4:	91386001 	add	x1, x0, #0xe18
    4801a1d8:	aa0203e0 	mov	x0, x2
    4801a1dc:	94000739 	bl	4801bec0 <strcmp>
    4801a1e0:	7100001f 	cmp	w0, #0x0
    4801a1e4:	540000a1 	b.ne	4801a1f8 <cmd_df+0x84>  // b.any
        {
            rt_kprintf("df [path]\n");
    4801a1e8:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a1ec:	91388000 	add	x0, x0, #0xe20
    4801a1f0:	97ffd6d0 	bl	4800fd30 <rt_kprintf>
    4801a1f4:	14000005 	b	4801a208 <cmd_df+0x94>
        }
        else
        {
            df(argv[1]);
    4801a1f8:	f9400be0 	ldr	x0, [sp, #16]
    4801a1fc:	91002000 	add	x0, x0, #0x8
    4801a200:	f9400000 	ldr	x0, [x0]
    4801a204:	97ffdb34 	bl	48010ed4 <df>
        }
    }

    return 0;
    4801a208:	52800000 	mov	w0, #0x0                   	// #0
}
    4801a20c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801a210:	d65f03c0 	ret

000000004801a214 <cmd_echo>:
MSH_CMD_EXPORT_ALIAS(cmd_df, df, disk free);

static int cmd_echo(int argc, char **argv)
{
    4801a214:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a218:	910003fd 	mov	x29, sp
    4801a21c:	f9000bf3 	str	x19, [sp, #16]
    4801a220:	b9002fe0 	str	w0, [sp, #44]
    4801a224:	f90013e1 	str	x1, [sp, #32]
    if (argc == 2)
    4801a228:	b9402fe0 	ldr	w0, [sp, #44]
    4801a22c:	7100081f 	cmp	w0, #0x2
    4801a230:	54000121 	b.ne	4801a254 <cmd_echo+0x40>  // b.any
    {
        rt_kprintf("%s\n", argv[1]);
    4801a234:	f94013e0 	ldr	x0, [sp, #32]
    4801a238:	91002000 	add	x0, x0, #0x8
    4801a23c:	f9400000 	ldr	x0, [x0]
    4801a240:	aa0003e1 	mov	x1, x0
    4801a244:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a248:	91310000 	add	x0, x0, #0xc40
    4801a24c:	97ffd6b9 	bl	4800fd30 <rt_kprintf>
    4801a250:	14000027 	b	4801a2ec <cmd_echo+0xd8>
    }
    else if (argc == 3)
    4801a254:	b9402fe0 	ldr	w0, [sp, #44]
    4801a258:	71000c1f 	cmp	w0, #0x3
    4801a25c:	54000421 	b.ne	4801a2e0 <cmd_echo+0xcc>  // b.any
    {
        int fd;

        fd = open(argv[2], O_RDWR | O_APPEND | O_CREAT, 0);
    4801a260:	f94013e0 	ldr	x0, [sp, #32]
    4801a264:	91004000 	add	x0, x0, #0x10
    4801a268:	f9400000 	ldr	x0, [x0]
    4801a26c:	52800002 	mov	w2, #0x0                   	// #0
    4801a270:	52804141 	mov	w1, #0x20a                 	// #522
    4801a274:	9400022c 	bl	4801ab24 <open>
    4801a278:	b9003fe0 	str	w0, [sp, #60]
        if (fd >= 0)
    4801a27c:	b9403fe0 	ldr	w0, [sp, #60]
    4801a280:	7100001f 	cmp	w0, #0x0
    4801a284:	540001eb 	b.lt	4801a2c0 <cmd_echo+0xac>  // b.tstop
        {
            write(fd, argv[1], strlen(argv[1]));
    4801a288:	f94013e0 	ldr	x0, [sp, #32]
    4801a28c:	91002000 	add	x0, x0, #0x8
    4801a290:	f9400013 	ldr	x19, [x0]
    4801a294:	f94013e0 	ldr	x0, [sp, #32]
    4801a298:	91002000 	add	x0, x0, #0x8
    4801a29c:	f9400000 	ldr	x0, [x0]
    4801a2a0:	940007b8 	bl	4801c180 <strlen>
    4801a2a4:	aa0003e2 	mov	x2, x0
    4801a2a8:	aa1303e1 	mov	x1, x19
    4801a2ac:	b9403fe0 	ldr	w0, [sp, #60]
    4801a2b0:	94000290 	bl	4801acf0 <write>
            close(fd);
    4801a2b4:	b9403fe0 	ldr	w0, [sp, #60]
    4801a2b8:	9400024e 	bl	4801abf0 <close>
    4801a2bc:	1400000c 	b	4801a2ec <cmd_echo+0xd8>
        }
        else
        {
            rt_kprintf("open file:%s failed!\n", argv[2]);
    4801a2c0:	f94013e0 	ldr	x0, [sp, #32]
    4801a2c4:	91004000 	add	x0, x0, #0x10
    4801a2c8:	f9400000 	ldr	x0, [x0]
    4801a2cc:	aa0003e1 	mov	x1, x0
    4801a2d0:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a2d4:	9138c000 	add	x0, x0, #0xe30
    4801a2d8:	97ffd696 	bl	4800fd30 <rt_kprintf>
    4801a2dc:	14000004 	b	4801a2ec <cmd_echo+0xd8>
        }
    }
    else
    {
        rt_kprintf("Usage: echo \"string\" [filename]\n");
    4801a2e0:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a2e4:	91392000 	add	x0, x0, #0xe48
    4801a2e8:	97ffd692 	bl	4800fd30 <rt_kprintf>
    }

    return 0;
    4801a2ec:	52800000 	mov	w0, #0x0                   	// #0
}
    4801a2f0:	f9400bf3 	ldr	x19, [sp, #16]
    4801a2f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a2f8:	d65f03c0 	ret

000000004801a2fc <cmd_tail>:
MSH_CMD_EXPORT_ALIAS(cmd_echo, echo, echo string to file);

static int cmd_tail(int argc, char **argv)
{
    4801a2fc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4801a300:	910003fd 	mov	x29, sp
    4801a304:	b9001fe0 	str	w0, [sp, #28]
    4801a308:	f9000be1 	str	x1, [sp, #16]
    int fd;
    char c = RT_NULL;
    4801a30c:	3900bfff 	strb	wzr, [sp, #47]
    char *file_name = RT_NULL;
    4801a310:	f90027ff 	str	xzr, [sp, #72]
    rt_uint32_t total_lines = 0;
    4801a314:	b90047ff 	str	wzr, [sp, #68]
    rt_uint32_t target_line = 0;
    4801a318:	b90037ff 	str	wzr, [sp, #52]
    rt_uint32_t current_line = 0;
    4801a31c:	b90043ff 	str	wzr, [sp, #64]
    rt_uint32_t required_lines = 0;
    4801a320:	b9003fff 	str	wzr, [sp, #60]
    rt_uint32_t after_xxx_line = 0;
    4801a324:	b9003bff 	str	wzr, [sp, #56]

    if (argc < 2)
    4801a328:	b9401fe0 	ldr	w0, [sp, #28]
    4801a32c:	7100041f 	cmp	w0, #0x1
    4801a330:	540000cc 	b.gt	4801a348 <cmd_tail+0x4c>
    {
        rt_kprintf("Usage: tail [-n numbers] <filename>\n");
    4801a334:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a338:	9139c000 	add	x0, x0, #0xe70
    4801a33c:	97ffd67d 	bl	4800fd30 <rt_kprintf>
        return -1;
    4801a340:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a344:	14000092 	b	4801a58c <cmd_tail+0x290>
    }
    else if (argc == 2)
    4801a348:	b9401fe0 	ldr	w0, [sp, #28]
    4801a34c:	7100081f 	cmp	w0, #0x2
    4801a350:	540000e1 	b.ne	4801a36c <cmd_tail+0x70>  // b.any
    {
        required_lines = 10; /* default: 10 lines from tail */
    4801a354:	52800140 	mov	w0, #0xa                   	// #10
    4801a358:	b9003fe0 	str	w0, [sp, #60]
        file_name = argv[1];
    4801a35c:	f9400be0 	ldr	x0, [sp, #16]
    4801a360:	f9400400 	ldr	x0, [x0, #8]
    4801a364:	f90027e0 	str	x0, [sp, #72]
    4801a368:	14000025 	b	4801a3fc <cmd_tail+0x100>
    }
    else if (rt_strcmp(argv[1], "-n") == 0)
    4801a36c:	f9400be0 	ldr	x0, [sp, #16]
    4801a370:	91002000 	add	x0, x0, #0x8
    4801a374:	f9400002 	ldr	x2, [x0]
    4801a378:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a37c:	913a6001 	add	x1, x0, #0xe98
    4801a380:	aa0203e0 	mov	x0, x2
    4801a384:	97ffd1a0 	bl	4800ea04 <rt_strcmp>
    4801a388:	7100001f 	cmp	w0, #0x0
    4801a38c:	540002e1 	b.ne	4801a3e8 <cmd_tail+0xec>  // b.any
    {
        if (argv[2][0] != '+')
    4801a390:	f9400be0 	ldr	x0, [sp, #16]
    4801a394:	91004000 	add	x0, x0, #0x10
    4801a398:	f9400000 	ldr	x0, [x0]
    4801a39c:	39400000 	ldrb	w0, [x0]
    4801a3a0:	7100ac1f 	cmp	w0, #0x2b
    4801a3a4:	540000e0 	b.eq	4801a3c0 <cmd_tail+0xc4>  // b.none
        {
            required_lines = atoi(argv[2]);
    4801a3a8:	f9400be0 	ldr	x0, [sp, #16]
    4801a3ac:	91004000 	add	x0, x0, #0x10
    4801a3b0:	f9400000 	ldr	x0, [x0]
    4801a3b4:	940008eb 	bl	4801c760 <atoi>
    4801a3b8:	b9003fe0 	str	w0, [sp, #60]
    4801a3bc:	14000007 	b	4801a3d8 <cmd_tail+0xdc>
        }
        else
        {
            after_xxx_line = atoi(&argv[2][1]); /* eg: +100, to get the 100 */
    4801a3c0:	f9400be0 	ldr	x0, [sp, #16]
    4801a3c4:	91004000 	add	x0, x0, #0x10
    4801a3c8:	f9400000 	ldr	x0, [x0]
    4801a3cc:	91000400 	add	x0, x0, #0x1
    4801a3d0:	940008e4 	bl	4801c760 <atoi>
    4801a3d4:	b9003be0 	str	w0, [sp, #56]
        }
        file_name = argv[3];
    4801a3d8:	f9400be0 	ldr	x0, [sp, #16]
    4801a3dc:	f9400c00 	ldr	x0, [x0, #24]
    4801a3e0:	f90027e0 	str	x0, [sp, #72]
    4801a3e4:	14000006 	b	4801a3fc <cmd_tail+0x100>
    }
    else
    {
        rt_kprintf("Usage: tail [-n numbers] <filename>\n");
    4801a3e8:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a3ec:	9139c000 	add	x0, x0, #0xe70
    4801a3f0:	97ffd650 	bl	4800fd30 <rt_kprintf>
        return -1;
    4801a3f4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a3f8:	14000065 	b	4801a58c <cmd_tail+0x290>
    }

    fd = open(file_name, O_RDONLY);
    4801a3fc:	52800001 	mov	w1, #0x0                   	// #0
    4801a400:	f94027e0 	ldr	x0, [sp, #72]
    4801a404:	940001c8 	bl	4801ab24 <open>
    4801a408:	b90033e0 	str	w0, [sp, #48]
    if (fd < 0)
    4801a40c:	b94033e0 	ldr	w0, [sp, #48]
    4801a410:	7100001f 	cmp	w0, #0x0
    4801a414:	5400018a 	b.ge	4801a444 <cmd_tail+0x148>  // b.tcont
    {
        rt_kprintf("File doesn't exist\n");
    4801a418:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a41c:	913a8000 	add	x0, x0, #0xea0
    4801a420:	97ffd644 	bl	4800fd30 <rt_kprintf>
        return -1;
    4801a424:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a428:	14000059 	b	4801a58c <cmd_tail+0x290>
    }

    while ((read(fd, &c, sizeof(char))) > 0)
    {
        if (c == '\n')
    4801a42c:	3940bfe0 	ldrb	w0, [sp, #47]
    4801a430:	7100281f 	cmp	w0, #0xa
    4801a434:	54000081 	b.ne	4801a444 <cmd_tail+0x148>  // b.any
        {
            total_lines++;
    4801a438:	b94047e0 	ldr	w0, [sp, #68]
    4801a43c:	11000400 	add	w0, w0, #0x1
    4801a440:	b90047e0 	str	w0, [sp, #68]
    while ((read(fd, &c, sizeof(char))) > 0)
    4801a444:	9100bfe0 	add	x0, sp, #0x2f
    4801a448:	d2800022 	mov	x2, #0x1                   	// #1
    4801a44c:	aa0003e1 	mov	x1, x0
    4801a450:	b94033e0 	ldr	w0, [sp, #48]
    4801a454:	94000205 	bl	4801ac68 <read>
    4801a458:	7100001f 	cmp	w0, #0x0
    4801a45c:	54fffe8c 	b.gt	4801a42c <cmd_tail+0x130>
        }
    }

    rt_kprintf("\nTotal Number of lines:%d\n", total_lines);
    4801a460:	b94047e1 	ldr	w1, [sp, #68]
    4801a464:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a468:	913ae000 	add	x0, x0, #0xeb8
    4801a46c:	97ffd631 	bl	4800fd30 <rt_kprintf>

    if (after_xxx_line != 0)
    4801a470:	b9403be0 	ldr	w0, [sp, #56]
    4801a474:	7100001f 	cmp	w0, #0x0
    4801a478:	54000220 	b.eq	4801a4bc <cmd_tail+0x1c0>  // b.none
    {
        if (total_lines > after_xxx_line)
    4801a47c:	b94047e1 	ldr	w1, [sp, #68]
    4801a480:	b9403be0 	ldr	w0, [sp, #56]
    4801a484:	6b00003f 	cmp	w1, w0
    4801a488:	540000c9 	b.ls	4801a4a0 <cmd_tail+0x1a4>  // b.plast
        {
            required_lines = total_lines - after_xxx_line;
    4801a48c:	b94047e1 	ldr	w1, [sp, #68]
    4801a490:	b9403be0 	ldr	w0, [sp, #56]
    4801a494:	4b000020 	sub	w0, w1, w0
    4801a498:	b9003fe0 	str	w0, [sp, #60]
    4801a49c:	14000008 	b	4801a4bc <cmd_tail+0x1c0>
        }
        else
        {
            rt_kprintf("\nError:Required lines are more than total number of lines\n");
    4801a4a0:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a4a4:	913b6000 	add	x0, x0, #0xed8
    4801a4a8:	97ffd622 	bl	4800fd30 <rt_kprintf>
            close(fd);
    4801a4ac:	b94033e0 	ldr	w0, [sp, #48]
    4801a4b0:	940001d0 	bl	4801abf0 <close>
            return -1;
    4801a4b4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a4b8:	14000035 	b	4801a58c <cmd_tail+0x290>
        }
    }

    if (required_lines > total_lines)
    4801a4bc:	b9403fe1 	ldr	w1, [sp, #60]
    4801a4c0:	b94047e0 	ldr	w0, [sp, #68]
    4801a4c4:	6b00003f 	cmp	w1, w0
    4801a4c8:	54000109 	b.ls	4801a4e8 <cmd_tail+0x1ec>  // b.plast
    {
        rt_kprintf("\nError:Required lines are more than total number of lines\n");
    4801a4cc:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a4d0:	913b6000 	add	x0, x0, #0xed8
    4801a4d4:	97ffd617 	bl	4800fd30 <rt_kprintf>
        close(fd);
    4801a4d8:	b94033e0 	ldr	w0, [sp, #48]
    4801a4dc:	940001c5 	bl	4801abf0 <close>
        return -1;
    4801a4e0:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801a4e4:	1400002a 	b	4801a58c <cmd_tail+0x290>
    }
    rt_kprintf("Required Number of lines:%d\n", required_lines);
    4801a4e8:	b9403fe1 	ldr	w1, [sp, #60]
    4801a4ec:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a4f0:	913c6000 	add	x0, x0, #0xf18
    4801a4f4:	97ffd60f 	bl	4800fd30 <rt_kprintf>

    target_line = total_lines - required_lines;
    4801a4f8:	b94047e1 	ldr	w1, [sp, #68]
    4801a4fc:	b9403fe0 	ldr	w0, [sp, #60]
    4801a500:	4b000020 	sub	w0, w1, w0
    4801a504:	b90037e0 	str	w0, [sp, #52]
    lseek(fd, 0, SEEK_SET); /* back to head */
    4801a508:	52800002 	mov	w2, #0x0                   	// #0
    4801a50c:	d2800001 	mov	x1, #0x0                   	// #0
    4801a510:	b94033e0 	ldr	w0, [sp, #48]
    4801a514:	94000219 	bl	4801ad78 <lseek>

    while ((read(fd, &c, sizeof(char))) > 0)
    4801a518:	14000010 	b	4801a558 <cmd_tail+0x25c>
    {
        if (c == '\n')
    4801a51c:	3940bfe0 	ldrb	w0, [sp, #47]
    4801a520:	7100281f 	cmp	w0, #0xa
    4801a524:	54000081 	b.ne	4801a534 <cmd_tail+0x238>  // b.any
        {
            current_line++;
    4801a528:	b94043e0 	ldr	w0, [sp, #64]
    4801a52c:	11000400 	add	w0, w0, #0x1
    4801a530:	b90043e0 	str	w0, [sp, #64]
        }
        if (current_line > target_line)
    4801a534:	b94043e1 	ldr	w1, [sp, #64]
    4801a538:	b94037e0 	ldr	w0, [sp, #52]
    4801a53c:	6b00003f 	cmp	w1, w0
    4801a540:	540000c9 	b.ls	4801a558 <cmd_tail+0x25c>  // b.plast
        {
            rt_kprintf("%c", c);
    4801a544:	3940bfe0 	ldrb	w0, [sp, #47]
    4801a548:	2a0003e1 	mov	w1, w0
    4801a54c:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a550:	913ce000 	add	x0, x0, #0xf38
    4801a554:	97ffd5f7 	bl	4800fd30 <rt_kprintf>
    while ((read(fd, &c, sizeof(char))) > 0)
    4801a558:	9100bfe0 	add	x0, sp, #0x2f
    4801a55c:	d2800022 	mov	x2, #0x1                   	// #1
    4801a560:	aa0003e1 	mov	x1, x0
    4801a564:	b94033e0 	ldr	w0, [sp, #48]
    4801a568:	940001c0 	bl	4801ac68 <read>
    4801a56c:	7100001f 	cmp	w0, #0x0
    4801a570:	54fffd6c 	b.gt	4801a51c <cmd_tail+0x220>
        }
    }
    rt_kprintf("\n");
    4801a574:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a578:	913d0000 	add	x0, x0, #0xf40
    4801a57c:	97ffd5ed 	bl	4800fd30 <rt_kprintf>

    close(fd);
    4801a580:	b94033e0 	ldr	w0, [sp, #48]
    4801a584:	9400019b 	bl	4801abf0 <close>
    return 0;
    4801a588:	52800000 	mov	w0, #0x0                   	// #0
}
    4801a58c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4801a590:	d65f03c0 	ret

000000004801a594 <__rt_libc_exit>:
#define DBG_TAG    "stdlib"
#define DBG_LVL    DBG_INFO
#include <rtdbg.h>

void __rt_libc_exit(int status)
{
    4801a594:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801a598:	910003fd 	mov	x29, sp
    4801a59c:	b9001fe0 	str	w0, [sp, #28]
    rt_thread_t self = rt_thread_self();
    4801a5a0:	97ffc57f 	bl	4800bb9c <rt_thread_self>
    4801a5a4:	f90017e0 	str	x0, [sp, #40]

    if (self != RT_NULL)
    4801a5a8:	f94017e0 	ldr	x0, [sp, #40]
    4801a5ac:	f100001f 	cmp	x0, #0x0
    4801a5b0:	54000220 	b.eq	4801a5f4 <__rt_libc_exit+0x60>  // b.none
    {
        LOG_E("thread:%s exit:%d!", self->name, status);
    4801a5b4:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a5b8:	913d2000 	add	x0, x0, #0xf48
    4801a5bc:	97ffd5dd 	bl	4800fd30 <rt_kprintf>
    4801a5c0:	f94017e0 	ldr	x0, [sp, #40]
    4801a5c4:	b9401fe2 	ldr	w2, [sp, #28]
    4801a5c8:	aa0003e1 	mov	x1, x0
    4801a5cc:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a5d0:	913d6000 	add	x0, x0, #0xf58
    4801a5d4:	97ffd5d7 	bl	4800fd30 <rt_kprintf>
    4801a5d8:	d0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801a5dc:	913dc000 	add	x0, x0, #0xf70
    4801a5e0:	97ffd5d4 	bl	4800fd30 <rt_kprintf>
        rt_thread_control(self, RT_THREAD_CTRL_CLOSE, RT_NULL);
    4801a5e4:	d2800002 	mov	x2, #0x0                   	// #0
    4801a5e8:	52800021 	mov	w1, #0x1                   	// #1
    4801a5ec:	f94017e0 	ldr	x0, [sp, #40]
    4801a5f0:	97ffc70a 	bl	4800c218 <rt_thread_control>
    }
}
    4801a5f4:	d503201f 	nop
    4801a5f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801a5fc:	d65f03c0 	ret

000000004801a600 <_malloc_r>:
#define DBG_LVL    DBG_INFO
#include <rtdbg.h>

#ifdef RT_USING_HEAP /* Memory routine */
void *_malloc_r (struct _reent *ptr, size_t size)
{
    4801a600:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801a604:	910003fd 	mov	x29, sp
    4801a608:	f9000fe0 	str	x0, [sp, #24]
    4801a60c:	f9000be1 	str	x1, [sp, #16]
    void* result;

    result = (void*)rt_malloc (size);
    4801a610:	f9400be0 	ldr	x0, [sp, #16]
    4801a614:	97ffbd5d 	bl	48009b88 <rt_malloc>
    4801a618:	f90017e0 	str	x0, [sp, #40]
    if (result == RT_NULL)
    4801a61c:	f94017e0 	ldr	x0, [sp, #40]
    4801a620:	f100001f 	cmp	x0, #0x0
    4801a624:	54000081 	b.ne	4801a634 <_malloc_r+0x34>  // b.any
    {
        ptr->_errno = ENOMEM;
    4801a628:	f9400fe0 	ldr	x0, [sp, #24]
    4801a62c:	52800181 	mov	w1, #0xc                   	// #12
    4801a630:	b9000001 	str	w1, [x0]
    }

    return result;
    4801a634:	f94017e0 	ldr	x0, [sp, #40]
}
    4801a638:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801a63c:	d65f03c0 	ret

000000004801a640 <_realloc_r>:

void *_realloc_r (struct _reent *ptr, void *old, size_t newlen)
{
    4801a640:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a644:	910003fd 	mov	x29, sp
    4801a648:	f90017e0 	str	x0, [sp, #40]
    4801a64c:	f90013e1 	str	x1, [sp, #32]
    4801a650:	f9000fe2 	str	x2, [sp, #24]
    void* result;

    result = (void*)rt_realloc (old, newlen);
    4801a654:	f9400fe1 	ldr	x1, [sp, #24]
    4801a658:	f94013e0 	ldr	x0, [sp, #32]
    4801a65c:	97ffbe86 	bl	4800a074 <rt_realloc>
    4801a660:	f9001fe0 	str	x0, [sp, #56]
    if (result == RT_NULL)
    4801a664:	f9401fe0 	ldr	x0, [sp, #56]
    4801a668:	f100001f 	cmp	x0, #0x0
    4801a66c:	54000081 	b.ne	4801a67c <_realloc_r+0x3c>  // b.any
    {
        ptr->_errno = ENOMEM;
    4801a670:	f94017e0 	ldr	x0, [sp, #40]
    4801a674:	52800181 	mov	w1, #0xc                   	// #12
    4801a678:	b9000001 	str	w1, [x0]
    }

    return result;
    4801a67c:	f9401fe0 	ldr	x0, [sp, #56]
}
    4801a680:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a684:	d65f03c0 	ret

000000004801a688 <_calloc_r>:

void *_calloc_r (struct _reent *ptr, size_t size, size_t len)
{
    4801a688:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a68c:	910003fd 	mov	x29, sp
    4801a690:	f90017e0 	str	x0, [sp, #40]
    4801a694:	f90013e1 	str	x1, [sp, #32]
    4801a698:	f9000fe2 	str	x2, [sp, #24]
    void* result;

    result = (void*)rt_calloc (size, len);
    4801a69c:	f9400fe1 	ldr	x1, [sp, #24]
    4801a6a0:	f94013e0 	ldr	x0, [sp, #32]
    4801a6a4:	97ffbf32 	bl	4800a36c <rt_calloc>
    4801a6a8:	f9001fe0 	str	x0, [sp, #56]
    if (result == RT_NULL)
    4801a6ac:	f9401fe0 	ldr	x0, [sp, #56]
    4801a6b0:	f100001f 	cmp	x0, #0x0
    4801a6b4:	54000081 	b.ne	4801a6c4 <_calloc_r+0x3c>  // b.any
    {
        ptr->_errno = ENOMEM;
    4801a6b8:	f94017e0 	ldr	x0, [sp, #40]
    4801a6bc:	52800181 	mov	w1, #0xc                   	// #12
    4801a6c0:	b9000001 	str	w1, [x0]
    }

    return result;
    4801a6c4:	f9401fe0 	ldr	x0, [sp, #56]
}
    4801a6c8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a6cc:	d65f03c0 	ret

000000004801a6d0 <_free_r>:

void _free_r (struct _reent *ptr, void *addr)
{
    4801a6d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801a6d4:	910003fd 	mov	x29, sp
    4801a6d8:	f9000fe0 	str	x0, [sp, #24]
    4801a6dc:	f9000be1 	str	x1, [sp, #16]
    rt_free (addr);
    4801a6e0:	f9400be0 	ldr	x0, [sp, #16]
    4801a6e4:	97ffbf38 	bl	4800a3c4 <rt_free>
}
    4801a6e8:	d503201f 	nop
    4801a6ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801a6f0:	d65f03c0 	ret

000000004801a6f4 <__libc_init_array>:

void __libc_init_array(void)
{
    /* we not use __libc init_aray to initialize C++ objects */
    /* __libc_init_array is ARM code, not Thumb; it will cause a hardfault. */
}
    4801a6f4:	d503201f 	nop
    4801a6f8:	d65f03c0 	ret

000000004801a6fc <__errno>:
#ifdef RT_USING_LIBC

/* Reentrant versions of system calls.  */
#ifndef _REENT_ONLY
int *__errno ()
{
    4801a6fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4801a700:	910003fd 	mov	x29, sp
  return _rt_errno();
    4801a704:	97ffcef5 	bl	4800e2d8 <_rt_errno>
}
    4801a708:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4801a70c:	d65f03c0 	ret

000000004801a710 <_getpid_r>:
#endif

int _getpid_r(struct _reent *ptr)
{
    4801a710:	d10043ff 	sub	sp, sp, #0x10
    4801a714:	f90007e0 	str	x0, [sp, #8]
    return 0;
    4801a718:	52800000 	mov	w0, #0x0                   	// #0
}
    4801a71c:	910043ff 	add	sp, sp, #0x10
    4801a720:	d65f03c0 	ret

000000004801a724 <_close_r>:

int _close_r(struct _reent *ptr, int fd)
{
    4801a724:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801a728:	910003fd 	mov	x29, sp
    4801a72c:	f9000fe0 	str	x0, [sp, #24]
    4801a730:	b90017e1 	str	w1, [sp, #20]
#ifdef RT_USING_POSIX
    return close(fd);
    4801a734:	b94017e0 	ldr	w0, [sp, #20]
    4801a738:	9400012e 	bl	4801abf0 <close>
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif
}
    4801a73c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801a740:	d65f03c0 	ret

000000004801a744 <_execve_r>:

int _execve_r(struct _reent *ptr, const char * name, char *const *argv, char *const *env)
{
    4801a744:	d10083ff 	sub	sp, sp, #0x20
    4801a748:	f9000fe0 	str	x0, [sp, #24]
    4801a74c:	f9000be1 	str	x1, [sp, #16]
    4801a750:	f90007e2 	str	x2, [sp, #8]
    4801a754:	f90003e3 	str	x3, [sp]
    ptr->_errno = ENOTSUP;
    4801a758:	f9400fe0 	ldr	x0, [sp, #24]
    4801a75c:	528010c1 	mov	w1, #0x86                  	// #134
    4801a760:	b9000001 	str	w1, [x0]
    return -1;
    4801a764:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801a768:	910083ff 	add	sp, sp, #0x20
    4801a76c:	d65f03c0 	ret

000000004801a770 <_fcntl_r>:

int _fcntl_r(struct _reent *ptr, int fd, int cmd, int arg)
{
    4801a770:	d10083ff 	sub	sp, sp, #0x20
    4801a774:	f9000fe0 	str	x0, [sp, #24]
    4801a778:	b90017e1 	str	w1, [sp, #20]
    4801a77c:	b90013e2 	str	w2, [sp, #16]
    4801a780:	b9000fe3 	str	w3, [sp, #12]
    ptr->_errno = ENOTSUP;
    4801a784:	f9400fe0 	ldr	x0, [sp, #24]
    4801a788:	528010c1 	mov	w1, #0x86                  	// #134
    4801a78c:	b9000001 	str	w1, [x0]
    return -1;
    4801a790:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801a794:	910083ff 	add	sp, sp, #0x20
    4801a798:	d65f03c0 	ret

000000004801a79c <_fork_r>:

int _fork_r(struct _reent *ptr)
{
    4801a79c:	d10043ff 	sub	sp, sp, #0x10
    4801a7a0:	f90007e0 	str	x0, [sp, #8]
    ptr->_errno = ENOTSUP;
    4801a7a4:	f94007e0 	ldr	x0, [sp, #8]
    4801a7a8:	528010c1 	mov	w1, #0x86                  	// #134
    4801a7ac:	b9000001 	str	w1, [x0]
    return -1;
    4801a7b0:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801a7b4:	910043ff 	add	sp, sp, #0x10
    4801a7b8:	d65f03c0 	ret

000000004801a7bc <_fstat_r>:

int _fstat_r(struct _reent *ptr, int fd, struct stat *pstat)
{
    4801a7bc:	d10083ff 	sub	sp, sp, #0x20
    4801a7c0:	f9000fe0 	str	x0, [sp, #24]
    4801a7c4:	b90017e1 	str	w1, [sp, #20]
    4801a7c8:	f90007e2 	str	x2, [sp, #8]
    ptr->_errno = ENOTSUP;
    4801a7cc:	f9400fe0 	ldr	x0, [sp, #24]
    4801a7d0:	528010c1 	mov	w1, #0x86                  	// #134
    4801a7d4:	b9000001 	str	w1, [x0]
    return -1;
    4801a7d8:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801a7dc:	910083ff 	add	sp, sp, #0x20
    4801a7e0:	d65f03c0 	ret

000000004801a7e4 <_isatty_r>:

int _isatty_r(struct _reent *ptr, int fd)
{
    4801a7e4:	d10043ff 	sub	sp, sp, #0x10
    4801a7e8:	f90007e0 	str	x0, [sp, #8]
    4801a7ec:	b90007e1 	str	w1, [sp, #4]
    if (fd >=0 && fd < 3)
    4801a7f0:	b94007e0 	ldr	w0, [sp, #4]
    4801a7f4:	7100001f 	cmp	w0, #0x0
    4801a7f8:	540000cb 	b.lt	4801a810 <_isatty_r+0x2c>  // b.tstop
    4801a7fc:	b94007e0 	ldr	w0, [sp, #4]
    4801a800:	7100081f 	cmp	w0, #0x2
    4801a804:	5400006c 	b.gt	4801a810 <_isatty_r+0x2c>
    {
        return 1;
    4801a808:	52800020 	mov	w0, #0x1                   	// #1
    4801a80c:	14000002 	b	4801a814 <_isatty_r+0x30>
    }
    else
    {
        return 0;
    4801a810:	52800000 	mov	w0, #0x0                   	// #0
    }
}
    4801a814:	910043ff 	add	sp, sp, #0x10
    4801a818:	d65f03c0 	ret

000000004801a81c <_kill_r>:

int _kill_r(struct _reent *ptr, int pid, int sig)
{
    4801a81c:	d10043ff 	sub	sp, sp, #0x10
    4801a820:	f90007e0 	str	x0, [sp, #8]
    4801a824:	b90007e1 	str	w1, [sp, #4]
    4801a828:	b90003e2 	str	w2, [sp]
    ptr->_errno = ENOTSUP;
    4801a82c:	f94007e0 	ldr	x0, [sp, #8]
    4801a830:	528010c1 	mov	w1, #0x86                  	// #134
    4801a834:	b9000001 	str	w1, [x0]
    return -1;
    4801a838:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801a83c:	910043ff 	add	sp, sp, #0x10
    4801a840:	d65f03c0 	ret

000000004801a844 <_link_r>:

int _link_r(struct _reent *ptr, const char *old, const char *new)
{
    4801a844:	d10083ff 	sub	sp, sp, #0x20
    4801a848:	f9000fe0 	str	x0, [sp, #24]
    4801a84c:	f9000be1 	str	x1, [sp, #16]
    4801a850:	f90007e2 	str	x2, [sp, #8]
    ptr->_errno = ENOTSUP;
    4801a854:	f9400fe0 	ldr	x0, [sp, #24]
    4801a858:	528010c1 	mov	w1, #0x86                  	// #134
    4801a85c:	b9000001 	str	w1, [x0]
    return -1;
    4801a860:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801a864:	910083ff 	add	sp, sp, #0x20
    4801a868:	d65f03c0 	ret

000000004801a86c <_wait_r>:

int _wait_r(struct _reent *ptr, int *status)
{
    4801a86c:	d10043ff 	sub	sp, sp, #0x10
    4801a870:	f90007e0 	str	x0, [sp, #8]
    4801a874:	f90003e1 	str	x1, [sp]
    ptr->_errno = ENOTSUP;
    4801a878:	f94007e0 	ldr	x0, [sp, #8]
    4801a87c:	528010c1 	mov	w1, #0x86                  	// #134
    4801a880:	b9000001 	str	w1, [x0]
    return -1;
    4801a884:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    4801a888:	910043ff 	add	sp, sp, #0x10
    4801a88c:	d65f03c0 	ret

000000004801a890 <umask>:

mode_t umask(mode_t mask)
{
    4801a890:	d10043ff 	sub	sp, sp, #0x10
    4801a894:	b9000fe0 	str	w0, [sp, #12]
    return 022;
    4801a898:	52800240 	mov	w0, #0x12                  	// #18
}
    4801a89c:	910043ff 	add	sp, sp, #0x10
    4801a8a0:	d65f03c0 	ret

000000004801a8a4 <flock>:

int flock(int fd, int operation)
{
    4801a8a4:	d10043ff 	sub	sp, sp, #0x10
    4801a8a8:	b9000fe0 	str	w0, [sp, #12]
    4801a8ac:	b9000be1 	str	w1, [sp, #8]
    return 0;
    4801a8b0:	52800000 	mov	w0, #0x0                   	// #0
}
    4801a8b4:	910043ff 	add	sp, sp, #0x10
    4801a8b8:	d65f03c0 	ret

000000004801a8bc <_lseek_r>:

_off_t _lseek_r(struct _reent *ptr, int fd, _off_t pos, int whence)
{
    4801a8bc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a8c0:	910003fd 	mov	x29, sp
    4801a8c4:	f90017e0 	str	x0, [sp, #40]
    4801a8c8:	b90027e1 	str	w1, [sp, #36]
    4801a8cc:	f9000fe2 	str	x2, [sp, #24]
    4801a8d0:	b90023e3 	str	w3, [sp, #32]
#ifdef RT_USING_POSIX
    _off_t rc;

    rc = lseek(fd, pos, whence);
    4801a8d4:	b94023e2 	ldr	w2, [sp, #32]
    4801a8d8:	f9400fe1 	ldr	x1, [sp, #24]
    4801a8dc:	b94027e0 	ldr	w0, [sp, #36]
    4801a8e0:	94000126 	bl	4801ad78 <lseek>
    4801a8e4:	f9001fe0 	str	x0, [sp, #56]
    return rc;
    4801a8e8:	f9401fe0 	ldr	x0, [sp, #56]
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801a8ec:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a8f0:	d65f03c0 	ret

000000004801a8f4 <_mkdir_r>:

int _mkdir_r(struct _reent *ptr, const char *name, int mode)
{
    4801a8f4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a8f8:	910003fd 	mov	x29, sp
    4801a8fc:	f90017e0 	str	x0, [sp, #40]
    4801a900:	f90013e1 	str	x1, [sp, #32]
    4801a904:	b9001fe2 	str	w2, [sp, #28]
#ifdef RT_USING_POSIX
    int rc;

    rc = mkdir(name, mode);
    4801a908:	b9401fe0 	ldr	w0, [sp, #28]
    4801a90c:	2a0003e1 	mov	w1, w0
    4801a910:	f94013e0 	ldr	x0, [sp, #32]
    4801a914:	9400029a 	bl	4801b37c <mkdir>
    4801a918:	b9003fe0 	str	w0, [sp, #60]
    return rc;
    4801a91c:	b9403fe0 	ldr	w0, [sp, #60]
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801a920:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a924:	d65f03c0 	ret

000000004801a928 <_open_r>:

int _open_r(struct _reent *ptr, const char *file, int flags, int mode)
{
    4801a928:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a92c:	910003fd 	mov	x29, sp
    4801a930:	f90017e0 	str	x0, [sp, #40]
    4801a934:	f90013e1 	str	x1, [sp, #32]
    4801a938:	b9001fe2 	str	w2, [sp, #28]
    4801a93c:	b9001be3 	str	w3, [sp, #24]
#ifdef RT_USING_POSIX
    int rc;
    rc = open(file, flags, mode);
    4801a940:	b9401be2 	ldr	w2, [sp, #24]
    4801a944:	b9401fe1 	ldr	w1, [sp, #28]
    4801a948:	f94013e0 	ldr	x0, [sp, #32]
    4801a94c:	94000076 	bl	4801ab24 <open>
    4801a950:	b9003fe0 	str	w0, [sp, #60]
    return rc;
    4801a954:	b9403fe0 	ldr	w0, [sp, #60]
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801a958:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a95c:	d65f03c0 	ret

000000004801a960 <_read_r>:

_ssize_t _read_r(struct _reent *ptr, int fd, void *buf, size_t nbytes)
{
    4801a960:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a964:	910003fd 	mov	x29, sp
    4801a968:	f90017e0 	str	x0, [sp, #40]
    4801a96c:	b90027e1 	str	w1, [sp, #36]
    4801a970:	f9000fe2 	str	x2, [sp, #24]
    4801a974:	f9000be3 	str	x3, [sp, #16]
#ifdef RT_USING_POSIX
    _ssize_t rc;
    if (fd == STDIN_FILENO)
    4801a978:	b94027e0 	ldr	w0, [sp, #36]
    4801a97c:	7100001f 	cmp	w0, #0x0
    4801a980:	540000c1 	b.ne	4801a998 <_read_r+0x38>  // b.any
        {
            LOG_W("Do not invoke standard input before initializing libc");
            return 0;
        }
#else
        ptr->_errno = ENOTSUP;
    4801a984:	f94017e0 	ldr	x0, [sp, #40]
    4801a988:	528010c1 	mov	w1, #0x86                  	// #134
    4801a98c:	b9000001 	str	w1, [x0]
        return -1;
    4801a990:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4801a994:	14000013 	b	4801a9e0 <_read_r+0x80>
#endif /* RT_USING_POSIX_STDIO */
    }
    else if (fd == STDOUT_FILENO || fd == STDERR_FILENO)
    4801a998:	b94027e0 	ldr	w0, [sp, #36]
    4801a99c:	7100041f 	cmp	w0, #0x1
    4801a9a0:	54000080 	b.eq	4801a9b0 <_read_r+0x50>  // b.none
    4801a9a4:	b94027e0 	ldr	w0, [sp, #36]
    4801a9a8:	7100081f 	cmp	w0, #0x2
    4801a9ac:	540000c1 	b.ne	4801a9c4 <_read_r+0x64>  // b.any
    {
        ptr->_errno = ENOTSUP;
    4801a9b0:	f94017e0 	ldr	x0, [sp, #40]
    4801a9b4:	528010c1 	mov	w1, #0x86                  	// #134
    4801a9b8:	b9000001 	str	w1, [x0]
        return -1;
    4801a9bc:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4801a9c0:	14000008 	b	4801a9e0 <_read_r+0x80>
    }

    rc = read(fd, buf, nbytes);
    4801a9c4:	f9400be2 	ldr	x2, [sp, #16]
    4801a9c8:	f9400fe1 	ldr	x1, [sp, #24]
    4801a9cc:	b94027e0 	ldr	w0, [sp, #36]
    4801a9d0:	940000a6 	bl	4801ac68 <read>
    4801a9d4:	93407c00 	sxtw	x0, w0
    4801a9d8:	f9001fe0 	str	x0, [sp, #56]
    return rc;
    4801a9dc:	f9401fe0 	ldr	x0, [sp, #56]
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801a9e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801a9e4:	d65f03c0 	ret

000000004801a9e8 <_rename_r>:

int _rename_r(struct _reent *ptr, const char *old, const char *new)
{
    4801a9e8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801a9ec:	910003fd 	mov	x29, sp
    4801a9f0:	f90017e0 	str	x0, [sp, #40]
    4801a9f4:	f90013e1 	str	x1, [sp, #32]
    4801a9f8:	f9000fe2 	str	x2, [sp, #24]
#ifdef RT_USING_POSIX
    int rc;

    rc = rename(old, new);
    4801a9fc:	f9400fe1 	ldr	x1, [sp, #24]
    4801aa00:	f94013e0 	ldr	x0, [sp, #32]
    4801aa04:	94000126 	bl	4801ae9c <rename>
    4801aa08:	b9003fe0 	str	w0, [sp, #60]
    return rc;
    4801aa0c:	b9403fe0 	ldr	w0, [sp, #60]
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801aa10:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801aa14:	d65f03c0 	ret

000000004801aa18 <_stat_r>:

int _stat_r(struct _reent *ptr, const char *file, struct stat *pstat)
{
    4801aa18:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801aa1c:	910003fd 	mov	x29, sp
    4801aa20:	f90017e0 	str	x0, [sp, #40]
    4801aa24:	f90013e1 	str	x1, [sp, #32]
    4801aa28:	f9000fe2 	str	x2, [sp, #24]
#ifdef RT_USING_POSIX
    int rc;

    rc = stat(file, pstat);
    4801aa2c:	f9400fe1 	ldr	x1, [sp, #24]
    4801aa30:	f94013e0 	ldr	x0, [sp, #32]
    4801aa34:	9400013c 	bl	4801af24 <stat>
    4801aa38:	b9003fe0 	str	w0, [sp, #60]
    return rc;
    4801aa3c:	b9403fe0 	ldr	w0, [sp, #60]
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801aa40:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801aa44:	d65f03c0 	ret

000000004801aa48 <_unlink_r>:

int _unlink_r(struct _reent *ptr, const char *file)
{
    4801aa48:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801aa4c:	910003fd 	mov	x29, sp
    4801aa50:	f9000fe0 	str	x0, [sp, #24]
    4801aa54:	f9000be1 	str	x1, [sp, #16]
#ifdef RT_USING_POSIX
    return unlink(file);
    4801aa58:	f9400be0 	ldr	x0, [sp, #16]
    4801aa5c:	94000122 	bl	4801aee4 <unlink>
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801aa60:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801aa64:	d65f03c0 	ret

000000004801aa68 <_write_r>:

_ssize_t _write_r(struct _reent *ptr, int fd, const void *buf, size_t nbytes)
{
    4801aa68:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801aa6c:	910003fd 	mov	x29, sp
    4801aa70:	f90017e0 	str	x0, [sp, #40]
    4801aa74:	b90027e1 	str	w1, [sp, #36]
    4801aa78:	f9000fe2 	str	x2, [sp, #24]
    4801aa7c:	f9000be3 	str	x3, [sp, #16]
#ifdef RT_USING_POSIX
    _ssize_t rc;
#endif /* RT_USING_POSIX */

    if (fd == STDOUT_FILENO || fd == STDERR_FILENO)
    4801aa80:	b94027e0 	ldr	w0, [sp, #36]
    4801aa84:	7100041f 	cmp	w0, #0x1
    4801aa88:	54000080 	b.eq	4801aa98 <_write_r+0x30>  // b.none
    4801aa8c:	b94027e0 	ldr	w0, [sp, #36]
    4801aa90:	7100081f 	cmp	w0, #0x2
    4801aa94:	54000181 	b.ne	4801aac4 <_write_r+0x5c>  // b.any
    {
#ifdef RT_USING_CONSOLE
        rt_device_t console;

        console = rt_console_get_device();
    4801aa98:	97ffd459 	bl	4800fbfc <rt_console_get_device>
    4801aa9c:	f9001fe0 	str	x0, [sp, #56]
        if (console)
    4801aaa0:	f9401fe0 	ldr	x0, [sp, #56]
    4801aaa4:	f100001f 	cmp	x0, #0x0
    4801aaa8:	540001e0 	b.eq	4801aae4 <_write_r+0x7c>  // b.none
            return rt_device_write(console, -1, buf, nbytes);
    4801aaac:	f9400be3 	ldr	x3, [sp, #16]
    4801aab0:	f9400fe2 	ldr	x2, [sp, #24]
    4801aab4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    4801aab8:	f9401fe0 	ldr	x0, [sp, #56]
    4801aabc:	97ffc8cc 	bl	4800cdec <rt_device_write>
    4801aac0:	14000011 	b	4801ab04 <_write_r+0x9c>
#else
        ptr->_errno = ENOTSUP;
        return -1;
#endif /* RT_USING_CONSOLE */
    }
    else if (fd == STDIN_FILENO)
    4801aac4:	b94027e0 	ldr	w0, [sp, #36]
    4801aac8:	7100001f 	cmp	w0, #0x0
    4801aacc:	540000e1 	b.ne	4801aae8 <_write_r+0x80>  // b.any
    {
        ptr->_errno = ENOTSUP;
    4801aad0:	f94017e0 	ldr	x0, [sp, #40]
    4801aad4:	528010c1 	mov	w1, #0x86                  	// #134
    4801aad8:	b9000001 	str	w1, [x0]
        return -1;
    4801aadc:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4801aae0:	14000009 	b	4801ab04 <_write_r+0x9c>
    {
    4801aae4:	d503201f 	nop
    }

#ifdef RT_USING_POSIX
    rc = write(fd, buf, nbytes);
    4801aae8:	f9400be2 	ldr	x2, [sp, #16]
    4801aaec:	f9400fe1 	ldr	x1, [sp, #24]
    4801aaf0:	b94027e0 	ldr	w0, [sp, #36]
    4801aaf4:	9400007f 	bl	4801acf0 <write>
    4801aaf8:	93407c00 	sxtw	x0, w0
    4801aafc:	f9001be0 	str	x0, [sp, #48]
    return rc;
    4801ab00:	f9401be0 	ldr	x0, [sp, #48]
#else
    ptr->_errno = ENOTSUP;
    return -1;
#endif /* RT_USING_POSIX */
}
    4801ab04:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801ab08:	d65f03c0 	ret

000000004801ab0c <_exit>:

/* for exit() and abort() */
__attribute__ ((noreturn)) void _exit (int status)
{
    4801ab0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801ab10:	910003fd 	mov	x29, sp
    4801ab14:	b9001fe0 	str	w0, [sp, #28]
    extern void __rt_libc_exit(int status);
    __rt_libc_exit(status);
    4801ab18:	b9401fe0 	ldr	w0, [sp, #28]
    4801ab1c:	97fffe9e 	bl	4801a594 <__rt_libc_exit>
    while(1);
    4801ab20:	14000000 	b	4801ab20 <_exit+0x14>

000000004801ab24 <open>:
 * @param flags the file open flags.
 *
 * @return the non-negative integer on successful open, others for failed.
 */
int open(const char *file, int flags, ...)
{
    4801ab24:	a9b17bfd 	stp	x29, x30, [sp, #-240]!
    4801ab28:	910003fd 	mov	x29, sp
    4801ab2c:	f9000fe0 	str	x0, [sp, #24]
    4801ab30:	b90017e1 	str	w1, [sp, #20]
    4801ab34:	f90063e2 	str	x2, [sp, #192]
    4801ab38:	f90067e3 	str	x3, [sp, #200]
    4801ab3c:	f9006be4 	str	x4, [sp, #208]
    4801ab40:	f9006fe5 	str	x5, [sp, #216]
    4801ab44:	f90073e6 	str	x6, [sp, #224]
    4801ab48:	f90077e7 	str	x7, [sp, #232]
    4801ab4c:	3d8013e0 	str	q0, [sp, #64]
    4801ab50:	3d8017e1 	str	q1, [sp, #80]
    4801ab54:	3d801be2 	str	q2, [sp, #96]
    4801ab58:	3d801fe3 	str	q3, [sp, #112]
    4801ab5c:	3d8023e4 	str	q4, [sp, #128]
    4801ab60:	3d8027e5 	str	q5, [sp, #144]
    4801ab64:	3d802be6 	str	q6, [sp, #160]
    4801ab68:	3d802fe7 	str	q7, [sp, #176]
    int fd, result;
    struct dfs_fd *d;

    /* allocate a fd */
    fd = fd_new();
    4801ab6c:	97ffda0f 	bl	480113a8 <fd_new>
    4801ab70:	b9003fe0 	str	w0, [sp, #60]
    if (fd < 0)
    4801ab74:	b9403fe0 	ldr	w0, [sp, #60]
    4801ab78:	7100001f 	cmp	w0, #0x0
    4801ab7c:	540000aa 	b.ge	4801ab90 <open+0x6c>  // b.tcont
    {
        rt_set_errno(-ENOMEM);
    4801ab80:	92800160 	mov	x0, #0xfffffffffffffff4    	// #-12
    4801ab84:	97ffcdb8 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ab88:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801ab8c:	14000017 	b	4801abe8 <open+0xc4>
    }
    d = fd_get(fd);
    4801ab90:	b9403fe0 	ldr	w0, [sp, #60]
    4801ab94:	97ffda31 	bl	48011458 <fd_get>
    4801ab98:	f9001be0 	str	x0, [sp, #48]

    result = dfs_file_open(d, file, flags);
    4801ab9c:	b94017e2 	ldr	w2, [sp, #20]
    4801aba0:	f9400fe1 	ldr	x1, [sp, #24]
    4801aba4:	f9401be0 	ldr	x0, [sp, #48]
    4801aba8:	97ffdc8d 	bl	48011ddc <dfs_file_open>
    4801abac:	b9002fe0 	str	w0, [sp, #44]
    if (result < 0)
    4801abb0:	b9402fe0 	ldr	w0, [sp, #44]
    4801abb4:	7100001f 	cmp	w0, #0x0
    4801abb8:	5400012a 	b.ge	4801abdc <open+0xb8>  // b.tcont
    {
        /* release the ref-count of fd */
        fd_put(d);
    4801abbc:	f9401be0 	ldr	x0, [sp, #48]
    4801abc0:	97ffda55 	bl	48011514 <fd_put>
        fd_put(d);
    4801abc4:	f9401be0 	ldr	x0, [sp, #48]
    4801abc8:	97ffda53 	bl	48011514 <fd_put>

        rt_set_errno(result);
    4801abcc:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801abd0:	97ffcda5 	bl	4800e264 <rt_set_errno>

        return -1;
    4801abd4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801abd8:	14000004 	b	4801abe8 <open+0xc4>
    }

    /* release the ref-count of fd */
    fd_put(d);
    4801abdc:	f9401be0 	ldr	x0, [sp, #48]
    4801abe0:	97ffda4d 	bl	48011514 <fd_put>

    return fd;
    4801abe4:	b9403fe0 	ldr	w0, [sp, #60]
}
    4801abe8:	a8cf7bfd 	ldp	x29, x30, [sp], #240
    4801abec:	d65f03c0 	ret

000000004801abf0 <close>:
 * @param fd the file descriptor.
 *
 * @return 0 on successful, -1 on failed.
 */
int close(int fd)
{
    4801abf0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801abf4:	910003fd 	mov	x29, sp
    4801abf8:	b9001fe0 	str	w0, [sp, #28]
    int result;
    struct dfs_fd *d;

    d = fd_get(fd);
    4801abfc:	b9401fe0 	ldr	w0, [sp, #28]
    4801ac00:	97ffda16 	bl	48011458 <fd_get>
    4801ac04:	f90017e0 	str	x0, [sp, #40]
    if (d == NULL)
    4801ac08:	f94017e0 	ldr	x0, [sp, #40]
    4801ac0c:	f100001f 	cmp	x0, #0x0
    4801ac10:	540000a1 	b.ne	4801ac24 <close+0x34>  // b.any
    {
        rt_set_errno(-EBADF);
    4801ac14:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801ac18:	97ffcd93 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ac1c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801ac20:	14000010 	b	4801ac60 <close+0x70>
    }

    result = dfs_file_close(d);
    4801ac24:	f94017e0 	ldr	x0, [sp, #40]
    4801ac28:	97ffdcef 	bl	48011fe4 <dfs_file_close>
    4801ac2c:	b90027e0 	str	w0, [sp, #36]
    fd_put(d);
    4801ac30:	f94017e0 	ldr	x0, [sp, #40]
    4801ac34:	97ffda38 	bl	48011514 <fd_put>

    if (result < 0)
    4801ac38:	b94027e0 	ldr	w0, [sp, #36]
    4801ac3c:	7100001f 	cmp	w0, #0x0
    4801ac40:	540000aa 	b.ge	4801ac54 <close+0x64>  // b.tcont
    {
        rt_set_errno(result);
    4801ac44:	b98027e0 	ldrsw	x0, [sp, #36]
    4801ac48:	97ffcd87 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ac4c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801ac50:	14000004 	b	4801ac60 <close+0x70>
    }

    fd_put(d);
    4801ac54:	f94017e0 	ldr	x0, [sp, #40]
    4801ac58:	97ffda2f 	bl	48011514 <fd_put>

    return 0;
    4801ac5c:	52800000 	mov	w0, #0x0                   	// #0
}
    4801ac60:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801ac64:	d65f03c0 	ret

000000004801ac68 <read>:
#ifdef _READ_WRITE_RETURN_TYPE
_READ_WRITE_RETURN_TYPE read(int fd, void *buf, size_t len) /* some gcc tool chains will use different data structure */
#else
ssize_t read(int fd, void *buf, size_t len)
#endif
{
    4801ac68:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801ac6c:	910003fd 	mov	x29, sp
    4801ac70:	b9002fe0 	str	w0, [sp, #44]
    4801ac74:	f90013e1 	str	x1, [sp, #32]
    4801ac78:	f9000fe2 	str	x2, [sp, #24]
    int result;
    struct dfs_fd *d;

    /* get the fd */
    d = fd_get(fd);
    4801ac7c:	b9402fe0 	ldr	w0, [sp, #44]
    4801ac80:	97ffd9f6 	bl	48011458 <fd_get>
    4801ac84:	f9001fe0 	str	x0, [sp, #56]
    if (d == NULL)
    4801ac88:	f9401fe0 	ldr	x0, [sp, #56]
    4801ac8c:	f100001f 	cmp	x0, #0x0
    4801ac90:	540000a1 	b.ne	4801aca4 <read+0x3c>  // b.any
    {
        rt_set_errno(-EBADF);
    4801ac94:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801ac98:	97ffcd73 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ac9c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801aca0:	14000012 	b	4801ace8 <read+0x80>
    }

    result = dfs_file_read(d, buf, len);
    4801aca4:	f9400fe2 	ldr	x2, [sp, #24]
    4801aca8:	f94013e1 	ldr	x1, [sp, #32]
    4801acac:	f9401fe0 	ldr	x0, [sp, #56]
    4801acb0:	97ffdd2d 	bl	48012164 <dfs_file_read>
    4801acb4:	b90037e0 	str	w0, [sp, #52]
    if (result < 0)
    4801acb8:	b94037e0 	ldr	w0, [sp, #52]
    4801acbc:	7100001f 	cmp	w0, #0x0
    4801acc0:	540000ea 	b.ge	4801acdc <read+0x74>  // b.tcont
    {
        fd_put(d);
    4801acc4:	f9401fe0 	ldr	x0, [sp, #56]
    4801acc8:	97ffda13 	bl	48011514 <fd_put>
        rt_set_errno(result);
    4801accc:	b98037e0 	ldrsw	x0, [sp, #52]
    4801acd0:	97ffcd65 	bl	4800e264 <rt_set_errno>

        return -1;
    4801acd4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801acd8:	14000004 	b	4801ace8 <read+0x80>
    }

    /* release the ref-count of fd */
    fd_put(d);
    4801acdc:	f9401fe0 	ldr	x0, [sp, #56]
    4801ace0:	97ffda0d 	bl	48011514 <fd_put>

    return result;
    4801ace4:	b94037e0 	ldr	w0, [sp, #52]
}
    4801ace8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801acec:	d65f03c0 	ret

000000004801acf0 <write>:
#ifdef _READ_WRITE_RETURN_TYPE
_READ_WRITE_RETURN_TYPE write(int fd, const void *buf, size_t len) /* some gcc tool chains will use different data structure */
#else
ssize_t write(int fd, const void *buf, size_t len)
#endif
{
    4801acf0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801acf4:	910003fd 	mov	x29, sp
    4801acf8:	b9002fe0 	str	w0, [sp, #44]
    4801acfc:	f90013e1 	str	x1, [sp, #32]
    4801ad00:	f9000fe2 	str	x2, [sp, #24]
    int result;
    struct dfs_fd *d;

    /* get the fd */
    d = fd_get(fd);
    4801ad04:	b9402fe0 	ldr	w0, [sp, #44]
    4801ad08:	97ffd9d4 	bl	48011458 <fd_get>
    4801ad0c:	f9001fe0 	str	x0, [sp, #56]
    if (d == NULL)
    4801ad10:	f9401fe0 	ldr	x0, [sp, #56]
    4801ad14:	f100001f 	cmp	x0, #0x0
    4801ad18:	540000a1 	b.ne	4801ad2c <write+0x3c>  // b.any
    {
        rt_set_errno(-EBADF);
    4801ad1c:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801ad20:	97ffcd51 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ad24:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801ad28:	14000012 	b	4801ad70 <write+0x80>
    }

    result = dfs_file_write(d, buf, len);
    4801ad2c:	f9400fe2 	ldr	x2, [sp, #24]
    4801ad30:	f94013e1 	ldr	x1, [sp, #32]
    4801ad34:	f9401fe0 	ldr	x0, [sp, #56]
    4801ad38:	97ffdda2 	bl	480123c0 <dfs_file_write>
    4801ad3c:	b90037e0 	str	w0, [sp, #52]
    if (result < 0)
    4801ad40:	b94037e0 	ldr	w0, [sp, #52]
    4801ad44:	7100001f 	cmp	w0, #0x0
    4801ad48:	540000ea 	b.ge	4801ad64 <write+0x74>  // b.tcont
    {
        fd_put(d);
    4801ad4c:	f9401fe0 	ldr	x0, [sp, #56]
    4801ad50:	97ffd9f1 	bl	48011514 <fd_put>
        rt_set_errno(result);
    4801ad54:	b98037e0 	ldrsw	x0, [sp, #52]
    4801ad58:	97ffcd43 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ad5c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801ad60:	14000004 	b	4801ad70 <write+0x80>
    }

    /* release the ref-count of fd */
    fd_put(d);
    4801ad64:	f9401fe0 	ldr	x0, [sp, #56]
    4801ad68:	97ffd9eb 	bl	48011514 <fd_put>

    return result;
    4801ad6c:	b94037e0 	ldr	w0, [sp, #52]
}
    4801ad70:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801ad74:	d65f03c0 	ret

000000004801ad78 <lseek>:
 * @param whence the directory of seek.
 *
 * @return the current read/write position in the file, or -1 on failed.
 */
off_t lseek(int fd, off_t offset, int whence)
{
    4801ad78:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801ad7c:	910003fd 	mov	x29, sp
    4801ad80:	b9001fe0 	str	w0, [sp, #28]
    4801ad84:	f9000be1 	str	x1, [sp, #16]
    4801ad88:	b9001be2 	str	w2, [sp, #24]
    int result;
    struct dfs_fd *d;

    d = fd_get(fd);
    4801ad8c:	b9401fe0 	ldr	w0, [sp, #28]
    4801ad90:	97ffd9b2 	bl	48011458 <fd_get>
    4801ad94:	f90017e0 	str	x0, [sp, #40]
    if (d == NULL)
    4801ad98:	f94017e0 	ldr	x0, [sp, #40]
    4801ad9c:	f100001f 	cmp	x0, #0x0
    4801ada0:	540000a1 	b.ne	4801adb4 <lseek+0x3c>  // b.any
    {
        rt_set_errno(-EBADF);
    4801ada4:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801ada8:	97ffcd2f 	bl	4800e264 <rt_set_errno>

        return -1;
    4801adac:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4801adb0:	14000039 	b	4801ae94 <lseek+0x11c>
    }

    switch (whence)
    4801adb4:	b9401be0 	ldr	w0, [sp, #24]
    4801adb8:	7100081f 	cmp	w0, #0x2
    4801adbc:	54000200 	b.eq	4801adfc <lseek+0x84>  // b.none
    4801adc0:	b9401be0 	ldr	w0, [sp, #24]
    4801adc4:	7100081f 	cmp	w0, #0x2
    4801adc8:	5400026c 	b.gt	4801ae14 <lseek+0x9c>
    4801adcc:	b9401be0 	ldr	w0, [sp, #24]
    4801add0:	7100001f 	cmp	w0, #0x0
    4801add4:	540002c0 	b.eq	4801ae2c <lseek+0xb4>  // b.none
    4801add8:	b9401be0 	ldr	w0, [sp, #24]
    4801addc:	7100041f 	cmp	w0, #0x1
    4801ade0:	540001a1 	b.ne	4801ae14 <lseek+0x9c>  // b.any
    {
    case SEEK_SET:
        break;

    case SEEK_CUR:
        offset += d->pos;
    4801ade4:	f94017e0 	ldr	x0, [sp, #40]
    4801ade8:	f9401c00 	ldr	x0, [x0, #56]
    4801adec:	f9400be1 	ldr	x1, [sp, #16]
    4801adf0:	8b000020 	add	x0, x1, x0
    4801adf4:	f9000be0 	str	x0, [sp, #16]
        break;
    4801adf8:	1400000e 	b	4801ae30 <lseek+0xb8>

    case SEEK_END:
        offset += d->size;
    4801adfc:	f94017e0 	ldr	x0, [sp, #40]
    4801ae00:	f9401801 	ldr	x1, [x0, #48]
    4801ae04:	f9400be0 	ldr	x0, [sp, #16]
    4801ae08:	8b000020 	add	x0, x1, x0
    4801ae0c:	f9000be0 	str	x0, [sp, #16]
        break;
    4801ae10:	14000008 	b	4801ae30 <lseek+0xb8>

    default:
        fd_put(d);
    4801ae14:	f94017e0 	ldr	x0, [sp, #40]
    4801ae18:	97ffd9bf 	bl	48011514 <fd_put>
        rt_set_errno(-EINVAL);
    4801ae1c:	928002a0 	mov	x0, #0xffffffffffffffea    	// #-22
    4801ae20:	97ffcd11 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ae24:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4801ae28:	1400001b 	b	4801ae94 <lseek+0x11c>
        break;
    4801ae2c:	d503201f 	nop
    }

    if (offset < 0)
    4801ae30:	f9400be0 	ldr	x0, [sp, #16]
    4801ae34:	f100001f 	cmp	x0, #0x0
    4801ae38:	540000ea 	b.ge	4801ae54 <lseek+0xdc>  // b.tcont
    {
        fd_put(d);
    4801ae3c:	f94017e0 	ldr	x0, [sp, #40]
    4801ae40:	97ffd9b5 	bl	48011514 <fd_put>
        rt_set_errno(-EINVAL);
    4801ae44:	928002a0 	mov	x0, #0xffffffffffffffea    	// #-22
    4801ae48:	97ffcd07 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ae4c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4801ae50:	14000011 	b	4801ae94 <lseek+0x11c>
    }
    result = dfs_file_lseek(d, offset);
    4801ae54:	f9400be1 	ldr	x1, [sp, #16]
    4801ae58:	f94017e0 	ldr	x0, [sp, #40]
    4801ae5c:	97ffdd89 	bl	48012480 <dfs_file_lseek>
    4801ae60:	b90027e0 	str	w0, [sp, #36]
    if (result < 0)
    4801ae64:	b94027e0 	ldr	w0, [sp, #36]
    4801ae68:	7100001f 	cmp	w0, #0x0
    4801ae6c:	540000ea 	b.ge	4801ae88 <lseek+0x110>  // b.tcont
    {
        fd_put(d);
    4801ae70:	f94017e0 	ldr	x0, [sp, #40]
    4801ae74:	97ffd9a8 	bl	48011514 <fd_put>
        rt_set_errno(result);
    4801ae78:	b98027e0 	ldrsw	x0, [sp, #36]
    4801ae7c:	97ffccfa 	bl	4800e264 <rt_set_errno>

        return -1;
    4801ae80:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4801ae84:	14000004 	b	4801ae94 <lseek+0x11c>
    }

    /* release the ref-count of fd */
    fd_put(d);
    4801ae88:	f94017e0 	ldr	x0, [sp, #40]
    4801ae8c:	97ffd9a2 	bl	48011514 <fd_put>

    return offset;
    4801ae90:	f9400be0 	ldr	x0, [sp, #16]
}
    4801ae94:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801ae98:	d65f03c0 	ret

000000004801ae9c <rename>:
 * @return 0 on successful, -1 on failed.
 *
 * note: the old and new file name must be belong to a same file system.
 */
int rename(const char *old_file, const char *new_file)
{
    4801ae9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801aea0:	910003fd 	mov	x29, sp
    4801aea4:	f9000fe0 	str	x0, [sp, #24]
    4801aea8:	f9000be1 	str	x1, [sp, #16]
    int result;

    result = dfs_file_rename(old_file, new_file);
    4801aeac:	f9400be1 	ldr	x1, [sp, #16]
    4801aeb0:	f9400fe0 	ldr	x0, [sp, #24]
    4801aeb4:	97ffde0a 	bl	480126dc <dfs_file_rename>
    4801aeb8:	b9002fe0 	str	w0, [sp, #44]
    if (result < 0)
    4801aebc:	b9402fe0 	ldr	w0, [sp, #44]
    4801aec0:	7100001f 	cmp	w0, #0x0
    4801aec4:	540000aa 	b.ge	4801aed8 <rename+0x3c>  // b.tcont
    {
        rt_set_errno(result);
    4801aec8:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801aecc:	97ffcce6 	bl	4800e264 <rt_set_errno>

        return -1;
    4801aed0:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801aed4:	14000002 	b	4801aedc <rename+0x40>
    }

    return 0;
    4801aed8:	52800000 	mov	w0, #0x0                   	// #0
}
    4801aedc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801aee0:	d65f03c0 	ret

000000004801aee4 <unlink>:
 * @param pathname the specified path name to be unlinked.
 *
 * @return 0 on successful, -1 on failed.
 */
int unlink(const char *pathname)
{
    4801aee4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801aee8:	910003fd 	mov	x29, sp
    4801aeec:	f9000fe0 	str	x0, [sp, #24]
    int result;

    result = dfs_file_unlink(pathname);
    4801aef0:	f9400fe0 	ldr	x0, [sp, #24]
    4801aef4:	97ffdce0 	bl	48012274 <dfs_file_unlink>
    4801aef8:	b9002fe0 	str	w0, [sp, #44]
    if (result < 0)
    4801aefc:	b9402fe0 	ldr	w0, [sp, #44]
    4801af00:	7100001f 	cmp	w0, #0x0
    4801af04:	540000aa 	b.ge	4801af18 <unlink+0x34>  // b.tcont
    {
        rt_set_errno(result);
    4801af08:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801af0c:	97ffccd6 	bl	4800e264 <rt_set_errno>

        return -1;
    4801af10:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801af14:	14000002 	b	4801af1c <unlink+0x38>
    }

    return 0;
    4801af18:	52800000 	mov	w0, #0x0                   	// #0
}
    4801af1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801af20:	d65f03c0 	ret

000000004801af24 <stat>:
 * @param buf the data buffer to save stat description.
 *
 * @return 0 on successful, -1 on failed.
 */
int stat(const char *file, struct stat *buf)
{
    4801af24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801af28:	910003fd 	mov	x29, sp
    4801af2c:	f9000fe0 	str	x0, [sp, #24]
    4801af30:	f9000be1 	str	x1, [sp, #16]
    int result;

    result = dfs_file_stat(file, buf);
    4801af34:	f9400be1 	ldr	x1, [sp, #16]
    4801af38:	f9400fe0 	ldr	x0, [sp, #24]
    4801af3c:	97ffdd71 	bl	48012500 <dfs_file_stat>
    4801af40:	b9002fe0 	str	w0, [sp, #44]
    if (result < 0)
    4801af44:	b9402fe0 	ldr	w0, [sp, #44]
    4801af48:	7100001f 	cmp	w0, #0x0
    4801af4c:	540000aa 	b.ge	4801af60 <stat+0x3c>  // b.tcont
    {
        rt_set_errno(result);
    4801af50:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801af54:	97ffccc4 	bl	4800e264 <rt_set_errno>

        return -1;
    4801af58:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801af5c:	14000002 	b	4801af64 <stat+0x40>
    }

    return result;
    4801af60:	b9402fe0 	ldr	w0, [sp, #44]
}
    4801af64:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801af68:	d65f03c0 	ret

000000004801af6c <fstat>:
 * @param buf the data buffer to save stat description.
 *
 * @return 0 on successful, -1 on failed.
 */
int fstat(int fildes, struct stat *buf)
{
    4801af6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801af70:	910003fd 	mov	x29, sp
    4801af74:	b9001fe0 	str	w0, [sp, #28]
    4801af78:	f9000be1 	str	x1, [sp, #16]
    struct dfs_fd *d;

    /* get the fd */
    d = fd_get(fildes);
    4801af7c:	b9401fe0 	ldr	w0, [sp, #28]
    4801af80:	97ffd936 	bl	48011458 <fd_get>
    4801af84:	f90017e0 	str	x0, [sp, #40]
    if (d == NULL)
    4801af88:	f94017e0 	ldr	x0, [sp, #40]
    4801af8c:	f100001f 	cmp	x0, #0x0
    4801af90:	540000a1 	b.ne	4801afa4 <fstat+0x38>  // b.any
    {
        rt_set_errno(-EBADF);
    4801af94:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801af98:	97ffccb3 	bl	4800e264 <rt_set_errno>

        return -1;
    4801af9c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801afa0:	1400001f 	b	4801b01c <fstat+0xb0>
    }

    /* it's the root directory */
    buf->st_dev = 0;
    4801afa4:	f9400be0 	ldr	x0, [sp, #16]
    4801afa8:	7900001f 	strh	wzr, [x0]

    buf->st_mode = S_IFREG | S_IRUSR | S_IRGRP | S_IROTH |
    4801afac:	f9400be0 	ldr	x0, [sp, #16]
    4801afb0:	529036c1 	mov	w1, #0x81b6                	// #33206
    4801afb4:	b9000401 	str	w1, [x0, #4]
                   S_IWUSR | S_IWGRP | S_IWOTH;
    if (d->type == FT_DIRECTORY)
    4801afb8:	f94017e0 	ldr	x0, [sp, #40]
    4801afbc:	79400400 	ldrh	w0, [x0, #2]
    4801afc0:	7100081f 	cmp	w0, #0x2
    4801afc4:	54000181 	b.ne	4801aff4 <fstat+0x88>  // b.any
    {
        buf->st_mode &= ~S_IFREG;
    4801afc8:	f9400be0 	ldr	x0, [sp, #16]
    4801afcc:	b9400400 	ldr	w0, [x0, #4]
    4801afd0:	12107801 	and	w1, w0, #0xffff7fff
    4801afd4:	f9400be0 	ldr	x0, [sp, #16]
    4801afd8:	b9000401 	str	w1, [x0, #4]
        buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
    4801afdc:	f9400be0 	ldr	x0, [sp, #16]
    4801afe0:	b9400401 	ldr	w1, [x0, #4]
    4801afe4:	52880920 	mov	w0, #0x4049                	// #16457
    4801afe8:	2a000021 	orr	w1, w1, w0
    4801afec:	f9400be0 	ldr	x0, [sp, #16]
    4801aff0:	b9000401 	str	w1, [x0, #4]
    }

    buf->st_size    = d->size;
    4801aff4:	f94017e0 	ldr	x0, [sp, #40]
    4801aff8:	f9401800 	ldr	x0, [x0, #48]
    4801affc:	aa0003e1 	mov	x1, x0
    4801b000:	f9400be0 	ldr	x0, [sp, #16]
    4801b004:	f9000801 	str	x1, [x0, #16]
    buf->st_mtime   = 0;
    4801b008:	f9400be0 	ldr	x0, [sp, #16]
    4801b00c:	f900141f 	str	xzr, [x0, #40]

    fd_put(d);
    4801b010:	f94017e0 	ldr	x0, [sp, #40]
    4801b014:	97ffd940 	bl	48011514 <fd_put>

    return RT_EOK;
    4801b018:	52800000 	mov	w0, #0x0                   	// #0
}
    4801b01c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b020:	d65f03c0 	ret

000000004801b024 <fsync>:
 *
 * @return 0 on successful completion. Otherwise, -1 shall be returned and errno
 * set to indicate the error.
 */
int fsync(int fildes)
{
    4801b024:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b028:	910003fd 	mov	x29, sp
    4801b02c:	b9001fe0 	str	w0, [sp, #28]
    int ret;
    struct dfs_fd *d;

    /* get the fd */
    d = fd_get(fildes);
    4801b030:	b9401fe0 	ldr	w0, [sp, #28]
    4801b034:	97ffd909 	bl	48011458 <fd_get>
    4801b038:	f90017e0 	str	x0, [sp, #40]
    if (d == NULL)
    4801b03c:	f94017e0 	ldr	x0, [sp, #40]
    4801b040:	f100001f 	cmp	x0, #0x0
    4801b044:	540000a1 	b.ne	4801b058 <fsync+0x34>  // b.any
    {
        rt_set_errno(-EBADF);
    4801b048:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801b04c:	97ffcc86 	bl	4800e264 <rt_set_errno>
        return -1;
    4801b050:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b054:	14000007 	b	4801b070 <fsync+0x4c>
    }

    ret = dfs_file_flush(d);
    4801b058:	f94017e0 	ldr	x0, [sp, #40]
    4801b05c:	97ffdcf3 	bl	48012428 <dfs_file_flush>
    4801b060:	b90027e0 	str	w0, [sp, #36]

    fd_put(d);
    4801b064:	f94017e0 	ldr	x0, [sp, #40]
    4801b068:	97ffd92b 	bl	48011514 <fd_put>
    return ret;
    4801b06c:	b94027e0 	ldr	w0, [sp, #36]
}
    4801b070:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b074:	d65f03c0 	ret

000000004801b078 <fcntl>:
 *
 * @return 0 on successful completion. Otherwise, -1 shall be returned and errno
 * set to indicate the error.
 */
int fcntl(int fildes, int cmd, ...)
{
    4801b078:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
    4801b07c:	910003fd 	mov	x29, sp
    4801b080:	b9001fe0 	str	w0, [sp, #28]
    4801b084:	b9001be1 	str	w1, [sp, #24]
    4801b088:	f90073e2 	str	x2, [sp, #224]
    4801b08c:	f90077e3 	str	x3, [sp, #232]
    4801b090:	f9007be4 	str	x4, [sp, #240]
    4801b094:	f9007fe5 	str	x5, [sp, #248]
    4801b098:	f90083e6 	str	x6, [sp, #256]
    4801b09c:	f90087e7 	str	x7, [sp, #264]
    4801b0a0:	3d801be0 	str	q0, [sp, #96]
    4801b0a4:	3d801fe1 	str	q1, [sp, #112]
    4801b0a8:	3d8023e2 	str	q2, [sp, #128]
    4801b0ac:	3d8027e3 	str	q3, [sp, #144]
    4801b0b0:	3d802be4 	str	q4, [sp, #160]
    4801b0b4:	3d802fe5 	str	q5, [sp, #176]
    4801b0b8:	3d8033e6 	str	q6, [sp, #192]
    4801b0bc:	3d8037e7 	str	q7, [sp, #208]
    int ret = -1;
    4801b0c0:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b0c4:	b9005fe0 	str	w0, [sp, #92]
    struct dfs_fd *d;

    /* get the fd */
    d = fd_get(fildes);
    4801b0c8:	b9401fe0 	ldr	w0, [sp, #28]
    4801b0cc:	97ffd8e3 	bl	48011458 <fd_get>
    4801b0d0:	f9002be0 	str	x0, [sp, #80]
    if (d)
    4801b0d4:	f9402be0 	ldr	x0, [sp, #80]
    4801b0d8:	f100001f 	cmp	x0, #0x0
    4801b0dc:	54000520 	b.eq	4801b180 <fcntl+0x108>  // b.none
    {
        void *arg;
        va_list ap;

        va_start(ap, cmd);
    4801b0e0:	910443e0 	add	x0, sp, #0x110
    4801b0e4:	f90017e0 	str	x0, [sp, #40]
    4801b0e8:	910443e0 	add	x0, sp, #0x110
    4801b0ec:	f9001be0 	str	x0, [sp, #48]
    4801b0f0:	910383e0 	add	x0, sp, #0xe0
    4801b0f4:	f9001fe0 	str	x0, [sp, #56]
    4801b0f8:	128005e0 	mov	w0, #0xffffffd0            	// #-48
    4801b0fc:	b90043e0 	str	w0, [sp, #64]
    4801b100:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4801b104:	b90047e0 	str	w0, [sp, #68]
        arg = va_arg(ap, void *);
    4801b108:	b94043e1 	ldr	w1, [sp, #64]
    4801b10c:	f94017e0 	ldr	x0, [sp, #40]
    4801b110:	7100003f 	cmp	w1, #0x0
    4801b114:	540000ab 	b.lt	4801b128 <fcntl+0xb0>  // b.tstop
    4801b118:	91003c01 	add	x1, x0, #0xf
    4801b11c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4801b120:	f90017e1 	str	x1, [sp, #40]
    4801b124:	1400000d 	b	4801b158 <fcntl+0xe0>
    4801b128:	11002022 	add	w2, w1, #0x8
    4801b12c:	b90043e2 	str	w2, [sp, #64]
    4801b130:	b94043e2 	ldr	w2, [sp, #64]
    4801b134:	7100005f 	cmp	w2, #0x0
    4801b138:	540000ad 	b.le	4801b14c <fcntl+0xd4>
    4801b13c:	91003c01 	add	x1, x0, #0xf
    4801b140:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4801b144:	f90017e1 	str	x1, [sp, #40]
    4801b148:	14000004 	b	4801b158 <fcntl+0xe0>
    4801b14c:	f9401be2 	ldr	x2, [sp, #48]
    4801b150:	93407c20 	sxtw	x0, w1
    4801b154:	8b000040 	add	x0, x2, x0
    4801b158:	f9400000 	ldr	x0, [x0]
    4801b15c:	f90027e0 	str	x0, [sp, #72]
        va_end(ap);

        ret = dfs_file_ioctl(d, cmd, arg);
    4801b160:	f94027e2 	ldr	x2, [sp, #72]
    4801b164:	b9401be1 	ldr	w1, [sp, #24]
    4801b168:	f9402be0 	ldr	x0, [sp, #80]
    4801b16c:	97ffdbbf 	bl	48012068 <dfs_file_ioctl>
    4801b170:	b9005fe0 	str	w0, [sp, #92]
        fd_put(d);
    4801b174:	f9402be0 	ldr	x0, [sp, #80]
    4801b178:	97ffd8e7 	bl	48011514 <fd_put>
    4801b17c:	14000003 	b	4801b188 <fcntl+0x110>
    }
    else ret = -EBADF;
    4801b180:	12800100 	mov	w0, #0xfffffff7            	// #-9
    4801b184:	b9005fe0 	str	w0, [sp, #92]

    if (ret < 0)
    4801b188:	b9405fe0 	ldr	w0, [sp, #92]
    4801b18c:	7100001f 	cmp	w0, #0x0
    4801b190:	540000aa 	b.ge	4801b1a4 <fcntl+0x12c>  // b.tcont
    {
        rt_set_errno(ret);
    4801b194:	b9805fe0 	ldrsw	x0, [sp, #92]
    4801b198:	97ffcc33 	bl	4800e264 <rt_set_errno>
        ret = -1;
    4801b19c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b1a0:	b9005fe0 	str	w0, [sp, #92]
    }

    return ret;
    4801b1a4:	b9405fe0 	ldr	w0, [sp, #92]
}
    4801b1a8:	a8d17bfd 	ldp	x29, x30, [sp], #272
    4801b1ac:	d65f03c0 	ret

000000004801b1b0 <ioctl>:
 *
 * @return 0 on successful completion. Otherwise, -1 shall be returned and errno
 * set to indicate the error.
 */
int ioctl(int fildes, int cmd, ...)
{
    4801b1b0:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    4801b1b4:	910003fd 	mov	x29, sp
    4801b1b8:	b9001fe0 	str	w0, [sp, #28]
    4801b1bc:	b9001be1 	str	w1, [sp, #24]
    4801b1c0:	f9006be2 	str	x2, [sp, #208]
    4801b1c4:	f9006fe3 	str	x3, [sp, #216]
    4801b1c8:	f90073e4 	str	x4, [sp, #224]
    4801b1cc:	f90077e5 	str	x5, [sp, #232]
    4801b1d0:	f9007be6 	str	x6, [sp, #240]
    4801b1d4:	f9007fe7 	str	x7, [sp, #248]
    4801b1d8:	3d8017e0 	str	q0, [sp, #80]
    4801b1dc:	3d801be1 	str	q1, [sp, #96]
    4801b1e0:	3d801fe2 	str	q2, [sp, #112]
    4801b1e4:	3d8023e3 	str	q3, [sp, #128]
    4801b1e8:	3d8027e4 	str	q4, [sp, #144]
    4801b1ec:	3d802be5 	str	q5, [sp, #160]
    4801b1f0:	3d802fe6 	str	q6, [sp, #176]
    4801b1f4:	3d8033e7 	str	q7, [sp, #192]
    void *arg;
    va_list ap;

    va_start(ap, cmd);
    4801b1f8:	910403e0 	add	x0, sp, #0x100
    4801b1fc:	f90017e0 	str	x0, [sp, #40]
    4801b200:	910403e0 	add	x0, sp, #0x100
    4801b204:	f9001be0 	str	x0, [sp, #48]
    4801b208:	910343e0 	add	x0, sp, #0xd0
    4801b20c:	f9001fe0 	str	x0, [sp, #56]
    4801b210:	128005e0 	mov	w0, #0xffffffd0            	// #-48
    4801b214:	b90043e0 	str	w0, [sp, #64]
    4801b218:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4801b21c:	b90047e0 	str	w0, [sp, #68]
    arg = va_arg(ap, void *);
    4801b220:	b94043e1 	ldr	w1, [sp, #64]
    4801b224:	f94017e0 	ldr	x0, [sp, #40]
    4801b228:	7100003f 	cmp	w1, #0x0
    4801b22c:	540000ab 	b.lt	4801b240 <ioctl+0x90>  // b.tstop
    4801b230:	91003c01 	add	x1, x0, #0xf
    4801b234:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4801b238:	f90017e1 	str	x1, [sp, #40]
    4801b23c:	1400000d 	b	4801b270 <ioctl+0xc0>
    4801b240:	11002022 	add	w2, w1, #0x8
    4801b244:	b90043e2 	str	w2, [sp, #64]
    4801b248:	b94043e2 	ldr	w2, [sp, #64]
    4801b24c:	7100005f 	cmp	w2, #0x0
    4801b250:	540000ad 	b.le	4801b264 <ioctl+0xb4>
    4801b254:	91003c01 	add	x1, x0, #0xf
    4801b258:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4801b25c:	f90017e1 	str	x1, [sp, #40]
    4801b260:	14000004 	b	4801b270 <ioctl+0xc0>
    4801b264:	f9401be2 	ldr	x2, [sp, #48]
    4801b268:	93407c20 	sxtw	x0, w1
    4801b26c:	8b000040 	add	x0, x2, x0
    4801b270:	f9400000 	ldr	x0, [x0]
    4801b274:	f90027e0 	str	x0, [sp, #72]
    va_end(ap);

    /* we use fcntl for this API. */
    return fcntl(fildes, cmd, arg);
    4801b278:	f94027e2 	ldr	x2, [sp, #72]
    4801b27c:	b9401be1 	ldr	w1, [sp, #24]
    4801b280:	b9401fe0 	ldr	w0, [sp, #28]
    4801b284:	97ffff7d 	bl	4801b078 <fcntl>
}
    4801b288:	a8d07bfd 	ldp	x29, x30, [sp], #256
    4801b28c:	d65f03c0 	ret

000000004801b290 <ftruncate>:
 *
 * @return Upon successful completion, ftruncate() shall return 0;
 * otherwise, -1 shall be returned and errno set to indicate the error.
 */
int ftruncate(int fd, off_t length)
{
    4801b290:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b294:	910003fd 	mov	x29, sp
    4801b298:	b9001fe0 	str	w0, [sp, #28]
    4801b29c:	f9000be1 	str	x1, [sp, #16]
    int result;
    struct dfs_fd *d;

    d = fd_get(fd);
    4801b2a0:	b9401fe0 	ldr	w0, [sp, #28]
    4801b2a4:	97ffd86d 	bl	48011458 <fd_get>
    4801b2a8:	f90017e0 	str	x0, [sp, #40]
    if (d == NULL)
    4801b2ac:	f94017e0 	ldr	x0, [sp, #40]
    4801b2b0:	f100001f 	cmp	x0, #0x0
    4801b2b4:	540000a1 	b.ne	4801b2c8 <ftruncate+0x38>  // b.any
    {
        rt_set_errno(-EBADF);
    4801b2b8:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801b2bc:	97ffcbea 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b2c0:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b2c4:	1400001a 	b	4801b32c <ftruncate+0x9c>
    }

    if (length < 0)
    4801b2c8:	f9400be0 	ldr	x0, [sp, #16]
    4801b2cc:	f100001f 	cmp	x0, #0x0
    4801b2d0:	540000ea 	b.ge	4801b2ec <ftruncate+0x5c>  // b.tcont
    {
        fd_put(d);
    4801b2d4:	f94017e0 	ldr	x0, [sp, #40]
    4801b2d8:	97ffd88f 	bl	48011514 <fd_put>
        rt_set_errno(-EINVAL);
    4801b2dc:	928002a0 	mov	x0, #0xffffffffffffffea    	// #-22
    4801b2e0:	97ffcbe1 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b2e4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b2e8:	14000011 	b	4801b32c <ftruncate+0x9c>
    }
    result = dfs_file_ftruncate(d, length);
    4801b2ec:	f9400be1 	ldr	x1, [sp, #16]
    4801b2f0:	f94017e0 	ldr	x0, [sp, #40]
    4801b2f4:	97ffdd53 	bl	48012840 <dfs_file_ftruncate>
    4801b2f8:	b90027e0 	str	w0, [sp, #36]
    if (result < 0)
    4801b2fc:	b94027e0 	ldr	w0, [sp, #36]
    4801b300:	7100001f 	cmp	w0, #0x0
    4801b304:	540000ea 	b.ge	4801b320 <ftruncate+0x90>  // b.tcont
    {
        fd_put(d);
    4801b308:	f94017e0 	ldr	x0, [sp, #40]
    4801b30c:	97ffd882 	bl	48011514 <fd_put>
        rt_set_errno(result);
    4801b310:	b98027e0 	ldrsw	x0, [sp, #36]
    4801b314:	97ffcbd4 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b318:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b31c:	14000004 	b	4801b32c <ftruncate+0x9c>
    }

    /* release the ref-count of fd */
    fd_put(d);
    4801b320:	f94017e0 	ldr	x0, [sp, #40]
    4801b324:	97ffd87c 	bl	48011514 <fd_put>

    return 0;
    4801b328:	52800000 	mov	w0, #0x0                   	// #0
}
    4801b32c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b330:	d65f03c0 	ret

000000004801b334 <statfs>:
 * @param buf the buffer to save the returned information.
 *
 * @return 0 on successful, others on failed.
 */
int statfs(const char *path, struct statfs *buf)
{
    4801b334:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b338:	910003fd 	mov	x29, sp
    4801b33c:	f9000fe0 	str	x0, [sp, #24]
    4801b340:	f9000be1 	str	x1, [sp, #16]
    int result;

    result = dfs_statfs(path, buf);
    4801b344:	f9400be1 	ldr	x1, [sp, #16]
    4801b348:	f9400fe0 	ldr	x0, [sp, #24]
    4801b34c:	97ffd6bf 	bl	48010e48 <dfs_statfs>
    4801b350:	b9002fe0 	str	w0, [sp, #44]
    if (result < 0)
    4801b354:	b9402fe0 	ldr	w0, [sp, #44]
    4801b358:	7100001f 	cmp	w0, #0x0
    4801b35c:	540000aa 	b.ge	4801b370 <statfs+0x3c>  // b.tcont
    {
        rt_set_errno(result);
    4801b360:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801b364:	97ffcbc0 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b368:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b36c:	14000002 	b	4801b374 <statfs+0x40>
    }

    return result;
    4801b370:	b9402fe0 	ldr	w0, [sp, #44]
}
    4801b374:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b378:	d65f03c0 	ret

000000004801b37c <mkdir>:
 * @param mode
 *
 * @return 0 on successful, others on failed.
 */
int mkdir(const char *path, mode_t mode)
{
    4801b37c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801b380:	910003fd 	mov	x29, sp
    4801b384:	f9000fe0 	str	x0, [sp, #24]
    4801b388:	b90017e1 	str	w1, [sp, #20]
    int fd;
    struct dfs_fd *d;
    int result;

    fd = fd_new();
    4801b38c:	97ffd807 	bl	480113a8 <fd_new>
    4801b390:	b9003fe0 	str	w0, [sp, #60]
    if (fd == -1)
    4801b394:	b9403fe0 	ldr	w0, [sp, #60]
    4801b398:	3100041f 	cmn	w0, #0x1
    4801b39c:	540000a1 	b.ne	4801b3b0 <mkdir+0x34>  // b.any
    {
        rt_set_errno(-ENOMEM);
    4801b3a0:	92800160 	mov	x0, #0xfffffffffffffff4    	// #-12
    4801b3a4:	97ffcbb0 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b3a8:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b3ac:	1400001c 	b	4801b41c <mkdir+0xa0>
    }

    d = fd_get(fd);
    4801b3b0:	b9403fe0 	ldr	w0, [sp, #60]
    4801b3b4:	97ffd829 	bl	48011458 <fd_get>
    4801b3b8:	f9001be0 	str	x0, [sp, #48]

    result = dfs_file_open(d, path, O_DIRECTORY | O_CREAT);
    4801b3bc:	52804002 	mov	w2, #0x200                 	// #512
    4801b3c0:	72a00402 	movk	w2, #0x20, lsl #16
    4801b3c4:	f9400fe1 	ldr	x1, [sp, #24]
    4801b3c8:	f9401be0 	ldr	x0, [sp, #48]
    4801b3cc:	97ffda84 	bl	48011ddc <dfs_file_open>
    4801b3d0:	b9002fe0 	str	w0, [sp, #44]

    if (result < 0)
    4801b3d4:	b9402fe0 	ldr	w0, [sp, #44]
    4801b3d8:	7100001f 	cmp	w0, #0x0
    4801b3dc:	5400012a 	b.ge	4801b400 <mkdir+0x84>  // b.tcont
    {
        fd_put(d);
    4801b3e0:	f9401be0 	ldr	x0, [sp, #48]
    4801b3e4:	97ffd84c 	bl	48011514 <fd_put>
        fd_put(d);
    4801b3e8:	f9401be0 	ldr	x0, [sp, #48]
    4801b3ec:	97ffd84a 	bl	48011514 <fd_put>
        rt_set_errno(result);
    4801b3f0:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801b3f4:	97ffcb9c 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b3f8:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b3fc:	14000008 	b	4801b41c <mkdir+0xa0>
    }

    dfs_file_close(d);
    4801b400:	f9401be0 	ldr	x0, [sp, #48]
    4801b404:	97ffdaf8 	bl	48011fe4 <dfs_file_close>
    fd_put(d);
    4801b408:	f9401be0 	ldr	x0, [sp, #48]
    4801b40c:	97ffd842 	bl	48011514 <fd_put>
    fd_put(d);
    4801b410:	f9401be0 	ldr	x0, [sp, #48]
    4801b414:	97ffd840 	bl	48011514 <fd_put>

    return 0;
    4801b418:	52800000 	mov	w0, #0x0                   	// #0
}
    4801b41c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801b420:	d65f03c0 	ret

000000004801b424 <rmdir>:
 * @param pathname the path name to be removed.
 *
 * @return 0 on successful, others on failed.
 */
int rmdir(const char *pathname)
{
    4801b424:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b428:	910003fd 	mov	x29, sp
    4801b42c:	f9000fe0 	str	x0, [sp, #24]
    int result;

    result = dfs_file_unlink(pathname);
    4801b430:	f9400fe0 	ldr	x0, [sp, #24]
    4801b434:	97ffdb90 	bl	48012274 <dfs_file_unlink>
    4801b438:	b9002fe0 	str	w0, [sp, #44]
    if (result < 0)
    4801b43c:	b9402fe0 	ldr	w0, [sp, #44]
    4801b440:	7100001f 	cmp	w0, #0x0
    4801b444:	540000aa 	b.ge	4801b458 <rmdir+0x34>  // b.tcont
    {
        rt_set_errno(result);
    4801b448:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801b44c:	97ffcb86 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b450:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b454:	14000002 	b	4801b45c <rmdir+0x38>
    }

    return 0;
    4801b458:	52800000 	mov	w0, #0x0                   	// #0
}
    4801b45c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b460:	d65f03c0 	ret

000000004801b464 <opendir>:
 * @param name the path name to be open.
 *
 * @return the DIR pointer of directory, NULL on open directory failed.
 */
DIR *opendir(const char *name)
{
    4801b464:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801b468:	910003fd 	mov	x29, sp
    4801b46c:	f9000fe0 	str	x0, [sp, #24]
    struct dfs_fd *d;
    int fd, result;
    DIR *t;

    t = NULL;
    4801b470:	f9001fff 	str	xzr, [sp, #56]

    /* allocate a fd */
    fd = fd_new();
    4801b474:	97ffd7cd 	bl	480113a8 <fd_new>
    4801b478:	b90037e0 	str	w0, [sp, #52]
    if (fd == -1)
    4801b47c:	b94037e0 	ldr	w0, [sp, #52]
    4801b480:	3100041f 	cmn	w0, #0x1
    4801b484:	540000a1 	b.ne	4801b498 <opendir+0x34>  // b.any
    {
        rt_set_errno(-ENOMEM);
    4801b488:	92800160 	mov	x0, #0xfffffffffffffff4    	// #-12
    4801b48c:	97ffcb76 	bl	4800e264 <rt_set_errno>

        return NULL;
    4801b490:	d2800000 	mov	x0, #0x0                   	// #0
    4801b494:	14000029 	b	4801b538 <opendir+0xd4>
    }
    d = fd_get(fd);
    4801b498:	b94037e0 	ldr	w0, [sp, #52]
    4801b49c:	97ffd7ef 	bl	48011458 <fd_get>
    4801b4a0:	f90017e0 	str	x0, [sp, #40]

    result = dfs_file_open(d, name, O_RDONLY | O_DIRECTORY);
    4801b4a4:	52a00402 	mov	w2, #0x200000              	// #2097152
    4801b4a8:	f9400fe1 	ldr	x1, [sp, #24]
    4801b4ac:	f94017e0 	ldr	x0, [sp, #40]
    4801b4b0:	97ffda4b 	bl	48011ddc <dfs_file_open>
    4801b4b4:	b90027e0 	str	w0, [sp, #36]
    if (result >= 0)
    4801b4b8:	b94027e0 	ldr	w0, [sp, #36]
    4801b4bc:	7100001f 	cmp	w0, #0x0
    4801b4c0:	540002eb 	b.lt	4801b51c <opendir+0xb8>  // b.tstop
    {
        /* open successfully */
        t = (DIR *) rt_malloc(sizeof(DIR));
    4801b4c4:	d2804180 	mov	x0, #0x20c                 	// #524
    4801b4c8:	97ffb9b0 	bl	48009b88 <rt_malloc>
    4801b4cc:	f9001fe0 	str	x0, [sp, #56]
        if (t == NULL)
    4801b4d0:	f9401fe0 	ldr	x0, [sp, #56]
    4801b4d4:	f100001f 	cmp	x0, #0x0
    4801b4d8:	540000c1 	b.ne	4801b4f0 <opendir+0x8c>  // b.any
        {
            dfs_file_close(d);
    4801b4dc:	f94017e0 	ldr	x0, [sp, #40]
    4801b4e0:	97ffdac1 	bl	48011fe4 <dfs_file_close>
            fd_put(d);
    4801b4e4:	f94017e0 	ldr	x0, [sp, #40]
    4801b4e8:	97ffd80b 	bl	48011514 <fd_put>
    4801b4ec:	14000008 	b	4801b50c <opendir+0xa8>
        }
        else
        {
            memset(t, 0, sizeof(DIR));
    4801b4f0:	d2804182 	mov	x2, #0x20c                 	// #524
    4801b4f4:	52800001 	mov	w1, #0x0                   	// #0
    4801b4f8:	f9401fe0 	ldr	x0, [sp, #56]
    4801b4fc:	940001f1 	bl	4801bcc0 <memset>

            t->fd = fd;
    4801b500:	f9401fe0 	ldr	x0, [sp, #56]
    4801b504:	b94037e1 	ldr	w1, [sp, #52]
    4801b508:	b9000001 	str	w1, [x0]
        }
        fd_put(d);
    4801b50c:	f94017e0 	ldr	x0, [sp, #40]
    4801b510:	97ffd801 	bl	48011514 <fd_put>

        return t;
    4801b514:	f9401fe0 	ldr	x0, [sp, #56]
    4801b518:	14000008 	b	4801b538 <opendir+0xd4>
    }

    /* open failed */
    fd_put(d);
    4801b51c:	f94017e0 	ldr	x0, [sp, #40]
    4801b520:	97ffd7fd 	bl	48011514 <fd_put>
    fd_put(d);
    4801b524:	f94017e0 	ldr	x0, [sp, #40]
    4801b528:	97ffd7fb 	bl	48011514 <fd_put>
    rt_set_errno(result);
    4801b52c:	b98027e0 	ldrsw	x0, [sp, #36]
    4801b530:	97ffcb4d 	bl	4800e264 <rt_set_errno>

    return NULL;
    4801b534:	d2800000 	mov	x0, #0x0                   	// #0
}
    4801b538:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801b53c:	d65f03c0 	ret

000000004801b540 <readdir>:
 * @param d the directory stream pointer.
 *
 * @return the next directory entry, NULL on the end of directory or failed.
 */
struct dirent *readdir(DIR *d)
{
    4801b540:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801b544:	910003fd 	mov	x29, sp
    4801b548:	f9000fe0 	str	x0, [sp, #24]
    int result;
    struct dfs_fd *fd;

    fd = fd_get(d->fd);
    4801b54c:	f9400fe0 	ldr	x0, [sp, #24]
    4801b550:	b9400000 	ldr	w0, [x0]
    4801b554:	97ffd7c1 	bl	48011458 <fd_get>
    4801b558:	f9001fe0 	str	x0, [sp, #56]
    if (fd == NULL)
    4801b55c:	f9401fe0 	ldr	x0, [sp, #56]
    4801b560:	f100001f 	cmp	x0, #0x0
    4801b564:	540000a1 	b.ne	4801b578 <readdir+0x38>  // b.any
    {
        rt_set_errno(-EBADF);
    4801b568:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801b56c:	97ffcb3e 	bl	4800e264 <rt_set_errno>
        return NULL;
    4801b570:	d2800000 	mov	x0, #0x0                   	// #0
    4801b574:	1400003a 	b	4801b65c <readdir+0x11c>
    }

    if (d->num)
    4801b578:	f9400fe0 	ldr	x0, [sp, #24]
    4801b57c:	b9420400 	ldr	w0, [x0, #516]
    4801b580:	7100001f 	cmp	w0, #0x0
    4801b584:	540001e0 	b.eq	4801b5c0 <readdir+0x80>  // b.none
    {
        struct dirent *dirent_ptr;
        dirent_ptr = (struct dirent *)&d->buf[d->cur];
    4801b588:	f9400fe0 	ldr	x0, [sp, #24]
    4801b58c:	b9420800 	ldr	w0, [x0, #520]
    4801b590:	93407c00 	sxtw	x0, w0
    4801b594:	f9400fe1 	ldr	x1, [sp, #24]
    4801b598:	8b000020 	add	x0, x1, x0
    4801b59c:	91001000 	add	x0, x0, #0x4
    4801b5a0:	f9001be0 	str	x0, [sp, #48]
        d->cur += dirent_ptr->d_reclen;
    4801b5a4:	f9400fe0 	ldr	x0, [sp, #24]
    4801b5a8:	b9420800 	ldr	w0, [x0, #520]
    4801b5ac:	f9401be1 	ldr	x1, [sp, #48]
    4801b5b0:	79400421 	ldrh	w1, [x1, #2]
    4801b5b4:	0b010001 	add	w1, w0, w1
    4801b5b8:	f9400fe0 	ldr	x0, [sp, #24]
    4801b5bc:	b9020801 	str	w1, [x0, #520]
    }

    if (!d->num || d->cur >= d->num)
    4801b5c0:	f9400fe0 	ldr	x0, [sp, #24]
    4801b5c4:	b9420400 	ldr	w0, [x0, #516]
    4801b5c8:	7100001f 	cmp	w0, #0x0
    4801b5cc:	540000e0 	b.eq	4801b5e8 <readdir+0xa8>  // b.none
    4801b5d0:	f9400fe0 	ldr	x0, [sp, #24]
    4801b5d4:	b9420801 	ldr	w1, [x0, #520]
    4801b5d8:	f9400fe0 	ldr	x0, [sp, #24]
    4801b5dc:	b9420400 	ldr	w0, [x0, #516]
    4801b5e0:	6b00003f 	cmp	w1, w0
    4801b5e4:	540002cb 	b.lt	4801b63c <readdir+0xfc>  // b.tstop
    {
        /* get a new entry */
        result = dfs_file_getdents(fd,
                                   (struct dirent *)d->buf,
    4801b5e8:	f9400fe0 	ldr	x0, [sp, #24]
    4801b5ec:	91001000 	add	x0, x0, #0x4
        result = dfs_file_getdents(fd,
    4801b5f0:	d2803fe2 	mov	x2, #0x1ff                 	// #511
    4801b5f4:	aa0003e1 	mov	x1, x0
    4801b5f8:	f9401fe0 	ldr	x0, [sp, #56]
    4801b5fc:	97ffdaff 	bl	480121f8 <dfs_file_getdents>
    4801b600:	b9002fe0 	str	w0, [sp, #44]
                                   sizeof(d->buf) - 1);
        if (result <= 0)
    4801b604:	b9402fe0 	ldr	w0, [sp, #44]
    4801b608:	7100001f 	cmp	w0, #0x0
    4801b60c:	540000ec 	b.gt	4801b628 <readdir+0xe8>
        {
            fd_put(fd);
    4801b610:	f9401fe0 	ldr	x0, [sp, #56]
    4801b614:	97ffd7c0 	bl	48011514 <fd_put>
            rt_set_errno(result);
    4801b618:	b9802fe0 	ldrsw	x0, [sp, #44]
    4801b61c:	97ffcb12 	bl	4800e264 <rt_set_errno>

            return NULL;
    4801b620:	d2800000 	mov	x0, #0x0                   	// #0
    4801b624:	1400000e 	b	4801b65c <readdir+0x11c>
        }

        d->num = result;
    4801b628:	f9400fe0 	ldr	x0, [sp, #24]
    4801b62c:	b9402fe1 	ldr	w1, [sp, #44]
    4801b630:	b9020401 	str	w1, [x0, #516]
        d->cur = 0; /* current entry index */
    4801b634:	f9400fe0 	ldr	x0, [sp, #24]
    4801b638:	b902081f 	str	wzr, [x0, #520]
    }

    fd_put(fd);
    4801b63c:	f9401fe0 	ldr	x0, [sp, #56]
    4801b640:	97ffd7b5 	bl	48011514 <fd_put>

    return (struct dirent *)(d->buf + d->cur);
    4801b644:	f9400fe0 	ldr	x0, [sp, #24]
    4801b648:	91001001 	add	x1, x0, #0x4
    4801b64c:	f9400fe0 	ldr	x0, [sp, #24]
    4801b650:	b9420800 	ldr	w0, [x0, #520]
    4801b654:	93407c00 	sxtw	x0, w0
    4801b658:	8b000020 	add	x0, x1, x0
}
    4801b65c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801b660:	d65f03c0 	ret

000000004801b664 <telldir>:
 * @param d the directory stream pointer.
 *
 * @return the current location in directory stream.
 */
long telldir(DIR *d)
{
    4801b664:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b668:	910003fd 	mov	x29, sp
    4801b66c:	f9000fe0 	str	x0, [sp, #24]
    struct dfs_fd *fd;
    long result;

    fd = fd_get(d->fd);
    4801b670:	f9400fe0 	ldr	x0, [sp, #24]
    4801b674:	b9400000 	ldr	w0, [x0]
    4801b678:	97ffd778 	bl	48011458 <fd_get>
    4801b67c:	f90017e0 	str	x0, [sp, #40]
    if (fd == NULL)
    4801b680:	f94017e0 	ldr	x0, [sp, #40]
    4801b684:	f100001f 	cmp	x0, #0x0
    4801b688:	540000a1 	b.ne	4801b69c <telldir+0x38>  // b.any
    {
        rt_set_errno(-EBADF);
    4801b68c:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801b690:	97ffcaf5 	bl	4800e264 <rt_set_errno>

        return 0;
    4801b694:	d2800000 	mov	x0, #0x0                   	// #0
    4801b698:	1400000f 	b	4801b6d4 <telldir+0x70>
    }

    result = fd->pos - d->num + d->cur;
    4801b69c:	f94017e0 	ldr	x0, [sp, #40]
    4801b6a0:	f9401c01 	ldr	x1, [x0, #56]
    4801b6a4:	f9400fe0 	ldr	x0, [sp, #24]
    4801b6a8:	b9420400 	ldr	w0, [x0, #516]
    4801b6ac:	93407c00 	sxtw	x0, w0
    4801b6b0:	cb000021 	sub	x1, x1, x0
    4801b6b4:	f9400fe0 	ldr	x0, [sp, #24]
    4801b6b8:	b9420800 	ldr	w0, [x0, #520]
    4801b6bc:	93407c00 	sxtw	x0, w0
    4801b6c0:	8b000020 	add	x0, x1, x0
    4801b6c4:	f90013e0 	str	x0, [sp, #32]
    fd_put(fd);
    4801b6c8:	f94017e0 	ldr	x0, [sp, #40]
    4801b6cc:	97ffd792 	bl	48011514 <fd_put>

    return result;
    4801b6d0:	f94013e0 	ldr	x0, [sp, #32]
}
    4801b6d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b6d8:	d65f03c0 	ret

000000004801b6dc <seekdir>:
 *
 * @param d the directory stream.
 * @param offset the offset in directory stream.
 */
void seekdir(DIR *d, off_t offset)
{
    4801b6dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b6e0:	910003fd 	mov	x29, sp
    4801b6e4:	f9000fe0 	str	x0, [sp, #24]
    4801b6e8:	f9000be1 	str	x1, [sp, #16]
    struct dfs_fd *fd;

    fd = fd_get(d->fd);
    4801b6ec:	f9400fe0 	ldr	x0, [sp, #24]
    4801b6f0:	b9400000 	ldr	w0, [x0]
    4801b6f4:	97ffd759 	bl	48011458 <fd_get>
    4801b6f8:	f90017e0 	str	x0, [sp, #40]
    if (fd == NULL)
    4801b6fc:	f94017e0 	ldr	x0, [sp, #40]
    4801b700:	f100001f 	cmp	x0, #0x0
    4801b704:	54000081 	b.ne	4801b714 <seekdir+0x38>  // b.any
    {
        rt_set_errno(-EBADF);
    4801b708:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801b70c:	97ffcad6 	bl	4800e264 <rt_set_errno>

        return ;
    4801b710:	1400000e 	b	4801b748 <seekdir+0x6c>
    }

    /* seek to the offset position of directory */
    if (dfs_file_lseek(fd, offset) >= 0)
    4801b714:	f9400be1 	ldr	x1, [sp, #16]
    4801b718:	f94017e0 	ldr	x0, [sp, #40]
    4801b71c:	97ffdb59 	bl	48012480 <dfs_file_lseek>
    4801b720:	7100001f 	cmp	w0, #0x0
    4801b724:	540000eb 	b.lt	4801b740 <seekdir+0x64>  // b.tstop
        d->num = d->cur = 0;
    4801b728:	f9400fe0 	ldr	x0, [sp, #24]
    4801b72c:	b902081f 	str	wzr, [x0, #520]
    4801b730:	f9400fe0 	ldr	x0, [sp, #24]
    4801b734:	b9420801 	ldr	w1, [x0, #520]
    4801b738:	f9400fe0 	ldr	x0, [sp, #24]
    4801b73c:	b9020401 	str	w1, [x0, #516]
    fd_put(fd);
    4801b740:	f94017e0 	ldr	x0, [sp, #40]
    4801b744:	97ffd774 	bl	48011514 <fd_put>
}
    4801b748:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b74c:	d65f03c0 	ret

000000004801b750 <rewinddir>:
 * stream.
 *
 * @param d the directory stream.
 */
void rewinddir(DIR *d)
{
    4801b750:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b754:	910003fd 	mov	x29, sp
    4801b758:	f9000fe0 	str	x0, [sp, #24]
    struct dfs_fd *fd;

    fd = fd_get(d->fd);
    4801b75c:	f9400fe0 	ldr	x0, [sp, #24]
    4801b760:	b9400000 	ldr	w0, [x0]
    4801b764:	97ffd73d 	bl	48011458 <fd_get>
    4801b768:	f90017e0 	str	x0, [sp, #40]
    if (fd == NULL)
    4801b76c:	f94017e0 	ldr	x0, [sp, #40]
    4801b770:	f100001f 	cmp	x0, #0x0
    4801b774:	54000081 	b.ne	4801b784 <rewinddir+0x34>  // b.any
    {
        rt_set_errno(-EBADF);
    4801b778:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801b77c:	97ffcaba 	bl	4800e264 <rt_set_errno>

        return ;
    4801b780:	1400000e 	b	4801b7b8 <rewinddir+0x68>
    }

    /* seek to the beginning of directory */
    if (dfs_file_lseek(fd, 0) >= 0)
    4801b784:	d2800001 	mov	x1, #0x0                   	// #0
    4801b788:	f94017e0 	ldr	x0, [sp, #40]
    4801b78c:	97ffdb3d 	bl	48012480 <dfs_file_lseek>
    4801b790:	7100001f 	cmp	w0, #0x0
    4801b794:	540000eb 	b.lt	4801b7b0 <rewinddir+0x60>  // b.tstop
        d->num = d->cur = 0;
    4801b798:	f9400fe0 	ldr	x0, [sp, #24]
    4801b79c:	b902081f 	str	wzr, [x0, #520]
    4801b7a0:	f9400fe0 	ldr	x0, [sp, #24]
    4801b7a4:	b9420801 	ldr	w1, [x0, #520]
    4801b7a8:	f9400fe0 	ldr	x0, [sp, #24]
    4801b7ac:	b9020401 	str	w1, [x0, #516]
    fd_put(fd);
    4801b7b0:	f94017e0 	ldr	x0, [sp, #40]
    4801b7b4:	97ffd758 	bl	48011514 <fd_put>
}
    4801b7b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b7bc:	d65f03c0 	ret

000000004801b7c0 <closedir>:
 * @param d the directory stream.
 *
 * @return 0 on successful, -1 on failed.
 */
int closedir(DIR *d)
{
    4801b7c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b7c4:	910003fd 	mov	x29, sp
    4801b7c8:	f9000fe0 	str	x0, [sp, #24]
    int result;
    struct dfs_fd *fd;

    fd = fd_get(d->fd);
    4801b7cc:	f9400fe0 	ldr	x0, [sp, #24]
    4801b7d0:	b9400000 	ldr	w0, [x0]
    4801b7d4:	97ffd721 	bl	48011458 <fd_get>
    4801b7d8:	f90017e0 	str	x0, [sp, #40]
    if (fd == NULL)
    4801b7dc:	f94017e0 	ldr	x0, [sp, #40]
    4801b7e0:	f100001f 	cmp	x0, #0x0
    4801b7e4:	540000a1 	b.ne	4801b7f8 <closedir+0x38>  // b.any
    {
        rt_set_errno(-EBADF);
    4801b7e8:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4801b7ec:	97ffca9e 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b7f0:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b7f4:	14000012 	b	4801b83c <closedir+0x7c>
    }

    result = dfs_file_close(fd);
    4801b7f8:	f94017e0 	ldr	x0, [sp, #40]
    4801b7fc:	97ffd9fa 	bl	48011fe4 <dfs_file_close>
    4801b800:	b90027e0 	str	w0, [sp, #36]
    fd_put(fd);
    4801b804:	f94017e0 	ldr	x0, [sp, #40]
    4801b808:	97ffd743 	bl	48011514 <fd_put>

    fd_put(fd);
    4801b80c:	f94017e0 	ldr	x0, [sp, #40]
    4801b810:	97ffd741 	bl	48011514 <fd_put>
    rt_free(d);
    4801b814:	f9400fe0 	ldr	x0, [sp, #24]
    4801b818:	97ffbaeb 	bl	4800a3c4 <rt_free>

    if (result < 0)
    4801b81c:	b94027e0 	ldr	w0, [sp, #36]
    4801b820:	7100001f 	cmp	w0, #0x0
    4801b824:	540000aa 	b.ge	4801b838 <closedir+0x78>  // b.tcont
    {
        rt_set_errno(result);
    4801b828:	b98027e0 	ldrsw	x0, [sp, #36]
    4801b82c:	97ffca8e 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b830:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b834:	14000002 	b	4801b83c <closedir+0x7c>
    }
    else
        return 0;
    4801b838:	52800000 	mov	w0, #0x0                   	// #0
}
    4801b83c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b840:	d65f03c0 	ret

000000004801b844 <chdir>:
 * @param path the path name to be changed to.
 *
 * @return 0 on successful, -1 on failed.
 */
int chdir(const char *path)
{
    4801b844:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801b848:	910003fd 	mov	x29, sp
    4801b84c:	f9000fe0 	str	x0, [sp, #24]
    char *fullpath;
    DIR *d;

    if (path == NULL)
    4801b850:	f9400fe0 	ldr	x0, [sp, #24]
    4801b854:	f100001f 	cmp	x0, #0x0
    4801b858:	54000141 	b.ne	4801b880 <chdir+0x3c>  // b.any
    {
        dfs_lock();
    4801b85c:	97ffd62e 	bl	48011114 <dfs_lock>
        rt_kprintf("%s\n", working_directory);
    4801b860:	d0000020 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4801b864:	911a6001 	add	x1, x0, #0x698
    4801b868:	b0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801b86c:	913de000 	add	x0, x0, #0xf78
    4801b870:	97ffd130 	bl	4800fd30 <rt_kprintf>
        dfs_unlock();
    4801b874:	97ffd641 	bl	48011178 <dfs_unlock>

        return 0;
    4801b878:	52800000 	mov	w0, #0x0                   	// #0
    4801b87c:	1400002b 	b	4801b928 <chdir+0xe4>
    }

    if (strlen(path) > DFS_PATH_MAX)
    4801b880:	f9400fe0 	ldr	x0, [sp, #24]
    4801b884:	9400023f 	bl	4801c180 <strlen>
    4801b888:	f104001f 	cmp	x0, #0x100
    4801b88c:	540000a9 	b.ls	4801b8a0 <chdir+0x5c>  // b.plast
    {
        rt_set_errno(-ENOTDIR);
    4801b890:	92800260 	mov	x0, #0xffffffffffffffec    	// #-20
    4801b894:	97ffca74 	bl	4800e264 <rt_set_errno>

        return -1;
    4801b898:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b89c:	14000023 	b	4801b928 <chdir+0xe4>
    }

    fullpath = dfs_normalize_path(NULL, path);
    4801b8a0:	f9400fe1 	ldr	x1, [sp, #24]
    4801b8a4:	d2800000 	mov	x0, #0x0                   	// #0
    4801b8a8:	97ffd7d6 	bl	48011800 <dfs_normalize_path>
    4801b8ac:	f90017e0 	str	x0, [sp, #40]
    if (fullpath == NULL)
    4801b8b0:	f94017e0 	ldr	x0, [sp, #40]
    4801b8b4:	f100001f 	cmp	x0, #0x0
    4801b8b8:	540000a1 	b.ne	4801b8cc <chdir+0x88>  // b.any
    {
        rt_set_errno(-ENOTDIR);
    4801b8bc:	92800260 	mov	x0, #0xffffffffffffffec    	// #-20
    4801b8c0:	97ffca69 	bl	4800e264 <rt_set_errno>

        return -1; /* build path failed */
    4801b8c4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b8c8:	14000018 	b	4801b928 <chdir+0xe4>
    }

    dfs_lock();
    4801b8cc:	97ffd612 	bl	48011114 <dfs_lock>
    d = opendir(fullpath);
    4801b8d0:	f94017e0 	ldr	x0, [sp, #40]
    4801b8d4:	97fffee4 	bl	4801b464 <opendir>
    4801b8d8:	f90013e0 	str	x0, [sp, #32]
    if (d == NULL)
    4801b8dc:	f94013e0 	ldr	x0, [sp, #32]
    4801b8e0:	f100001f 	cmp	x0, #0x0
    4801b8e4:	540000c1 	b.ne	4801b8fc <chdir+0xb8>  // b.any
    {
        rt_free(fullpath);
    4801b8e8:	f94017e0 	ldr	x0, [sp, #40]
    4801b8ec:	97ffbab6 	bl	4800a3c4 <rt_free>
        /* this is a not exist directory */
        dfs_unlock();
    4801b8f0:	97ffd622 	bl	48011178 <dfs_unlock>

        return -1;
    4801b8f4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b8f8:	1400000c 	b	4801b928 <chdir+0xe4>
    }

    /* close directory stream */
    closedir(d);
    4801b8fc:	f94013e0 	ldr	x0, [sp, #32]
    4801b900:	97ffffb0 	bl	4801b7c0 <closedir>

    /* copy full path to working directory */
    strncpy(working_directory, fullpath, DFS_PATH_MAX);
    4801b904:	d2802002 	mov	x2, #0x100                 	// #256
    4801b908:	f94017e1 	ldr	x1, [sp, #40]
    4801b90c:	d0000020 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4801b910:	911a6000 	add	x0, x0, #0x698
    4801b914:	940003db 	bl	4801c880 <strncpy>
    /* release normalize directory path name */
    rt_free(fullpath);
    4801b918:	f94017e0 	ldr	x0, [sp, #40]
    4801b91c:	97ffbaaa 	bl	4800a3c4 <rt_free>

    dfs_unlock();
    4801b920:	97ffd616 	bl	48011178 <dfs_unlock>

    return 0;
    4801b924:	52800000 	mov	w0, #0x0                   	// #0
}
    4801b928:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801b92c:	d65f03c0 	ret

000000004801b930 <access>:
 * @param path the specified file/dir path.
 * @param amode the value is either the bitwise-inclusive OR of the access
 * permissions to be checked (R_OK, W_OK, X_OK) or the existence test (F_OK).
 */
int access(const char *path, int amode)
{
    4801b930:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    4801b934:	910003fd 	mov	x29, sp
    4801b938:	f9000fe0 	str	x0, [sp, #24]
    4801b93c:	b90017e1 	str	w1, [sp, #20]
    struct stat sb;
    if (stat(path, &sb) < 0)
    4801b940:	9100a3e0 	add	x0, sp, #0x28
    4801b944:	aa0003e1 	mov	x1, x0
    4801b948:	f9400fe0 	ldr	x0, [sp, #24]
    4801b94c:	97fffd76 	bl	4801af24 <stat>
    4801b950:	7100001f 	cmp	w0, #0x0
    4801b954:	5400006a 	b.ge	4801b960 <access+0x30>  // b.tcont
        return -1; /* already sets errno */
    4801b958:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801b95c:	14000002 	b	4801b964 <access+0x34>

    /* ignore R_OK,W_OK,X_OK condition */
    return 0;
    4801b960:	52800000 	mov	w0, #0x0                   	// #0
}
    4801b964:	a8c97bfd 	ldp	x29, x30, [sp], #144
    4801b968:	d65f03c0 	ret

000000004801b96c <getcwd>:
 * @param size the buffer size.
 *
 * @return the returned current directory.
 */
char *getcwd(char *buf, size_t size)
{
    4801b96c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801b970:	910003fd 	mov	x29, sp
    4801b974:	f9000fe0 	str	x0, [sp, #24]
    4801b978:	f9000be1 	str	x1, [sp, #16]
#ifdef DFS_USING_WORKDIR
    dfs_lock();
    4801b97c:	97ffd5e6 	bl	48011114 <dfs_lock>
    strncpy(buf, working_directory, size);
    4801b980:	f9400be2 	ldr	x2, [sp, #16]
    4801b984:	d0000020 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4801b988:	911a6001 	add	x1, x0, #0x698
    4801b98c:	f9400fe0 	ldr	x0, [sp, #24]
    4801b990:	940003bc 	bl	4801c880 <strncpy>
    dfs_unlock();
    4801b994:	97ffd5f9 	bl	48011178 <dfs_unlock>
#else
    rt_kprintf(NO_WORKING_DIR);
#endif

    return buf;
    4801b998:	f9400fe0 	ldr	x0, [sp, #24]
}
    4801b99c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801b9a0:	d65f03c0 	ret

000000004801b9a4 <isatty>:
    struct termios ts;
    return(tcgetattr(fd, &ts) != -1); /*true if no error (is a tty)*/
}
#else
int isatty(int fd)
{
    4801b9a4:	d10043ff 	sub	sp, sp, #0x10
    4801b9a8:	b9000fe0 	str	w0, [sp, #12]
    if (fd >=0 && fd < 3)
    4801b9ac:	b9400fe0 	ldr	w0, [sp, #12]
    4801b9b0:	7100001f 	cmp	w0, #0x0
    4801b9b4:	540000cb 	b.lt	4801b9cc <isatty+0x28>  // b.tstop
    4801b9b8:	b9400fe0 	ldr	w0, [sp, #12]
    4801b9bc:	7100081f 	cmp	w0, #0x2
    4801b9c0:	5400006c 	b.gt	4801b9cc <isatty+0x28>
    {
        return 1;
    4801b9c4:	52800020 	mov	w0, #0x1                   	// #1
    4801b9c8:	14000002 	b	4801b9d0 <isatty+0x2c>
    }
    else
    {
        return 0;
    4801b9cc:	52800000 	mov	w0, #0x0                   	// #0
    }
}
    4801b9d0:	910043ff 	add	sp, sp, #0x10
    4801b9d4:	d65f03c0 	ret

000000004801b9d8 <ttyname>:
#endif
RTM_EXPORT(isatty);

char *ttyname(int fd)
{
    4801b9d8:	d10043ff 	sub	sp, sp, #0x10
    4801b9dc:	b9000fe0 	str	w0, [sp, #12]
    return "/dev/tty"; /* TODO: need to add more specific */
    4801b9e0:	b0000020 	adrp	x0, 48020000 <__FUNCTION__.0+0x168>
    4801b9e4:	913e0000 	add	x0, x0, #0xf80
}
    4801b9e8:	910043ff 	add	sp, sp, #0x10
    4801b9ec:	d65f03c0 	ret
	...

000000004801ba00 <memcmp>:
    4801ba00:	f1002042 	subs	x2, x2, #0x8
    4801ba04:	54000663 	b.cc	4801bad0 <memcmp+0xd0>  // b.lo, b.ul, b.last
    4801ba08:	f8408403 	ldr	x3, [x0], #8
    4801ba0c:	f8408425 	ldr	x5, [x1], #8
    4801ba10:	eb05007f 	cmp	x3, x5
    4801ba14:	54000501 	b.ne	4801bab4 <memcmp+0xb4>  // b.any
    4801ba18:	f1002042 	subs	x2, x2, #0x8
    4801ba1c:	5400008c 	b.gt	4801ba2c <memcmp+0x2c>
    4801ba20:	f8626803 	ldr	x3, [x0, x2]
    4801ba24:	f8626825 	ldr	x5, [x1, x2]
    4801ba28:	14000023 	b	4801bab4 <memcmp+0xb4>
    4801ba2c:	f8408403 	ldr	x3, [x0], #8
    4801ba30:	f8408425 	ldr	x5, [x1], #8
    4801ba34:	eb05007f 	cmp	x3, x5
    4801ba38:	540003e1 	b.ne	4801bab4 <memcmp+0xb4>  // b.any
    4801ba3c:	f1004042 	subs	x2, x2, #0x10
    4801ba40:	54000289 	b.ls	4801ba90 <memcmp+0x90>  // b.plast
    4801ba44:	f101805f 	cmp	x2, #0x60
    4801ba48:	540000c9 	b.ls	4801ba60 <memcmp+0x60>  // b.plast
    4801ba4c:	92400c07 	and	x7, x0, #0xf
    4801ba50:	8b070042 	add	x2, x2, x7
    4801ba54:	cb070000 	sub	x0, x0, x7
    4801ba58:	cb070021 	sub	x1, x1, x7
    4801ba5c:	d503201f 	nop
    4801ba60:	a8c11003 	ldp	x3, x4, [x0], #16
    4801ba64:	a8c11825 	ldp	x5, x6, [x1], #16
    4801ba68:	f1004042 	subs	x2, x2, #0x10
    4801ba6c:	fa458060 	ccmp	x3, x5, #0x0, hi  // hi = pmore
    4801ba70:	fa460080 	ccmp	x4, x6, #0x0, eq  // eq = none
    4801ba74:	54ffff60 	b.eq	4801ba60 <memcmp+0x60>  // b.none
    4801ba78:	eb05007f 	cmp	x3, x5
    4801ba7c:	540001c1 	b.ne	4801bab4 <memcmp+0xb4>  // b.any
    4801ba80:	aa0403e3 	mov	x3, x4
    4801ba84:	aa0603e5 	mov	x5, x6
    4801ba88:	eb05007f 	cmp	x3, x5
    4801ba8c:	54000141 	b.ne	4801bab4 <memcmp+0xb4>  // b.any
    4801ba90:	8b020000 	add	x0, x0, x2
    4801ba94:	8b020021 	add	x1, x1, x2
    4801ba98:	a9401003 	ldp	x3, x4, [x0]
    4801ba9c:	a9401825 	ldp	x5, x6, [x1]
    4801baa0:	eb05007f 	cmp	x3, x5
    4801baa4:	54000081 	b.ne	4801bab4 <memcmp+0xb4>  // b.any
    4801baa8:	aa0403e3 	mov	x3, x4
    4801baac:	aa0603e5 	mov	x5, x6
    4801bab0:	eb05007f 	cmp	x3, x5
    4801bab4:	dac00c63 	rev	x3, x3
    4801bab8:	dac00ca5 	rev	x5, x5
    4801babc:	eb05007f 	cmp	x3, x5
    4801bac0:	1a9f07e0 	cset	w0, ne  // ne = any
    4801bac4:	5a802400 	cneg	w0, w0, cc  // cc = lo, ul, last
    4801bac8:	d65f03c0 	ret
    4801bacc:	d503201f 	nop
    4801bad0:	b1001042 	adds	x2, x2, #0x4
    4801bad4:	540000c3 	b.cc	4801baec <memcmp+0xec>  // b.lo, b.ul, b.last
    4801bad8:	b8404403 	ldr	w3, [x0], #4
    4801badc:	b8404425 	ldr	w5, [x1], #4
    4801bae0:	6b05007f 	cmp	w3, w5
    4801bae4:	54fffe81 	b.ne	4801bab4 <memcmp+0xb4>  // b.any
    4801bae8:	d1001042 	sub	x2, x2, #0x4
    4801baec:	b1001042 	adds	x2, x2, #0x4
    4801baf0:	54fffe80 	b.eq	4801bac0 <memcmp+0xc0>  // b.none
    4801baf4:	38401403 	ldrb	w3, [x0], #1
    4801baf8:	38401425 	ldrb	w5, [x1], #1
    4801bafc:	f1000442 	subs	x2, x2, #0x1
    4801bb00:	7a451060 	ccmp	w3, w5, #0x0, ne  // ne = any
    4801bb04:	54ffff80 	b.eq	4801baf4 <memcmp+0xf4>  // b.none
    4801bb08:	4b050060 	sub	w0, w3, w5
    4801bb0c:	d65f03c0 	ret
	...

000000004801bb40 <memcpy>:
    4801bb40:	f9800020 	prfm	pldl1keep, [x1]
    4801bb44:	8b020024 	add	x4, x1, x2
    4801bb48:	8b020005 	add	x5, x0, x2
    4801bb4c:	f100405f 	cmp	x2, #0x10
    4801bb50:	54000209 	b.ls	4801bb90 <memcpy+0x50>  // b.plast
    4801bb54:	f101805f 	cmp	x2, #0x60
    4801bb58:	54000648 	b.hi	4801bc20 <memcpy+0xe0>  // b.pmore
    4801bb5c:	d1000449 	sub	x9, x2, #0x1
    4801bb60:	a9401c26 	ldp	x6, x7, [x1]
    4801bb64:	37300469 	tbnz	w9, #6, 4801bbf0 <memcpy+0xb0>
    4801bb68:	a97f348c 	ldp	x12, x13, [x4, #-16]
    4801bb6c:	362800a9 	tbz	w9, #5, 4801bb80 <memcpy+0x40>
    4801bb70:	a9412428 	ldp	x8, x9, [x1, #16]
    4801bb74:	a97e2c8a 	ldp	x10, x11, [x4, #-32]
    4801bb78:	a9012408 	stp	x8, x9, [x0, #16]
    4801bb7c:	a93e2caa 	stp	x10, x11, [x5, #-32]
    4801bb80:	a9001c06 	stp	x6, x7, [x0]
    4801bb84:	a93f34ac 	stp	x12, x13, [x5, #-16]
    4801bb88:	d65f03c0 	ret
    4801bb8c:	d503201f 	nop
    4801bb90:	f100205f 	cmp	x2, #0x8
    4801bb94:	540000e3 	b.cc	4801bbb0 <memcpy+0x70>  // b.lo, b.ul, b.last
    4801bb98:	f9400026 	ldr	x6, [x1]
    4801bb9c:	f85f8087 	ldur	x7, [x4, #-8]
    4801bba0:	f9000006 	str	x6, [x0]
    4801bba4:	f81f80a7 	stur	x7, [x5, #-8]
    4801bba8:	d65f03c0 	ret
    4801bbac:	d503201f 	nop
    4801bbb0:	361000c2 	tbz	w2, #2, 4801bbc8 <memcpy+0x88>
    4801bbb4:	b9400026 	ldr	w6, [x1]
    4801bbb8:	b85fc087 	ldur	w7, [x4, #-4]
    4801bbbc:	b9000006 	str	w6, [x0]
    4801bbc0:	b81fc0a7 	stur	w7, [x5, #-4]
    4801bbc4:	d65f03c0 	ret
    4801bbc8:	b4000102 	cbz	x2, 4801bbe8 <memcpy+0xa8>
    4801bbcc:	d341fc49 	lsr	x9, x2, #1
    4801bbd0:	39400026 	ldrb	w6, [x1]
    4801bbd4:	385ff087 	ldurb	w7, [x4, #-1]
    4801bbd8:	38696828 	ldrb	w8, [x1, x9]
    4801bbdc:	39000006 	strb	w6, [x0]
    4801bbe0:	38296808 	strb	w8, [x0, x9]
    4801bbe4:	381ff0a7 	sturb	w7, [x5, #-1]
    4801bbe8:	d65f03c0 	ret
    4801bbec:	d503201f 	nop
    4801bbf0:	a9412428 	ldp	x8, x9, [x1, #16]
    4801bbf4:	a9422c2a 	ldp	x10, x11, [x1, #32]
    4801bbf8:	a943342c 	ldp	x12, x13, [x1, #48]
    4801bbfc:	a97e0881 	ldp	x1, x2, [x4, #-32]
    4801bc00:	a97f0c84 	ldp	x4, x3, [x4, #-16]
    4801bc04:	a9001c06 	stp	x6, x7, [x0]
    4801bc08:	a9012408 	stp	x8, x9, [x0, #16]
    4801bc0c:	a9022c0a 	stp	x10, x11, [x0, #32]
    4801bc10:	a903340c 	stp	x12, x13, [x0, #48]
    4801bc14:	a93e08a1 	stp	x1, x2, [x5, #-32]
    4801bc18:	a93f0ca4 	stp	x4, x3, [x5, #-16]
    4801bc1c:	d65f03c0 	ret
    4801bc20:	92400c09 	and	x9, x0, #0xf
    4801bc24:	927cec03 	and	x3, x0, #0xfffffffffffffff0
    4801bc28:	a940342c 	ldp	x12, x13, [x1]
    4801bc2c:	cb090021 	sub	x1, x1, x9
    4801bc30:	8b090042 	add	x2, x2, x9
    4801bc34:	a9411c26 	ldp	x6, x7, [x1, #16]
    4801bc38:	a900340c 	stp	x12, x13, [x0]
    4801bc3c:	a9422428 	ldp	x8, x9, [x1, #32]
    4801bc40:	a9432c2a 	ldp	x10, x11, [x1, #48]
    4801bc44:	a9c4342c 	ldp	x12, x13, [x1, #64]!
    4801bc48:	f1024042 	subs	x2, x2, #0x90
    4801bc4c:	54000169 	b.ls	4801bc78 <memcpy+0x138>  // b.plast
    4801bc50:	a9011c66 	stp	x6, x7, [x3, #16]
    4801bc54:	a9411c26 	ldp	x6, x7, [x1, #16]
    4801bc58:	a9022468 	stp	x8, x9, [x3, #32]
    4801bc5c:	a9422428 	ldp	x8, x9, [x1, #32]
    4801bc60:	a9032c6a 	stp	x10, x11, [x3, #48]
    4801bc64:	a9432c2a 	ldp	x10, x11, [x1, #48]
    4801bc68:	a984346c 	stp	x12, x13, [x3, #64]!
    4801bc6c:	a9c4342c 	ldp	x12, x13, [x1, #64]!
    4801bc70:	f1010042 	subs	x2, x2, #0x40
    4801bc74:	54fffee8 	b.hi	4801bc50 <memcpy+0x110>  // b.pmore
    4801bc78:	a97c0881 	ldp	x1, x2, [x4, #-64]
    4801bc7c:	a9011c66 	stp	x6, x7, [x3, #16]
    4801bc80:	a97d1c86 	ldp	x6, x7, [x4, #-48]
    4801bc84:	a9022468 	stp	x8, x9, [x3, #32]
    4801bc88:	a97e2488 	ldp	x8, x9, [x4, #-32]
    4801bc8c:	a9032c6a 	stp	x10, x11, [x3, #48]
    4801bc90:	a97f2c8a 	ldp	x10, x11, [x4, #-16]
    4801bc94:	a904346c 	stp	x12, x13, [x3, #64]
    4801bc98:	a93c08a1 	stp	x1, x2, [x5, #-64]
    4801bc9c:	a93d1ca6 	stp	x6, x7, [x5, #-48]
    4801bca0:	a93e24a8 	stp	x8, x9, [x5, #-32]
    4801bca4:	a93f2caa 	stp	x10, x11, [x5, #-16]
    4801bca8:	d65f03c0 	ret
	...

000000004801bcc0 <memset>:
    4801bcc0:	4e010c20 	dup	v0.16b, w1
    4801bcc4:	8b020004 	add	x4, x0, x2
    4801bcc8:	f101805f 	cmp	x2, #0x60
    4801bccc:	540003c8 	b.hi	4801bd44 <memset+0x84>  // b.pmore
    4801bcd0:	f100405f 	cmp	x2, #0x10
    4801bcd4:	54000202 	b.cs	4801bd14 <memset+0x54>  // b.hs, b.nlast
    4801bcd8:	4e083c01 	mov	x1, v0.d[0]
    4801bcdc:	361800a2 	tbz	w2, #3, 4801bcf0 <memset+0x30>
    4801bce0:	f9000001 	str	x1, [x0]
    4801bce4:	f81f8081 	stur	x1, [x4, #-8]
    4801bce8:	d65f03c0 	ret
    4801bcec:	d503201f 	nop
    4801bcf0:	36100082 	tbz	w2, #2, 4801bd00 <memset+0x40>
    4801bcf4:	b9000001 	str	w1, [x0]
    4801bcf8:	b81fc081 	stur	w1, [x4, #-4]
    4801bcfc:	d65f03c0 	ret
    4801bd00:	b4000082 	cbz	x2, 4801bd10 <memset+0x50>
    4801bd04:	39000001 	strb	w1, [x0]
    4801bd08:	36080042 	tbz	w2, #1, 4801bd10 <memset+0x50>
    4801bd0c:	781fe081 	sturh	w1, [x4, #-2]
    4801bd10:	d65f03c0 	ret
    4801bd14:	3d800000 	str	q0, [x0]
    4801bd18:	373000c2 	tbnz	w2, #6, 4801bd30 <memset+0x70>
    4801bd1c:	3c9f0080 	stur	q0, [x4, #-16]
    4801bd20:	36280062 	tbz	w2, #5, 4801bd2c <memset+0x6c>
    4801bd24:	3d800400 	str	q0, [x0, #16]
    4801bd28:	3c9e0080 	stur	q0, [x4, #-32]
    4801bd2c:	d65f03c0 	ret
    4801bd30:	3d800400 	str	q0, [x0, #16]
    4801bd34:	ad010000 	stp	q0, q0, [x0, #32]
    4801bd38:	ad3f0080 	stp	q0, q0, [x4, #-32]
    4801bd3c:	d65f03c0 	ret
    4801bd40:	d503201f 	nop
    4801bd44:	12001c21 	and	w1, w1, #0xff
    4801bd48:	927cec03 	and	x3, x0, #0xfffffffffffffff0
    4801bd4c:	3d800000 	str	q0, [x0]
    4801bd50:	f104005f 	cmp	x2, #0x100
    4801bd54:	7a402820 	ccmp	w1, #0x0, #0x0, cs  // cs = hs, nlast
    4801bd58:	54000180 	b.eq	4801bd88 <memset+0xc8>  // b.none
    4801bd5c:	cb030082 	sub	x2, x4, x3
    4801bd60:	d1004063 	sub	x3, x3, #0x10
    4801bd64:	d1014042 	sub	x2, x2, #0x50
    4801bd68:	ad010060 	stp	q0, q0, [x3, #32]
    4801bd6c:	ad820060 	stp	q0, q0, [x3, #64]!
    4801bd70:	f1010042 	subs	x2, x2, #0x40
    4801bd74:	54ffffa8 	b.hi	4801bd68 <memset+0xa8>  // b.pmore
    4801bd78:	ad3e0080 	stp	q0, q0, [x4, #-64]
    4801bd7c:	ad3f0080 	stp	q0, q0, [x4, #-32]
    4801bd80:	d65f03c0 	ret
    4801bd84:	d503201f 	nop
    4801bd88:	d53b00e5 	mrs	x5, dczid_el0
    4801bd8c:	3727fe85 	tbnz	w5, #4, 4801bd5c <memset+0x9c>
    4801bd90:	12000ca5 	and	w5, w5, #0xf
    4801bd94:	710010bf 	cmp	w5, #0x4
    4801bd98:	54000281 	b.ne	4801bde8 <memset+0x128>  // b.any
    4801bd9c:	3d800460 	str	q0, [x3, #16]
    4801bda0:	ad010060 	stp	q0, q0, [x3, #32]
    4801bda4:	927ae463 	and	x3, x3, #0xffffffffffffffc0
    4801bda8:	ad020060 	stp	q0, q0, [x3, #64]
    4801bdac:	ad030060 	stp	q0, q0, [x3, #96]
    4801bdb0:	cb030082 	sub	x2, x4, x3
    4801bdb4:	d1040042 	sub	x2, x2, #0x100
    4801bdb8:	91020063 	add	x3, x3, #0x80
    4801bdbc:	d503201f 	nop
    4801bdc0:	d50b7423 	dc	zva, x3
    4801bdc4:	91010063 	add	x3, x3, #0x40
    4801bdc8:	f1010042 	subs	x2, x2, #0x40
    4801bdcc:	54ffffa8 	b.hi	4801bdc0 <memset+0x100>  // b.pmore
    4801bdd0:	ad000060 	stp	q0, q0, [x3]
    4801bdd4:	ad010060 	stp	q0, q0, [x3, #32]
    4801bdd8:	ad3e0080 	stp	q0, q0, [x4, #-64]
    4801bddc:	ad3f0080 	stp	q0, q0, [x4, #-32]
    4801bde0:	d65f03c0 	ret
    4801bde4:	d503201f 	nop
    4801bde8:	710014bf 	cmp	w5, #0x5
    4801bdec:	54000241 	b.ne	4801be34 <memset+0x174>  // b.any
    4801bdf0:	3d800460 	str	q0, [x3, #16]
    4801bdf4:	ad010060 	stp	q0, q0, [x3, #32]
    4801bdf8:	ad020060 	stp	q0, q0, [x3, #64]
    4801bdfc:	ad030060 	stp	q0, q0, [x3, #96]
    4801be00:	9279e063 	and	x3, x3, #0xffffffffffffff80
    4801be04:	cb030082 	sub	x2, x4, x3
    4801be08:	d1040042 	sub	x2, x2, #0x100
    4801be0c:	91020063 	add	x3, x3, #0x80
    4801be10:	d50b7423 	dc	zva, x3
    4801be14:	91020063 	add	x3, x3, #0x80
    4801be18:	f1020042 	subs	x2, x2, #0x80
    4801be1c:	54ffffa8 	b.hi	4801be10 <memset+0x150>  // b.pmore
    4801be20:	ad3c0080 	stp	q0, q0, [x4, #-128]
    4801be24:	ad3d0080 	stp	q0, q0, [x4, #-96]
    4801be28:	ad3e0080 	stp	q0, q0, [x4, #-64]
    4801be2c:	ad3f0080 	stp	q0, q0, [x4, #-32]
    4801be30:	d65f03c0 	ret
    4801be34:	52800086 	mov	w6, #0x4                   	// #4
    4801be38:	1ac520c7 	lsl	w7, w6, w5
    4801be3c:	910100e5 	add	x5, x7, #0x40
    4801be40:	eb05005f 	cmp	x2, x5
    4801be44:	54fff8c3 	b.cc	4801bd5c <memset+0x9c>  // b.lo, b.ul, b.last
    4801be48:	d10004e6 	sub	x6, x7, #0x1
    4801be4c:	8b070065 	add	x5, x3, x7
    4801be50:	91004063 	add	x3, x3, #0x10
    4801be54:	eb0300a2 	subs	x2, x5, x3
    4801be58:	8a2600a5 	bic	x5, x5, x6
    4801be5c:	540000a0 	b.eq	4801be70 <memset+0x1b0>  // b.none
    4801be60:	ac820060 	stp	q0, q0, [x3], #64
    4801be64:	ad3f0060 	stp	q0, q0, [x3, #-32]
    4801be68:	f1010042 	subs	x2, x2, #0x40
    4801be6c:	54ffffa8 	b.hi	4801be60 <memset+0x1a0>  // b.pmore
    4801be70:	aa0503e3 	mov	x3, x5
    4801be74:	cb050082 	sub	x2, x4, x5
    4801be78:	eb070042 	subs	x2, x2, x7
    4801be7c:	540000a3 	b.cc	4801be90 <memset+0x1d0>  // b.lo, b.ul, b.last
    4801be80:	d50b7423 	dc	zva, x3
    4801be84:	8b070063 	add	x3, x3, x7
    4801be88:	eb070042 	subs	x2, x2, x7
    4801be8c:	54ffffa2 	b.cs	4801be80 <memset+0x1c0>  // b.hs, b.nlast
    4801be90:	8b070042 	add	x2, x2, x7
    4801be94:	d1008063 	sub	x3, x3, #0x20
    4801be98:	17ffffb6 	b	4801bd70 <memset+0xb0>
	...

000000004801bec0 <strcmp>:
    4801bec0:	ca010007 	eor	x7, x0, x1
    4801bec4:	b200c3ea 	mov	x10, #0x101010101010101     	// #72340172838076673
    4801bec8:	f24008ff 	tst	x7, #0x7
    4801becc:	540003e1 	b.ne	4801bf48 <strcmp+0x88>  // b.any
    4801bed0:	f2400807 	ands	x7, x0, #0x7
    4801bed4:	54000241 	b.ne	4801bf1c <strcmp+0x5c>  // b.any
    4801bed8:	f8408402 	ldr	x2, [x0], #8
    4801bedc:	f8408423 	ldr	x3, [x1], #8
    4801bee0:	cb0a0047 	sub	x7, x2, x10
    4801bee4:	b200d848 	orr	x8, x2, #0x7f7f7f7f7f7f7f7f
    4801bee8:	ca030045 	eor	x5, x2, x3
    4801beec:	8a2800e4 	bic	x4, x7, x8
    4801bef0:	aa0400a6 	orr	x6, x5, x4
    4801bef4:	b4ffff26 	cbz	x6, 4801bed8 <strcmp+0x18>
    4801bef8:	dac00cc6 	rev	x6, x6
    4801befc:	dac00c42 	rev	x2, x2
    4801bf00:	dac010cb 	clz	x11, x6
    4801bf04:	dac00c63 	rev	x3, x3
    4801bf08:	9acb2042 	lsl	x2, x2, x11
    4801bf0c:	9acb2063 	lsl	x3, x3, x11
    4801bf10:	d378fc42 	lsr	x2, x2, #56
    4801bf14:	cb43e040 	sub	x0, x2, x3, lsr #56
    4801bf18:	d65f03c0 	ret
    4801bf1c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    4801bf20:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4801bf24:	d37df0e7 	lsl	x7, x7, #3
    4801bf28:	f8408402 	ldr	x2, [x0], #8
    4801bf2c:	cb0703e7 	neg	x7, x7
    4801bf30:	f8408423 	ldr	x3, [x1], #8
    4801bf34:	92800008 	mov	x8, #0xffffffffffffffff    	// #-1
    4801bf38:	9ac72508 	lsr	x8, x8, x7
    4801bf3c:	aa080042 	orr	x2, x2, x8
    4801bf40:	aa080063 	orr	x3, x3, x8
    4801bf44:	17ffffe7 	b	4801bee0 <strcmp+0x20>
    4801bf48:	f240081f 	tst	x0, #0x7
    4801bf4c:	54000100 	b.eq	4801bf6c <strcmp+0xac>  // b.none
    4801bf50:	38401402 	ldrb	w2, [x0], #1
    4801bf54:	38401423 	ldrb	w3, [x1], #1
    4801bf58:	7100045f 	cmp	w2, #0x1
    4801bf5c:	7a432040 	ccmp	w2, w3, #0x0, cs  // cs = hs, nlast
    4801bf60:	540001e1 	b.ne	4801bf9c <strcmp+0xdc>  // b.any
    4801bf64:	f240081f 	tst	x0, #0x7
    4801bf68:	54ffff41 	b.ne	4801bf50 <strcmp+0x90>  // b.any
    4801bf6c:	927d2027 	and	x7, x1, #0xff8
    4801bf70:	d27d20e7 	eor	x7, x7, #0xff8
    4801bf74:	b4fffee7 	cbz	x7, 4801bf50 <strcmp+0x90>
    4801bf78:	f8408402 	ldr	x2, [x0], #8
    4801bf7c:	f8408423 	ldr	x3, [x1], #8
    4801bf80:	cb0a0047 	sub	x7, x2, x10
    4801bf84:	b200d848 	orr	x8, x2, #0x7f7f7f7f7f7f7f7f
    4801bf88:	ca030045 	eor	x5, x2, x3
    4801bf8c:	8a2800e4 	bic	x4, x7, x8
    4801bf90:	aa0400a6 	orr	x6, x5, x4
    4801bf94:	b4fffec6 	cbz	x6, 4801bf6c <strcmp+0xac>
    4801bf98:	17ffffd8 	b	4801bef8 <strcmp+0x38>
    4801bf9c:	cb030040 	sub	x0, x2, x3
    4801bfa0:	d65f03c0 	ret
	...

000000004801bfc0 <strcpy>:
    4801bfc0:	92402c29 	and	x9, x1, #0xfff
    4801bfc4:	b200c3ec 	mov	x12, #0x101010101010101     	// #72340172838076673
    4801bfc8:	92400c31 	and	x17, x1, #0xf
    4801bfcc:	f13fc13f 	cmp	x9, #0xff0
    4801bfd0:	cb1103e8 	neg	x8, x17
    4801bfd4:	540008cc 	b.gt	4801c0ec <strcpy+0x12c>
    4801bfd8:	a9401424 	ldp	x4, x5, [x1]
    4801bfdc:	cb0c0088 	sub	x8, x4, x12
    4801bfe0:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
    4801bfe4:	ea290106 	bics	x6, x8, x9
    4801bfe8:	540001c1 	b.ne	4801c020 <strcpy+0x60>  // b.any
    4801bfec:	cb0c00aa 	sub	x10, x5, x12
    4801bff0:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
    4801bff4:	ea2b0147 	bics	x7, x10, x11
    4801bff8:	54000440 	b.eq	4801c080 <strcpy+0xc0>  // b.none
    4801bffc:	dac00ce7 	rev	x7, x7
    4801c000:	dac010ef 	clz	x15, x7
    4801c004:	d2800709 	mov	x9, #0x38                  	// #56
    4801c008:	8b4f0c03 	add	x3, x0, x15, lsr #3
    4801c00c:	cb0f012f 	sub	x15, x9, x15
    4801c010:	9acf20a5 	lsl	x5, x5, x15
    4801c014:	f8001065 	stur	x5, [x3, #1]
    4801c018:	f9000004 	str	x4, [x0]
    4801c01c:	d65f03c0 	ret
    4801c020:	dac00cc6 	rev	x6, x6
    4801c024:	dac010cf 	clz	x15, x6
    4801c028:	8b4f0c03 	add	x3, x0, x15, lsr #3
    4801c02c:	f10061e9 	subs	x9, x15, #0x18
    4801c030:	540000ab 	b.lt	4801c044 <strcpy+0x84>  // b.tstop
    4801c034:	9ac92485 	lsr	x5, x4, x9
    4801c038:	b81fd065 	stur	w5, [x3, #-3]
    4801c03c:	b9000004 	str	w4, [x0]
    4801c040:	d65f03c0 	ret
    4801c044:	b400004f 	cbz	x15, 4801c04c <strcpy+0x8c>
    4801c048:	79000004 	strh	w4, [x0]
    4801c04c:	3900007f 	strb	wzr, [x3]
    4801c050:	d65f03c0 	ret
    4801c054:	d503201f 	nop
    4801c058:	d503201f 	nop
    4801c05c:	d503201f 	nop
    4801c060:	d503201f 	nop
    4801c064:	d503201f 	nop
    4801c068:	d503201f 	nop
    4801c06c:	d503201f 	nop
    4801c070:	d503201f 	nop
    4801c074:	d503201f 	nop
    4801c078:	d503201f 	nop
    4801c07c:	d503201f 	nop
    4801c080:	d1004231 	sub	x17, x17, #0x10
    4801c084:	a9001404 	stp	x4, x5, [x0]
    4801c088:	cb110022 	sub	x2, x1, x17
    4801c08c:	cb110003 	sub	x3, x0, x17
    4801c090:	14000002 	b	4801c098 <strcpy+0xd8>
    4801c094:	a8811464 	stp	x4, x5, [x3], #16
    4801c098:	a8c11444 	ldp	x4, x5, [x2], #16
    4801c09c:	cb0c0088 	sub	x8, x4, x12
    4801c0a0:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
    4801c0a4:	cb0c00aa 	sub	x10, x5, x12
    4801c0a8:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
    4801c0ac:	8a290106 	bic	x6, x8, x9
    4801c0b0:	ea2b0147 	bics	x7, x10, x11
    4801c0b4:	fa4008c0 	ccmp	x6, #0x0, #0x0, eq  // eq = none
    4801c0b8:	54fffee0 	b.eq	4801c094 <strcpy+0xd4>  // b.none
    4801c0bc:	f10000df 	cmp	x6, #0x0
    4801c0c0:	9a8710c6 	csel	x6, x6, x7, ne  // ne = any
    4801c0c4:	dac00cc6 	rev	x6, x6
    4801c0c8:	dac010cf 	clz	x15, x6
    4801c0cc:	910121e8 	add	x8, x15, #0x48
    4801c0d0:	910021ef 	add	x15, x15, #0x8
    4801c0d4:	9a8811ef 	csel	x15, x15, x8, ne  // ne = any
    4801c0d8:	8b4f0c42 	add	x2, x2, x15, lsr #3
    4801c0dc:	8b4f0c63 	add	x3, x3, x15, lsr #3
    4801c0e0:	a97e1444 	ldp	x4, x5, [x2, #-32]
    4801c0e4:	a93f1464 	stp	x4, x5, [x3, #-16]
    4801c0e8:	d65f03c0 	ret
    4801c0ec:	927cec22 	and	x2, x1, #0xfffffffffffffff0
    4801c0f0:	a9401444 	ldp	x4, x5, [x2]
    4801c0f4:	d37df108 	lsl	x8, x8, #3
    4801c0f8:	f2400a3f 	tst	x17, #0x7
    4801c0fc:	da9f03e9 	csetm	x9, ne  // ne = any
    4801c100:	9ac82529 	lsr	x9, x9, x8
    4801c104:	aa090084 	orr	x4, x4, x9
    4801c108:	aa0900ae 	orr	x14, x5, x9
    4801c10c:	f100223f 	cmp	x17, #0x8
    4801c110:	da9fb084 	csinv	x4, x4, xzr, lt  // lt = tstop
    4801c114:	9a8eb0a5 	csel	x5, x5, x14, lt  // lt = tstop
    4801c118:	cb0c0088 	sub	x8, x4, x12
    4801c11c:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
    4801c120:	cb0c00aa 	sub	x10, x5, x12
    4801c124:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
    4801c128:	8a290106 	bic	x6, x8, x9
    4801c12c:	ea2b0147 	bics	x7, x10, x11
    4801c130:	fa4008c0 	ccmp	x6, #0x0, #0x0, eq  // eq = none
    4801c134:	54fff520 	b.eq	4801bfd8 <strcpy+0x18>  // b.none
    4801c138:	d37df228 	lsl	x8, x17, #3
    4801c13c:	cb110fe9 	neg	x9, x17, lsl #3
    4801c140:	9ac8248d 	lsr	x13, x4, x8
    4801c144:	9ac920ab 	lsl	x11, x5, x9
    4801c148:	9ac824a5 	lsr	x5, x5, x8
    4801c14c:	aa0d016b 	orr	x11, x11, x13
    4801c150:	f100223f 	cmp	x17, #0x8
    4801c154:	9a85b164 	csel	x4, x11, x5, lt  // lt = tstop
    4801c158:	cb0c0088 	sub	x8, x4, x12
    4801c15c:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
    4801c160:	cb0c00aa 	sub	x10, x5, x12
    4801c164:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
    4801c168:	8a290106 	bic	x6, x8, x9
    4801c16c:	b5fff5a6 	cbnz	x6, 4801c020 <strcpy+0x60>
    4801c170:	8a2b0147 	bic	x7, x10, x11
    4801c174:	17ffffa2 	b	4801bffc <strcpy+0x3c>
	...

000000004801c180 <strlen>:
    4801c180:	92402c04 	and	x4, x0, #0xfff
    4801c184:	b200c3e8 	mov	x8, #0x101010101010101     	// #72340172838076673
    4801c188:	f13fc09f 	cmp	x4, #0xff0
    4801c18c:	5400082c 	b.gt	4801c290 <strlen+0x110>
    4801c190:	a9400c02 	ldp	x2, x3, [x0]
    4801c194:	cb080044 	sub	x4, x2, x8
    4801c198:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
    4801c19c:	cb080066 	sub	x6, x3, x8
    4801c1a0:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
    4801c1a4:	ea250084 	bics	x4, x4, x5
    4801c1a8:	8a2700c5 	bic	x5, x6, x7
    4801c1ac:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
    4801c1b0:	54000100 	b.eq	4801c1d0 <strlen+0x50>  // b.none
    4801c1b4:	9a853084 	csel	x4, x4, x5, cc  // cc = lo, ul, last
    4801c1b8:	d2800100 	mov	x0, #0x8                   	// #8
    4801c1bc:	dac00c84 	rev	x4, x4
    4801c1c0:	dac01084 	clz	x4, x4
    4801c1c4:	9a8033e0 	csel	x0, xzr, x0, cc  // cc = lo, ul, last
    4801c1c8:	8b440c00 	add	x0, x0, x4, lsr #3
    4801c1cc:	d65f03c0 	ret
    4801c1d0:	927cec01 	and	x1, x0, #0xfffffffffffffff0
    4801c1d4:	d1004021 	sub	x1, x1, #0x10
    4801c1d8:	a9c20c22 	ldp	x2, x3, [x1, #32]!
    4801c1dc:	cb080044 	sub	x4, x2, x8
    4801c1e0:	cb080066 	sub	x6, x3, x8
    4801c1e4:	aa060085 	orr	x5, x4, x6
    4801c1e8:	ea081cbf 	tst	x5, x8, lsl #7
    4801c1ec:	54000101 	b.ne	4801c20c <strlen+0x8c>  // b.any
    4801c1f0:	a9410c22 	ldp	x2, x3, [x1, #16]
    4801c1f4:	cb080044 	sub	x4, x2, x8
    4801c1f8:	cb080066 	sub	x6, x3, x8
    4801c1fc:	aa060085 	orr	x5, x4, x6
    4801c200:	ea081cbf 	tst	x5, x8, lsl #7
    4801c204:	54fffea0 	b.eq	4801c1d8 <strlen+0x58>  // b.none
    4801c208:	91004021 	add	x1, x1, #0x10
    4801c20c:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
    4801c210:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
    4801c214:	ea250084 	bics	x4, x4, x5
    4801c218:	8a2700c5 	bic	x5, x6, x7
    4801c21c:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
    4801c220:	54000120 	b.eq	4801c244 <strlen+0xc4>  // b.none
    4801c224:	9a853084 	csel	x4, x4, x5, cc  // cc = lo, ul, last
    4801c228:	cb000020 	sub	x0, x1, x0
    4801c22c:	dac00c84 	rev	x4, x4
    4801c230:	91002005 	add	x5, x0, #0x8
    4801c234:	dac01084 	clz	x4, x4
    4801c238:	9a853000 	csel	x0, x0, x5, cc  // cc = lo, ul, last
    4801c23c:	8b440c00 	add	x0, x0, x4, lsr #3
    4801c240:	d65f03c0 	ret
    4801c244:	a9c10c22 	ldp	x2, x3, [x1, #16]!
    4801c248:	cb080044 	sub	x4, x2, x8
    4801c24c:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
    4801c250:	cb080066 	sub	x6, x3, x8
    4801c254:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
    4801c258:	ea250084 	bics	x4, x4, x5
    4801c25c:	8a2700c5 	bic	x5, x6, x7
    4801c260:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
    4801c264:	54fffe01 	b.ne	4801c224 <strlen+0xa4>  // b.any
    4801c268:	a9c10c22 	ldp	x2, x3, [x1, #16]!
    4801c26c:	cb080044 	sub	x4, x2, x8
    4801c270:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
    4801c274:	cb080066 	sub	x6, x3, x8
    4801c278:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
    4801c27c:	ea250084 	bics	x4, x4, x5
    4801c280:	8a2700c5 	bic	x5, x6, x7
    4801c284:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
    4801c288:	54fffde0 	b.eq	4801c244 <strlen+0xc4>  // b.none
    4801c28c:	17ffffe6 	b	4801c224 <strlen+0xa4>
    4801c290:	927cec01 	and	x1, x0, #0xfffffffffffffff0
    4801c294:	a9400c22 	ldp	x2, x3, [x1]
    4801c298:	d37df004 	lsl	x4, x0, #3
    4801c29c:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
    4801c2a0:	9ac420e4 	lsl	x4, x7, x4
    4801c2a4:	b201c084 	orr	x4, x4, #0x8080808080808080
    4801c2a8:	aa240042 	orn	x2, x2, x4
    4801c2ac:	aa240065 	orn	x5, x3, x4
    4801c2b0:	f27d001f 	tst	x0, #0x8
    4801c2b4:	9a870042 	csel	x2, x2, x7, eq  // eq = none
    4801c2b8:	9a850063 	csel	x3, x3, x5, eq  // eq = none
    4801c2bc:	17ffffc8 	b	4801c1dc <strlen+0x5c>
    4801c2c0:	d503201f 	nop
    4801c2c4:	d503201f 	nop
    4801c2c8:	d503201f 	nop
    4801c2cc:	d503201f 	nop
    4801c2d0:	d503201f 	nop
    4801c2d4:	d503201f 	nop
    4801c2d8:	d503201f 	nop

000000004801c2dc <strncmp>:
    4801c2dc:	b4000d82 	cbz	x2, 4801c48c <strncmp+0x1b0>
    4801c2e0:	ca010008 	eor	x8, x0, x1
    4801c2e4:	b200c3eb 	mov	x11, #0x101010101010101     	// #72340172838076673
    4801c2e8:	f240091f 	tst	x8, #0x7
    4801c2ec:	9240080e 	and	x14, x0, #0x7
    4801c2f0:	54000681 	b.ne	4801c3c0 <strncmp+0xe4>  // b.any
    4801c2f4:	b500040e 	cbnz	x14, 4801c374 <strncmp+0x98>
    4801c2f8:	d100044d 	sub	x13, x2, #0x1
    4801c2fc:	d343fdad 	lsr	x13, x13, #3
    4801c300:	f8408403 	ldr	x3, [x0], #8
    4801c304:	f8408424 	ldr	x4, [x1], #8
    4801c308:	f10005ad 	subs	x13, x13, #0x1
    4801c30c:	cb0b0068 	sub	x8, x3, x11
    4801c310:	b200d869 	orr	x9, x3, #0x7f7f7f7f7f7f7f7f
    4801c314:	ca040066 	eor	x6, x3, x4
    4801c318:	da9f50cf 	csinv	x15, x6, xzr, pl  // pl = nfrst
    4801c31c:	ea290105 	bics	x5, x8, x9
    4801c320:	fa4009e0 	ccmp	x15, #0x0, #0x0, eq  // eq = none
    4801c324:	54fffee0 	b.eq	4801c300 <strncmp+0x24>  // b.none
    4801c328:	b6f8012d 	tbz	x13, #63, 4801c34c <strncmp+0x70>
    4801c32c:	f2400842 	ands	x2, x2, #0x7
    4801c330:	540000e0 	b.eq	4801c34c <strncmp+0x70>  // b.none
    4801c334:	d37df042 	lsl	x2, x2, #3
    4801c338:	9280000e 	mov	x14, #0xffffffffffffffff    	// #-1
    4801c33c:	9ac221ce 	lsl	x14, x14, x2
    4801c340:	8a2e0063 	bic	x3, x3, x14
    4801c344:	8a2e0084 	bic	x4, x4, x14
    4801c348:	aa0e00a5 	orr	x5, x5, x14
    4801c34c:	aa0500c7 	orr	x7, x6, x5
    4801c350:	dac00ce7 	rev	x7, x7
    4801c354:	dac00c63 	rev	x3, x3
    4801c358:	dac010ec 	clz	x12, x7
    4801c35c:	dac00c84 	rev	x4, x4
    4801c360:	9acc2063 	lsl	x3, x3, x12
    4801c364:	9acc2084 	lsl	x4, x4, x12
    4801c368:	d378fc63 	lsr	x3, x3, #56
    4801c36c:	cb44e060 	sub	x0, x3, x4, lsr #56
    4801c370:	d65f03c0 	ret
    4801c374:	927df000 	and	x0, x0, #0xfffffffffffffff8
    4801c378:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4801c37c:	f8408403 	ldr	x3, [x0], #8
    4801c380:	cb0e0fea 	neg	x10, x14, lsl #3
    4801c384:	f8408424 	ldr	x4, [x1], #8
    4801c388:	92800009 	mov	x9, #0xffffffffffffffff    	// #-1
    4801c38c:	d100044d 	sub	x13, x2, #0x1
    4801c390:	9aca2529 	lsr	x9, x9, x10
    4801c394:	924009aa 	and	x10, x13, #0x7
    4801c398:	d343fdad 	lsr	x13, x13, #3
    4801c39c:	8b0e0042 	add	x2, x2, x14
    4801c3a0:	8b0e014a 	add	x10, x10, x14
    4801c3a4:	aa090063 	orr	x3, x3, x9
    4801c3a8:	aa090084 	orr	x4, x4, x9
    4801c3ac:	8b4a0dad 	add	x13, x13, x10, lsr #3
    4801c3b0:	17ffffd6 	b	4801c308 <strncmp+0x2c>
    4801c3b4:	d503201f 	nop
    4801c3b8:	d503201f 	nop
    4801c3bc:	d503201f 	nop
    4801c3c0:	f100405f 	cmp	x2, #0x10
    4801c3c4:	54000122 	b.cs	4801c3e8 <strncmp+0x10c>  // b.hs, b.nlast
    4801c3c8:	38401403 	ldrb	w3, [x0], #1
    4801c3cc:	38401424 	ldrb	w4, [x1], #1
    4801c3d0:	f1000442 	subs	x2, x2, #0x1
    4801c3d4:	7a418860 	ccmp	w3, #0x1, #0x0, hi  // hi = pmore
    4801c3d8:	7a442060 	ccmp	w3, w4, #0x0, cs  // cs = hs, nlast
    4801c3dc:	54ffff60 	b.eq	4801c3c8 <strncmp+0xec>  // b.none
    4801c3e0:	cb040060 	sub	x0, x3, x4
    4801c3e4:	d65f03c0 	ret
    4801c3e8:	d343fc4d 	lsr	x13, x2, #3
    4801c3ec:	b400018e 	cbz	x14, 4801c41c <strncmp+0x140>
    4801c3f0:	cb0e03ee 	neg	x14, x14
    4801c3f4:	924009ce 	and	x14, x14, #0x7
    4801c3f8:	cb0e0042 	sub	x2, x2, x14
    4801c3fc:	d343fc4d 	lsr	x13, x2, #3
    4801c400:	38401403 	ldrb	w3, [x0], #1
    4801c404:	38401424 	ldrb	w4, [x1], #1
    4801c408:	7100047f 	cmp	w3, #0x1
    4801c40c:	7a442060 	ccmp	w3, w4, #0x0, cs  // cs = hs, nlast
    4801c410:	54fffe81 	b.ne	4801c3e0 <strncmp+0x104>  // b.any
    4801c414:	f10005ce 	subs	x14, x14, #0x1
    4801c418:	54ffff48 	b.hi	4801c400 <strncmp+0x124>  // b.pmore
    4801c41c:	d280010e 	mov	x14, #0x8                   	// #8
    4801c420:	f10005ad 	subs	x13, x13, #0x1
    4801c424:	540001c3 	b.cc	4801c45c <strncmp+0x180>  // b.lo, b.ul, b.last
    4801c428:	927d2029 	and	x9, x1, #0xff8
    4801c42c:	d27d2129 	eor	x9, x9, #0xff8
    4801c430:	b4fffe89 	cbz	x9, 4801c400 <strncmp+0x124>
    4801c434:	f8408403 	ldr	x3, [x0], #8
    4801c438:	f8408424 	ldr	x4, [x1], #8
    4801c43c:	cb0b0068 	sub	x8, x3, x11
    4801c440:	b200d869 	orr	x9, x3, #0x7f7f7f7f7f7f7f7f
    4801c444:	ca040066 	eor	x6, x3, x4
    4801c448:	ea290105 	bics	x5, x8, x9
    4801c44c:	fa4008c0 	ccmp	x6, #0x0, #0x0, eq  // eq = none
    4801c450:	54fff7e1 	b.ne	4801c34c <strncmp+0x70>  // b.any
    4801c454:	f10005ad 	subs	x13, x13, #0x1
    4801c458:	54fffe85 	b.pl	4801c428 <strncmp+0x14c>  // b.nfrst
    4801c45c:	92400842 	and	x2, x2, #0x7
    4801c460:	b4fff762 	cbz	x2, 4801c34c <strncmp+0x70>
    4801c464:	d1002000 	sub	x0, x0, #0x8
    4801c468:	d1002021 	sub	x1, x1, #0x8
    4801c46c:	f8626803 	ldr	x3, [x0, x2]
    4801c470:	f8626824 	ldr	x4, [x1, x2]
    4801c474:	cb0b0068 	sub	x8, x3, x11
    4801c478:	b200d869 	orr	x9, x3, #0x7f7f7f7f7f7f7f7f
    4801c47c:	ca040066 	eor	x6, x3, x4
    4801c480:	ea290105 	bics	x5, x8, x9
    4801c484:	fa4008c0 	ccmp	x6, #0x0, #0x0, eq  // eq = none
    4801c488:	54fff621 	b.ne	4801c34c <strncmp+0x70>  // b.any
    4801c48c:	d2800000 	mov	x0, #0x0                   	// #0
    4801c490:	d65f03c0 	ret

000000004801c494 <strrchr>:
    4801c494:	52808024 	mov	w4, #0x401                 	// #1025
    4801c498:	72a80204 	movk	w4, #0x4010, lsl #16
    4801c49c:	4e010c20 	dup	v0.16b, w1
    4801c4a0:	927be802 	and	x2, x0, #0xffffffffffffffe0
    4801c4a4:	4e040c90 	dup	v16.4s, w4
    4801c4a8:	d2800007 	mov	x7, #0x0                   	// #0
    4801c4ac:	f2401003 	ands	x3, x0, #0x1f
    4801c4b0:	4eb08607 	add	v7.4s, v16.4s, v16.4s
    4801c4b4:	54000340 	b.eq	4801c51c <strrchr+0x88>  // b.none
    4801c4b8:	4cdfa041 	ld1	{v1.16b, v2.16b}, [x2], #32
    4801c4bc:	cb0303e3 	neg	x3, x3
    4801c4c0:	4e209823 	cmeq	v3.16b, v1.16b, #0
    4801c4c4:	6e208c25 	cmeq	v5.16b, v1.16b, v0.16b
    4801c4c8:	4e209844 	cmeq	v4.16b, v2.16b, #0
    4801c4cc:	6e208c46 	cmeq	v6.16b, v2.16b, v0.16b
    4801c4d0:	4e271c63 	and	v3.16b, v3.16b, v7.16b
    4801c4d4:	4e301ca5 	and	v5.16b, v5.16b, v16.16b
    4801c4d8:	4e271c84 	and	v4.16b, v4.16b, v7.16b
    4801c4dc:	4e301cc6 	and	v6.16b, v6.16b, v16.16b
    4801c4e0:	4e24bc63 	addp	v3.16b, v3.16b, v4.16b
    4801c4e4:	4e26bca5 	addp	v5.16b, v5.16b, v6.16b
    4801c4e8:	4e23bc63 	addp	v3.16b, v3.16b, v3.16b
    4801c4ec:	4e25bca5 	addp	v5.16b, v5.16b, v5.16b
    4801c4f0:	4e083c6a 	mov	x10, v3.d[0]
    4801c4f4:	d37ff863 	lsl	x3, x3, #1
    4801c4f8:	92800008 	mov	x8, #0xffffffffffffffff    	// #-1
    4801c4fc:	4e083cab 	mov	x11, v5.d[0]
    4801c500:	9ac32505 	lsr	x5, x8, x3
    4801c504:	8a25014a 	bic	x10, x10, x5
    4801c508:	8a25016b 	bic	x11, x11, x5
    4801c50c:	b50002ea 	cbnz	x10, 4801c568 <strrchr+0xd4>
    4801c510:	f100017f 	cmp	x11, #0x0
    4801c514:	9a861046 	csel	x6, x2, x6, ne  // ne = any
    4801c518:	9a871167 	csel	x7, x11, x7, ne  // ne = any
    4801c51c:	4cdfa041 	ld1	{v1.16b, v2.16b}, [x2], #32
    4801c520:	4e209823 	cmeq	v3.16b, v1.16b, #0
    4801c524:	6e208c25 	cmeq	v5.16b, v1.16b, v0.16b
    4801c528:	4e209844 	cmeq	v4.16b, v2.16b, #0
    4801c52c:	6e208c46 	cmeq	v6.16b, v2.16b, v0.16b
    4801c530:	4e24bc71 	addp	v17.16b, v3.16b, v4.16b
    4801c534:	4e301ca5 	and	v5.16b, v5.16b, v16.16b
    4801c538:	4e301cc6 	and	v6.16b, v6.16b, v16.16b
    4801c53c:	4e26bca5 	addp	v5.16b, v5.16b, v6.16b
    4801c540:	4e31be31 	addp	v17.16b, v17.16b, v17.16b
    4801c544:	4e25bca5 	addp	v5.16b, v5.16b, v5.16b
    4801c548:	4e083e2a 	mov	x10, v17.d[0]
    4801c54c:	4e083cab 	mov	x11, v5.d[0]
    4801c550:	b4fffe0a 	cbz	x10, 4801c510 <strrchr+0x7c>
    4801c554:	4e271c63 	and	v3.16b, v3.16b, v7.16b
    4801c558:	4e271c84 	and	v4.16b, v4.16b, v7.16b
    4801c55c:	4e24bc63 	addp	v3.16b, v3.16b, v4.16b
    4801c560:	4e23bc63 	addp	v3.16b, v3.16b, v3.16b
    4801c564:	4e083c6a 	mov	x10, v3.d[0]
    4801c568:	d1000549 	sub	x9, x10, #0x1
    4801c56c:	ca0a0129 	eor	x9, x9, x10
    4801c570:	ea09016b 	ands	x11, x11, x9
    4801c574:	9a861046 	csel	x6, x2, x6, ne  // ne = any
    4801c578:	9a871167 	csel	x7, x11, x7, ne  // ne = any
    4801c57c:	dac010e5 	clz	x5, x7
    4801c580:	910008a5 	add	x5, x5, #0x2
    4801c584:	cb4504c0 	sub	x0, x6, x5, lsr #1
    4801c588:	f10000ff 	cmp	x7, #0x0
    4801c58c:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
    4801c590:	d65f03c0 	ret

000000004801c594 <strchr>:
    4801c594:	52808024 	mov	w4, #0x401                 	// #1025
    4801c598:	72a80204 	movk	w4, #0x4010, lsl #16
    4801c59c:	4e010c20 	dup	v0.16b, w1
    4801c5a0:	927be802 	and	x2, x0, #0xffffffffffffffe0
    4801c5a4:	4e040c90 	dup	v16.4s, w4
    4801c5a8:	f2401003 	ands	x3, x0, #0x1f
    4801c5ac:	4eb08607 	add	v7.4s, v16.4s, v16.4s
    4801c5b0:	540002a0 	b.eq	4801c604 <strchr+0x70>  // b.none
    4801c5b4:	4cdfa041 	ld1	{v1.16b, v2.16b}, [x2], #32
    4801c5b8:	cb0303e3 	neg	x3, x3
    4801c5bc:	4e209823 	cmeq	v3.16b, v1.16b, #0
    4801c5c0:	6e208c25 	cmeq	v5.16b, v1.16b, v0.16b
    4801c5c4:	4e209844 	cmeq	v4.16b, v2.16b, #0
    4801c5c8:	6e208c46 	cmeq	v6.16b, v2.16b, v0.16b
    4801c5cc:	4e271c63 	and	v3.16b, v3.16b, v7.16b
    4801c5d0:	4e271c84 	and	v4.16b, v4.16b, v7.16b
    4801c5d4:	4e301ca5 	and	v5.16b, v5.16b, v16.16b
    4801c5d8:	4e301cc6 	and	v6.16b, v6.16b, v16.16b
    4801c5dc:	4ea51c71 	orr	v17.16b, v3.16b, v5.16b
    4801c5e0:	4ea61c92 	orr	v18.16b, v4.16b, v6.16b
    4801c5e4:	d37ff863 	lsl	x3, x3, #1
    4801c5e8:	4e32be31 	addp	v17.16b, v17.16b, v18.16b
    4801c5ec:	92800005 	mov	x5, #0xffffffffffffffff    	// #-1
    4801c5f0:	4e32be31 	addp	v17.16b, v17.16b, v18.16b
    4801c5f4:	9ac324a3 	lsr	x3, x5, x3
    4801c5f8:	4e083e25 	mov	x5, v17.d[0]
    4801c5fc:	8a2300a3 	bic	x3, x5, x3
    4801c600:	b50002a3 	cbnz	x3, 4801c654 <strchr+0xc0>
    4801c604:	4cdfa041 	ld1	{v1.16b, v2.16b}, [x2], #32
    4801c608:	4e209823 	cmeq	v3.16b, v1.16b, #0
    4801c60c:	6e208c25 	cmeq	v5.16b, v1.16b, v0.16b
    4801c610:	4e209844 	cmeq	v4.16b, v2.16b, #0
    4801c614:	6e208c46 	cmeq	v6.16b, v2.16b, v0.16b
    4801c618:	4ea51c71 	orr	v17.16b, v3.16b, v5.16b
    4801c61c:	4ea61c92 	orr	v18.16b, v4.16b, v6.16b
    4801c620:	4eb21e31 	orr	v17.16b, v17.16b, v18.16b
    4801c624:	4ef1be31 	addp	v17.2d, v17.2d, v17.2d
    4801c628:	4e083e23 	mov	x3, v17.d[0]
    4801c62c:	b4fffec3 	cbz	x3, 4801c604 <strchr+0x70>
    4801c630:	4e271c63 	and	v3.16b, v3.16b, v7.16b
    4801c634:	4e271c84 	and	v4.16b, v4.16b, v7.16b
    4801c638:	4e301ca5 	and	v5.16b, v5.16b, v16.16b
    4801c63c:	4e301cc6 	and	v6.16b, v6.16b, v16.16b
    4801c640:	4ea51c71 	orr	v17.16b, v3.16b, v5.16b
    4801c644:	4ea61c92 	orr	v18.16b, v4.16b, v6.16b
    4801c648:	4e32be31 	addp	v17.16b, v17.16b, v18.16b
    4801c64c:	4e32be31 	addp	v17.16b, v17.16b, v18.16b
    4801c650:	4e083e23 	mov	x3, v17.d[0]
    4801c654:	dac00063 	rbit	x3, x3
    4801c658:	d1008042 	sub	x2, x2, #0x20
    4801c65c:	dac01063 	clz	x3, x3
    4801c660:	f240007f 	tst	x3, #0x1
    4801c664:	8b430440 	add	x0, x2, x3, lsr #1
    4801c668:	9a9f0000 	csel	x0, x0, xzr, eq  // eq = none
    4801c66c:	d65f03c0 	ret
	...
    4801c680:	d503201f 	nop
    4801c684:	d503201f 	nop
    4801c688:	d503201f 	nop
    4801c68c:	d503201f 	nop
    4801c690:	d503201f 	nop
    4801c694:	d503201f 	nop
    4801c698:	d503201f 	nop
    4801c69c:	aa0103e0 	mov	x0, x1
    4801c6a0:	d65f03c0 	ret

000000004801c6a4 <strnlen>:
    4801c6a4:	b4ffffc1 	cbz	x1, 4801c69c <strchr+0x108>
    4801c6a8:	b200c3ec 	mov	x12, #0x101010101010101     	// #72340172838076673
    4801c6ac:	927cec02 	and	x2, x0, #0xfffffffffffffff0
    4801c6b0:	f2400c08 	ands	x8, x0, #0xf
    4801c6b4:	54000361 	b.ne	4801c720 <strnlen+0x7c>  // b.any
    4801c6b8:	d100042e 	sub	x14, x1, #0x1
    4801c6bc:	d344fdce 	lsr	x14, x14, #4
    4801c6c0:	a8c11043 	ldp	x3, x4, [x2], #16
    4801c6c4:	cb0c0068 	sub	x8, x3, x12
    4801c6c8:	b200d869 	orr	x9, x3, #0x7f7f7f7f7f7f7f7f
    4801c6cc:	cb0c008a 	sub	x10, x4, x12
    4801c6d0:	b200d88b 	orr	x11, x4, #0x7f7f7f7f7f7f7f7f
    4801c6d4:	8a290106 	bic	x6, x8, x9
    4801c6d8:	8a2b0147 	bic	x7, x10, x11
    4801c6dc:	f10005ce 	subs	x14, x14, #0x1
    4801c6e0:	aa0700c8 	orr	x8, x6, x7
    4801c6e4:	fa405900 	ccmp	x8, #0x0, #0x0, pl  // pl = nfrst
    4801c6e8:	54fffec0 	b.eq	4801c6c0 <strnlen+0x1c>  // b.none
    4801c6ec:	aa0700c8 	orr	x8, x6, x7
    4801c6f0:	b4fffd68 	cbz	x8, 4801c69c <strchr+0x108>
    4801c6f4:	cb000040 	sub	x0, x2, x0
    4801c6f8:	b4000066 	cbz	x6, 4801c704 <strnlen+0x60>
    4801c6fc:	d1002000 	sub	x0, x0, #0x8
    4801c700:	aa0603e7 	mov	x7, x6
    4801c704:	d1002000 	sub	x0, x0, #0x8
    4801c708:	dac00ce7 	rev	x7, x7
    4801c70c:	dac010ed 	clz	x13, x7
    4801c710:	8b4d0c00 	add	x0, x0, x13, lsr #3
    4801c714:	eb01001f 	cmp	x0, x1
    4801c718:	9a819000 	csel	x0, x0, x1, ls  // ls = plast
    4801c71c:	d65f03c0 	ret
    4801c720:	d100042e 	sub	x14, x1, #0x1
    4801c724:	cb0803eb 	neg	x11, x8
    4801c728:	f100211f 	cmp	x8, #0x8
    4801c72c:	92400dca 	and	x10, x14, #0xf
    4801c730:	d344fdce 	lsr	x14, x14, #4
    4801c734:	92800009 	mov	x9, #0xffffffffffffffff    	// #-1
    4801c738:	a8c11043 	ldp	x3, x4, [x2], #16
    4801c73c:	d37df16b 	lsl	x11, x11, #3
    4801c740:	8b08014a 	add	x10, x10, x8
    4801c744:	9acb2529 	lsr	x9, x9, x11
    4801c748:	8b4a11ce 	add	x14, x14, x10, lsr #4
    4801c74c:	aa090063 	orr	x3, x3, x9
    4801c750:	aa090085 	orr	x5, x4, x9
    4801c754:	da9fd063 	csinv	x3, x3, xzr, le
    4801c758:	9a85d084 	csel	x4, x4, x5, le
    4801c75c:	17ffffda 	b	4801c6c4 <strnlen+0x20>

000000004801c760 <atoi>:
    4801c760:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4801c764:	52800142 	mov	w2, #0xa                   	// #10
    4801c768:	d2800001 	mov	x1, #0x0                   	// #0
    4801c76c:	910003fd 	mov	x29, sp
    4801c770:	9400026c 	bl	4801d120 <strtol>
    4801c774:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4801c778:	d65f03c0 	ret
    4801c77c:	00000000 	udf	#0

000000004801c780 <getchar>:
    4801c780:	b0000020 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4801c784:	f943cc00 	ldr	x0, [x0, #1944]
    4801c788:	f9400401 	ldr	x1, [x0, #8]
    4801c78c:	14000001 	b	4801c790 <_getc_r>

000000004801c790 <_getc_r>:
    4801c790:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801c794:	910003fd 	mov	x29, sp
    4801c798:	a90153f3 	stp	x19, x20, [sp, #16]
    4801c79c:	aa0103f3 	mov	x19, x1
    4801c7a0:	aa0003f4 	mov	x20, x0
    4801c7a4:	b4000060 	cbz	x0, 4801c7b0 <_getc_r+0x20>
    4801c7a8:	b9405001 	ldr	w1, [x0, #80]
    4801c7ac:	34000181 	cbz	w1, 4801c7dc <_getc_r+0x4c>
    4801c7b0:	b9400a61 	ldr	w1, [x19, #8]
    4801c7b4:	51000421 	sub	w1, w1, #0x1
    4801c7b8:	b9000a61 	str	w1, [x19, #8]
    4801c7bc:	37f801a1 	tbnz	w1, #31, 4801c7f0 <_getc_r+0x60>
    4801c7c0:	f9400260 	ldr	x0, [x19]
    4801c7c4:	91000401 	add	x1, x0, #0x1
    4801c7c8:	f9000261 	str	x1, [x19]
    4801c7cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801c7d0:	39400000 	ldrb	w0, [x0]
    4801c7d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801c7d8:	d65f03c0 	ret
    4801c7dc:	940002b9 	bl	4801d2c0 <__sinit>
    4801c7e0:	b9400a61 	ldr	w1, [x19, #8]
    4801c7e4:	51000421 	sub	w1, w1, #0x1
    4801c7e8:	b9000a61 	str	w1, [x19, #8]
    4801c7ec:	36fffea1 	tbz	w1, #31, 4801c7c0 <_getc_r+0x30>
    4801c7f0:	aa1303e1 	mov	x1, x19
    4801c7f4:	aa1403e0 	mov	x0, x20
    4801c7f8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801c7fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801c800:	14000004 	b	4801c810 <__srget_r>
	...

000000004801c810 <__srget_r>:
    4801c810:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801c814:	910003fd 	mov	x29, sp
    4801c818:	a90153f3 	stp	x19, x20, [sp, #16]
    4801c81c:	aa0103f3 	mov	x19, x1
    4801c820:	aa0003f4 	mov	x20, x0
    4801c824:	b4000060 	cbz	x0, 4801c830 <__srget_r+0x20>
    4801c828:	b9405001 	ldr	w1, [x0, #80]
    4801c82c:	340001e1 	cbz	w1, 4801c868 <__srget_r+0x58>
    4801c830:	aa1403e0 	mov	x0, x20
    4801c834:	aa1303e1 	mov	x1, x19
    4801c838:	9400030a 	bl	4801d460 <__srefill_r>
    4801c83c:	350001a0 	cbnz	w0, 4801c870 <__srget_r+0x60>
    4801c840:	f9400261 	ldr	x1, [x19]
    4801c844:	b9400a60 	ldr	w0, [x19, #8]
    4801c848:	91000422 	add	x2, x1, #0x1
    4801c84c:	f9000262 	str	x2, [x19]
    4801c850:	51000400 	sub	w0, w0, #0x1
    4801c854:	b9000a60 	str	w0, [x19, #8]
    4801c858:	39400020 	ldrb	w0, [x1]
    4801c85c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801c860:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801c864:	d65f03c0 	ret
    4801c868:	94000296 	bl	4801d2c0 <__sinit>
    4801c86c:	17fffff1 	b	4801c830 <__srget_r+0x20>
    4801c870:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801c874:	17fffffa 	b	4801c85c <__srget_r+0x4c>
	...

000000004801c880 <strncpy>:
    4801c880:	aa000023 	orr	x3, x1, x0
    4801c884:	f240087f 	tst	x3, #0x7
    4801c888:	aa0003e3 	mov	x3, x0
    4801c88c:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
    4801c890:	540002c8 	b.hi	4801c8e8 <strncpy+0x68>  // b.pmore
    4801c894:	d1000445 	sub	x5, x2, #0x1
    4801c898:	d2800027 	mov	x7, #0x1                   	// #1
    4801c89c:	8b050025 	add	x5, x1, x5
    4801c8a0:	14000007 	b	4801c8bc <strncpy+0x3c>
    4801c8a4:	386468a4 	ldrb	w4, [x5, x4]
    4801c8a8:	d1000446 	sub	x6, x2, #0x1
    4801c8ac:	38001424 	strb	w4, [x1], #1
    4801c8b0:	340000e4 	cbz	w4, 4801c8cc <strncpy+0x4c>
    4801c8b4:	aa0103e3 	mov	x3, x1
    4801c8b8:	aa0603e2 	mov	x2, x6
    4801c8bc:	cb0200e4 	sub	x4, x7, x2
    4801c8c0:	aa0303e1 	mov	x1, x3
    4801c8c4:	b5ffff02 	cbnz	x2, 4801c8a4 <strncpy+0x24>
    4801c8c8:	d65f03c0 	ret
    4801c8cc:	8b020062 	add	x2, x3, x2
    4801c8d0:	b4ffffc6 	cbz	x6, 4801c8c8 <strncpy+0x48>
    4801c8d4:	d503201f 	nop
    4801c8d8:	3800143f 	strb	wzr, [x1], #1
    4801c8dc:	eb02003f 	cmp	x1, x2
    4801c8e0:	54ffffc1 	b.ne	4801c8d8 <strncpy+0x58>  // b.any
    4801c8e4:	d65f03c0 	ret
    4801c8e8:	b207dbe6 	mov	x6, #0xfefefefefefefefe    	// #-72340172838076674
    4801c8ec:	f29fdfe6 	movk	x6, #0xfeff
    4801c8f0:	f9400025 	ldr	x5, [x1]
    4801c8f4:	8b0600a4 	add	x4, x5, x6
    4801c8f8:	8a250084 	bic	x4, x4, x5
    4801c8fc:	f201c09f 	tst	x4, #0x8080808080808080
    4801c900:	54fffca1 	b.ne	4801c894 <strncpy+0x14>  // b.any
    4801c904:	d1002042 	sub	x2, x2, #0x8
    4801c908:	f8008465 	str	x5, [x3], #8
    4801c90c:	91002021 	add	x1, x1, #0x8
    4801c910:	f1001c5f 	cmp	x2, #0x7
    4801c914:	54fffee8 	b.hi	4801c8f0 <strncpy+0x70>  // b.pmore
    4801c918:	17ffffdf 	b	4801c894 <strncpy+0x14>
    4801c91c:	00000000 	udf	#0

000000004801c920 <two_way_long_needle>:
    4801c920:	d12203ff 	sub	sp, sp, #0x880
    4801c924:	d2800026 	mov	x6, #0x1                   	// #1
    4801c928:	a9007bfd 	stp	x29, x30, [sp]
    4801c92c:	910003fd 	mov	x29, sp
    4801c930:	a90153f3 	stp	x19, x20, [sp, #16]
    4801c934:	aa0203f3 	mov	x19, x2
    4801c938:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801c93c:	aa0303f5 	mov	x21, x3
    4801c940:	d1000476 	sub	x22, x3, #0x1
    4801c944:	a90363f7 	stp	x23, x24, [sp, #48]
    4801c948:	a9046bf9 	stp	x25, x26, [sp, #64]
    4801c94c:	aa0103fa 	mov	x26, x1
    4801c950:	a90573fb 	stp	x27, x28, [sp, #80]
    4801c954:	aa0003fc 	mov	x28, x0
    4801c958:	f100047f 	cmp	x3, #0x1
    4801c95c:	54001ee9 	b.ls	4801cd38 <two_way_long_needle+0x418>  // b.plast
    4801c960:	aa0603e3 	mov	x3, x6
    4801c964:	aa0603e0 	mov	x0, x6
    4801c968:	d2800004 	mov	x4, #0x0                   	// #0
    4801c96c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    4801c970:	14000007 	b	4801c98c <two_way_long_needle+0x6c>
    4801c974:	cb020006 	sub	x6, x0, x2
    4801c978:	aa0003e4 	mov	x4, x0
    4801c97c:	d2800023 	mov	x3, #0x1                   	// #1
    4801c980:	8b040060 	add	x0, x3, x4
    4801c984:	eb0002bf 	cmp	x21, x0
    4801c988:	540001c9 	b.ls	4801c9c0 <two_way_long_needle+0xa0>  // b.plast
    4801c98c:	8b020261 	add	x1, x19, x2
    4801c990:	38606a65 	ldrb	w5, [x19, x0]
    4801c994:	38636821 	ldrb	w1, [x1, x3]
    4801c998:	6b0100bf 	cmp	w5, w1
    4801c99c:	54fffec3 	b.cc	4801c974 <two_way_long_needle+0x54>  // b.lo, b.ul, b.last
    4801c9a0:	54000c80 	b.eq	4801cb30 <two_way_long_needle+0x210>  // b.none
    4801c9a4:	d2800026 	mov	x6, #0x1                   	// #1
    4801c9a8:	aa0403e2 	mov	x2, x4
    4801c9ac:	aa0603e3 	mov	x3, x6
    4801c9b0:	8b060084 	add	x4, x4, x6
    4801c9b4:	8b040060 	add	x0, x3, x4
    4801c9b8:	eb0002bf 	cmp	x21, x0
    4801c9bc:	54fffe88 	b.hi	4801c98c <two_way_long_needle+0x6c>  // b.pmore
    4801c9c0:	d2800028 	mov	x8, #0x1                   	// #1
    4801c9c4:	d2800004 	mov	x4, #0x0                   	// #0
    4801c9c8:	aa0803e3 	mov	x3, x8
    4801c9cc:	aa0803e0 	mov	x0, x8
    4801c9d0:	92800005 	mov	x5, #0xffffffffffffffff    	// #-1
    4801c9d4:	14000007 	b	4801c9f0 <two_way_long_needle+0xd0>
    4801c9d8:	cb050008 	sub	x8, x0, x5
    4801c9dc:	aa0003e4 	mov	x4, x0
    4801c9e0:	d2800023 	mov	x3, #0x1                   	// #1
    4801c9e4:	8b030080 	add	x0, x4, x3
    4801c9e8:	eb0002bf 	cmp	x21, x0
    4801c9ec:	540001c9 	b.ls	4801ca24 <two_way_long_needle+0x104>  // b.plast
    4801c9f0:	8b030261 	add	x1, x19, x3
    4801c9f4:	38606a67 	ldrb	w7, [x19, x0]
    4801c9f8:	38656821 	ldrb	w1, [x1, x5]
    4801c9fc:	6b0100ff 	cmp	w7, w1
    4801ca00:	54fffec8 	b.hi	4801c9d8 <two_way_long_needle+0xb8>  // b.pmore
    4801ca04:	540009e0 	b.eq	4801cb40 <two_way_long_needle+0x220>  // b.none
    4801ca08:	d2800028 	mov	x8, #0x1                   	// #1
    4801ca0c:	aa0403e5 	mov	x5, x4
    4801ca10:	aa0803e3 	mov	x3, x8
    4801ca14:	8b080084 	add	x4, x4, x8
    4801ca18:	8b030080 	add	x0, x4, x3
    4801ca1c:	eb0002bf 	cmp	x21, x0
    4801ca20:	54fffe88 	b.hi	4801c9f0 <two_way_long_needle+0xd0>  // b.pmore
    4801ca24:	910004a5 	add	x5, x5, #0x1
    4801ca28:	91000457 	add	x23, x2, #0x1
    4801ca2c:	eb0502ff 	cmp	x23, x5
    4801ca30:	9a8880c6 	csel	x6, x6, x8, hi  // hi = pmore
    4801ca34:	9a8582f7 	csel	x23, x23, x5, hi  // hi = pmore
    4801ca38:	910203fb 	add	x27, sp, #0x80
    4801ca3c:	912203e0 	add	x0, sp, #0x880
    4801ca40:	aa1b03e4 	mov	x4, x27
    4801ca44:	d503201f 	nop
    4801ca48:	f8008495 	str	x21, [x4], #8
    4801ca4c:	eb04001f 	cmp	x0, x4
    4801ca50:	54ffffc1 	b.ne	4801ca48 <two_way_long_needle+0x128>  // b.any
    4801ca54:	8b1302a4 	add	x4, x21, x19
    4801ca58:	aa1303e0 	mov	x0, x19
    4801ca5c:	b4000115 	cbz	x21, 4801ca7c <two_way_long_needle+0x15c>
    4801ca60:	39400003 	ldrb	w3, [x0]
    4801ca64:	cb000261 	sub	x1, x19, x0
    4801ca68:	8b160021 	add	x1, x1, x22
    4801ca6c:	91000400 	add	x0, x0, #0x1
    4801ca70:	f8237b61 	str	x1, [x27, x3, lsl #3]
    4801ca74:	eb00009f 	cmp	x4, x0
    4801ca78:	54ffff41 	b.ne	4801ca60 <two_way_long_needle+0x140>  // b.any
    4801ca7c:	8b060261 	add	x1, x19, x6
    4801ca80:	aa1703e2 	mov	x2, x23
    4801ca84:	aa1303e0 	mov	x0, x19
    4801ca88:	f90037e6 	str	x6, [sp, #104]
    4801ca8c:	97fffbdd 	bl	4801ba00 <memcmp>
    4801ca90:	f94037e6 	ldr	x6, [sp, #104]
    4801ca94:	35000c60 	cbnz	w0, 4801cc20 <two_way_long_needle+0x300>
    4801ca98:	d2800020 	mov	x0, #0x1                   	// #1
    4801ca9c:	8b160398 	add	x24, x28, x22
    4801caa0:	cb170000 	sub	x0, x0, x23
    4801caa4:	d2800019 	mov	x25, #0x0                   	// #0
    4801caa8:	d2800014 	mov	x20, #0x0                   	// #0
    4801caac:	f9003be0 	str	x0, [sp, #112]
    4801cab0:	d10006e0 	sub	x0, x23, #0x1
    4801cab4:	f9003fe0 	str	x0, [sp, #120]
    4801cab8:	38746b00 	ldrb	w0, [x24, x20]
    4801cabc:	f8607b60 	ldr	x0, [x27, x0, lsl #3]
    4801cac0:	b4000480 	cbz	x0, 4801cb50 <two_way_long_needle+0x230>
    4801cac4:	f100033f 	cmp	x25, #0x0
    4801cac8:	cb0602a1 	sub	x1, x21, x6
    4801cacc:	fa461002 	ccmp	x0, x6, #0x2, ne  // ne = any
    4801cad0:	d2800019 	mov	x25, #0x0                   	// #0
    4801cad4:	9a803020 	csel	x0, x1, x0, cc  // cc = lo, ul, last
    4801cad8:	8b000294 	add	x20, x20, x0
    4801cadc:	cb150340 	sub	x0, x26, x21
    4801cae0:	eb14001f 	cmp	x0, x20
    4801cae4:	54fffea2 	b.cs	4801cab8 <two_way_long_needle+0x198>  // b.hs, b.nlast
    4801cae8:	8b1a0380 	add	x0, x28, x26
    4801caec:	b27502a1 	orr	x1, x21, #0x800
    4801caf0:	f90037e6 	str	x6, [sp, #104]
    4801caf4:	97fffeec 	bl	4801c6a4 <strnlen>
    4801caf8:	8b00035a 	add	x26, x26, x0
    4801cafc:	cb150340 	sub	x0, x26, x21
    4801cb00:	eb14001f 	cmp	x0, x20
    4801cb04:	f94037e6 	ldr	x6, [sp, #104]
    4801cb08:	54fffd82 	b.cs	4801cab8 <two_way_long_needle+0x198>  // b.hs, b.nlast
    4801cb0c:	d2800000 	mov	x0, #0x0                   	// #0
    4801cb10:	a9407bfd 	ldp	x29, x30, [sp]
    4801cb14:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801cb18:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801cb1c:	a94363f7 	ldp	x23, x24, [sp, #48]
    4801cb20:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4801cb24:	a94573fb 	ldp	x27, x28, [sp, #80]
    4801cb28:	912203ff 	add	sp, sp, #0x880
    4801cb2c:	d65f03c0 	ret
    4801cb30:	eb0300df 	cmp	x6, x3
    4801cb34:	54000e40 	b.eq	4801ccfc <two_way_long_needle+0x3dc>  // b.none
    4801cb38:	91000463 	add	x3, x3, #0x1
    4801cb3c:	17ffff91 	b	4801c980 <two_way_long_needle+0x60>
    4801cb40:	eb03011f 	cmp	x8, x3
    4801cb44:	54000e20 	b.eq	4801cd08 <two_way_long_needle+0x3e8>  // b.none
    4801cb48:	91000463 	add	x3, x3, #0x1
    4801cb4c:	17ffffa6 	b	4801c9e4 <two_way_long_needle+0xc4>
    4801cb50:	eb1902ff 	cmp	x23, x25
    4801cb54:	8b140380 	add	x0, x28, x20
    4801cb58:	9a9922e4 	csel	x4, x23, x25, cs  // cs = hs, nlast
    4801cb5c:	eb0402df 	cmp	x22, x4
    4801cb60:	540000a8 	b.hi	4801cb74 <two_way_long_needle+0x254>  // b.pmore
    4801cb64:	1400000d 	b	4801cb98 <two_way_long_needle+0x278>
    4801cb68:	91000484 	add	x4, x4, #0x1
    4801cb6c:	eb0402df 	cmp	x22, x4
    4801cb70:	54000149 	b.ls	4801cb98 <two_way_long_needle+0x278>  // b.plast
    4801cb74:	38646a65 	ldrb	w5, [x19, x4]
    4801cb78:	38646803 	ldrb	w3, [x0, x4]
    4801cb7c:	6b0300bf 	cmp	w5, w3
    4801cb80:	54ffff40 	b.eq	4801cb68 <two_way_long_needle+0x248>  // b.none
    4801cb84:	f9403be0 	ldr	x0, [sp, #112]
    4801cb88:	8b140084 	add	x4, x4, x20
    4801cb8c:	d2800019 	mov	x25, #0x0                   	// #0
    4801cb90:	8b040014 	add	x20, x0, x4
    4801cb94:	17ffffd2 	b	4801cadc <two_way_long_needle+0x1bc>
    4801cb98:	8b140380 	add	x0, x28, x20
    4801cb9c:	aa1703e8 	mov	x8, x23
    4801cba0:	f9403fe3 	ldr	x3, [sp, #120]
    4801cba4:	eb1902ff 	cmp	x23, x25
    4801cba8:	540000a8 	b.hi	4801cbbc <two_way_long_needle+0x29c>  // b.pmore
    4801cbac:	1400000a 	b	4801cbd4 <two_way_long_needle+0x2b4>
    4801cbb0:	eb19007f 	cmp	x3, x25
    4801cbb4:	540001c0 	b.eq	4801cbec <two_way_long_needle+0x2cc>  // b.none
    4801cbb8:	aa0503e3 	mov	x3, x5
    4801cbbc:	38636a64 	ldrb	w4, [x19, x3]
    4801cbc0:	91000468 	add	x8, x3, #0x1
    4801cbc4:	38636801 	ldrb	w1, [x0, x3]
    4801cbc8:	d1000465 	sub	x5, x3, #0x1
    4801cbcc:	6b01009f 	cmp	w4, w1
    4801cbd0:	54ffff00 	b.eq	4801cbb0 <two_way_long_needle+0x290>  // b.none
    4801cbd4:	91000739 	add	x25, x25, #0x1
    4801cbd8:	eb08033f 	cmp	x25, x8
    4801cbdc:	54000108 	b.hi	4801cbfc <two_way_long_needle+0x2dc>  // b.pmore
    4801cbe0:	8b060294 	add	x20, x20, x6
    4801cbe4:	cb0602b9 	sub	x25, x21, x6
    4801cbe8:	17ffffbd 	b	4801cadc <two_way_long_needle+0x1bc>
    4801cbec:	aa1903e8 	mov	x8, x25
    4801cbf0:	91000739 	add	x25, x25, #0x1
    4801cbf4:	eb08033f 	cmp	x25, x8
    4801cbf8:	54ffff49 	b.ls	4801cbe0 <two_way_long_needle+0x2c0>  // b.plast
    4801cbfc:	8b140380 	add	x0, x28, x20
    4801cc00:	a9407bfd 	ldp	x29, x30, [sp]
    4801cc04:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801cc08:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801cc0c:	a94363f7 	ldp	x23, x24, [sp, #48]
    4801cc10:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4801cc14:	a94573fb 	ldp	x27, x28, [sp, #80]
    4801cc18:	912203ff 	add	sp, sp, #0x880
    4801cc1c:	d65f03c0 	ret
    4801cc20:	cb1702a0 	sub	x0, x21, x23
    4801cc24:	8b160398 	add	x24, x28, x22
    4801cc28:	eb17001f 	cmp	x0, x23
    4801cc2c:	b27502b9 	orr	x25, x21, #0x800
    4801cc30:	9a972000 	csel	x0, x0, x23, cs  // cs = hs, nlast
    4801cc34:	d2800021 	mov	x1, #0x1                   	// #1
    4801cc38:	91000400 	add	x0, x0, #0x1
    4801cc3c:	cb170021 	sub	x1, x1, x23
    4801cc40:	d2800014 	mov	x20, #0x0                   	// #0
    4801cc44:	a90683e1 	stp	x1, x0, [sp, #104]
    4801cc48:	38746b00 	ldrb	w0, [x24, x20]
    4801cc4c:	f8607b60 	ldr	x0, [x27, x0, lsl #3]
    4801cc50:	b40001e0 	cbz	x0, 4801cc8c <two_way_long_needle+0x36c>
    4801cc54:	8b000294 	add	x20, x20, x0
    4801cc58:	cb150340 	sub	x0, x26, x21
    4801cc5c:	eb00029f 	cmp	x20, x0
    4801cc60:	54ffff49 	b.ls	4801cc48 <two_way_long_needle+0x328>  // b.plast
    4801cc64:	8b1a0380 	add	x0, x28, x26
    4801cc68:	aa1903e1 	mov	x1, x25
    4801cc6c:	97fffe8e 	bl	4801c6a4 <strnlen>
    4801cc70:	8b00035a 	add	x26, x26, x0
    4801cc74:	cb150340 	sub	x0, x26, x21
    4801cc78:	eb00029f 	cmp	x20, x0
    4801cc7c:	54fff488 	b.hi	4801cb0c <two_way_long_needle+0x1ec>  // b.pmore
    4801cc80:	38746b00 	ldrb	w0, [x24, x20]
    4801cc84:	f8607b60 	ldr	x0, [x27, x0, lsl #3]
    4801cc88:	b5fffe60 	cbnz	x0, 4801cc54 <two_way_long_needle+0x334>
    4801cc8c:	aa1703e4 	mov	x4, x23
    4801cc90:	8b140385 	add	x5, x28, x20
    4801cc94:	eb1702df 	cmp	x22, x23
    4801cc98:	540000a8 	b.hi	4801ccac <two_way_long_needle+0x38c>  // b.pmore
    4801cc9c:	1400000c 	b	4801cccc <two_way_long_needle+0x3ac>
    4801cca0:	91000484 	add	x4, x4, #0x1
    4801cca4:	eb0402df 	cmp	x22, x4
    4801cca8:	54000129 	b.ls	4801cccc <two_way_long_needle+0x3ac>  // b.plast
    4801ccac:	38646a66 	ldrb	w6, [x19, x4]
    4801ccb0:	386468a3 	ldrb	w3, [x5, x4]
    4801ccb4:	6b0300df 	cmp	w6, w3
    4801ccb8:	54ffff40 	b.eq	4801cca0 <two_way_long_needle+0x380>  // b.none
    4801ccbc:	f94037e0 	ldr	x0, [sp, #104]
    4801ccc0:	8b140094 	add	x20, x4, x20
    4801ccc4:	8b140014 	add	x20, x0, x20
    4801ccc8:	17ffffe4 	b	4801cc58 <two_way_long_needle+0x338>
    4801cccc:	d10006e0 	sub	x0, x23, #0x1
    4801ccd0:	b5000097 	cbnz	x23, 4801cce0 <two_way_long_needle+0x3c0>
    4801ccd4:	14000010 	b	4801cd14 <two_way_long_needle+0x3f4>
    4801ccd8:	b100041f 	cmn	x0, #0x1
    4801ccdc:	540001c0 	b.eq	4801cd14 <two_way_long_needle+0x3f4>  // b.none
    4801cce0:	38606a63 	ldrb	w3, [x19, x0]
    4801cce4:	386068a1 	ldrb	w1, [x5, x0]
    4801cce8:	d1000400 	sub	x0, x0, #0x1
    4801ccec:	6b01007f 	cmp	w3, w1
    4801ccf0:	54ffff40 	b.eq	4801ccd8 <two_way_long_needle+0x3b8>  // b.none
    4801ccf4:	f9403be0 	ldr	x0, [sp, #112]
    4801ccf8:	17ffffd7 	b	4801cc54 <two_way_long_needle+0x334>
    4801ccfc:	8b060084 	add	x4, x4, x6
    4801cd00:	d2800023 	mov	x3, #0x1                   	// #1
    4801cd04:	17ffff1f 	b	4801c980 <two_way_long_needle+0x60>
    4801cd08:	8b080084 	add	x4, x4, x8
    4801cd0c:	d2800023 	mov	x3, #0x1                   	// #1
    4801cd10:	17ffff35 	b	4801c9e4 <two_way_long_needle+0xc4>
    4801cd14:	aa0503e0 	mov	x0, x5
    4801cd18:	a9407bfd 	ldp	x29, x30, [sp]
    4801cd1c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801cd20:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801cd24:	a94363f7 	ldp	x23, x24, [sp, #48]
    4801cd28:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4801cd2c:	a94573fb 	ldp	x27, x28, [sp, #80]
    4801cd30:	912203ff 	add	sp, sp, #0x880
    4801cd34:	d65f03c0 	ret
    4801cd38:	d2800017 	mov	x23, #0x0                   	// #0
    4801cd3c:	17ffff3f 	b	4801ca38 <two_way_long_needle+0x118>

000000004801cd40 <strstr>:
    4801cd40:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    4801cd44:	910003fd 	mov	x29, sp
    4801cd48:	a90153f3 	stp	x19, x20, [sp, #16]
    4801cd4c:	aa0103f4 	mov	x20, x1
    4801cd50:	aa0003f3 	mov	x19, x0
    4801cd54:	39400021 	ldrb	w1, [x1]
    4801cd58:	34000781 	cbz	w1, 4801ce48 <strstr+0x108>
    4801cd5c:	39400683 	ldrb	w3, [x20, #1]
    4801cd60:	34000b83 	cbz	w3, 4801ced0 <strstr+0x190>
    4801cd64:	39400a80 	ldrb	w0, [x20, #2]
    4801cd68:	34000780 	cbz	w0, 4801ce58 <strstr+0x118>
    4801cd6c:	39400e82 	ldrb	w2, [x20, #3]
    4801cd70:	34000d42 	cbz	w2, 4801cf18 <strstr+0x1d8>
    4801cd74:	39401280 	ldrb	w0, [x20, #4]
    4801cd78:	34000b20 	cbz	w0, 4801cedc <strstr+0x19c>
    4801cd7c:	aa1403e0 	mov	x0, x20
    4801cd80:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801cd84:	97fffcff 	bl	4801c180 <strlen>
    4801cd88:	aa0003f5 	mov	x21, x0
    4801cd8c:	aa1303e0 	mov	x0, x19
    4801cd90:	b27702a1 	orr	x1, x21, #0x200
    4801cd94:	97fffe44 	bl	4801c6a4 <strnlen>
    4801cd98:	eb0002bf 	cmp	x21, x0
    4801cd9c:	54000e08 	b.hi	4801cf5c <strstr+0x21c>  // b.pmore
    4801cda0:	f103fabf 	cmp	x21, #0xfe
    4801cda4:	54000e28 	b.hi	4801cf68 <strstr+0x228>  // b.pmore
    4801cda8:	cb150000 	sub	x0, x0, x21
    4801cdac:	a90363f7 	stp	x23, x24, [sp, #48]
    4801cdb0:	910103f7 	add	x23, sp, #0x40
    4801cdb4:	8b000276 	add	x22, x19, x0
    4801cdb8:	110006a1 	add	w1, w21, #0x1
    4801cdbc:	aa1703e0 	mov	x0, x23
    4801cdc0:	d2800802 	mov	x2, #0x40                  	// #64
    4801cdc4:	97fffbbf 	bl	4801bcc0 <memset>
    4801cdc8:	aa1403e0 	mov	x0, x20
    4801cdcc:	8b1402a4 	add	x4, x21, x20
    4801cdd0:	0b350283 	add	w3, w20, w21, uxtb
    4801cdd4:	b4000115 	cbz	x21, 4801cdf4 <strstr+0xb4>
    4801cdd8:	39400001 	ldrb	w1, [x0]
    4801cddc:	4b000062 	sub	w2, w3, w0
    4801cde0:	91000400 	add	x0, x0, #0x1
    4801cde4:	92401421 	and	x1, x1, #0x3f
    4801cde8:	38216ae2 	strb	w2, [x23, x1]
    4801cdec:	eb04001f 	cmp	x0, x4
    4801cdf0:	54ffff41 	b.ne	4801cdd8 <strstr+0x98>  // b.any
    4801cdf4:	d1000673 	sub	x19, x19, #0x1
    4801cdf8:	38756a60 	ldrb	w0, [x19, x21]
    4801cdfc:	92401400 	and	x0, x0, #0x3f
    4801ce00:	38606ae0 	ldrb	w0, [x23, x0]
    4801ce04:	8b000273 	add	x19, x19, x0
    4801ce08:	eb1302df 	cmp	x22, x19
    4801ce0c:	540000a2 	b.cs	4801ce20 <strstr+0xe0>  // b.hs, b.nlast
    4801ce10:	14000024 	b	4801cea0 <strstr+0x160>
    4801ce14:	8b180273 	add	x19, x19, x24
    4801ce18:	eb1302df 	cmp	x22, x19
    4801ce1c:	54000423 	b.cc	4801cea0 <strstr+0x160>  // b.lo, b.ul, b.last
    4801ce20:	38756a64 	ldrb	w4, [x19, x21]
    4801ce24:	aa1503e2 	mov	x2, x21
    4801ce28:	aa1403e1 	mov	x1, x20
    4801ce2c:	aa1303e0 	mov	x0, x19
    4801ce30:	92401484 	and	x4, x4, #0x3f
    4801ce34:	38646af8 	ldrb	w24, [x23, x4]
    4801ce38:	97fffaf2 	bl	4801ba00 <memcmp>
    4801ce3c:	35fffec0 	cbnz	w0, 4801ce14 <strstr+0xd4>
    4801ce40:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801ce44:	a94363f7 	ldp	x23, x24, [sp, #48]
    4801ce48:	aa1303e0 	mov	x0, x19
    4801ce4c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801ce50:	a8c87bfd 	ldp	x29, x30, [sp], #128
    4801ce54:	d65f03c0 	ret
    4801ce58:	39400260 	ldrb	w0, [x19]
    4801ce5c:	2a014061 	orr	w1, w3, w1, lsl #16
    4801ce60:	52800002 	mov	w2, #0x0                   	// #0
    4801ce64:	34000140 	cbz	w0, 4801ce8c <strstr+0x14c>
    4801ce68:	2a024002 	orr	w2, w0, w2, lsl #16
    4801ce6c:	aa1303e3 	mov	x3, x19
    4801ce70:	38401e60 	ldrb	w0, [x19, #1]!
    4801ce74:	7100001f 	cmp	w0, #0x0
    4801ce78:	7a421024 	ccmp	w1, w2, #0x4, ne  // ne = any
    4801ce7c:	54ffff61 	b.ne	4801ce68 <strstr+0x128>  // b.any
    4801ce80:	d1000473 	sub	x19, x3, #0x1
    4801ce84:	6b02003f 	cmp	w1, w2
    4801ce88:	54fffe00 	b.eq	4801ce48 <strstr+0x108>  // b.none
    4801ce8c:	d2800013 	mov	x19, #0x0                   	// #0
    4801ce90:	aa1303e0 	mov	x0, x19
    4801ce94:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801ce98:	a8c87bfd 	ldp	x29, x30, [sp], #128
    4801ce9c:	d65f03c0 	ret
    4801cea0:	38756ac1 	ldrb	w1, [x22, x21]
    4801cea4:	8b1502c0 	add	x0, x22, x21
    4801cea8:	340000c1 	cbz	w1, 4801cec0 <strstr+0x180>
    4801ceac:	d2810001 	mov	x1, #0x800                 	// #2048
    4801ceb0:	97fffdfd 	bl	4801c6a4 <strnlen>
    4801ceb4:	8b0002d6 	add	x22, x22, x0
    4801ceb8:	eb1302df 	cmp	x22, x19
    4801cebc:	54fff9c2 	b.cs	4801cdf4 <strstr+0xb4>  // b.hs, b.nlast
    4801cec0:	d2800013 	mov	x19, #0x0                   	// #0
    4801cec4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801cec8:	a94363f7 	ldp	x23, x24, [sp, #48]
    4801cecc:	17ffffdf 	b	4801ce48 <strstr+0x108>
    4801ced0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801ced4:	a8c87bfd 	ldp	x29, x30, [sp], #128
    4801ced8:	17fffdaf 	b	4801c594 <strchr>
    4801cedc:	39400260 	ldrb	w0, [x19]
    4801cee0:	34fffd60 	cbz	w0, 4801ce8c <strstr+0x14c>
    4801cee4:	b9400282 	ldr	w2, [x20]
    4801cee8:	52800001 	mov	w1, #0x0                   	// #0
    4801ceec:	5ac00842 	rev	w2, w2
    4801cef0:	2a012001 	orr	w1, w0, w1, lsl #8
    4801cef4:	aa1303e3 	mov	x3, x19
    4801cef8:	38401e60 	ldrb	w0, [x19, #1]!
    4801cefc:	7100001f 	cmp	w0, #0x0
    4801cf00:	7a421024 	ccmp	w1, w2, #0x4, ne  // ne = any
    4801cf04:	54ffff61 	b.ne	4801cef0 <strstr+0x1b0>  // b.any
    4801cf08:	d1000c73 	sub	x19, x3, #0x3
    4801cf0c:	6b02003f 	cmp	w1, w2
    4801cf10:	54fff9c0 	b.eq	4801ce48 <strstr+0x108>  // b.none
    4801cf14:	17ffffde 	b	4801ce8c <strstr+0x14c>
    4801cf18:	39400262 	ldrb	w2, [x19]
    4801cf1c:	53103c63 	lsl	w3, w3, #16
    4801cf20:	2a016061 	orr	w1, w3, w1, lsl #24
    4801cf24:	2a002021 	orr	w1, w1, w0, lsl #8
    4801cf28:	34fffb22 	cbz	w2, 4801ce8c <strstr+0x14c>
    4801cf2c:	52800000 	mov	w0, #0x0                   	// #0
    4801cf30:	2a000040 	orr	w0, w2, w0
    4801cf34:	aa1303e3 	mov	x3, x19
    4801cf38:	38401e62 	ldrb	w2, [x19, #1]!
    4801cf3c:	53185c00 	lsl	w0, w0, #8
    4801cf40:	7100005f 	cmp	w2, #0x0
    4801cf44:	7a401024 	ccmp	w1, w0, #0x4, ne  // ne = any
    4801cf48:	54ffff41 	b.ne	4801cf30 <strstr+0x1f0>  // b.any
    4801cf4c:	d1000873 	sub	x19, x3, #0x2
    4801cf50:	6b00003f 	cmp	w1, w0
    4801cf54:	54fff7a0 	b.eq	4801ce48 <strstr+0x108>  // b.none
    4801cf58:	17ffffcd 	b	4801ce8c <strstr+0x14c>
    4801cf5c:	d2800013 	mov	x19, #0x0                   	// #0
    4801cf60:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801cf64:	17ffffcb 	b	4801ce90 <strstr+0x150>
    4801cf68:	aa1503e3 	mov	x3, x21
    4801cf6c:	aa1403e2 	mov	x2, x20
    4801cf70:	aa0003e1 	mov	x1, x0
    4801cf74:	aa1303e0 	mov	x0, x19
    4801cf78:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801cf7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801cf80:	a8c87bfd 	ldp	x29, x30, [sp], #128
    4801cf84:	17fffe67 	b	4801c920 <two_way_long_needle>
	...

000000004801cf90 <_strtol_l.part.0>:
    4801cf90:	b0000027 	adrp	x7, 48021000 <__fsym_help_desc+0x8>
    4801cf94:	aa0003ec 	mov	x12, x0
    4801cf98:	aa0103e6 	mov	x6, x1
    4801cf9c:	910944e7 	add	x7, x7, #0x251
    4801cfa0:	aa0603e8 	mov	x8, x6
    4801cfa4:	384014c4 	ldrb	w4, [x6], #1
    4801cfa8:	92401c85 	and	x5, x4, #0xff
    4801cfac:	386568e5 	ldrb	w5, [x7, x5]
    4801cfb0:	371fff85 	tbnz	w5, #3, 4801cfa0 <_strtol_l.part.0+0x10>
    4801cfb4:	2a0403e5 	mov	w5, w4
    4801cfb8:	7100b49f 	cmp	w4, #0x2d
    4801cfbc:	54000880 	b.eq	4801d0cc <_strtol_l.part.0+0x13c>  // b.none
    4801cfc0:	92f0000b 	mov	x11, #0x7fffffffffffffff    	// #9223372036854775807
    4801cfc4:	5280000d 	mov	w13, #0x0                   	// #0
    4801cfc8:	7100ac9f 	cmp	w4, #0x2b
    4801cfcc:	540006a0 	b.eq	4801d0a0 <_strtol_l.part.0+0x110>  // b.none
    4801cfd0:	721b787f 	tst	w3, #0xffffffef
    4801cfd4:	54000121 	b.ne	4801cff8 <_strtol_l.part.0+0x68>  // b.any
    4801cfd8:	7100c0bf 	cmp	w5, #0x30
    4801cfdc:	54000820 	b.eq	4801d0e0 <_strtol_l.part.0+0x150>  // b.none
    4801cfe0:	350000c3 	cbnz	w3, 4801cff8 <_strtol_l.part.0+0x68>
    4801cfe4:	d280014a 	mov	x10, #0xa                   	// #10
    4801cfe8:	2a0a03e3 	mov	w3, w10
    4801cfec:	14000004 	b	4801cffc <_strtol_l.part.0+0x6c>
    4801cff0:	34000903 	cbz	w3, 4801d110 <_strtol_l.part.0+0x180>
    4801cff4:	d503201f 	nop
    4801cff8:	93407c6a 	sxtw	x10, w3
    4801cffc:	9aca0968 	udiv	x8, x11, x10
    4801d000:	52800007 	mov	w7, #0x0                   	// #0
    4801d004:	d2800000 	mov	x0, #0x0                   	// #0
    4801d008:	1b0aad09 	msub	w9, w8, w10, w11
    4801d00c:	d503201f 	nop
    4801d010:	5100c0a4 	sub	w4, w5, #0x30
    4801d014:	7100249f 	cmp	w4, #0x9
    4801d018:	540000a9 	b.ls	4801d02c <_strtol_l.part.0+0x9c>  // b.plast
    4801d01c:	510104a4 	sub	w4, w5, #0x41
    4801d020:	7100649f 	cmp	w4, #0x19
    4801d024:	54000208 	b.hi	4801d064 <_strtol_l.part.0+0xd4>  // b.pmore
    4801d028:	5100dca4 	sub	w4, w5, #0x37
    4801d02c:	6b04007f 	cmp	w3, w4
    4801d030:	5400028d 	b.le	4801d080 <_strtol_l.part.0+0xf0>
    4801d034:	710000ff 	cmp	w7, #0x0
    4801d038:	12800007 	mov	w7, #0xffffffff            	// #-1
    4801d03c:	fa40a100 	ccmp	x8, x0, #0x0, ge  // ge = tcont
    4801d040:	540000e3 	b.cc	4801d05c <_strtol_l.part.0+0xcc>  // b.lo, b.ul, b.last
    4801d044:	eb00011f 	cmp	x8, x0
    4801d048:	7a440120 	ccmp	w9, w4, #0x0, eq  // eq = none
    4801d04c:	5400008b 	b.lt	4801d05c <_strtol_l.part.0+0xcc>  // b.tstop
    4801d050:	93407c84 	sxtw	x4, w4
    4801d054:	52800027 	mov	w7, #0x1                   	// #1
    4801d058:	9b0a1000 	madd	x0, x0, x10, x4
    4801d05c:	384014c5 	ldrb	w5, [x6], #1
    4801d060:	17ffffec 	b	4801d010 <_strtol_l.part.0+0x80>
    4801d064:	510184a4 	sub	w4, w5, #0x61
    4801d068:	7100649f 	cmp	w4, #0x19
    4801d06c:	540000a8 	b.hi	4801d080 <_strtol_l.part.0+0xf0>  // b.pmore
    4801d070:	51015ca4 	sub	w4, w5, #0x57
    4801d074:	6b04007f 	cmp	w3, w4
    4801d078:	54fffdec 	b.gt	4801d034 <_strtol_l.part.0+0xa4>
    4801d07c:	d503201f 	nop
    4801d080:	310004ff 	cmn	w7, #0x1
    4801d084:	54000140 	b.eq	4801d0ac <_strtol_l.part.0+0x11c>  // b.none
    4801d088:	710001bf 	cmp	w13, #0x0
    4801d08c:	da800400 	cneg	x0, x0, ne  // ne = any
    4801d090:	b4000062 	cbz	x2, 4801d09c <_strtol_l.part.0+0x10c>
    4801d094:	350003a7 	cbnz	w7, 4801d108 <_strtol_l.part.0+0x178>
    4801d098:	f9000041 	str	x1, [x2]
    4801d09c:	d65f03c0 	ret
    4801d0a0:	394000c5 	ldrb	w5, [x6]
    4801d0a4:	91000906 	add	x6, x8, #0x2
    4801d0a8:	17ffffca 	b	4801cfd0 <_strtol_l.part.0+0x40>
    4801d0ac:	52800440 	mov	w0, #0x22                  	// #34
    4801d0b0:	b9000180 	str	w0, [x12]
    4801d0b4:	aa0b03e0 	mov	x0, x11
    4801d0b8:	b4ffff22 	cbz	x2, 4801d09c <_strtol_l.part.0+0x10c>
    4801d0bc:	d10004c1 	sub	x1, x6, #0x1
    4801d0c0:	aa0b03e0 	mov	x0, x11
    4801d0c4:	f9000041 	str	x1, [x2]
    4801d0c8:	17fffff5 	b	4801d09c <_strtol_l.part.0+0x10c>
    4801d0cc:	394000c5 	ldrb	w5, [x6]
    4801d0d0:	d2f0000b 	mov	x11, #0x8000000000000000    	// #-9223372036854775808
    4801d0d4:	91000906 	add	x6, x8, #0x2
    4801d0d8:	5280002d 	mov	w13, #0x1                   	// #1
    4801d0dc:	17ffffbd 	b	4801cfd0 <_strtol_l.part.0+0x40>
    4801d0e0:	394000c0 	ldrb	w0, [x6]
    4801d0e4:	121a7800 	and	w0, w0, #0xffffffdf
    4801d0e8:	12001c00 	and	w0, w0, #0xff
    4801d0ec:	7101601f 	cmp	w0, #0x58
    4801d0f0:	54fff801 	b.ne	4801cff0 <_strtol_l.part.0+0x60>  // b.any
    4801d0f4:	394004c5 	ldrb	w5, [x6, #1]
    4801d0f8:	d280020a 	mov	x10, #0x10                  	// #16
    4801d0fc:	910008c6 	add	x6, x6, #0x2
    4801d100:	2a0a03e3 	mov	w3, w10
    4801d104:	17ffffbe 	b	4801cffc <_strtol_l.part.0+0x6c>
    4801d108:	aa0003eb 	mov	x11, x0
    4801d10c:	17ffffec 	b	4801d0bc <_strtol_l.part.0+0x12c>
    4801d110:	d280010a 	mov	x10, #0x8                   	// #8
    4801d114:	2a0a03e3 	mov	w3, w10
    4801d118:	17ffffb9 	b	4801cffc <_strtol_l.part.0+0x6c>
    4801d11c:	00000000 	udf	#0

000000004801d120 <strtol>:
    4801d120:	7100905f 	cmp	w2, #0x24
    4801d124:	7a419844 	ccmp	w2, #0x1, #0x4, ls  // ls = plast
    4801d128:	540000e0 	b.eq	4801d144 <strtol+0x24>  // b.none
    4801d12c:	90000024 	adrp	x4, 48021000 <__fsym_help_desc+0x8>
    4801d130:	2a0203e3 	mov	w3, w2
    4801d134:	aa0103e2 	mov	x2, x1
    4801d138:	aa0003e1 	mov	x1, x0
    4801d13c:	f943cc80 	ldr	x0, [x4, #1944]
    4801d140:	17ffff94 	b	4801cf90 <_strtol_l.part.0>
    4801d144:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4801d148:	910003fd 	mov	x29, sp
    4801d14c:	97fff56c 	bl	4801a6fc <__errno>
    4801d150:	528002c1 	mov	w1, #0x16                  	// #22
    4801d154:	b9000001 	str	w1, [x0]
    4801d158:	d2800000 	mov	x0, #0x0                   	// #0
    4801d15c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4801d160:	d65f03c0 	ret
	...

000000004801d170 <_cleanup_r>:
    4801d170:	90000001 	adrp	x1, 4801d000 <_strtol_l.part.0+0x70>
    4801d174:	91208021 	add	x1, x1, #0x820
    4801d178:	14000086 	b	4801d390 <_fwalk_reent>
    4801d17c:	00000000 	udf	#0

000000004801d180 <__sinit.part.0>:
    4801d180:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4801d184:	52800065 	mov	w5, #0x3                   	// #3
    4801d188:	90000001 	adrp	x1, 4801d000 <_strtol_l.part.0+0x70>
    4801d18c:	910003fd 	mov	x29, sp
    4801d190:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d194:	aa0003f5 	mov	x21, x0
    4801d198:	9114e2a4 	add	x4, x21, #0x538
    4801d19c:	a90153f3 	stp	x19, x20, [sp, #16]
    4801d1a0:	9105c020 	add	x0, x1, #0x170
    4801d1a4:	52800083 	mov	w3, #0x4                   	// #4
    4801d1a8:	f94006b3 	ldr	x19, [x21, #8]
    4801d1ac:	a90363f7 	stp	x23, x24, [sp, #48]
    4801d1b0:	d2800102 	mov	x2, #0x8                   	// #8
    4801d1b4:	f90023f9 	str	x25, [sp, #64]
    4801d1b8:	52800001 	mov	w1, #0x0                   	// #0
    4801d1bc:	f9002ea0 	str	x0, [x21, #88]
    4801d1c0:	91029260 	add	x0, x19, #0xa4
    4801d1c4:	f90292bf 	str	xzr, [x21, #1312]
    4801d1c8:	90000018 	adrp	x24, 4801d000 <_strtol_l.part.0+0x70>
    4801d1cc:	b9052aa5 	str	w5, [x21, #1320]
    4801d1d0:	911a8318 	add	x24, x24, #0x6a0
    4801d1d4:	f9029aa4 	str	x4, [x21, #1328]
    4801d1d8:	90000017 	adrp	x23, 4801d000 <_strtol_l.part.0+0x70>
    4801d1dc:	a9007e7f 	stp	xzr, xzr, [x19]
    4801d1e0:	911c42f7 	add	x23, x23, #0x710
    4801d1e4:	90000016 	adrp	x22, 4801d000 <_strtol_l.part.0+0x70>
    4801d1e8:	b9001263 	str	w3, [x19, #16]
    4801d1ec:	911d82d6 	add	x22, x22, #0x760
    4801d1f0:	f9000e7f 	str	xzr, [x19, #24]
    4801d1f4:	90000019 	adrp	x25, 4801d000 <_strtol_l.part.0+0x70>
    4801d1f8:	b900227f 	str	wzr, [x19, #32]
    4801d1fc:	91194339 	add	x25, x25, #0x650
    4801d200:	b9002a7f 	str	wzr, [x19, #40]
    4801d204:	b900ae7f 	str	wzr, [x19, #172]
    4801d208:	97fffaae 	bl	4801bcc0 <memset>
    4801d20c:	f9400ab4 	ldr	x20, [x21, #16]
    4801d210:	52800123 	mov	w3, #0x9                   	// #9
    4801d214:	a9036673 	stp	x19, x25, [x19, #48]
    4801d218:	72a00023 	movk	w3, #0x1, lsl #16
    4801d21c:	91029280 	add	x0, x20, #0xa4
    4801d220:	a9045e78 	stp	x24, x23, [x19, #64]
    4801d224:	d2800102 	mov	x2, #0x8                   	// #8
    4801d228:	52800001 	mov	w1, #0x0                   	// #0
    4801d22c:	f9002a76 	str	x22, [x19, #80]
    4801d230:	a9007e9f 	stp	xzr, xzr, [x20]
    4801d234:	b9001283 	str	w3, [x20, #16]
    4801d238:	f9000e9f 	str	xzr, [x20, #24]
    4801d23c:	b900229f 	str	wzr, [x20, #32]
    4801d240:	b9002a9f 	str	wzr, [x20, #40]
    4801d244:	b900ae9f 	str	wzr, [x20, #172]
    4801d248:	97fffa9e 	bl	4801bcc0 <memset>
    4801d24c:	f9400eb3 	ldr	x19, [x21, #24]
    4801d250:	52800243 	mov	w3, #0x12                  	// #18
    4801d254:	a9036694 	stp	x20, x25, [x20, #48]
    4801d258:	72a00043 	movk	w3, #0x2, lsl #16
    4801d25c:	91029260 	add	x0, x19, #0xa4
    4801d260:	a9045e98 	stp	x24, x23, [x20, #64]
    4801d264:	d2800102 	mov	x2, #0x8                   	// #8
    4801d268:	52800001 	mov	w1, #0x0                   	// #0
    4801d26c:	f9002a96 	str	x22, [x20, #80]
    4801d270:	a9007e7f 	stp	xzr, xzr, [x19]
    4801d274:	b9001263 	str	w3, [x19, #16]
    4801d278:	f9000e7f 	str	xzr, [x19, #24]
    4801d27c:	b900227f 	str	wzr, [x19, #32]
    4801d280:	b9002a7f 	str	wzr, [x19, #40]
    4801d284:	b900ae7f 	str	wzr, [x19, #172]
    4801d288:	97fffa8e 	bl	4801bcc0 <memset>
    4801d28c:	a9036673 	stp	x19, x25, [x19, #48]
    4801d290:	52800020 	mov	w0, #0x1                   	// #1
    4801d294:	a9045e78 	stp	x24, x23, [x19, #64]
    4801d298:	f9002a76 	str	x22, [x19, #80]
    4801d29c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d2a0:	a94363f7 	ldp	x23, x24, [sp, #48]
    4801d2a4:	f94023f9 	ldr	x25, [sp, #64]
    4801d2a8:	b90052a0 	str	w0, [x21, #80]
    4801d2ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d2b0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4801d2b4:	d65f03c0 	ret
	...

000000004801d2c0 <__sinit>:
    4801d2c0:	b9405001 	ldr	w1, [x0, #80]
    4801d2c4:	34000041 	cbz	w1, 4801d2cc <__sinit+0xc>
    4801d2c8:	d65f03c0 	ret
    4801d2cc:	17ffffad 	b	4801d180 <__sinit.part.0>

000000004801d2d0 <__sfp_lock_acquire>:
    4801d2d0:	d65f03c0 	ret
	...

000000004801d2e0 <__sfp_lock_release>:
    4801d2e0:	d65f03c0 	ret
	...

000000004801d2f0 <_fwalk>:
    4801d2f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801d2f4:	910003fd 	mov	x29, sp
    4801d2f8:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d2fc:	91148015 	add	x21, x0, #0x520
    4801d300:	aa0103f6 	mov	x22, x1
    4801d304:	a90153f3 	stp	x19, x20, [sp, #16]
    4801d308:	f9001bf7 	str	x23, [sp, #48]
    4801d30c:	52800017 	mov	w23, #0x0                   	// #0
    4801d310:	b9400aa0 	ldr	w0, [x21, #8]
    4801d314:	f9400ab3 	ldr	x19, [x21, #16]
    4801d318:	7100001f 	cmp	w0, #0x0
    4801d31c:	5400026d 	b.le	4801d368 <_fwalk+0x78>
    4801d320:	51000400 	sub	w0, w0, #0x1
    4801d324:	91000400 	add	x0, x0, #0x1
    4801d328:	8b000414 	add	x20, x0, x0, lsl #1
    4801d32c:	d37ef694 	lsl	x20, x20, #2
    4801d330:	cb000294 	sub	x20, x20, x0
    4801d334:	8b141274 	add	x20, x19, x20, lsl #4
    4801d338:	79402260 	ldrh	w0, [x19, #16]
    4801d33c:	7100041f 	cmp	w0, #0x1
    4801d340:	540000e9 	b.ls	4801d35c <_fwalk+0x6c>  // b.plast
    4801d344:	79c02662 	ldrsh	w2, [x19, #18]
    4801d348:	aa1303e0 	mov	x0, x19
    4801d34c:	3100045f 	cmn	w2, #0x1
    4801d350:	54000060 	b.eq	4801d35c <_fwalk+0x6c>  // b.none
    4801d354:	d63f02c0 	blr	x22
    4801d358:	2a0002f7 	orr	w23, w23, w0
    4801d35c:	9102c273 	add	x19, x19, #0xb0
    4801d360:	eb13029f 	cmp	x20, x19
    4801d364:	54fffea1 	b.ne	4801d338 <_fwalk+0x48>  // b.any
    4801d368:	f94002b5 	ldr	x21, [x21]
    4801d36c:	b5fffd35 	cbnz	x21, 4801d310 <_fwalk+0x20>
    4801d370:	2a1703e0 	mov	w0, w23
    4801d374:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d378:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d37c:	f9401bf7 	ldr	x23, [sp, #48]
    4801d380:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801d384:	d65f03c0 	ret
	...

000000004801d390 <_fwalk_reent>:
    4801d390:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4801d394:	910003fd 	mov	x29, sp
    4801d398:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d39c:	aa0103f6 	mov	x22, x1
    4801d3a0:	91148015 	add	x21, x0, #0x520
    4801d3a4:	a90363f7 	stp	x23, x24, [sp, #48]
    4801d3a8:	aa0003f8 	mov	x24, x0
    4801d3ac:	52800017 	mov	w23, #0x0                   	// #0
    4801d3b0:	a90153f3 	stp	x19, x20, [sp, #16]
    4801d3b4:	d503201f 	nop
    4801d3b8:	b9400aa2 	ldr	w2, [x21, #8]
    4801d3bc:	f9400ab3 	ldr	x19, [x21, #16]
    4801d3c0:	7100005f 	cmp	w2, #0x0
    4801d3c4:	5400028d 	b.le	4801d414 <_fwalk_reent+0x84>
    4801d3c8:	51000442 	sub	w2, w2, #0x1
    4801d3cc:	91000442 	add	x2, x2, #0x1
    4801d3d0:	8b020454 	add	x20, x2, x2, lsl #1
    4801d3d4:	d37ef694 	lsl	x20, x20, #2
    4801d3d8:	cb020294 	sub	x20, x20, x2
    4801d3dc:	8b141274 	add	x20, x19, x20, lsl #4
    4801d3e0:	79402262 	ldrh	w2, [x19, #16]
    4801d3e4:	7100045f 	cmp	w2, #0x1
    4801d3e8:	54000109 	b.ls	4801d408 <_fwalk_reent+0x78>  // b.plast
    4801d3ec:	79c02662 	ldrsh	w2, [x19, #18]
    4801d3f0:	aa1303e1 	mov	x1, x19
    4801d3f4:	aa1803e0 	mov	x0, x24
    4801d3f8:	3100045f 	cmn	w2, #0x1
    4801d3fc:	54000060 	b.eq	4801d408 <_fwalk_reent+0x78>  // b.none
    4801d400:	d63f02c0 	blr	x22
    4801d404:	2a0002f7 	orr	w23, w23, w0
    4801d408:	9102c273 	add	x19, x19, #0xb0
    4801d40c:	eb13029f 	cmp	x20, x19
    4801d410:	54fffe81 	b.ne	4801d3e0 <_fwalk_reent+0x50>  // b.any
    4801d414:	f94002b5 	ldr	x21, [x21]
    4801d418:	b5fffd15 	cbnz	x21, 4801d3b8 <_fwalk_reent+0x28>
    4801d41c:	2a1703e0 	mov	w0, w23
    4801d420:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d424:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d428:	a94363f7 	ldp	x23, x24, [sp, #48]
    4801d42c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4801d430:	d65f03c0 	ret
	...

000000004801d440 <lflush>:
    4801d440:	79402002 	ldrh	w2, [x0, #16]
    4801d444:	52800121 	mov	w1, #0x9                   	// #9
    4801d448:	0a020021 	and	w1, w1, w2
    4801d44c:	7100243f 	cmp	w1, #0x9
    4801d450:	54000060 	b.eq	4801d45c <lflush+0x1c>  // b.none
    4801d454:	52800000 	mov	w0, #0x0                   	// #0
    4801d458:	d65f03c0 	ret
    4801d45c:	140001b1 	b	4801db20 <fflush>

000000004801d460 <__srefill_r>:
    4801d460:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801d464:	910003fd 	mov	x29, sp
    4801d468:	a90153f3 	stp	x19, x20, [sp, #16]
    4801d46c:	aa0103f3 	mov	x19, x1
    4801d470:	aa0003f4 	mov	x20, x0
    4801d474:	b4000060 	cbz	x0, 4801d480 <__srefill_r+0x20>
    4801d478:	b9405001 	ldr	w1, [x0, #80]
    4801d47c:	340009a1 	cbz	w1, 4801d5b0 <__srefill_r+0x150>
    4801d480:	79c02261 	ldrsh	w1, [x19, #16]
    4801d484:	12003c20 	and	w0, w1, #0xffff
    4801d488:	376800e1 	tbnz	w1, #13, 4801d4a4 <__srefill_r+0x44>
    4801d48c:	b940ae62 	ldr	w2, [x19, #172]
    4801d490:	32130021 	orr	w1, w1, #0x2000
    4801d494:	12003c20 	and	w0, w1, #0xffff
    4801d498:	79002261 	strh	w1, [x19, #16]
    4801d49c:	12127842 	and	w2, w2, #0xffffdfff
    4801d4a0:	b900ae62 	str	w2, [x19, #172]
    4801d4a4:	b9000a7f 	str	wzr, [x19, #8]
    4801d4a8:	37280a80 	tbnz	w0, #5, 4801d5f8 <__srefill_r+0x198>
    4801d4ac:	37100360 	tbnz	w0, #2, 4801d518 <__srefill_r+0xb8>
    4801d4b0:	36200b60 	tbz	w0, #4, 4801d61c <__srefill_r+0x1bc>
    4801d4b4:	371808e0 	tbnz	w0, #3, 4801d5d0 <__srefill_r+0x170>
    4801d4b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d4bc:	321e0021 	orr	w1, w1, #0x4
    4801d4c0:	f9400e60 	ldr	x0, [x19, #24]
    4801d4c4:	79002261 	strh	w1, [x19, #16]
    4801d4c8:	b4000440 	cbz	x0, 4801d550 <__srefill_r+0xf0>
    4801d4cc:	79c02275 	ldrsh	w21, [x19, #16]
    4801d4d0:	12003eb6 	and	w22, w21, #0xffff
    4801d4d4:	f24006bf 	tst	x21, #0x3
    4801d4d8:	540004c1 	b.ne	4801d570 <__srefill_r+0x110>  // b.any
    4801d4dc:	a9431261 	ldp	x1, x4, [x19, #48]
    4801d4e0:	aa1403e0 	mov	x0, x20
    4801d4e4:	b9402263 	ldr	w3, [x19, #32]
    4801d4e8:	f9400e62 	ldr	x2, [x19, #24]
    4801d4ec:	f9000262 	str	x2, [x19]
    4801d4f0:	d63f0080 	blr	x4
    4801d4f4:	2a0003e1 	mov	w1, w0
    4801d4f8:	b9000a61 	str	w1, [x19, #8]
    4801d4fc:	52800000 	mov	w0, #0x0                   	// #0
    4801d500:	7100003f 	cmp	w1, #0x0
    4801d504:	540007ed 	b.le	4801d600 <__srefill_r+0x1a0>
    4801d508:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d50c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d510:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801d514:	d65f03c0 	ret
    4801d518:	f9402e61 	ldr	x1, [x19, #88]
    4801d51c:	b4000141 	cbz	x1, 4801d544 <__srefill_r+0xe4>
    4801d520:	9101d260 	add	x0, x19, #0x74
    4801d524:	eb00003f 	cmp	x1, x0
    4801d528:	54000060 	b.eq	4801d534 <__srefill_r+0xd4>  // b.none
    4801d52c:	aa1403e0 	mov	x0, x20
    4801d530:	97fff468 	bl	4801a6d0 <_free_r>
    4801d534:	b9407260 	ldr	w0, [x19, #112]
    4801d538:	b9000a60 	str	w0, [x19, #8]
    4801d53c:	f9002e7f 	str	xzr, [x19, #88]
    4801d540:	350003c0 	cbnz	w0, 4801d5b8 <__srefill_r+0x158>
    4801d544:	f9400e60 	ldr	x0, [x19, #24]
    4801d548:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d54c:	b5fffc00 	cbnz	x0, 4801d4cc <__srefill_r+0x6c>
    4801d550:	aa1303e1 	mov	x1, x19
    4801d554:	aa1403e0 	mov	x0, x20
    4801d558:	94000192 	bl	4801dba0 <__smakebuf_r>
    4801d55c:	79c02275 	ldrsh	w21, [x19, #16]
    4801d560:	12003eb6 	and	w22, w21, #0xffff
    4801d564:	f24006bf 	tst	x21, #0x3
    4801d568:	54fffba0 	b.eq	4801d4dc <__srefill_r+0x7c>  // b.none
    4801d56c:	d503201f 	nop
    4801d570:	90000020 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4801d574:	52800021 	mov	w1, #0x1                   	// #1
    4801d578:	79002261 	strh	w1, [x19, #16]
    4801d57c:	90000001 	adrp	x1, 4801d000 <_strtol_l.part.0+0x70>
    4801d580:	f9412400 	ldr	x0, [x0, #584]
    4801d584:	91110021 	add	x1, x1, #0x440
    4801d588:	97ffff5a 	bl	4801d2f0 <_fwalk>
    4801d58c:	79002275 	strh	w21, [x19, #16]
    4801d590:	52800120 	mov	w0, #0x9                   	// #9
    4801d594:	0a0002d6 	and	w22, w22, w0
    4801d598:	6b0002df 	cmp	w22, w0
    4801d59c:	54fffa01 	b.ne	4801d4dc <__srefill_r+0x7c>  // b.any
    4801d5a0:	aa1303e1 	mov	x1, x19
    4801d5a4:	aa1403e0 	mov	x0, x20
    4801d5a8:	940000ba 	bl	4801d890 <__sflush_r>
    4801d5ac:	17ffffcc 	b	4801d4dc <__srefill_r+0x7c>
    4801d5b0:	97ffff44 	bl	4801d2c0 <__sinit>
    4801d5b4:	17ffffb3 	b	4801d480 <__srefill_r+0x20>
    4801d5b8:	f9403661 	ldr	x1, [x19, #104]
    4801d5bc:	f9000261 	str	x1, [x19]
    4801d5c0:	52800000 	mov	w0, #0x0                   	// #0
    4801d5c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d5c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801d5cc:	d65f03c0 	ret
    4801d5d0:	aa1303e1 	mov	x1, x19
    4801d5d4:	aa1403e0 	mov	x0, x20
    4801d5d8:	9400013a 	bl	4801dac0 <_fflush_r>
    4801d5dc:	350000e0 	cbnz	w0, 4801d5f8 <__srefill_r+0x198>
    4801d5e0:	79c02261 	ldrsh	w1, [x19, #16]
    4801d5e4:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d5e8:	121c7821 	and	w1, w1, #0xfffffff7
    4801d5ec:	b9000e7f 	str	wzr, [x19, #12]
    4801d5f0:	b9002a7f 	str	wzr, [x19, #40]
    4801d5f4:	17ffffb2 	b	4801d4bc <__srefill_r+0x5c>
    4801d5f8:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801d5fc:	17ffffc4 	b	4801d50c <__srefill_r+0xac>
    4801d600:	79c02260 	ldrsh	w0, [x19, #16]
    4801d604:	54000181 	b.ne	4801d634 <__srefill_r+0x1d4>  // b.any
    4801d608:	321b0001 	orr	w1, w0, #0x20
    4801d60c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801d610:	79002261 	strh	w1, [x19, #16]
    4801d614:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d618:	17ffffbd 	b	4801d50c <__srefill_r+0xac>
    4801d61c:	52800120 	mov	w0, #0x9                   	// #9
    4801d620:	b9000280 	str	w0, [x20]
    4801d624:	321a0021 	orr	w1, w1, #0x40
    4801d628:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801d62c:	79002261 	strh	w1, [x19, #16]
    4801d630:	17ffffb7 	b	4801d50c <__srefill_r+0xac>
    4801d634:	321a0001 	orr	w1, w0, #0x40
    4801d638:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801d63c:	79002261 	strh	w1, [x19, #16]
    4801d640:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d644:	b9000a7f 	str	wzr, [x19, #8]
    4801d648:	17ffffb1 	b	4801d50c <__srefill_r+0xac>
    4801d64c:	00000000 	udf	#0

000000004801d650 <__sread>:
    4801d650:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801d654:	93407c63 	sxtw	x3, w3
    4801d658:	910003fd 	mov	x29, sp
    4801d65c:	f9000bf3 	str	x19, [sp, #16]
    4801d660:	aa0103f3 	mov	x19, x1
    4801d664:	79c02421 	ldrsh	w1, [x1, #18]
    4801d668:	97fff4be 	bl	4801a960 <_read_r>
    4801d66c:	b7f800e0 	tbnz	x0, #63, 4801d688 <__sread+0x38>
    4801d670:	f9404a61 	ldr	x1, [x19, #144]
    4801d674:	8b000021 	add	x1, x1, x0
    4801d678:	f9004a61 	str	x1, [x19, #144]
    4801d67c:	f9400bf3 	ldr	x19, [sp, #16]
    4801d680:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801d684:	d65f03c0 	ret
    4801d688:	79402261 	ldrh	w1, [x19, #16]
    4801d68c:	12137821 	and	w1, w1, #0xffffefff
    4801d690:	79002261 	strh	w1, [x19, #16]
    4801d694:	f9400bf3 	ldr	x19, [sp, #16]
    4801d698:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801d69c:	d65f03c0 	ret

000000004801d6a0 <__swrite>:
    4801d6a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801d6a4:	910003fd 	mov	x29, sp
    4801d6a8:	79c02024 	ldrsh	w4, [x1, #16]
    4801d6ac:	a90153f3 	stp	x19, x20, [sp, #16]
    4801d6b0:	aa0103f3 	mov	x19, x1
    4801d6b4:	aa0003f4 	mov	x20, x0
    4801d6b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d6bc:	aa0203f5 	mov	x21, x2
    4801d6c0:	79c02421 	ldrsh	w1, [x1, #18]
    4801d6c4:	2a0303f6 	mov	w22, w3
    4801d6c8:	37400164 	tbnz	w4, #8, 4801d6f4 <__swrite+0x54>
    4801d6cc:	12137884 	and	w4, w4, #0xffffefff
    4801d6d0:	79002264 	strh	w4, [x19, #16]
    4801d6d4:	93407ec3 	sxtw	x3, w22
    4801d6d8:	aa1503e2 	mov	x2, x21
    4801d6dc:	aa1403e0 	mov	x0, x20
    4801d6e0:	97fff4e2 	bl	4801aa68 <_write_r>
    4801d6e4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d6e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d6ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801d6f0:	d65f03c0 	ret
    4801d6f4:	52800043 	mov	w3, #0x2                   	// #2
    4801d6f8:	d2800002 	mov	x2, #0x0                   	// #0
    4801d6fc:	97fff470 	bl	4801a8bc <_lseek_r>
    4801d700:	79c02264 	ldrsh	w4, [x19, #16]
    4801d704:	79c02661 	ldrsh	w1, [x19, #18]
    4801d708:	17fffff1 	b	4801d6cc <__swrite+0x2c>
    4801d70c:	00000000 	udf	#0

000000004801d710 <__sseek>:
    4801d710:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801d714:	910003fd 	mov	x29, sp
    4801d718:	f9000bf3 	str	x19, [sp, #16]
    4801d71c:	aa0103f3 	mov	x19, x1
    4801d720:	79c02421 	ldrsh	w1, [x1, #18]
    4801d724:	97fff466 	bl	4801a8bc <_lseek_r>
    4801d728:	79402261 	ldrh	w1, [x19, #16]
    4801d72c:	b100041f 	cmn	x0, #0x1
    4801d730:	540000e0 	b.eq	4801d74c <__sseek+0x3c>  // b.none
    4801d734:	32140021 	orr	w1, w1, #0x1000
    4801d738:	79002261 	strh	w1, [x19, #16]
    4801d73c:	f9004a60 	str	x0, [x19, #144]
    4801d740:	f9400bf3 	ldr	x19, [sp, #16]
    4801d744:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801d748:	d65f03c0 	ret
    4801d74c:	12137821 	and	w1, w1, #0xffffefff
    4801d750:	79002261 	strh	w1, [x19, #16]
    4801d754:	f9400bf3 	ldr	x19, [sp, #16]
    4801d758:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801d75c:	d65f03c0 	ret

000000004801d760 <__sclose>:
    4801d760:	79c02421 	ldrsh	w1, [x1, #18]
    4801d764:	17fff3f0 	b	4801a724 <_close_r>
	...

000000004801d770 <_fclose_r.part.0>:
    4801d770:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801d774:	910003fd 	mov	x29, sp
    4801d778:	a90153f3 	stp	x19, x20, [sp, #16]
    4801d77c:	aa0103f3 	mov	x19, x1
    4801d780:	f90013f5 	str	x21, [sp, #32]
    4801d784:	aa0003f5 	mov	x21, x0
    4801d788:	94000042 	bl	4801d890 <__sflush_r>
    4801d78c:	2a0003f4 	mov	w20, w0
    4801d790:	f9402a62 	ldr	x2, [x19, #80]
    4801d794:	b40000c2 	cbz	x2, 4801d7ac <_fclose_r.part.0+0x3c>
    4801d798:	f9401a61 	ldr	x1, [x19, #48]
    4801d79c:	aa1503e0 	mov	x0, x21
    4801d7a0:	d63f0040 	blr	x2
    4801d7a4:	7100001f 	cmp	w0, #0x0
    4801d7a8:	5a9fa294 	csinv	w20, w20, wzr, ge  // ge = tcont
    4801d7ac:	79402260 	ldrh	w0, [x19, #16]
    4801d7b0:	373802c0 	tbnz	w0, #7, 4801d808 <_fclose_r.part.0+0x98>
    4801d7b4:	f9402e61 	ldr	x1, [x19, #88]
    4801d7b8:	b40000e1 	cbz	x1, 4801d7d4 <_fclose_r.part.0+0x64>
    4801d7bc:	9101d260 	add	x0, x19, #0x74
    4801d7c0:	eb00003f 	cmp	x1, x0
    4801d7c4:	54000060 	b.eq	4801d7d0 <_fclose_r.part.0+0x60>  // b.none
    4801d7c8:	aa1503e0 	mov	x0, x21
    4801d7cc:	97fff3c1 	bl	4801a6d0 <_free_r>
    4801d7d0:	f9002e7f 	str	xzr, [x19, #88]
    4801d7d4:	f9403e61 	ldr	x1, [x19, #120]
    4801d7d8:	b4000081 	cbz	x1, 4801d7e8 <_fclose_r.part.0+0x78>
    4801d7dc:	aa1503e0 	mov	x0, x21
    4801d7e0:	97fff3bc 	bl	4801a6d0 <_free_r>
    4801d7e4:	f9003e7f 	str	xzr, [x19, #120]
    4801d7e8:	97fffeba 	bl	4801d2d0 <__sfp_lock_acquire>
    4801d7ec:	7900227f 	strh	wzr, [x19, #16]
    4801d7f0:	97fffebc 	bl	4801d2e0 <__sfp_lock_release>
    4801d7f4:	2a1403e0 	mov	w0, w20
    4801d7f8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d7fc:	f94013f5 	ldr	x21, [sp, #32]
    4801d800:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801d804:	d65f03c0 	ret
    4801d808:	f9400e61 	ldr	x1, [x19, #24]
    4801d80c:	aa1503e0 	mov	x0, x21
    4801d810:	97fff3b0 	bl	4801a6d0 <_free_r>
    4801d814:	17ffffe8 	b	4801d7b4 <_fclose_r.part.0+0x44>
	...

000000004801d820 <_fclose_r>:
    4801d820:	b4000301 	cbz	x1, 4801d880 <_fclose_r+0x60>
    4801d824:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801d828:	910003fd 	mov	x29, sp
    4801d82c:	f9000bf4 	str	x20, [sp, #16]
    4801d830:	aa0003f4 	mov	x20, x0
    4801d834:	b4000060 	cbz	x0, 4801d840 <_fclose_r+0x20>
    4801d838:	b9405002 	ldr	w2, [x0, #80]
    4801d83c:	34000162 	cbz	w2, 4801d868 <_fclose_r+0x48>
    4801d840:	79c02020 	ldrsh	w0, [x1, #16]
    4801d844:	350000a0 	cbnz	w0, 4801d858 <_fclose_r+0x38>
    4801d848:	52800000 	mov	w0, #0x0                   	// #0
    4801d84c:	f9400bf4 	ldr	x20, [sp, #16]
    4801d850:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801d854:	d65f03c0 	ret
    4801d858:	aa1403e0 	mov	x0, x20
    4801d85c:	f9400bf4 	ldr	x20, [sp, #16]
    4801d860:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801d864:	17ffffc3 	b	4801d770 <_fclose_r.part.0>
    4801d868:	f90017e1 	str	x1, [sp, #40]
    4801d86c:	97fffe95 	bl	4801d2c0 <__sinit>
    4801d870:	f94017e1 	ldr	x1, [sp, #40]
    4801d874:	79c02020 	ldrsh	w0, [x1, #16]
    4801d878:	34fffe80 	cbz	w0, 4801d848 <_fclose_r+0x28>
    4801d87c:	17fffff7 	b	4801d858 <_fclose_r+0x38>
    4801d880:	52800000 	mov	w0, #0x0                   	// #0
    4801d884:	d65f03c0 	ret
	...

000000004801d890 <__sflush_r>:
    4801d890:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801d894:	910003fd 	mov	x29, sp
    4801d898:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801d89c:	aa0003f6 	mov	x22, x0
    4801d8a0:	79c02020 	ldrsh	w0, [x1, #16]
    4801d8a4:	a90153f3 	stp	x19, x20, [sp, #16]
    4801d8a8:	aa0103f3 	mov	x19, x1
    4801d8ac:	37180560 	tbnz	w0, #3, 4801d958 <__sflush_r+0xc8>
    4801d8b0:	32150000 	orr	w0, w0, #0x800
    4801d8b4:	79002020 	strh	w0, [x1, #16]
    4801d8b8:	b9400821 	ldr	w1, [x1, #8]
    4801d8bc:	7100003f 	cmp	w1, #0x0
    4801d8c0:	5400092d 	b.le	4801d9e4 <__sflush_r+0x154>
    4801d8c4:	f9402664 	ldr	x4, [x19, #72]
    4801d8c8:	b4000944 	cbz	x4, 4801d9f0 <__sflush_r+0x160>
    4801d8cc:	b94002d4 	ldr	w20, [x22]
    4801d8d0:	12003c03 	and	w3, w0, #0xffff
    4801d8d4:	f9401a61 	ldr	x1, [x19, #48]
    4801d8d8:	b90002df 	str	wzr, [x22]
    4801d8dc:	37600940 	tbnz	w0, #12, 4801da04 <__sflush_r+0x174>
    4801d8e0:	d2800002 	mov	x2, #0x0                   	// #0
    4801d8e4:	aa1603e0 	mov	x0, x22
    4801d8e8:	52800023 	mov	w3, #0x1                   	// #1
    4801d8ec:	d63f0080 	blr	x4
    4801d8f0:	aa0003e2 	mov	x2, x0
    4801d8f4:	b100041f 	cmn	x0, #0x1
    4801d8f8:	54000d00 	b.eq	4801da98 <__sflush_r+0x208>  // b.none
    4801d8fc:	79402263 	ldrh	w3, [x19, #16]
    4801d900:	f9401a61 	ldr	x1, [x19, #48]
    4801d904:	f9402664 	ldr	x4, [x19, #72]
    4801d908:	361000e3 	tbz	w3, #2, 4801d924 <__sflush_r+0x94>
    4801d90c:	f9402e60 	ldr	x0, [x19, #88]
    4801d910:	b9800a63 	ldrsw	x3, [x19, #8]
    4801d914:	cb030042 	sub	x2, x2, x3
    4801d918:	b4000060 	cbz	x0, 4801d924 <__sflush_r+0x94>
    4801d91c:	b9807260 	ldrsw	x0, [x19, #112]
    4801d920:	cb000042 	sub	x2, x2, x0
    4801d924:	aa1603e0 	mov	x0, x22
    4801d928:	52800003 	mov	w3, #0x0                   	// #0
    4801d92c:	d63f0080 	blr	x4
    4801d930:	b100041f 	cmn	x0, #0x1
    4801d934:	540006c1 	b.ne	4801da0c <__sflush_r+0x17c>  // b.any
    4801d938:	b94002c2 	ldr	w2, [x22]
    4801d93c:	7100745f 	cmp	w2, #0x1d
    4801d940:	54000929 	b.ls	4801da64 <__sflush_r+0x1d4>  // b.plast
    4801d944:	79c02261 	ldrsh	w1, [x19, #16]
    4801d948:	321a0021 	orr	w1, w1, #0x40
    4801d94c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801d950:	79002261 	strh	w1, [x19, #16]
    4801d954:	14000028 	b	4801d9f4 <__sflush_r+0x164>
    4801d958:	f9400c35 	ldr	x21, [x1, #24]
    4801d95c:	b40004b5 	cbz	x21, 4801d9f0 <__sflush_r+0x160>
    4801d960:	12003c01 	and	w1, w0, #0xffff
    4801d964:	52800002 	mov	w2, #0x0                   	// #0
    4801d968:	f9400260 	ldr	x0, [x19]
    4801d96c:	f9000275 	str	x21, [x19]
    4801d970:	cb150000 	sub	x0, x0, x21
    4801d974:	2a0003f4 	mov	w20, w0
    4801d978:	f240043f 	tst	x1, #0x3
    4801d97c:	54000041 	b.ne	4801d984 <__sflush_r+0xf4>  // b.any
    4801d980:	b9402262 	ldr	w2, [x19, #32]
    4801d984:	b9000e62 	str	w2, [x19, #12]
    4801d988:	7100001f 	cmp	w0, #0x0
    4801d98c:	540000ac 	b.gt	4801d9a0 <__sflush_r+0x110>
    4801d990:	14000018 	b	4801d9f0 <__sflush_r+0x160>
    4801d994:	8b20c2b5 	add	x21, x21, w0, sxtw
    4801d998:	7100029f 	cmp	w20, #0x0
    4801d99c:	540002ad 	b.le	4801d9f0 <__sflush_r+0x160>
    4801d9a0:	f9401a61 	ldr	x1, [x19, #48]
    4801d9a4:	2a1403e3 	mov	w3, w20
    4801d9a8:	f9402264 	ldr	x4, [x19, #64]
    4801d9ac:	aa1503e2 	mov	x2, x21
    4801d9b0:	aa1603e0 	mov	x0, x22
    4801d9b4:	d63f0080 	blr	x4
    4801d9b8:	4b000294 	sub	w20, w20, w0
    4801d9bc:	7100001f 	cmp	w0, #0x0
    4801d9c0:	54fffeac 	b.gt	4801d994 <__sflush_r+0x104>
    4801d9c4:	79402261 	ldrh	w1, [x19, #16]
    4801d9c8:	12800000 	mov	w0, #0xffffffff            	// #-1
    4801d9cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d9d0:	321a0021 	orr	w1, w1, #0x40
    4801d9d4:	79002261 	strh	w1, [x19, #16]
    4801d9d8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d9dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801d9e0:	d65f03c0 	ret
    4801d9e4:	b9407261 	ldr	w1, [x19, #112]
    4801d9e8:	7100003f 	cmp	w1, #0x0
    4801d9ec:	54fff6cc 	b.gt	4801d8c4 <__sflush_r+0x34>
    4801d9f0:	52800000 	mov	w0, #0x0                   	// #0
    4801d9f4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801d9f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801d9fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801da00:	d65f03c0 	ret
    4801da04:	f9404a62 	ldr	x2, [x19, #144]
    4801da08:	17ffffc0 	b	4801d908 <__sflush_r+0x78>
    4801da0c:	79c02261 	ldrsh	w1, [x19, #16]
    4801da10:	f9400e62 	ldr	x2, [x19, #24]
    4801da14:	12147821 	and	w1, w1, #0xfffff7ff
    4801da18:	f9000262 	str	x2, [x19]
    4801da1c:	b9000a7f 	str	wzr, [x19, #8]
    4801da20:	79002261 	strh	w1, [x19, #16]
    4801da24:	36600041 	tbz	w1, #12, 4801da2c <__sflush_r+0x19c>
    4801da28:	f9004a60 	str	x0, [x19, #144]
    4801da2c:	f9402e61 	ldr	x1, [x19, #88]
    4801da30:	b90002d4 	str	w20, [x22]
    4801da34:	b4fffde1 	cbz	x1, 4801d9f0 <__sflush_r+0x160>
    4801da38:	9101d260 	add	x0, x19, #0x74
    4801da3c:	eb00003f 	cmp	x1, x0
    4801da40:	54000060 	b.eq	4801da4c <__sflush_r+0x1bc>  // b.none
    4801da44:	aa1603e0 	mov	x0, x22
    4801da48:	97fff322 	bl	4801a6d0 <_free_r>
    4801da4c:	f9002e7f 	str	xzr, [x19, #88]
    4801da50:	52800000 	mov	w0, #0x0                   	// #0
    4801da54:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801da58:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801da5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801da60:	d65f03c0 	ret
    4801da64:	d2800023 	mov	x3, #0x1                   	// #1
    4801da68:	79c02261 	ldrsh	w1, [x19, #16]
    4801da6c:	f2a40803 	movk	x3, #0x2040, lsl #16
    4801da70:	9ac22463 	lsr	x3, x3, x2
    4801da74:	3607f6a3 	tbz	w3, #0, 4801d948 <__sflush_r+0xb8>
    4801da78:	f9400e63 	ldr	x3, [x19, #24]
    4801da7c:	12147821 	and	w1, w1, #0xfffff7ff
    4801da80:	f9000263 	str	x3, [x19]
    4801da84:	b9000a7f 	str	wzr, [x19, #8]
    4801da88:	79002261 	strh	w1, [x19, #16]
    4801da8c:	3667fd01 	tbz	w1, #12, 4801da2c <__sflush_r+0x19c>
    4801da90:	35fffce2 	cbnz	w2, 4801da2c <__sflush_r+0x19c>
    4801da94:	17ffffe5 	b	4801da28 <__sflush_r+0x198>
    4801da98:	b94002c0 	ldr	w0, [x22]
    4801da9c:	34fff300 	cbz	w0, 4801d8fc <__sflush_r+0x6c>
    4801daa0:	7100741f 	cmp	w0, #0x1d
    4801daa4:	7a561804 	ccmp	w0, #0x16, #0x4, ne  // ne = any
    4801daa8:	54fff8e1 	b.ne	4801d9c4 <__sflush_r+0x134>  // b.any
    4801daac:	52800000 	mov	w0, #0x0                   	// #0
    4801dab0:	b90002d4 	str	w20, [x22]
    4801dab4:	17ffffd0 	b	4801d9f4 <__sflush_r+0x164>
	...

000000004801dac0 <_fflush_r>:
    4801dac0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4801dac4:	910003fd 	mov	x29, sp
    4801dac8:	f9000bf3 	str	x19, [sp, #16]
    4801dacc:	aa0003f3 	mov	x19, x0
    4801dad0:	b4000060 	cbz	x0, 4801dadc <_fflush_r+0x1c>
    4801dad4:	b9405002 	ldr	w2, [x0, #80]
    4801dad8:	340000e2 	cbz	w2, 4801daf4 <_fflush_r+0x34>
    4801dadc:	79c02020 	ldrsh	w0, [x1, #16]
    4801dae0:	35000140 	cbnz	w0, 4801db08 <_fflush_r+0x48>
    4801dae4:	52800000 	mov	w0, #0x0                   	// #0
    4801dae8:	f9400bf3 	ldr	x19, [sp, #16]
    4801daec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801daf0:	d65f03c0 	ret
    4801daf4:	f90017e1 	str	x1, [sp, #40]
    4801daf8:	97fffdf2 	bl	4801d2c0 <__sinit>
    4801dafc:	f94017e1 	ldr	x1, [sp, #40]
    4801db00:	79c02020 	ldrsh	w0, [x1, #16]
    4801db04:	34ffff00 	cbz	w0, 4801dae4 <_fflush_r+0x24>
    4801db08:	aa1303e0 	mov	x0, x19
    4801db0c:	f9400bf3 	ldr	x19, [sp, #16]
    4801db10:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4801db14:	17ffff5f 	b	4801d890 <__sflush_r>
	...

000000004801db20 <fflush>:
    4801db20:	b4000340 	cbz	x0, 4801db88 <fflush+0x68>
    4801db24:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4801db28:	910003fd 	mov	x29, sp
    4801db2c:	a90153f3 	stp	x19, x20, [sp, #16]
    4801db30:	aa0003f3 	mov	x19, x0
    4801db34:	90000020 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4801db38:	f943cc14 	ldr	x20, [x0, #1944]
    4801db3c:	b4000074 	cbz	x20, 4801db48 <fflush+0x28>
    4801db40:	b9405280 	ldr	w0, [x20, #80]
    4801db44:	34000180 	cbz	w0, 4801db74 <fflush+0x54>
    4801db48:	79c02260 	ldrsh	w0, [x19, #16]
    4801db4c:	350000a0 	cbnz	w0, 4801db60 <fflush+0x40>
    4801db50:	52800000 	mov	w0, #0x0                   	// #0
    4801db54:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801db58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801db5c:	d65f03c0 	ret
    4801db60:	aa1303e1 	mov	x1, x19
    4801db64:	aa1403e0 	mov	x0, x20
    4801db68:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801db6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4801db70:	17ffff48 	b	4801d890 <__sflush_r>
    4801db74:	aa1403e0 	mov	x0, x20
    4801db78:	97fffdd2 	bl	4801d2c0 <__sinit>
    4801db7c:	79c02260 	ldrsh	w0, [x19, #16]
    4801db80:	34fffe80 	cbz	w0, 4801db50 <fflush+0x30>
    4801db84:	17fffff7 	b	4801db60 <fflush+0x40>
    4801db88:	90000020 	adrp	x0, 48021000 <__fsym_help_desc+0x8>
    4801db8c:	90000001 	adrp	x1, 4801d000 <_strtol_l.part.0+0x70>
    4801db90:	912b0021 	add	x1, x1, #0xac0
    4801db94:	f9412400 	ldr	x0, [x0, #584]
    4801db98:	17fffdfe 	b	4801d390 <_fwalk_reent>
    4801db9c:	00000000 	udf	#0

000000004801dba0 <__smakebuf_r>:
    4801dba0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    4801dba4:	910003fd 	mov	x29, sp
    4801dba8:	79402022 	ldrh	w2, [x1, #16]
    4801dbac:	a90153f3 	stp	x19, x20, [sp, #16]
    4801dbb0:	aa0103f3 	mov	x19, x1
    4801dbb4:	36080122 	tbz	w2, #1, 4801dbd8 <__smakebuf_r+0x38>
    4801dbb8:	9101dc20 	add	x0, x1, #0x77
    4801dbbc:	52800021 	mov	w1, #0x1                   	// #1
    4801dbc0:	f9000260 	str	x0, [x19]
    4801dbc4:	f9000e60 	str	x0, [x19, #24]
    4801dbc8:	b9002261 	str	w1, [x19, #32]
    4801dbcc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801dbd0:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    4801dbd4:	d65f03c0 	ret
    4801dbd8:	79c02421 	ldrsh	w1, [x1, #18]
    4801dbdc:	aa0003f4 	mov	x20, x0
    4801dbe0:	a9025bf5 	stp	x21, x22, [sp, #32]
    4801dbe4:	f9001bf7 	str	x23, [sp, #48]
    4801dbe8:	37f80381 	tbnz	w1, #31, 4801dc58 <__smakebuf_r+0xb8>
    4801dbec:	910123e2 	add	x2, sp, #0x48
    4801dbf0:	97fff2f3 	bl	4801a7bc <_fstat_r>
    4801dbf4:	37f80300 	tbnz	w0, #31, 4801dc54 <__smakebuf_r+0xb4>
    4801dbf8:	b9404fe0 	ldr	w0, [sp, #76]
    4801dbfc:	d2808016 	mov	x22, #0x400                 	// #1024
    4801dc00:	52810015 	mov	w21, #0x800                 	// #2048
    4801dc04:	aa1603e1 	mov	x1, x22
    4801dc08:	12140c00 	and	w0, w0, #0xf000
    4801dc0c:	7140081f 	cmp	w0, #0x2, lsl #12
    4801dc10:	aa1403e0 	mov	x0, x20
    4801dc14:	1a9f17f7 	cset	w23, eq  // eq = none
    4801dc18:	97fff27a 	bl	4801a600 <_malloc_r>
    4801dc1c:	b5000320 	cbnz	x0, 4801dc80 <__smakebuf_r+0xe0>
    4801dc20:	79c02260 	ldrsh	w0, [x19, #16]
    4801dc24:	374805c0 	tbnz	w0, #9, 4801dcdc <__smakebuf_r+0x13c>
    4801dc28:	121e7400 	and	w0, w0, #0xfffffffc
    4801dc2c:	9101de61 	add	x1, x19, #0x77
    4801dc30:	321f0000 	orr	w0, w0, #0x2
    4801dc34:	52800022 	mov	w2, #0x1                   	// #1
    4801dc38:	79002260 	strh	w0, [x19, #16]
    4801dc3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801dc40:	f9401bf7 	ldr	x23, [sp, #48]
    4801dc44:	f9000261 	str	x1, [x19]
    4801dc48:	f9000e61 	str	x1, [x19, #24]
    4801dc4c:	b9002262 	str	w2, [x19, #32]
    4801dc50:	17ffffdf 	b	4801dbcc <__smakebuf_r+0x2c>
    4801dc54:	79402262 	ldrh	w2, [x19, #16]
    4801dc58:	f279005f 	tst	x2, #0x80
    4801dc5c:	d2808001 	mov	x1, #0x400                 	// #1024
    4801dc60:	d2800816 	mov	x22, #0x40                  	// #64
    4801dc64:	9a8112d6 	csel	x22, x22, x1, ne  // ne = any
    4801dc68:	aa1603e1 	mov	x1, x22
    4801dc6c:	aa1403e0 	mov	x0, x20
    4801dc70:	52800017 	mov	w23, #0x0                   	// #0
    4801dc74:	52800015 	mov	w21, #0x0                   	// #0
    4801dc78:	97fff262 	bl	4801a600 <_malloc_r>
    4801dc7c:	b4fffd20 	cbz	x0, 4801dc20 <__smakebuf_r+0x80>
    4801dc80:	79c02262 	ldrsh	w2, [x19, #16]
    4801dc84:	90000001 	adrp	x1, 4801d000 <_strtol_l.part.0+0x70>
    4801dc88:	9105c021 	add	x1, x1, #0x170
    4801dc8c:	f9002e81 	str	x1, [x20, #88]
    4801dc90:	32190042 	orr	w2, w2, #0x80
    4801dc94:	f9000260 	str	x0, [x19]
    4801dc98:	79002262 	strh	w2, [x19, #16]
    4801dc9c:	f9000e60 	str	x0, [x19, #24]
    4801dca0:	b9002276 	str	w22, [x19, #32]
    4801dca4:	35000117 	cbnz	w23, 4801dcc4 <__smakebuf_r+0x124>
    4801dca8:	2a150042 	orr	w2, w2, w21
    4801dcac:	79002262 	strh	w2, [x19, #16]
    4801dcb0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4801dcb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801dcb8:	f9401bf7 	ldr	x23, [sp, #48]
    4801dcbc:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    4801dcc0:	d65f03c0 	ret
    4801dcc4:	79c02661 	ldrsh	w1, [x19, #18]
    4801dcc8:	aa1403e0 	mov	x0, x20
    4801dccc:	97fff2c6 	bl	4801a7e4 <_isatty_r>
    4801dcd0:	350000c0 	cbnz	w0, 4801dce8 <__smakebuf_r+0x148>
    4801dcd4:	79c02262 	ldrsh	w2, [x19, #16]
    4801dcd8:	17fffff4 	b	4801dca8 <__smakebuf_r+0x108>
    4801dcdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4801dce0:	f9401bf7 	ldr	x23, [sp, #48]
    4801dce4:	17ffffba 	b	4801dbcc <__smakebuf_r+0x2c>
    4801dce8:	79402262 	ldrh	w2, [x19, #16]
    4801dcec:	121e7442 	and	w2, w2, #0xfffffffc
    4801dcf0:	32000042 	orr	w2, w2, #0x1
    4801dcf4:	13003c42 	sxth	w2, w2
    4801dcf8:	17ffffec 	b	4801dca8 <__smakebuf_r+0x108>
    4801dcfc:	00000000 	udf	#0
    4801dd00:	202c6948 	.word	0x202c6948
    4801dd04:	73696874 	.word	0x73696874
    4801dd08:	20736920 	.word	0x20736920
    4801dd0c:	542d5452 	.word	0x542d5452
    4801dd10:	61657268 	.word	0x61657268
    4801dd14:	0a212164 	.word	0x0a212164
	...
    4801dd20:	61656c70 	.word	0x61656c70
    4801dd24:	69206573 	.word	0x69206573
    4801dd28:	2074696e 	.word	0x2074696e
    4801dd2c:	21756d6d 	.word	0x21756d6d
    4801dd30:	0000000a 	.word	0x0000000a
    4801dd34:	00000000 	.word	0x00000000
    4801dd38:	73756c66 	.word	0x73756c66
    4801dd3c:	676e6968 	.word	0x676e6968
    4801dd40:	61636420 	.word	0x61636420
    4801dd44:	20656863 	.word	0x20656863
    4801dd48:	75746572 	.word	0x75746572
    4801dd4c:	20736e72 	.word	0x20736e72
    4801dd50:	78257830 	.word	0x78257830
    4801dd54:	0000000a 	.word	0x0000000a
    4801dd58:	73756c66 	.word	0x73756c66
    4801dd5c:	676e6968 	.word	0x676e6968
    4801dd60:	61636420 	.word	0x61636420
    4801dd64:	20656863 	.word	0x20656863
    4801dd68:	63637573 	.word	0x63637573
    4801dd6c:	66737365 	.word	0x66737365
    4801dd70:	796c6c75 	.word	0x796c6c75
    4801dd74:	00000a2e 	.word	0x00000a2e
    4801dd78:	6465656e 	.word	0x6465656e
    4801dd7c:	616e6520 	.word	0x616e6520
    4801dd80:	20656c62 	.word	0x20656c62
    4801dd84:	68636163 	.word	0x68636163
    4801dd88:	000a2165 	.word	0x000a2165
    4801dd8c:	00000000 	.word	0x00000000
    4801dd90:	65646e69 	.word	0x65646e69
    4801dd94:	203c2078 	.word	0x203c2078
    4801dd98:	5f4d5241 	.word	0x5f4d5241
    4801dd9c:	5f434947 	.word	0x5f434947
    4801dda0:	5f58414d 	.word	0x5f58414d
    4801dda4:	0000524e 	.word	0x0000524e
    4801dda8:	75706328 	.word	0x75706328
    4801ddac:	2964695f 	.word	0x2964695f
    4801ddb0:	52203c20 	.word	0x52203c20
    4801ddb4:	50435f54 	.word	0x50435f54
    4801ddb8:	4e5f5355 	.word	0x4e5f5355
    4801ddbc:	00000052 	.word	0x00000052
    4801ddc0:	756f7267 	.word	0x756f7267
    4801ddc4:	3d3c2070 	.word	0x3d3c2070
    4801ddc8:	00553120 	.word	0x00553120
    4801ddcc:	00000000 	.word	0x00000000
    4801ddd0:	00736168 	.word	0x00736168
    4801ddd4:	00000000 	.word	0x00000000
    4801ddd8:	00006f6e 	.word	0x00006f6e
    4801dddc:	00000000 	.word	0x00000000
    4801dde0:	76434947 	.word	0x76434947
    4801dde4:	6f206425 	.word	0x6f206425
    4801dde8:	7025206e 	.word	0x7025206e
    4801ddec:	616d202c 	.word	0x616d202c
    4801ddf0:	52492078 	.word	0x52492078
    4801ddf4:	203a7351 	.word	0x203a7351
    4801ddf8:	202c6425 	.word	0x202c6425
    4801ddfc:	73207325 	.word	0x73207325
    4801de00:	72756365 	.word	0x72756365
    4801de04:	20797469 	.word	0x20797469
    4801de08:	65747865 	.word	0x65747865
    4801de0c:	6f69736e 	.word	0x6f69736e
    4801de10:	3025286e 	.word	0x3025286e
    4801de14:	0a297838 	.word	0x0a297838
	...
    4801de20:	202d2d2d 	.word	0x202d2d2d
    4801de24:	68676968 	.word	0x68676968
    4801de28:	6e657020 	.word	0x6e657020
    4801de2c:	676e6964 	.word	0x676e6964
    4801de30:	69727020 	.word	0x69727020
    4801de34:	7469726f 	.word	0x7469726f
    4801de38:	25203a79 	.word	0x25203a79
    4801de3c:	30252864 	.word	0x30252864
    4801de40:	0a297838 	.word	0x0a297838
    4801de44:	00000000 	.word	0x00000000
    4801de48:	202d2d2d 	.word	0x202d2d2d
    4801de4c:	6d207768 	.word	0x6d207768
    4801de50:	206b7361 	.word	0x206b7361
    4801de54:	0a2d2d2d 	.word	0x0a2d2d2d
	...
    4801de60:	30257830 	.word	0x30257830
    4801de64:	202c7838 	.word	0x202c7838
	...
    4801de70:	2d2d2d0a 	.word	0x2d2d2d0a
    4801de74:	20776820 	.word	0x20776820
    4801de78:	646e6570 	.word	0x646e6570
    4801de7c:	20676e69 	.word	0x20676e69
    4801de80:	0a2d2d2d 	.word	0x0a2d2d2d
    4801de84:	00000000 	.word	0x00000000
    4801de88:	2d2d2d0a 	.word	0x2d2d2d0a
    4801de8c:	20776820 	.word	0x20776820
    4801de90:	69746361 	.word	0x69746361
    4801de94:	2d206576 	.word	0x2d206576
    4801de98:	000a2d2d 	.word	0x000a2d2d
    4801de9c:	00000000 	.word	0x00000000
    4801dea0:	0000000a 	.word	0x0000000a
    4801dea4:	00000000 	.word	0x00000000

000000004801dea8 <__FUNCTION__.28>:
    4801dea8:	5f6d7261 5f636967 5f746567 69746361     arm_gic_get_acti
    4801deb8:	695f6576 00007172                       ve_irq..

000000004801dec0 <__FUNCTION__.27>:
    4801dec0:	5f6d7261 5f636967 006b6361 00000000     arm_gic_ack.....

000000004801ded0 <__FUNCTION__.26>:
    4801ded0:	5f6d7261 5f636967 6b73616d 00000000     arm_gic_mask....

000000004801dee0 <__FUNCTION__.25>:
    4801dee0:	5f6d7261 5f636967 73616d75 0000006b     arm_gic_umask...

000000004801def0 <__FUNCTION__.24>:
    4801def0:	5f6d7261 5f636967 5f746567 646e6570     arm_gic_get_pend
    4801df00:	5f676e69 00717269                       ing_irq.

000000004801df08 <__FUNCTION__.23>:
    4801df08:	5f6d7261 5f636967 5f746573 646e6570     arm_gic_set_pend
    4801df18:	5f676e69 00717269                       ing_irq.

000000004801df20 <__FUNCTION__.22>:
    4801df20:	5f6d7261 5f636967 61656c63 65705f72     arm_gic_clear_pe
    4801df30:	6e69646e 72695f67 00000071 00000000     nding_irq.......

000000004801df40 <__FUNCTION__.21>:
    4801df40:	5f6d7261 5f636967 5f746573 666e6f63     arm_gic_set_conf
    4801df50:	72756769 6f697461 0000006e 00000000     iguration.......

000000004801df60 <__FUNCTION__.20>:
    4801df60:	5f6d7261 5f636967 5f746567 666e6f63     arm_gic_get_conf
    4801df70:	72756769 6f697461 0000006e 00000000     iguration.......

000000004801df80 <__FUNCTION__.19>:
    4801df80:	5f6d7261 5f636967 61656c63 63615f72     arm_gic_clear_ac
    4801df90:	65766974 00000000                       tive....

000000004801df98 <__FUNCTION__.18>:
    4801df98:	5f6d7261 5f636967 5f746573 00757063     arm_gic_set_cpu.

000000004801dfa8 <__FUNCTION__.17>:
    4801dfa8:	5f6d7261 5f636967 5f746567 67726174     arm_gic_get_targ
    4801dfb8:	635f7465 00007570                       et_cpu..

000000004801dfc0 <__FUNCTION__.16>:
    4801dfc0:	5f6d7261 5f636967 5f746573 6f697270     arm_gic_set_prio
    4801dfd0:	79746972 00000000                       rity....

000000004801dfd8 <__FUNCTION__.15>:
    4801dfd8:	5f6d7261 5f636967 5f746567 6f697270     arm_gic_get_prio
    4801dfe8:	79746972 00000000                       rity....

000000004801dff0 <__FUNCTION__.14>:
    4801dff0:	5f6d7261 5f636967 5f746573 74737973     arm_gic_set_syst
    4801e000:	725f6d65 73696765 5f726574 62616e65     em_register_enab
    4801e010:	6d5f656c 006b7361                       le_mask.

000000004801e018 <__FUNCTION__.13>:
    4801e018:	5f6d7261 5f636967 5f746567 74737973     arm_gic_get_syst
    4801e028:	725f6d65 73696765 5f726574 62616e65     em_register_enab
    4801e038:	6d5f656c 006b7361                       le_mask.

000000004801e040 <__FUNCTION__.12>:
    4801e040:	5f6d7261 5f636967 5f746573 65746e69     arm_gic_set_inte
    4801e050:	63616672 72705f65 5f726f69 6b73616d     rface_prior_mask
	...

000000004801e068 <__FUNCTION__.11>:
    4801e068:	5f6d7261 5f636967 5f746567 65746e69     arm_gic_get_inte
    4801e078:	63616672 72705f65 5f726f69 6b73616d     rface_prior_mask
	...

000000004801e090 <__FUNCTION__.10>:
    4801e090:	5f6d7261 5f636967 5f746567 5f717269     arm_gic_get_irq_
    4801e0a0:	74617473 00007375                       status..

000000004801e0a8 <__FUNCTION__.9>:
    4801e0a8:	5f6d7261 5f636967 5f746567 68676968     arm_gic_get_high
    4801e0b8:	6e65705f 676e6964 7172695f 00000000     _pending_irq....

000000004801e0c8 <__FUNCTION__.8>:
    4801e0c8:	5f6d7261 5f636967 5f746567 65746e69     arm_gic_get_inte
    4801e0d8:	63616672 64695f65 00000000 00000000     rface_id........

000000004801e0e8 <__FUNCTION__.7>:
    4801e0e8:	5f6d7261 5f636967 5f746573 756f7267     arm_gic_set_grou
    4801e0f8:	00000070 00000000                       p.......

000000004801e100 <__FUNCTION__.6>:
    4801e100:	5f6d7261 5f636967 5f746567 756f7267     arm_gic_get_grou
    4801e110:	00000070 00000000                       p.......

000000004801e118 <__FUNCTION__.5>:
    4801e118:	5f6d7261 76636967 61775f33 725f7469     arm_gicv3_wait_r
    4801e128:	00007077 00000000                       wp......

000000004801e130 <__FUNCTION__.4>:
    4801e130:	5f6d7261 5f636967 74736964 696e695f     arm_gic_dist_ini
    4801e140:	00000074 00000000                       t.......

000000004801e148 <__FUNCTION__.3>:
    4801e148:	5f6d7261 5f636967 69646572 615f7473     arm_gic_redist_a
    4801e158:	65726464 735f7373 00007465 00000000     ddress_set......

000000004801e168 <__FUNCTION__.2>:
    4801e168:	5f6d7261 5f636967 5f757063 65746e69     arm_gic_cpu_inte
    4801e178:	63616672 64615f65 73657264 65735f73     rface_address_se
    4801e188:	00000074 00000000                       t.......

000000004801e190 <__FUNCTION__.1>:
    4801e190:	5f6d7261 5f636967 69646572 695f7473     arm_gic_redist_i
    4801e1a0:	0074696e 00000000                       nit.....

000000004801e1a8 <__FUNCTION__.0>:
    4801e1a8:	5f6d7261 5f636967 5f757063 74696e69     arm_gic_cpu_init
	...
    4801e1c0:	63657845 6f697470 000a3a6e 00000000     Execption:......
    4801e1d0:	3a303058 31257830 36312e36 30582070     X00:0x%16.16p X0
    4801e1e0:	78303a31 2e363125 20703631 3a323058     1:0x%16.16p X02:
    4801e1f0:	31257830 36312e36 30582070 78303a33     0x%16.16p X03:0x
    4801e200:	2e363125 0a703631 00000000 00000000     %16.16p.........
    4801e210:	3a343058 31257830 36312e36 30582070     X04:0x%16.16p X0
    4801e220:	78303a35 2e363125 20703631 3a363058     5:0x%16.16p X06:
    4801e230:	31257830 36312e36 30582070 78303a37     0x%16.16p X07:0x
    4801e240:	2e363125 0a703631 00000000 00000000     %16.16p.........
    4801e250:	3a383058 31257830 36312e36 30582070     X08:0x%16.16p X0
    4801e260:	78303a39 2e363125 20703631 3a303158     9:0x%16.16p X10:
    4801e270:	31257830 36312e36 31582070 78303a31     0x%16.16p X11:0x
    4801e280:	2e363125 0a703631 00000000 00000000     %16.16p.........
    4801e290:	3a323158 31257830 36312e36 31582070     X12:0x%16.16p X1
    4801e2a0:	78303a33 2e363125 20703631 3a343158     3:0x%16.16p X14:
    4801e2b0:	31257830 36312e36 31582070 78303a35     0x%16.16p X15:0x
    4801e2c0:	2e363125 0a703631 00000000 00000000     %16.16p.........
    4801e2d0:	3a363158 31257830 36312e36 31582070     X16:0x%16.16p X1
    4801e2e0:	78303a37 2e363125 20703631 3a383158     7:0x%16.16p X18:
    4801e2f0:	31257830 36312e36 31582070 78303a39     0x%16.16p X19:0x
    4801e300:	2e363125 0a703631 00000000 00000000     %16.16p.........
    4801e310:	3a303258 31257830 36312e36 32582070     X20:0x%16.16p X2
    4801e320:	78303a31 2e363125 20703631 3a323258     1:0x%16.16p X22:
    4801e330:	31257830 36312e36 32582070 78303a33     0x%16.16p X23:0x
    4801e340:	2e363125 0a703631 00000000 00000000     %16.16p.........
    4801e350:	3a343258 31257830 36312e36 32582070     X24:0x%16.16p X2
    4801e360:	78303a35 2e363125 20703631 3a363258     5:0x%16.16p X26:
    4801e370:	31257830 36312e36 32582070 78303a37     0x%16.16p X27:0x
    4801e380:	2e363125 0a703631 00000000 00000000     %16.16p.........
    4801e390:	3a383258 31257830 36312e36 32582070     X28:0x%16.16p X2
    4801e3a0:	78303a39 2e363125 20703631 3a303358     9:0x%16.16p X30:
    4801e3b0:	31257830 36312e36 00000a70 00000000     0x%16.16p.......
    4801e3c0:	52535053 303a2020 36312578 7036312e     SPSR  :0x%16.16p
    4801e3d0:	0000000a 00000000 20435045 303a2020     ........EPC   :0
    4801e3e0:	36312578 7036312e 0000000a 00000000     x%16.16p........
    4801e3f0:	6f727265 78652072 74706563 3a6e6f69     error exception:
    4801e400:	0000000a 00000000 74756873 6e776f64     ........shutdown
    4801e410:	0a2e2e2e 00000000 00000030 00000000     ........0.......

000000004801e420 <__FUNCTION__.0>:
    4801e420:	685f7472 70635f77 68735f75 6f647475     rt_hw_cpu_shutdo
    4801e430:	00006e77 00000000 69726573 21206c61     wn......serial !
    4801e440:	5452203d 4c554e5f 0000004c 00000000     = RT_NULL.......

000000004801e450 <_uart_ops>:
    4801e450:	48004c14 00000000 48004de0 00000000     .L.H.....M.H....
    4801e460:	48004e68 00000000 48004ee8 00000000     hN.H.....N.H....
	...
    4801e478:	74726175 00000000                       uart....

000000004801e480 <__FUNCTION__.4>:
    4801e480:	74726175 6e6f635f 75676966 00006572     uart_configure..

000000004801e490 <__FUNCTION__.3>:
    4801e490:	74726175 6e6f635f 6c6f7274 00000000     uart_control....

000000004801e4a0 <__FUNCTION__.2>:
    4801e4a0:	74726175 7475705f 00000063 00000000     uart_putc.......

000000004801e4b0 <__FUNCTION__.1>:
    4801e4b0:	74726175 7465675f 00000063 00000000     uart_getc.......

000000004801e4c0 <__FUNCTION__.0>:
    4801e4c0:	685f7472 61755f77 695f7472 00007273     rt_hw_uart_isr..
    4801e4d0:	6b636974 00000000 74726175 00000000     tick....uart....
    4801e4e0:	70616568 7830203a 78383025 30202d20     heap: 0x%08x - 0
    4801e4f0:	38302578 00000a78 656d6974 746e4372     x%08x...timerCnt
    4801e500:	7830203a 74207825 72656d69 70657453     : 0x%x timerStep
    4801e510:	7830203a 74207825 72656d69 71657246     : 0x%x timerFreq
    4801e520:	7830203a 000a7825 776f6873 74636120     : 0x%x..show act
    4801e530:	20657669 3a717269 25783020 000a0d78     ive irq: 0x%x...
    4801e540:	70039939 00000000 6e69616d 00000000     9..p....main....
    4801e550:	20646974 52203d21 554e5f54 00004c4c     tid != RT_NULL..

000000004801e560 <__FUNCTION__.0>:
    4801e560:	615f7472 696c7070 69746163 695f6e6f     rt_application_i
    4801e570:	0074696e 00000000 636e7546 6e6f6974     nit.....Function
    4801e580:	5d73255b 61687320 6e206c6c 6220746f     [%s] shall not b
    4801e590:	73752065 69206465 5349206e 00000a52     e used in ISR...
    4801e5a0:	00000030 00000000 6c646974 00642565     0.......tidle%d.

000000004801e5b0 <__FUNCTION__.0>:
    4801e5b0:	645f7472 6e756665 655f7463 75636578     rt_defunct_execu
    4801e5c0:	00006574 00000000 00000030 00000000     te......0.......
    4801e5d0:	206d6573 52203d21 554e5f54 00004c4c     sem != RT_NULL..
    4801e5e0:	756c6176 203c2065 30317830 55303030     value < 0x10000U
	...
    4801e5f8:	616c6628 3d3d2067 5f545220 5f435049     (flag == RT_IPC_
    4801e608:	47414c46 4649465f 7c20294f 6628207c     FLAG_FIFO) || (f
    4801e618:	2067616c 52203d3d 50495f54 4c465f43     lag == RT_IPC_FL
    4801e628:	505f4741 294f4952 00000000 00000000     AG_PRIO)........
    4801e638:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801e648:	26286570 2d6d6573 7261703e 2e746e65     pe(&sem->parent.
    4801e658:	65726170 2029746e 52203d3d 624f5f54     parent) == RT_Ob
    4801e668:	7463656a 616c435f 535f7373 70616d65     ject_Class_Semap
    4801e678:	65726f68 00000000 6f5f7472 63656a62     hore....rt_objec
    4801e688:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801e698:	73262874 3e2d6d65 65726170 702e746e     t(&sem->parent.p
    4801e6a8:	6e657261 00002974 636e7546 6e6f6974     arent)..Function
    4801e6b8:	5d73255b 61687320 6e206c6c 6220746f     [%s] shall not b
    4801e6c8:	73752065 69206465 5349206e 00000a52     e used in ISR...
    4801e6d8:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801e6e8:	6f6d6574 63656a62 73262874 3e2d6d65     temobject(&sem->
    4801e6f8:	65726170 702e746e 6e657261 3d202974     parent.parent) =
    4801e708:	5452203d 4c41465f 00004553 00000000     = RT_FALSE......
    4801e718:	636e7546 6e6f6974 5d73255b 61687320     Function[%s] sha
    4801e728:	6e206c6c 6220746f 73752065 62206465     ll not be used b
    4801e738:	726f6665 63732065 75646568 2072656c     efore scheduler 
    4801e748:	72617473 00000a74 6574756d 3d212078     start...mutex !=
    4801e758:	5f545220 4c4c554e 00000000 00000000      RT_NULL........
    4801e768:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801e778:	26286570 6574756d 703e2d78 6e657261     pe(&mutex->paren
    4801e788:	61702e74 746e6572 3d3d2029 5f545220     t.parent) == RT_
    4801e798:	656a624f 435f7463 7373616c 74754d5f     Object_Class_Mut
    4801e7a8:	00007865 00000000 6f5f7472 63656a62     ex......rt_objec
    4801e7b8:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801e7c8:	6d262874 78657475 61703e2d 746e6572     t(&mutex->parent
    4801e7d8:	7261702e 29746e65 00000000 00000000     .parent)........
    4801e7e8:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801e7f8:	6f6d6574 63656a62 6d262874 78657475     temobject(&mutex
    4801e808:	61703e2d 746e6572 7261702e 29746e65     ->parent.parent)
    4801e818:	203d3d20 465f5452 45534c41 00000000      == RT_FALSE....
    4801e828:	6e657665 3d212074 5f545220 4c4c554e     event != RT_NULL
	...
    4801e840:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801e850:	26286570 6e657665 703e2d74 6e657261     pe(&event->paren
    4801e860:	61702e74 746e6572 3d3d2029 5f545220     t.parent) == RT_
    4801e870:	656a624f 435f7463 7373616c 6576455f     Object_Class_Eve
    4801e880:	0000746e 00000000 6f5f7472 63656a62     nt......rt_objec
    4801e890:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801e8a0:	65262874 746e6576 61703e2d 746e6572     t(&event->parent
    4801e8b0:	7261702e 29746e65 00000000 00000000     .parent)........
    4801e8c0:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801e8d0:	6f6d6574 63656a62 65262874 746e6576     temobject(&event
    4801e8e0:	61703e2d 746e6572 7261702e 29746e65     ->parent.parent)
    4801e8f0:	203d3d20 465f5452 45534c41 00000000      == RT_FALSE....
    4801e900:	2120626d 5452203d 4c554e5f 0000004c     mb != RT_NULL...
    4801e910:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801e920:	26286570 3e2d626d 65726170 702e746e     pe(&mb->parent.p
    4801e930:	6e657261 3d202974 5452203d 6a624f5f     arent) == RT_Obj
    4801e940:	5f746365 73616c43 614d5f73 6f426c69     ect_Class_MailBo
    4801e950:	00000078 00000000 6f5f7472 63656a62     x.......rt_objec
    4801e960:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801e970:	6d262874 703e2d62 6e657261 61702e74     t(&mb->parent.pa
    4801e980:	746e6572 00000029 6f5f7472 63656a62     rent)...rt_objec
    4801e990:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801e9a0:	6d262874 703e2d62 6e657261 61702e74     t(&mb->parent.pa
    4801e9b0:	746e6572 3d3d2029 5f545220 534c4146     rent) == RT_FALS
    4801e9c0:	00000045 00000000 2120716d 5452203d     E.......mq != RT
    4801e9d0:	4c554e5f 0000004c 6f5f7472 63656a62     _NULL...rt_objec
    4801e9e0:	65675f74 79745f74 26286570 3e2d716d     t_get_type(&mq->
    4801e9f0:	65726170 702e746e 6e657261 3d202974     parent.parent) =
    4801ea00:	5452203d 6a624f5f 5f746365 73616c43     = RT_Object_Clas
    4801ea10:	654d5f73 67617373 65755165 00006575     s_MessageQueue..
    4801ea20:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801ea30:	6f6d6574 63656a62 6d262874 703e2d71     temobject(&mq->p
    4801ea40:	6e657261 61702e74 746e6572 00000029     arent.parent)...
    4801ea50:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801ea60:	6f6d6574 63656a62 6d262874 703e2d71     temobject(&mq->p
    4801ea70:	6e657261 61702e74 746e6572 3d3d2029     arent.parent) ==
    4801ea80:	5f545220 534c4146 00000045 00000000      RT_FALSE.......
    4801ea90:	66667562 21207265 5452203d 4c554e5f     buffer != RT_NUL
    4801eaa0:	0000004c 00000000 657a6973 203d2120     L.......size != 
    4801eab0:	00000030 00000000                       0.......

000000004801eab8 <__FUNCTION__.37>:
    4801eab8:	735f7472 695f6d65 0074696e 00000000     rt_sem_init.....

000000004801eac8 <__FUNCTION__.36>:
    4801eac8:	735f7472 645f6d65 63617465 00000068     rt_sem_detach...

000000004801ead8 <__FUNCTION__.35>:
    4801ead8:	735f7472 635f6d65 74616572 00000065     rt_sem_create...

000000004801eae8 <__FUNCTION__.34>:
    4801eae8:	735f7472 645f6d65 74656c65 00000065     rt_sem_delete...

000000004801eaf8 <__FUNCTION__.33>:
    4801eaf8:	735f7472 745f6d65 00656b61 00000000     rt_sem_take.....

000000004801eb08 <__FUNCTION__.32>:
    4801eb08:	6370695f 73696c5f 75735f74 6e657073     _ipc_list_suspen
    4801eb18:	00000064 00000000                       d.......

000000004801eb20 <__FUNCTION__.31>:
    4801eb20:	735f7472 725f6d65 61656c65 00006573     rt_sem_release..

000000004801eb30 <__FUNCTION__.30>:
    4801eb30:	735f7472 635f6d65 72746e6f 00006c6f     rt_sem_control..

000000004801eb40 <__FUNCTION__.29>:
    4801eb40:	6d5f7472 78657475 696e695f 00000074     rt_mutex_init...

000000004801eb50 <__FUNCTION__.28>:
    4801eb50:	6d5f7472 78657475 7465645f 00686361     rt_mutex_detach.

000000004801eb60 <__FUNCTION__.27>:
    4801eb60:	6d5f7472 78657475 6572635f 00657461     rt_mutex_create.

000000004801eb70 <__FUNCTION__.26>:
    4801eb70:	6d5f7472 78657475 6c65645f 00657465     rt_mutex_delete.

000000004801eb80 <__FUNCTION__.25>:
    4801eb80:	6d5f7472 78657475 6b61745f 00000065     rt_mutex_take...

000000004801eb90 <__FUNCTION__.24>:
    4801eb90:	6d5f7472 78657475 6c65725f 65736165     rt_mutex_release
	...

000000004801eba8 <__FUNCTION__.23>:
    4801eba8:	6d5f7472 78657475 6e6f635f 6c6f7274     rt_mutex_control
	...

000000004801ebc0 <__FUNCTION__.22>:
    4801ebc0:	655f7472 746e6576 696e695f 00000074     rt_event_init...

000000004801ebd0 <__FUNCTION__.21>:
    4801ebd0:	655f7472 746e6576 7465645f 00686361     rt_event_detach.

000000004801ebe0 <__FUNCTION__.20>:
    4801ebe0:	655f7472 746e6576 6572635f 00657461     rt_event_create.

000000004801ebf0 <__FUNCTION__.19>:
    4801ebf0:	655f7472 746e6576 6c65645f 00657465     rt_event_delete.

000000004801ec00 <__FUNCTION__.18>:
    4801ec00:	655f7472 746e6576 6e65735f 00000064     rt_event_send...

000000004801ec10 <__FUNCTION__.17>:
    4801ec10:	655f7472 746e6576 6365725f 00000076     rt_event_recv...

000000004801ec20 <__FUNCTION__.16>:
    4801ec20:	655f7472 746e6576 6e6f635f 6c6f7274     rt_event_control
	...

000000004801ec38 <__FUNCTION__.15>:
    4801ec38:	6d5f7472 6e695f62 00007469 00000000     rt_mb_init......

000000004801ec48 <__FUNCTION__.14>:
    4801ec48:	6d5f7472 65645f62 68636174 00000000     rt_mb_detach....

000000004801ec58 <__FUNCTION__.13>:
    4801ec58:	6d5f7472 72635f62 65746165 00000000     rt_mb_create....

000000004801ec68 <__FUNCTION__.12>:
    4801ec68:	6d5f7472 65645f62 6574656c 00000000     rt_mb_delete....

000000004801ec78 <__FUNCTION__.11>:
    4801ec78:	6d5f7472 65735f62 775f646e 00746961     rt_mb_send_wait.

000000004801ec88 <__FUNCTION__.10>:
    4801ec88:	6d5f7472 72755f62 746e6567 00000000     rt_mb_urgent....

000000004801ec98 <__FUNCTION__.9>:
    4801ec98:	6d5f7472 65725f62 00007663 00000000     rt_mb_recv......

000000004801eca8 <__FUNCTION__.8>:
    4801eca8:	6d5f7472 6f635f62 6f72746e 0000006c     rt_mb_control...

000000004801ecb8 <__FUNCTION__.7>:
    4801ecb8:	6d5f7472 6e695f71 00007469 00000000     rt_mq_init......

000000004801ecc8 <__FUNCTION__.6>:
    4801ecc8:	6d5f7472 65645f71 68636174 00000000     rt_mq_detach....

000000004801ecd8 <__FUNCTION__.5>:
    4801ecd8:	6d5f7472 72635f71 65746165 00000000     rt_mq_create....

000000004801ece8 <__FUNCTION__.4>:
    4801ece8:	6d5f7472 65645f71 6574656c 00000000     rt_mq_delete....

000000004801ecf8 <__FUNCTION__.3>:
    4801ecf8:	6d5f7472 65735f71 775f646e 00746961     rt_mq_send_wait.

000000004801ed08 <__FUNCTION__.2>:
    4801ed08:	6d5f7472 72755f71 746e6567 00000000     rt_mq_urgent....

000000004801ed18 <__FUNCTION__.1>:
    4801ed18:	6d5f7472 65725f71 00007663 00000000     rt_mq_recv......

000000004801ed28 <__FUNCTION__.0>:
    4801ed28:	6d5f7472 6f635f71 6f72746e 0000006c     rt_mq_control...
    4801ed38:	5f747228 746e6975 20745f38 656d292a     (rt_uint8_t *)me
    4801ed48:	3d3e206d 61656820 74705f70 00000072     m >= heap_ptr...
    4801ed58:	5f747228 746e6975 20745f38 656d292a     (rt_uint8_t *)me
    4801ed68:	203c206d 5f747228 746e6975 20745f38     m < (rt_uint8_t 
    4801ed78:	6568292a 655f7061 0000646e 00000000     *)heap_end......
    4801ed88:	2d6d656d 6573753e 3d3d2064 00003020     mem->used == 0..
    4801ed98:	636e7546 6e6f6974 5d73255b 61687320     Function[%s] sha
    4801eda8:	6e206c6c 6220746f 73752065 69206465     ll not be used i
    4801edb8:	5349206e 00000a52 00000030 00000000     n ISR...0.......
    4801edc8:	206d656d 74696e69 7265202c 20726f72     mem init, error 
    4801edd8:	69676562 6461206e 73657264 78302073     begin address 0x
    4801ede8:	202c7825 20646e61 20646e65 72646461     %x, and end addr
    4801edf8:	20737365 78257830 0000000a 00000000     ess 0x%x........
    4801ee08:	70616568 00000000 666c2828 20656572     heap....((lfree 
    4801ee18:	68203d3d 5f706165 29646e65 207c7c20     == heap_end) || 
    4801ee28:	666c2128 2d656572 6573753e 00292964     (!lfree->used)).
    4801ee38:	5f747228 73616275 29745f65 206d656d     (rt_ubase_t)mem 
    4801ee48:	4953202b 464f455a 5254535f 5f544355     + SIZEOF_STRUCT_
    4801ee58:	204d454d 6973202b 3c20657a 7228203d     MEM + size <= (r
    4801ee68:	62755f74 5f657361 65682974 655f7061     t_ubase_t)heap_e
    4801ee78:	0000646e 00000000 5f747228 73616275     nd......(rt_ubas
    4801ee88:	29745f65 74722828 6e69755f 745f3874     e_t)((rt_uint8_t
    4801ee98:	6d292a20 2b206d65 5a495320 5f464f45      *)mem + SIZEOF_
    4801eea8:	55525453 4d5f5443 20294d45 54522025     STRUCT_MEM) % RT
    4801eeb8:	494c415f 535f4e47 20455a49 30203d3d     _ALIGN_SIZE == 0
	...
    4801eed0:	72282828 62755f74 5f657361 656d2974     (((rt_ubase_t)me
    4801eee0:	2620296d 54522820 494c415f 535f4e47     m) & (RT_ALIGN_S
    4801eef0:	20455a49 2931202d 3d3d2029 00003020     IZE - 1)) == 0..
    4801ef00:	72282828 62755f74 5f657361 6d722974     (((rt_ubase_t)rm
    4801ef10:	20296d65 52282026 4c415f54 5f4e4749     em) & (RT_ALIGN_
    4801ef20:	455a4953 31202d20 3d202929 0030203d     SIZE - 1)) == 0.
    4801ef30:	5f747228 746e6975 20745f38 6d72292a     (rt_uint8_t *)rm
    4801ef40:	3e206d65 7228203d 69755f74 5f38746e     em >= (rt_uint8_
    4801ef50:	292a2074 70616568 7274705f 20262620     t *)heap_ptr && 
    4801ef60:	5f747228 746e6975 20745f38 6d72292a     (rt_uint8_t *)rm
    4801ef70:	3c206d65 74722820 6e69755f 745f3874     em < (rt_uint8_t
    4801ef80:	68292a20 5f706165 00646e65 00000000      *)heap_end.....
    4801ef90:	66206f74 20656572 61622061 61642064     to free a bad da
    4801efa0:	62206174 6b636f6c 00000a3a 00000000     ta block:.......
    4801efb0:	3a6d656d 25783020 2c783830 65737520     mem: 0x%08x, use
    4801efc0:	6c662064 203a6761 202c6425 6967616d     d flag: %d, magi
    4801efd0:	6f632063 203a6564 30257830 000a7834     c code: 0x%04x..
    4801efe0:	2d6d656d 6573753e 00000064 00000000     mem->used.......
    4801eff0:	2d6d656d 67616d3e 3d206369 4548203d     mem->magic == HE
    4801f000:	4d5f5041 43494741 00000000 00000000     AP_MAGIC........
    4801f010:	61746f74 656d206c 79726f6d 6425203a     total memory: %d
    4801f020:	0000000a 00000000 64657375 6d656d20     ........used mem
    4801f030:	2079726f 6425203a 0000000a 00000000     ory : %d........
    4801f040:	6978616d 206d756d 6f6c6c61 65746163     maximum allocate
    4801f050:	656d2064 79726f6d 6425203a 0000000a     d memory: %d....

000000004801f060 <__FUNCTION__.4>:
    4801f060:	67756c70 6c6f685f 00007365 00000000     plug_holes......

000000004801f070 <__FUNCTION__.3>:
    4801f070:	735f7472 65747379 65685f6d 695f7061     rt_system_heap_i
    4801f080:	0074696e 00000000                       nit.....

000000004801f088 <__FUNCTION__.2>:
    4801f088:	6d5f7472 6f6c6c61 00000063 00000000     rt_malloc.......

000000004801f098 <__FUNCTION__.1>:
    4801f098:	725f7472 6c6c6165 0000636f 00000000     rt_realloc......

000000004801f0a8 <__FUNCTION__.0>:
    4801f0a8:	665f7472 00656572 656d6974 3d212072     rt_free.timer !=
    4801f0b8:	5f545220 4c4c554e 00000000 00000000      RT_NULL........
    4801f0c8:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801f0d8:	26286570 656d6974 703e2d72 6e657261     pe(&timer->paren
    4801f0e8:	3d202974 5452203d 6a624f5f 5f746365     t) == RT_Object_
    4801f0f8:	73616c43 69545f73 0072656d 00000000     Class_Timer.....
    4801f108:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801f118:	6f6d6574 63656a62 74262874 72656d69     temobject(&timer
    4801f128:	61703e2d 746e6572 00000029 00000000     ->parent).......
    4801f138:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801f148:	6f6d6574 63656a62 74262874 72656d69     temobject(&timer
    4801f158:	61703e2d 746e6572 3d3d2029 5f545220     ->parent) == RT_
    4801f168:	534c4146 00000045 656d6974 693e2d72     FALSE...timer->i
    4801f178:	5f74696e 6b636974 52203c20 49545f54     nit_tick < RT_TI
    4801f188:	4d5f4b43 2f205841 00003220 00000000     CK_MAX / 2......
    4801f198:	656d6974 00000072                       timer...

000000004801f1a0 <__FUNCTION__.6>:
    4801f1a0:	745f7472 72656d69 696e695f 00000074     rt_timer_init...

000000004801f1b0 <__FUNCTION__.5>:
    4801f1b0:	745f7472 72656d69 7465645f 00686361     rt_timer_detach.

000000004801f1c0 <__FUNCTION__.4>:
    4801f1c0:	745f7472 72656d69 6c65645f 00657465     rt_timer_delete.

000000004801f1d0 <__FUNCTION__.3>:
    4801f1d0:	745f7472 72656d69 6174735f 00007472     rt_timer_start..

000000004801f1e0 <__FUNCTION__.1>:
    4801f1e0:	745f7472 72656d69 6f74735f 00000070     rt_timer_stop...

000000004801f1f0 <__FUNCTION__.0>:
    4801f1f0:	745f7472 72656d69 6e6f635f 6c6f7274     rt_timer_control
	...
    4801f208:	6f697270 79746972 52203c20 48545f54     priority < RT_TH
    4801f218:	44414552 4952505f 5449524f 414d5f59     READ_PRIORITY_MA
    4801f228:	00000058 00000000 65726874 21206461     X.......thread !
    4801f238:	5452203d 4c554e5f 0000004c 00000000     = RT_NULL.......
    4801f248:	63617473 74735f6b 20747261 52203d21     stack_start != R
    4801f258:	554e5f54 00004c4c 72687428 2d646165     T_NULL..(thread-
    4801f268:	6174733e 20262074 545f5452 41455248     >stat & RT_THREA
    4801f278:	54535f44 4d5f5441 294b5341 203d3d20     D_STAT_MASK) == 
    4801f288:	545f5452 41455248 4e495f44 00005449     RT_THREAD_INIT..
    4801f298:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801f2a8:	28286570 6f5f7472 63656a62 29745f74     pe((rt_object_t)
    4801f2b8:	65726874 20296461 52203d3d 624f5f54     thread) == RT_Ob
    4801f2c8:	7463656a 616c435f 545f7373 61657268     ject_Class_Threa
    4801f2d8:	00000064 00000000 6f5f7472 63656a62     d.......rt_objec
    4801f2e8:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801f2f8:	72282874 626f5f74 7463656a 7429745f     t((rt_object_t)t
    4801f308:	61657268 00002964 6f5f7472 63656a62     hread)..rt_objec
    4801f318:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801f328:	72282874 626f5f74 7463656a 7429745f     t((rt_object_t)t
    4801f338:	61657268 3d202964 5452203d 4c41465f     hread) == RT_FAL
    4801f348:	00004553 00000000 6b636974 203d2120     SE......tick != 
    4801f358:	4e5f5452 004c4c55 65726874 3d206461     RT_NULL.thread =
    4801f368:	7472203d 7268745f 5f646165 666c6573     = rt_thread_self
    4801f378:	00002928 00000000 72687428 2d646165     ()......(thread-
    4801f388:	6174733e 20262074 545f5452 41455248     >stat & RT_THREA
    4801f398:	54535f44 4d5f5441 294b5341 203d3d20     D_STAT_MASK) == 
    4801f3a8:	545f5452 41455248 55535f44 4e455053     RT_THREAD_SUSPEN
    4801f3b8:	00000044 00000000                       D.......

000000004801f3c0 <__FUNCTION__.10>:
    4801f3c0:	7268745f 5f646165 74696e69 00000000     _thread_init....

000000004801f3d0 <__FUNCTION__.9>:
    4801f3d0:	745f7472 61657268 6e695f64 00007469     rt_thread_init..

000000004801f3e0 <__FUNCTION__.8>:
    4801f3e0:	745f7472 61657268 74735f64 75747261     rt_thread_startu
    4801f3f0:	00000070 00000000                       p.......

000000004801f3f8 <__FUNCTION__.7>:
    4801f3f8:	745f7472 61657268 65645f64 68636174     rt_thread_detach
	...

000000004801f410 <__FUNCTION__.6>:
    4801f410:	745f7472 61657268 65645f64 6574656c     rt_thread_delete
	...

000000004801f428 <__FUNCTION__.5>:
    4801f428:	745f7472 61657268 6c735f64 00706565     rt_thread_sleep.

000000004801f438 <__FUNCTION__.4>:
    4801f438:	745f7472 61657268 65645f64 5f79616c     rt_thread_delay_
    4801f448:	69746e75 0000006c                       until...

000000004801f450 <__FUNCTION__.3>:
    4801f450:	745f7472 61657268 6f635f64 6f72746e     rt_thread_contro
    4801f460:	0000006c 00000000                       l.......

000000004801f468 <__FUNCTION__.2>:
    4801f468:	745f7472 61657268 75735f64 6e657073     rt_thread_suspen
    4801f478:	00000064 00000000                       d.......

000000004801f480 <__FUNCTION__.1>:
    4801f480:	745f7472 61657268 65725f64 656d7573     rt_thread_resume
	...

000000004801f498 <__FUNCTION__.0>:
    4801f498:	745f7472 61657268 69745f64 756f656d     rt_thread_timeou
    4801f4a8:	00000074 00000000 75657571 3d212065     t.......queue !=
    4801f4b8:	5f545220 4c4c554e 00000000 00000000      RT_NULL........
    4801f4c8:	20766564 52203d21 554e5f54 00004c4c     dev != RT_NULL..
    4801f4d8:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801f4e8:	26286570 2d766564 7261703e 29746e65     pe(&dev->parent)
    4801f4f8:	203d3d20 4f5f5452 63656a62 6c435f74      == RT_Object_Cl
    4801f508:	5f737361 69766544 00006563 00000000     ass_Device......
    4801f518:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801f528:	6f6d6574 63656a62 64262874 3e2d7665     temobject(&dev->
    4801f538:	65726170 0029746e 6f5f7472 63656a62     parent).rt_objec
    4801f548:	73695f74 7379735f 6f6d6574 63656a62     t_is_systemobjec
    4801f558:	64262874 3e2d7665 65726170 2029746e     t(&dev->parent) 
    4801f568:	52203d3d 41465f54 0045534c 00000000     == RT_FALSE.....
    4801f578:	69206f54 6974696e 7a696c61 65642065     To initialize de
    4801f588:	65636976 2073253a 6c696166 202e6465     vice:%s failed. 
    4801f598:	20656854 6f727265 6f632072 69206564     The error code i
    4801f5a8:	64252073 0000000a 2d766564 6665723e     s %d....dev->ref
    4801f5b8:	756f635f 2120746e 0030203d 00000000     _count != 0.....

000000004801f5c8 <__FUNCTION__.10>:
    4801f5c8:	775f7472 75657571 6e695f65 00007469     rt_wqueue_init..

000000004801f5d8 <__FUNCTION__.9>:
    4801f5d8:	645f7472 63697665 6e755f65 69676572     rt_device_unregi
    4801f5e8:	72657473 00000000                       ster....

000000004801f5f0 <__FUNCTION__.8>:
    4801f5f0:	645f7472 63697665 65645f65 6f727473     rt_device_destro
    4801f600:	00000079 00000000                       y.......

000000004801f608 <__FUNCTION__.7>:
    4801f608:	645f7472 63697665 6e695f65 00007469     rt_device_init..

000000004801f618 <__FUNCTION__.6>:
    4801f618:	645f7472 63697665 706f5f65 00006e65     rt_device_open..

000000004801f628 <__FUNCTION__.5>:
    4801f628:	645f7472 63697665 6c635f65 0065736f     rt_device_close.

000000004801f638 <__FUNCTION__.4>:
    4801f638:	645f7472 63697665 65725f65 00006461     rt_device_read..

000000004801f648 <__FUNCTION__.3>:
    4801f648:	645f7472 63697665 72775f65 00657469     rt_device_write.

000000004801f658 <__FUNCTION__.2>:
    4801f658:	645f7472 63697665 6f635f65 6f72746e     rt_device_contro
    4801f668:	0000006c 00000000                       l.......

000000004801f670 <__FUNCTION__.1>:
    4801f670:	645f7472 63697665 65735f65 78725f74     rt_device_set_rx
    4801f680:	646e695f 74616369 00000065 00000000     _indicate.......

000000004801f690 <__FUNCTION__.0>:
    4801f690:	645f7472 63697665 65735f65 78745f74     rt_device_set_tx
    4801f6a0:	6d6f635f 74656c70 00000065 00000000     _complete.......
    4801f6b0:	65726874 21206461 5452203d 4c554e5f     thread != RT_NUL
    4801f6c0:	0000004c 00000000 65726874 253a6461     L.......thread:%
    4801f6d0:	74732073 206b6361 7265766f 776f6c66     s stack overflow
    4801f6e0:	0000000a 00000000 6e726177 3a676e69     ........warning:
    4801f6f0:	20732520 63617473 7369206b 6f6c6320      %s stack is clo
    4801f700:	74206573 6e65206f 666f2064 61747320     se to end of sta
    4801f710:	61206b63 65726464 0a2e7373 00000000     ck address......

000000004801f720 <__FUNCTION__.2>:
    4801f720:	5f74725f 65686373 656c7564 74735f72     _rt_scheduler_st
    4801f730:	5f6b6361 63656863 0000006b 00000000     ack_check.......

000000004801f740 <__FUNCTION__.1>:
    4801f740:	735f7472 64656863 5f656c75 65736e69     rt_schedule_inse
    4801f750:	745f7472 61657268 00000064 00000000     rt_thread.......

000000004801f760 <__FUNCTION__.0>:
    4801f760:	735f7472 64656863 5f656c75 6f6d6572     rt_schedule_remo
    4801f770:	745f6576 61657268 00000064 00000000     ve_thread.......
    4801f780:	6f666e69 74616d72 206e6f69 52203d21     information != R
    4801f790:	554e5f54 00004c4c 206a626f 6f203d21     T_NULL..obj != o
    4801f7a0:	63656a62 00000074 656a626f 21207463     bject...object !
    4801f7b0:	5452203d 4c554e5f 0000004c 00000000     = RT_NULL.......
    4801f7c0:	636e7546 6e6f6974 5d73255b 61687320     Function[%s] sha
    4801f7d0:	6e206c6c 6220746f 73752065 69206465     ll not be used i
    4801f7e0:	5349206e 00000a52 00000030 00000000     n ISR...0.......
    4801f7f0:	626f2821 7463656a 79743e2d 26206570     !(object->type &
    4801f800:	5f545220 656a624f 435f7463 7373616c      RT_Object_Class
    4801f810:	6174535f 29636974 00000000 00000000     _Static)........

000000004801f820 <__FUNCTION__.6>:
    4801f820:	6f5f7472 63656a62 6e695f74 00007469     rt_object_init..

000000004801f830 <__FUNCTION__.5>:
    4801f830:	6f5f7472 63656a62 65645f74 68636174     rt_object_detach
	...

000000004801f848 <__FUNCTION__.4>:
    4801f848:	6f5f7472 63656a62 6c615f74 61636f6c     rt_object_alloca
    4801f858:	00006574 00000000                       te......

000000004801f860 <__FUNCTION__.3>:
    4801f860:	6f5f7472 63656a62 65645f74 6574656c     rt_object_delete
	...

000000004801f878 <__FUNCTION__.2>:
    4801f878:	6f5f7472 63656a62 73695f74 7379735f     rt_object_is_sys
    4801f888:	6f6d6574 63656a62 00000074 00000000     temobject.......

000000004801f898 <__FUNCTION__.1>:
    4801f898:	6f5f7472 63656a62 65675f74 79745f74     rt_object_get_ty
    4801f8a8:	00006570 00000000                       pe......

000000004801f8b0 <__FUNCTION__.0>:
    4801f8b0:	6f5f7472 63656a62 69665f74 0000646e     rt_object_find..
    4801f8c0:	205c200a 0a2f207c 00000000 00000000     . \ | /.........
    4801f8d0:	5452202d 20202d20 54202020 61657268     - RT -     Threa
    4801f8e0:	704f2064 74617265 20676e69 74737953     d Operating Syst
    4801f8f0:	000a6d65 00000000 313a3332 38323a30     em......23:10:28
	...
    4801f908:	20636544 32203131 00313230 00000000     Dec 11 2021.....
    4801f918:	7c202f20 20205c20 25202020 64252e64      / | \     %d.%d
    4801f928:	2064252e 6c697562 73252064 0a732520     .%d build %s %s.
	...
    4801f940:	30303220 202d2036 31323032 706f4320      2006 - 2021 Cop
    4801f950:	67697279 62207468 74722079 7268742d     yright by rt-thr
    4801f960:	20646165 6d616574 0000000a 00000000     ead team........
    4801f970:	4c554e28 0000294c                       (NULL)..

000000004801f978 <__lowest_bit_bitmap>:
    4801f978:	00010000 00010002 00010003 00010002     ................
    4801f988:	00010004 00010002 00010003 00010002     ................
    4801f998:	00010005 00010002 00010003 00010002     ................
    4801f9a8:	00010004 00010002 00010003 00010002     ................
    4801f9b8:	00010006 00010002 00010003 00010002     ................
    4801f9c8:	00010004 00010002 00010003 00010002     ................
    4801f9d8:	00010005 00010002 00010003 00010002     ................
    4801f9e8:	00010004 00010002 00010003 00010002     ................
    4801f9f8:	00010007 00010002 00010003 00010002     ................
    4801fa08:	00010004 00010002 00010003 00010002     ................
    4801fa18:	00010005 00010002 00010003 00010002     ................
    4801fa28:	00010004 00010002 00010003 00010002     ................
    4801fa38:	00010006 00010002 00010003 00010002     ................
    4801fa48:	00010004 00010002 00010003 00010002     ................
    4801fa58:	00010005 00010002 00010003 00010002     ................
    4801fa68:	00010004 00010002 00010003 00010002     ................
    4801fa78:	29732528 73736120 69747265 66206e6f     (%s) assertion f
    4801fa88:	656c6961 74612064 6e756620 6f697463     ailed at functio
    4801fa98:	73253a6e 696c202c 6e20656e 65626d75     n:%s, line numbe
    4801faa8:	64253a72 00000a20                       r:%d ...

000000004801fab0 <large_digits.2>:
    4801fab0:	33323130 37363534 42413938 46454443     0123456789ABCDEF
	...

000000004801fac8 <small_digits.1>:
    4801fac8:	33323130 37363534 62613938 66656463     0123456789abcdef
	...
    4801fae0:	0000424b 00000000 0000424d 00000000     KB......MB......
    4801faf0:	00004247 00000000 442f455b 205d5346     GB......[E/DFS] 
	...
    4801fb08:	72656854 73692065 206f6e20 63617073     There is no spac
    4801fb18:	6f742065 67657220 65747369 68742072     e to register th
    4801fb28:	66207369 20656c69 74737973 28206d65     is file system (
    4801fb38:	2e297325 00000000 0000000a 00000000     %s).............
    4801fb48:	68746170 00000000 74726170 203d2120     path....part != 
    4801fb58:	4c4c554e 00000000 20667562 4e203d21     NULL....buf != N
    4801fb68:	004c4c55 00000000 6e756f66 61702064     ULL.....found pa
    4801fb78:	255b7472 202c5d64 69676562 25203a6e     rt[%d], begin: %
    4801fb88:	73202c64 3a657a69 00000020 00000000     d, size: .......
    4801fb98:	000a424b 00000000 73256425 00000000     KB......%d%s....
    4801fba8:	000a424d 00000000 252e6425 00732564     MB......%d.%d%s.
    4801fbb8:	000a4247 00000000 0000002f 00000000     GB....../.......
    4801fbc8:	7665642f 00000000 72656854 73692065     /dev....There is
    4801fbd8:	206f6e20 63617073 6f742065 756f6d20      no space to mou
    4801fbe8:	7420746e 20736968 656c6966 73797320     nt this file sys
    4801fbf8:	206d6574 29732528 0000002e 00000000     tem (%s)........
    4801fc08:	69766544 28206563 20297325 20736177     Device (%s) was 
    4801fc18:	20746f6e 6e756f66 00000064 00000000     not found.......
    4801fc28:	20656854 656c6966 73797320 206d6574     The file system 
    4801fc38:	29732528 666b6d20 75662073 6974636e     (%s) mkfs functi
    4801fc48:	77206e6f 6e207361 6920746f 656c706d     on was not imple
    4801fc58:	746e656d 00000000 656c6946 73797320     ment....File sys
    4801fc68:	206d6574 29732528 73617720 746f6e20     tem (%s) was not
    4801fc78:	756f6620 002e646e 5f736664 74617473      found..dfs_stat
    4801fc88:	66207366 656c6961 000a2e64 00000000     fs failed.......
    4801fc98:	6b736964 65726620 25203a65 64252e64     disk free: %d.%d
    4801fca8:	20732520 6425205b 6f6c6220 202c6b63      %s [ %d block, 
    4801fcb8:	62206425 73657479 72657020 6f6c6220     %d bytes per blo
    4801fcc8:	5d206b63 0000000a 4801fae0 00000000     ck ].......H....
    4801fcd8:	4801fae8 00000000 4801faf0 00000000     ...H.......H....

000000004801fce8 <__FUNCTION__.1>:
    4801fce8:	5f736664 656c6966 74737973 6c5f6d65     dfs_filesystem_l
    4801fcf8:	756b6f6f 00000070                       ookup...

000000004801fd00 <__FUNCTION__.0>:
    4801fd00:	5f736664 656c6966 74737973 675f6d65     dfs_filesystem_g
    4801fd10:	705f7465 69747261 6e6f6974 00000000     et_partition....
    4801fd20:	20736664 65726c61 20796461 74696e69     dfs already init
    4801fd30:	00000a2e 00000000 6f6c7366 00006b63     ........fslock..
    4801fd40:	66766564 00000073 7665642f 00000000     devfs.../dev....
    4801fd50:	00000030 00000000 442f455b 205d5346     0.......[E/DFS] 
	...
    4801fd68:	20534644 6e206466 69207765 61662073     DFS fd new is fa
    4801fd78:	64656c69 6f432021 20646c75 20746f6e     iled! Could not 
    4801fd88:	6e756f66 6e612064 706d6520 66207974     found an empty f
    4801fd98:	6e652064 2e797274 00000000 00000000     d entry.........
    4801fda8:	0000000a 00000000 21206466 554e203d     ........fd != NU
    4801fdb8:	00004c4c 00000000 656c6966 656d616e     LL......filename
    4801fdc8:	203d2120 4c4c554e 00000000 00000000      != NULL........
    4801fdd8:	252f7325 00000073 74206466 20657079     %s/%s...fd type 
    4801fde8:	72202020 6d206665 63696761 61702020        ref magic  pa
    4801fdf8:	000a6874 00000000 2d202d2d 2d2d2d2d     th......-- -----
    4801fe08:	2d20202d 2d202d2d 2d2d2d2d 2d2d2d20     -  --- ----- ---
    4801fe18:	0a2d2d2d 00000000 20643225 00000000     ---.....%2d ....
    4801fe28:	00726964 00000000 2e372d25 00207337     dir.....%-7.7s .
    4801fe38:	656c6966 00000000 6b636f73 00007465     file....socket..
    4801fe48:	72657375 00000000 69766564 00006563     user....device..
    4801fe58:	6e6b6e75 006e776f 2e382d25 00207338     unknown.%-8.8s .
    4801fe68:	20643325 00000000 78343025 00002020     %3d ....%04x  ..
    4801fe78:	000a7325 00000000                       %s......

000000004801fe80 <__FUNCTION__.2>:
    4801fe80:	5f736664 6b636f6c 00000000 00000000     dfs_lock........

000000004801fe90 <__FUNCTION__.1>:
    4801fe90:	705f6466 00007475                       fd_put..

000000004801fe98 <__FUNCTION__.0>:
    4801fe98:	5f736664 6d726f6e 7a696c61 61705f65     dfs_normalize_pa
    4801fea8:	00006874 00000000 0000002f 00000000     th....../.......
    4801feb8:	442f455b 205d5346 00000000 00000000     [E/DFS] ........
    4801fec8:	276e6163 69662074 6d20646e 746e756f     can't find mount
    4801fed8:	66206465 73656c69 65747379 6e6f206d     ed filesystem on
    4801fee8:	69687420 61702073 253a6874 00000073      this path:%s...
    4801fef8:	0000000a 00000000 20656874 656c6966     ........the file
    4801ff08:	74737973 64206d65 276e6469 6d692074     system didn't im
    4801ff18:	6d656c70 20746e65 73696874 6e756620     plement this fun
    4801ff28:	6f697463 0000006e 65726944 726f7463     ction...Director
    4801ff38:	73252079 00000a3a 30322d25 00000073     y %s:...%-20s...
    4801ff48:	5249443c 0000003e 35322d25 00000a73     <DIR>...%-25s...
    4801ff58:	35322d25 000a756c 20444142 656c6966     %-25lu..BAD file
    4801ff68:	7325203a 0000000a 73206f4e 20686375     : %s....No such 
    4801ff78:	65726964 726f7463 00000a79 00000000     directory.......
    4801ff88:	656c6544 25206574 61662073 64656c69     Delete %s failed
    4801ff98:	0000000a 00000000 6e65704f 20732520     ........Open %s 
    4801ffa8:	6c696166 000a6465 00007325 00000000     failed..%s......
    4801ffb8:	2074756f 6d20666f 726f6d65 00000a79     out of memory...
    4801ffc8:	64616552 20732520 6c696166 000a6465     Read %s failed..
    4801ffd8:	74697257 73252065 69616620 0a64656c     Write %s failed.
	...
    4801fff0:	74697257 69662065 6420656c 20617461     Write file data 
    48020000:	6c696166 202c6465 6e727265 64253d6f     failed, errno=%d
    48020010:	0000000a 00000000 6e65706f 20732520     ........open %s 
    48020020:	6c696166 000a6465 00002e2e 00000000     failed..........
    48020030:	0000002e 00000000 2074756f 6d20666f     ........out of m
    48020040:	726f6d65 000a2179 6e65706f 6c696620     emory!..open fil
    48020050:	25203a65 61662073 64656c69 0000000a     e: %s failed....
    48020060:	79706f63 69616620 2c64656c 64616220     copy failed, bad
    48020070:	0a732520 00000000 66207063 646c6961      %s.....cp faild
    48020080:	7063202c 72696420 206f7420 656c6966     , cp dir to file
    48020090:	20736920 20746f6e 6d726570 65747469      is not permitte
    480200a0:	000a2164 00000000 656c6966 203d2120     d!......file != 
    480200b0:	4e5f5452 004c4c55 5f766564 21206469     RT_NULL.dev_id !
    480200c0:	5452203d 4c554e5f 0000004c 00000000     = RT_NULL.......
    480200d0:	746f6f72 7269645f 20746e65 52203d21     root_dirent != R
    480200e0:	554e5f54 00004c4c 6f666e69 74616d72     T_NULL..informat
    480200f0:	206e6f69 52203d21 554e5f54 00004c4c     ion != RT_NULL..

0000000048020100 <_device_fops>:
    48020100:	480133d4 00000000 480132f0 00000000     .3.H.....2.H....
    48020110:	480130fc 00000000 48013198 00000000     .0.H.....1.H....
    48020120:	48013244 00000000 00000000 00000000     D2.H............
	...
    48020138:	480137d8 00000000 48013948 00000000     .7.H....H9.H....
    48020148:	66766564 00000073                       devfs...

0000000048020150 <_device_fs>:
    48020150:	48020148 00000000 00000000 00000000     H..H............
    48020160:	48020100 00000000 480130e0 00000000     ...H.....0.H....
	...
    48020190:	48013668 00000000 00000000 00000000     h6.H............

00000000480201a0 <__FUNCTION__.5>:
    480201a0:	5f736664 69766564 665f6563 6f695f73     dfs_device_fs_io
    480201b0:	006c7463 00000000                       ctl.....

00000000480201b8 <__FUNCTION__.4>:
    480201b8:	5f736664 69766564 665f6563 65725f73     dfs_device_fs_re
    480201c8:	00006461 00000000                       ad......

00000000480201d0 <__FUNCTION__.3>:
    480201d0:	5f736664 69766564 665f6563 72775f73     dfs_device_fs_wr
    480201e0:	00657469 00000000                       ite.....

00000000480201e8 <__FUNCTION__.2>:
    480201e8:	5f736664 69766564 665f6563 6c635f73     dfs_device_fs_cl
    480201f8:	0065736f 00000000                       ose.....

0000000048020200 <__FUNCTION__.1>:
    48020200:	5f736664 69766564 665f6563 706f5f73     dfs_device_fs_op
    48020210:	00006e65 00000000                       en......

0000000048020218 <__FUNCTION__.0>:
    48020218:	5f736664 69766564 665f6563 65675f73     dfs_device_fs_ge
    48020228:	6e656474 00007374 69766564 21206563     tdents..device !
    48020238:	5452203d 4c554e5f 0000004c 00000000     = RT_NULL.......
    48020248:	552f455b 5d545241 00000020 00000000     [E/UART] .......
    48020258:	73706f66 65706f20 75203a6e 6f6e6b6e     fops open: unkno
    48020268:	6d206e77 2065646f 6425202d 00000021     wn mode - %d!...
    48020278:	0000000a 00000000                       ........

0000000048020280 <_serial_fops>:
    48020280:	48013a08 00000000 48013b2c 00000000     .:.H....,;.H....
    48020290:	48013b64 00000000 48013bc8 00000000     d;.H.....;.H....
    480202a0:	48013c5c 00000000 00000000 00000000     \<.H............
	...
    480202c0:	48013c98 00000000 69726573 21206c61     .<.H....serial !
    480202d0:	5452203d 4c554e5f 0000004c 00000000     = RT_NULL.......
    480202e0:	665f7872 206f6669 52203d21 554e5f54     rx_fifo != RT_NU
    480202f0:	00004c4c 00000000 21207874 5452203d     LL......tx != RT
    48020300:	4c554e5f 0000004c 552f575b 5d545241     _NULL...[W/UART]
    48020310:	00000020 00000000 6e726157 3a676e69      .......Warning:
    48020320:	65685420 69206572 6f6e2073 6f6e6520      There is no eno
    48020330:	20686775 66667562 66207265 7320726f     ugh buffer for s
    48020340:	6e697661 61642067 202c6174 61656c70     aving data, plea
    48020350:	69206573 6572636e 20657361 20656874     se increase the 
    48020360:	535f5452 41495245 42525f4c 4655425f     RT_SERIAL_RB_BUF
    48020370:	6f205a53 6f697470 00002e6e 00000000     SZ option.......
    48020380:	206e656c 72203d3c 6d645f74 61635f61     len <= rt_dma_ca
    48020390:	725f636c 65766365 656c5f64 6573286e     lc_recved_len(se
    480203a0:	6c616972 00000029 72657328 206c6169     rial)...(serial 
    480203b0:	52203d21 554e5f54 20294c4c 28202626     != RT_NULL) && (
    480203c0:	61746164 203d2120 4e5f5452 294c4c55     data != RT_NULL)
	...
    480203d8:	645f7872 2120616d 5452203d 4c554e5f     rx_dma != RT_NUL
    480203e8:	0000004c 00000000 69726573 3e2d6c61     L.......serial->
    480203f8:	2d73706f 616d643e 6172745f 696d736e     ops->dma_transmi
    48020408:	3d212074 5f545220 4c4c554e 00000000     t != RT_NULL....
    48020418:	20766564 52203d21 554e5f54 00004c4c     dev != RT_NULL..
    48020428:	665f7874 206f6669 52203d21 554e5f54     tx_fifo != RT_NU
    48020438:	00004c4c 00000000 645f7874 2120616d     LL......tx_dma !
    48020448:	5452203d 4c554e5f 0000004c 00000000     = RT_NULL.......
    48020458:	3b385b1b 253b6425 00007464 00000000     .[8;%d;%dt......
    48020468:	65687374 00006c6c 38315b1b 00000074     tshell...[18t...
    48020478:	69726573 3e2d6c61 65726170 722e746e     serial->parent.r
    48020488:	6e695f78 61636964 21206574 5452203d     x_indicate != RT
    48020498:	4c554e5f 0000004c                       _NULL...

00000000480204a0 <__FUNCTION__.18>:
    480204a0:	69726573 665f6c61 5f73706f 6e65706f     serial_fops_open
	...

00000000480204b8 <__FUNCTION__.17>:
    480204b8:	69726573 665f6c61 5f73706f 6c6c6f70     serial_fops_poll
	...

00000000480204d0 <__FUNCTION__.15>:
    480204d0:	7265735f 5f6c6169 6f666966 6c61635f     _serial_fifo_cal
    480204e0:	65725f63 64657663 6e656c5f 00000000     c_recved_len....

00000000480204f0 <__FUNCTION__.14>:
    480204f0:	645f7472 725f616d 5f766365 61647075     rt_dma_recv_upda
    48020500:	675f6574 695f7465 7865646e 00000000     te_get_index....

0000000048020510 <__FUNCTION__.13>:
    48020510:	645f7472 725f616d 5f766365 61647075     rt_dma_recv_upda
    48020520:	705f6574 695f7475 7865646e 00000000     te_put_index....

0000000048020530 <__FUNCTION__.12>:
    48020530:	735f7472 61697265 6e695f6c 00007469     rt_serial_init..

0000000048020540 <__FUNCTION__.11>:
    48020540:	735f7472 61697265 706f5f6c 00006e65     rt_serial_open..

0000000048020550 <__FUNCTION__.10>:
    48020550:	735f7472 61697265 6c635f6c 0065736f     rt_serial_close.

0000000048020560 <__FUNCTION__.9>:
    48020560:	735f7472 61697265 65725f6c 00006461     rt_serial_read..

0000000048020570 <__FUNCTION__.8>:
    48020570:	7265735f 5f6c6169 5f746e69 00007872     _serial_int_rx..

0000000048020580 <__FUNCTION__.7>:
    48020580:	7265735f 5f6c6169 5f616d64 00007872     _serial_dma_rx..

0000000048020590 <__FUNCTION__.6>:
    48020590:	7265735f 5f6c6169 6c6c6f70 0078725f     _serial_poll_rx.

00000000480205a0 <__FUNCTION__.5>:
    480205a0:	735f7472 61697265 72775f6c 00657469     rt_serial_write.

00000000480205b0 <__FUNCTION__.4>:
    480205b0:	7265735f 5f6c6169 5f746e69 00007874     _serial_int_tx..

00000000480205c0 <__FUNCTION__.3>:
    480205c0:	7265735f 5f6c6169 6c6c6f70 0078745f     _serial_poll_tx.

00000000480205d0 <__FUNCTION__.2>:
    480205d0:	735f7472 61697265 6f635f6c 6f72746e     rt_serial_contro
    480205e0:	0000006c 00000000                       l.......

00000000480205e8 <__FUNCTION__.1>:
    480205e8:	685f7472 65735f77 6c616972 6765725f     rt_hw_serial_reg
    480205f8:	65747369 00000072                       ister...

0000000048020600 <__FUNCTION__.0>:
    48020600:	685f7472 65735f77 6c616972 7273695f     rt_hw_serial_isr
	...
    48020618:	636e7546 6e6f6974 5d73255b 61687320     Function[%s] sha
    48020628:	6e206c6c 6220746f 73752065 69206465     ll not be used i
    48020638:	5349206e 00000a52 00000030 00000000     n ISR...0.......

0000000048020648 <__FUNCTION__.0>:
    48020648:	775f7472 75657571 61775f65 00007469     rt_wqueue_wait..
    48020658:	75657571 3d212065 5f545220 4c4c554e     queue != RT_NULL
	...
    48020670:	657a6973 30203e20 00000000 00000000     size > 0........
    48020680:	75657571 6d3e2d65 63696761 203d3d20     queue->magic == 
    48020690:	41544144 55455551 414d5f45 00434947     DATAQUEUE_MAGIC.
    480206a0:	636e7546 6e6f6974 5d73255b 61687320     Function[%s] sha
    480206b0:	6e206c6c 6220746f 73752065 69206465     ll not be used i
    480206c0:	5349206e 00000a52 00000030 00000000     n ISR...0.......
    480206d0:	61746164 7274705f 203d2120 4e5f5452     data_ptr != RT_N
    480206e0:	004c4c55 00000000 657a6973 203d2120     ULL.....size != 
    480206f0:	4e5f5452 004c4c55                       RT_NULL.

00000000480206f8 <__FUNCTION__.6>:
    480206f8:	645f7472 5f617461 75657571 6e695f65     rt_data_queue_in
    48020708:	00007469 00000000                       it......

0000000048020710 <__FUNCTION__.5>:
    48020710:	645f7472 5f617461 75657571 75705f65     rt_data_queue_pu
    48020720:	00006873 00000000                       sh......

0000000048020728 <__FUNCTION__.4>:
    48020728:	645f7472 5f617461 75657571 6f705f65     rt_data_queue_po
    48020738:	00000070 00000000                       p.......

0000000048020740 <__FUNCTION__.3>:
    48020740:	645f7472 5f617461 75657571 65705f65     rt_data_queue_pe
    48020750:	00006b65 00000000                       ek......

0000000048020758 <__FUNCTION__.2>:
    48020758:	645f7472 5f617461 75657571 65725f65     rt_data_queue_re
    48020768:	00746573 00000000                       set.....

0000000048020770 <__FUNCTION__.1>:
    48020770:	645f7472 5f617461 75657571 65645f65     rt_data_queue_de
    48020780:	74696e69 00000000                       init....

0000000048020788 <__FUNCTION__.0>:
    48020788:	645f7472 5f617461 75657571 656c5f65     rt_data_queue_le
    48020798:	0000006e 00000000 706d6f63 6974656c     n.......completi
    480207a8:	21206e6f 5452203d 4c554e5f 0000004c     on != RT_NULL...
    480207b8:	6c5f7472 5f747369 6d657369 28797470     rt_list_isempty(
    480207c8:	6f632826 656c706d 6e6f6974 75733e2d     &(completion->su
    480207d8:	6e657073 5f646564 7473696c 00002929     spended_list))..
    480207e8:	636e7546 6e6f6974 5d73255b 61687320     Function[%s] sha
    480207f8:	6e206c6c 6220746f 73752065 69206465     ll not be used i
    48020808:	5349206e 00000a52 00000030 00000000     n ISR...0.......

0000000048020818 <__FUNCTION__.2>:
    48020818:	635f7472 6c706d6f 6f697465 6e695f6e     rt_completion_in
    48020828:	00007469 00000000                       it......

0000000048020830 <__FUNCTION__.1>:
    48020830:	635f7472 6c706d6f 6f697465 61775f6e     rt_completion_wa
    48020840:	00007469 00000000                       it......

0000000048020848 <__FUNCTION__.0>:
    48020848:	635f7472 6c706d6f 6f697465 6f645f6e     rt_completion_do
    48020858:	0000656e 00000000 2068736d 00000000     ne......msh ....
    48020868:	6c656873 3d21206c 5f545220 4c4c554e     shell != RT_NULL
	...
    48020880:	736e6966 63203a68 6e206e61 6620746f     finsh: can not f
    48020890:	20646e69 69766564 203a6563 000a7325     ind device: %s..
    480208a0:	0000000a 00000000 73257325 00000000     ........%s%s....
    480208b0:	4b325b1b 0000000d 00000008 00000000     .[2K............
    480208c0:	00006325 00000000 20732508 00000820     %c.......%s  ...
    480208d0:	00082008 00000000 00007325 00000000     . ......%s......
    480208e0:	6d206f6e 726f6d65 6f662079 68732072     no memory for sh
    480208f0:	0a6c6c65 00000000 65687374 00006c6c     ell.....tshell..
    48020900:	78726873 00000000                       shrx....

0000000048020908 <__FUNCTION__.7>:
    48020908:	736e6966 65675f68 72705f74 74706d6f     finsh_get_prompt
    48020918:	646f6d5f 00000065                       _mode...

0000000048020920 <__FUNCTION__.6>:
    48020920:	736e6966 65735f68 72705f74 74706d6f     finsh_set_prompt
    48020930:	646f6d5f 00000065                       _mode...

0000000048020938 <__FUNCTION__.5>:
    48020938:	736e6966 65675f68 61686374 00000072     finsh_getchar...

0000000048020948 <__FUNCTION__.4>:
    48020948:	736e6966 78725f68 646e695f 00000000     finsh_rx_ind....

0000000048020958 <__FUNCTION__.3>:
    48020958:	736e6966 65735f68 65645f74 65636976     finsh_set_device
	...

0000000048020970 <__FUNCTION__.2>:
    48020970:	736e6966 65675f68 65645f74 65636976     finsh_get_device
	...

0000000048020988 <__FUNCTION__.1>:
    48020988:	736e6966 65735f68 63655f74 00006f68     finsh_set_echo..

0000000048020998 <__FUNCTION__.0>:
    48020998:	736e6966 65675f68 63655f74 00006f68     finsh_get_echo..
    480209a8:	542d5452 61657268 68732064 206c6c65     RT-Thread shell 
    480209b8:	6d6d6f63 73646e61 00000a3a 00000000     commands:.......
    480209c8:	36312d25 202d2073 000a7325 00000000     %-16s - %s......
    480209d8:	0000000a 00000000 206f6f54 796e616d     ........Too many
    480209e8:	67726120 20212073 6f206557 20796c6e      args ! We only 
    480209f8:	3a657355 0000000a 00207325 00000000     Use:....%s .....
    48020a08:	00646d63 00000000 70746572 00000000     cmd.....retp....
    48020a18:	203a7325 6d6d6f63 20646e61 20746f6e     %s: command not 
    48020a28:	6e756f66 000a2e64 000a7325 00000000     found...%s......

0000000048020a38 <__FUNCTION__.0>:
    48020a38:	68736d5f 6578655f 6d635f63 00000064     _msh_exec_cmd...
    48020a48:	0068732e 00000000 0048532e 00000000     .sh......SH.....
    48020a58:	6e69622f 2a2e252f 00000073 00000000     /bin/%.*s.......
    48020a68:	67617355 63203a65 4f532070 45435255     Usage: cp SOURCE
    48020a78:	53454420 00000a54 79706f43 554f5320      DEST...Copy SOU
    48020a88:	20454352 44206f74 2e545345 0000000a     RCE to DEST.....
    48020a98:	67617355 6d203a65 4f532076 45435255     Usage: mv SOURCE
    48020aa8:	53454420 00000a54 616e6552 5320656d      DEST...Rename S
    48020ab8:	4352554f 6f742045 53454420 6f202c54     OURCE to DEST, o
    48020ac8:	6f6d2072 53206576 4352554f 29732845     r move SOURCE(s)
    48020ad8:	206f7420 45524944 524f5443 000a2e59      to DIRECTORY...
    48020ae8:	3d207325 7325203e 0000000a 00000000     %s => %s........
    48020af8:	2074756f 6d20666f 726f6d65 00000a79     out of memory...
    48020b08:	252f7325 00000073 67617355 63203a65     %s/%s...Usage: c
    48020b18:	5b207461 454c4946 2e2e2e5d 0000000a     at [FILE].......
    48020b28:	636e6f43 6e657461 20657461 454c4946     Concatenate FILE
    48020b38:	0a297328 00000000 6e6e6163 7220746f     (s).....cannot r
    48020b48:	766f6d65 25272065 000a2773 00000000     emove '%s'......
    48020b58:	0000002e 00000000 00002e2e 00000000     ................
    48020b68:	6f6d6572 20646576 27732527 0000000a     removed '%s'....
    48020b78:	6f6d6572 20646576 65726964 726f7463     removed director
    48020b88:	25272079 000a2773 67617355 72203a65     y '%s'..Usage: r
    48020b98:	706f206d 6e6f6974 20297328 454c4946     m option(s) FILE
    48020ba8:	0a2e2e2e 00000000 6f6d6552 28206576     ........Remove (
    48020bb8:	696c6e75 20296b6e 20656874 454c4946     unlink) the FILE
    48020bc8:	2e297328 0000000a 6f727245 42203a72     (s).....Error: B
    48020bd8:	6f206461 6f697470 25203a6e 00000a63     ad option: %c...
    48020be8:	6e6e6163 7220746f 766f6d65 25272065     cannot remove '%
    48020bf8:	203a2773 61207349 72696420 6f746365     s': Is a directo
    48020c08:	000a7972 00000000 6e6e6163 7220746f     ry......cannot r
    48020c18:	766f6d65 25272065 203a2773 73206f4e     emove '%s': No s
    48020c28:	20686375 656c6966 20726f20 65726964     uch file or dire
    48020c38:	726f7463 00000a79 000a7325 00000000     ctory...%s......
    48020c48:	73206f4e 20686375 65726964 726f7463     No such director
    48020c58:	25203a79 00000a73 67617355 6d203a65     y: %s...Usage: m
    48020c68:	7269646b 504f5b20 4e4f4954 4944205d     kdir [OPTION] DI
    48020c78:	54434552 0a59524f 00000000 00000000     RECTORY.........
    48020c88:	61657243 74206574 44206568 43455249     Create the DIREC
    48020c98:	59524f54 6669202c 65687420 6f642079     TORY, if they do
    48020ca8:	746f6e20 726c6120 79646165 69786520      not already exi
    48020cb8:	0a2e7473 00000000 006d6c65 00000000     st......elm.....
    48020cc8:	0000742d 00000000 67617355 6d203a65     -t......Usage: m
    48020cd8:	2073666b 20742d5b 65707974 6564205d     kfs [-t type] de
    48020ce8:	65636976 0000000a 73666b6d 69616620     vice....mkfs fai
    48020cf8:	2c64656c 73657220 3d746c75 000a6425     led, result=%d..
    48020d08:	656c6966 74737973 20206d65 69766564     filesystem  devi
    48020d18:	20206563 6e756f6d 696f7074 000a746e     ce  mountpoint..
    48020d28:	2d2d2d2d 2d2d2d2d 20202d2d 2d2d2d2d     ----------  ----
    48020d38:	20202d2d 2d2d2d2d 2d2d2d2d 000a2d2d     --  ----------..
    48020d48:	30312d25 25202073 2073362d 732d2520     %-10s  %-6s  %-s
    48020d58:	0000000a 00000000 6e756f6d 65642074     ........mount de
    48020d68:	65636976 28732520 20297325 6f746e6f     vice %s(%s) onto
    48020d78:	20732520 202e2e2e 00000000 00000000      %s ... ........
    48020d88:	63637573 21646565 0000000a 00000000     succeed!........
    48020d98:	6c696166 0a216465 00000000 00000000     failed!.........
    48020da8:	67617355 6d203a65 746e756f 65643c20     Usage: mount <de
    48020db8:	65636976 6d3c203e 746e756f 6e696f70     vice> <mountpoin
    48020dc8:	3c203e74 79747366 2e3e6570 0000000a     t> <fstype>.....
    48020dd8:	67617355 75203a65 756f6d6e 3c20746e     Usage: unmount <
    48020de8:	6e756f6d 696f7074 2e3e746e 0000000a     mountpoint>.....
    48020df8:	6f6d6e75 20746e75 2e207325 00202e2e     unmount %s ... .
    48020e08:	0000002f 00000000 65682d2d 0000706c     /.......--help..
    48020e18:	0000682d 00000000 5b206664 68746170     -h......df [path
    48020e28:	00000a5d 00000000 6e65706f 6c696620     ].......open fil
    48020e38:	73253a65 69616620 2164656c 0000000a     e:%s failed!....
    48020e48:	67617355 65203a65 206f6863 72747322     Usage: echo "str
    48020e58:	22676e69 69665b20 616e656c 0a5d656d     ing" [filename].
	...
    48020e70:	67617355 74203a65 206c6961 206e2d5b     Usage: tail [-n 
    48020e80:	626d756e 5d737265 69663c20 616e656c     numbers] <filena
    48020e90:	0a3e656d 00000000 00006e2d 00000000     me>.....-n......
    48020ea0:	656c6946 656f6420 74276e73 69786520     File doesn't exi
    48020eb0:	000a7473 00000000 746f540a 4e206c61     st.......Total N
    48020ec0:	65626d75 666f2072 6e696c20 253a7365     umber of lines:%
    48020ed0:	00000a64 00000000 7272450a 523a726f     d........Error:R
    48020ee0:	69757165 20646572 656e696c 72612073     equired lines ar
    48020ef0:	6f6d2065 74206572 206e6168 61746f74     e more than tota
    48020f00:	756e206c 7265626d 20666f20 656e696c     l number of line
    48020f10:	00000a73 00000000 75716552 64657269     s.......Required
    48020f20:	6d754e20 20726562 6c20666f 73656e69      Number of lines
    48020f30:	0a64253a 00000000 00006325 00000000     :%d.....%c......
    48020f40:	0000000a 00000000 732f455b 696c6474     ........[E/stdli
    48020f50:	00205d62 00000000 65726874 253a6461     b] .....thread:%
    48020f60:	78652073 253a7469 00002164 00000000     s exit:%d!......
    48020f70:	0000000a 00000000 000a7325 00000000     ........%s......
    48020f80:	7665642f 7974742f 00000000 00000000     /dev/tty........

0000000048020f90 <__fsym_gic_dump_name>:
    48020f90:	5f636967 706d7564 00000000 00000000     gic_dump........

0000000048020fa0 <__fsym_gic_dump_desc>:
    48020fa0:	776f6873 63696720 61747320 00737574     show gic status.

0000000048020fb0 <__fsym_rk_show_name>:
    48020fb0:	735f6b72 00776f68                       rk_show.

0000000048020fb8 <__fsym_rk_show_desc>:
    48020fb8:	776f6873 6d697420 73207265 75746174     show timer statu
    48020fc8:	00000073 00000000                       s.......

0000000048020fd0 <__fsym_list_fd_name>:
    48020fd0:	7473696c 0064665f                       list_fd.

0000000048020fd8 <__fsym_list_fd_desc>:
    48020fd8:	7473696c 6c696620 65642065 69726373     list file descri
    48020fe8:	726f7470 00000000                       ptor....

0000000048020ff0 <__fsym_help_name>:
    48020ff0:	706c6568 00000000                       help....

0000000048020ff8 <__fsym_help_desc>:
    48020ff8:	2d205452 72685420 20646165 6c656873     RT - Thread shel
    48021008:	6568206c 002e706c                       l help..

0000000048021010 <__fsym_ls_name>:
    48021010:	0000736c 00000000                       ls......

0000000048021018 <__fsym_ls_desc>:
    48021018:	7473694c 666e6920 616d726f 6e6f6974     List information
    48021028:	6f626120 74207475 46206568 73454c49      about the FILEs
    48021038:	0000002e 00000000                       ........

0000000048021040 <__fsym_cp_name>:
    48021040:	00007063 00000000                       cp......

0000000048021048 <__fsym_cp_desc>:
    48021048:	79706f43 554f5320 20454352 44206f74     Copy SOURCE to D
    48021058:	2e545345 00000000                       EST.....

0000000048021060 <__fsym_mv_name>:
    48021060:	0000766d 00000000                       mv......

0000000048021068 <__fsym_mv_desc>:
    48021068:	616e6552 5320656d 4352554f 6f742045     Rename SOURCE to
    48021078:	53454420 00002e54                        DEST...

0000000048021080 <__fsym_cat_name>:
    48021080:	00746163 00000000                       cat.....

0000000048021088 <__fsym_cat_desc>:
    48021088:	636e6f43 6e657461 20657461 454c4946     Concatenate FILE
    48021098:	00297328 00000000                       (s).....

00000000480210a0 <__fsym_rm_name>:
    480210a0:	00006d72 00000000                       rm......

00000000480210a8 <__fsym_rm_desc>:
    480210a8:	6f6d6552 75286576 6e696c6e 7420296b     Remove(unlink) t
    480210b8:	46206568 28454c49 002e2973 00000000     he FILE(s)......

00000000480210c8 <__fsym_cd_name>:
    480210c8:	00006463 00000000                       cd......

00000000480210d0 <__fsym_cd_desc>:
    480210d0:	6e616843 74206567 73206568 6c6c6568     Change the shell
    480210e0:	726f7720 676e696b 72696420 6f746365      working directo
    480210f0:	002e7972 00000000                       ry......

00000000480210f8 <__fsym_pwd_name>:
    480210f8:	00647770 00000000                       pwd.....

0000000048021100 <__fsym_pwd_desc>:
    48021100:	6e697250 68742074 616e2065 6f20656d     Print the name o
    48021110:	68742066 75632065 6e657272 6f772074     f the current wo
    48021120:	6e696b72 69642067 74636572 2e79726f     rking directory.
	...

0000000048021138 <__fsym_mkdir_name>:
    48021138:	69646b6d 00000072                       mkdir...

0000000048021140 <__fsym_mkdir_desc>:
    48021140:	61657243 74206574 44206568 43455249     Create the DIREC
    48021150:	59524f54 0000002e                       TORY....

0000000048021158 <__fsym_mkfs_name>:
    48021158:	73666b6d 00000000                       mkfs....

0000000048021160 <__fsym_mkfs_desc>:
    48021160:	6d726f66 64207461 206b7369 68746977     format disk with
    48021170:	6c696620 79732065 6d657473 00000000      file system....

0000000048021180 <__fsym_mount_name>:
    48021180:	6e756f6d 00000074                       mount...

0000000048021188 <__fsym_mount_desc>:
    48021188:	6e756f6d 643c2074 63697665 3c203e65     mount <device> <
    48021198:	6e756f6d 696f7074 203e746e 7473663c     mountpoint> <fst
    480211a8:	3e657079 00000000                       ype>....

00000000480211b0 <__fsym_umount_name>:
    480211b0:	756f6d75 0000746e                       umount..

00000000480211b8 <__fsym_umount_desc>:
    480211b8:	6f6d6e55 20746e75 69766564 66206563     Unmount device f
    480211c8:	206d6f72 656c6966 73797320 006d6574     rom file system.

00000000480211d8 <__fsym_df_name>:
    480211d8:	00006664 00000000                       df......

00000000480211e0 <__fsym_df_desc>:
    480211e0:	6b736964 65726620 00000065 00000000     disk free.......

00000000480211f0 <__fsym_echo_name>:
    480211f0:	6f686365 00000000                       echo....

00000000480211f8 <__fsym_echo_desc>:
    480211f8:	6f686365 72747320 20676e69 66206f74     echo string to f
    48021208:	00656c69 00000000                       ile.....

0000000048021210 <__fsym_tail_name>:
    48021210:	6c696174 00000000                       tail....

0000000048021218 <__fsym_tail_desc>:
    48021218:	6e697270 68742074 616c2065 4e207473     print the last N
    48021228:	6c202d20 73656e69 74616420 666f2061      - lines data of
    48021238:	65687420 76696720 66206e65 00656c69      the given file.

0000000048021248 <_global_impure_ptr>:
    48021248:	480217a0 00000000                       ...H....

0000000048021250 <_ctype_>:
    48021250:	20202000 20202020 28282020 20282828     .         ((((( 
    48021260:	20202020 20202020 20202020 20202020                     
    48021270:	10108820 10101010 10101010 10101010      ...............
    48021280:	04040410 04040404 10040404 10101010     ................
    48021290:	41411010 41414141 01010101 01010101     ..AAAAAA........
    480212a0:	01010101 01010101 01010101 10101010     ................
    480212b0:	42421010 42424242 02020202 02020202     ..BBBBBB........
    480212c0:	02020202 02020202 02020202 10101010     ................
    480212d0:	00000020 00000000 00000000 00000000      ...............
	...

0000000048021360 <__fsym_gic_dump>:
    48021360:	48020f90 00000000 48020fa0 00000000     ...H.......H....
    48021370:	48003cb8 00000000                       .<.H....

0000000048021378 <__fsym_rk_show>:
    48021378:	48020fb0 00000000 48020fb8 00000000     ...H.......H....
    48021388:	4800548c 00000000                       .T.H....

0000000048021390 <__fsym_list_fd>:
    48021390:	48020fd0 00000000 48020fd8 00000000     ...H.......H....
    480213a0:	48011bcc 00000000                       ...H....

00000000480213a8 <__fsym_help>:
    480213a8:	48020ff0 00000000 48020ff8 00000000     ...H.......H....
    480213b8:	4801868c 00000000                       ...H....

00000000480213c0 <__fsym_ls>:
    480213c0:	48021010 00000000 48021018 00000000     ...H.......H....
    480213d0:	480195b0 00000000                       ...H....

00000000480213d8 <__fsym_cp>:
    480213d8:	48021040 00000000 48021048 00000000     @..H....H..H....
    480213e8:	480195f8 00000000                       ...H....

00000000480213f0 <__fsym_mv>:
    480213f0:	48021060 00000000 48021068 00000000     `..H....h..H....
    48021400:	48019660 00000000                       `..H....

0000000048021408 <__fsym_cat>:
    48021408:	48021080 00000000 48021088 00000000     ...H.......H....
    48021418:	48019850 00000000                       P..H....

0000000048021420 <__fsym_rm>:
    48021420:	480210a0 00000000 480210a8 00000000     ...H.......H....
    48021430:	48019acc 00000000                       ...H....

0000000048021438 <__fsym_cd>:
    48021438:	480210c8 00000000 480210d0 00000000     ...H.......H....
    48021448:	48019da0 00000000                       ...H....

0000000048021450 <__fsym_pwd>:
    48021450:	480210f8 00000000 48021100 00000000     ...H.......H....
    48021460:	48019e20 00000000                        ..H....

0000000048021468 <__fsym_mkdir>:
    48021468:	48021138 00000000 48021140 00000000     8..H....@..H....
    48021478:	48019e50 00000000                       P..H....

0000000048021480 <__fsym_mkfs>:
    48021480:	48021158 00000000 48021160 00000000     X..H....`..H....
    48021490:	48019ea8 00000000                       ...H....

0000000048021498 <__fsym_mount>:
    48021498:	48021180 00000000 48021188 00000000     ...H.......H....
    480214a8:	48019f8c 00000000                       ...H....

00000000480214b0 <__fsym_umount>:
    480214b0:	480211b0 00000000 480211b8 00000000     ...H.......H....
    480214c0:	4801a0ec 00000000                       ...H....

00000000480214c8 <__fsym_df>:
    480214c8:	480211d8 00000000 480211e0 00000000     ...H.......H....
    480214d8:	4801a174 00000000                       t..H....

00000000480214e0 <__fsym_echo>:
    480214e0:	480211f0 00000000 480211f8 00000000     ...H.......H....
    480214f0:	4801a214 00000000                       ...H....

00000000480214f8 <__fsym_tail>:
    480214f8:	48021210 00000000 48021218 00000000     ...H.......H....
    48021508:	4801a2fc 00000000                       ...H....

0000000048021510 <__rt_init_rti_start>:
    48021510:	480054f0 00000000                       .T.H....

0000000048021518 <__rt_init_rti_board_start>:
    48021518:	480054f8 00000000                       .T.H....

0000000048021520 <__rt_init_rti_board_end>:
    48021520:	48005500 00000000                       .U.H....

0000000048021528 <__rt_init_dfs_init>:
    48021528:	4801102c 00000000                       ,..H....

0000000048021530 <__rt_init_finsh_system_init>:
    48021530:	480185a4 00000000                       ...H....

0000000048021538 <__rt_init_rti_end>:
    48021538:	48005508 00000000                       .U.H....
